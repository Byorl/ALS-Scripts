repeat task.wait() until game:IsLoaded()

local missingFunctions = {}

if not getnamecallmethod then
    table.insert(missingFunctions, "getnamecallmethod")
    getgenv().getnamecallmethod = function()
        return "Unknown"
    end
    getnamecallmethod = getgenv().getnamecallmethod
end

if not newcclosure then
    table.insert(missingFunctions, "newcclosure")
    getgenv().newcclosure = function(f)
        return f
    end
    newcclosure = getgenv().newcclosure
end

if not getrawmetatable then
    table.insert(missingFunctions, "getrawmetatable")
end

if not setreadonly then
    table.insert(missingFunctions, "setreadonly")
    getgenv().setreadonly = function() end
    setreadonly = getgenv().setreadonly
end

if not getconnections then
    table.insert(missingFunctions, "getconnections")
    getgenv().getconnections = function()
        return {}
    end
    getconnections = getgenv().getconnections
end

if #missingFunctions > 0 then
    warn("[ALS] Executor compatibility mode enabled. Missing functions: " .. table.concat(missingFunctions, ", "))
    warn("[ALS] Macro recording may not work properly, but playback should function.")
end

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

repeat task.wait() until LocalPlayer

task.spawn(function()
    local RS = game:GetService("ReplicatedStorage")
    local StarterPlayer = game:GetService("StarterPlayer")
    
    local afkInstancesToRemove = {
        {parent = RS, path = {"FusionPackage", "Components", "Lobby", "AFKChamber"}},
        {parent = RS, path = {"FusionPackage", "Stories", "Lobby", "AFKChamber.story"}},
        {parent = RS, path = {"FusionPackage", "TestStories", "AFKChamber.story"}},
        {parent = StarterPlayer, path = {"StarterPlayerScripts", "AFK"}}
    }
    
    local removedCount = 0
    
    for _, instanceInfo in ipairs(afkInstancesToRemove) do
        pcall(function()
            local current = instanceInfo.parent
            for i = 1, #instanceInfo.path - 1 do
                current = current:FindFirstChild(instanceInfo.path[i])
                if not current then return end
            end
            
            if current then
                local target = current:FindFirstChild(instanceInfo.path[#instanceInfo.path])
                if target then
                    target:Destroy()
                    removedCount = removedCount + 1
                    print("[ALS] Removed AFK instance: " .. table.concat(instanceInfo.path, "."))
                end
            end
        end)
    end
    
    if removedCount > 0 then
        print("[ALS] ✅ Removed " .. removedCount .. " AFK-related instances")
    end
end)

getgenv().DebugMode = getgenv().DebugMode or false

local function debugPrint(...)
    if getgenv().DebugMode then
        print(...)
    end
end

getgenv().DebugPrint = debugPrint

if not getgenv().Config then
    getgenv().Config = {}
end

local savedLoadingMonitorConfig = getgenv().Config.loadingScreenMonitor or {}
getgenv().LoadingScreenMonitorConfig = {
    enabled = savedLoadingMonitorConfig.enabled ~= false,
    maxLoadingTime = savedLoadingMonitorConfig.maxLoadingTime or 30,
    checkInterval = savedLoadingMonitorConfig.checkInterval or 2,
    enableRecovery = savedLoadingMonitorConfig.enableRecovery ~= false
}

getgenv().LoadingScreenMonitor = getgenv().LoadingScreenMonitor or {
    isMonitoring = false,
    loadingStartTime = 0,
    maxLoadingTime = getgenv().LoadingScreenMonitorConfig.maxLoadingTime,
    checkInterval = getgenv().LoadingScreenMonitorConfig.checkInterval,
    monitoringConnection = nil
}

getgenv()._LoadingScreenMonitor_startMonitoring = function()
    local monitor = getgenv().LoadingScreenMonitor
    local config = getgenv().LoadingScreenMonitorConfig
    
    if not config.enabled then
        return
    end
    
    if monitor.isMonitoring then
        return
    end
    
    monitor.isMonitoring = true
    monitor.loadingStartTime = tick()
    
    if monitor.monitoringConnection then
        pcall(function()
            monitor.monitoringConnection:Disconnect()
        end)
    end
    
    monitor.monitoringConnection = task.spawn(function()
        while monitor.isMonitoring do
            task.wait(monitor.checkInterval)
            
            local isLoading, reason = getgenv()._LoadingScreenMonitor_isPlayerLoading()
            
            if isLoading then
                local duration = getgenv()._LoadingScreenMonitor_getLoadingDuration()
                
                local isFrozen, freezeDuration = getgenv()._LoadingScreenMonitor_checkForFreeze()
                
                if isFrozen then
                    warn(string.format("[LoadingScreenMonitor] Loading screen freeze detected! Duration: %.1fs | Reason: %s", 
                        freezeDuration, reason or "Unknown"))
                    
                    getgenv()._DiagnosticsLogger_logLoadingScreenFreeze(freezeDuration, reason)
                    
                    if getgenv().LoadingScreenMonitorConfig.enableRecovery then
                        getgenv()._RestartRecovery_attemptRecovery("loading_screen_freeze")
                    end
                    
                    getgenv()._LoadingScreenMonitor_stopMonitoring()
                    break
                end
            else
                getgenv()._LoadingScreenMonitor_stopMonitoring()
            end
        end
    end)
end

getgenv()._LoadingScreenMonitor_stopMonitoring = function()
    local monitor = getgenv().LoadingScreenMonitor
    
    if not monitor.isMonitoring then
        return
    end
    
    monitor.isMonitoring = false
    monitor.loadingStartTime = 0
    
    if monitor.monitoringConnection then
        pcall(function()
            if typeof(monitor.monitoringConnection) == "RBXScriptConnection" then
                monitor.monitoringConnection:Disconnect()
            end
        end)
        monitor.monitoringConnection = nil
    end
end

getgenv()._LoadingScreenMonitor_isPlayerLoading = function()
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    if not LocalPlayer then
        return false, "No LocalPlayer"
    end
    
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        return false, "Character loaded"
    end
    
    local hasLoadingUI = false
    local uiReason = ""
    
    pcall(function()
        local loadingUI = LocalPlayer.PlayerGui:FindFirstChild("LoadingUI")
        if loadingUI and loadingUI.Enabled then
            hasLoadingUI = true
            uiReason = "LoadingUI visible"
        end
        
        if not hasLoadingUI then
            local teleportUI = LocalPlayer.PlayerGui:FindFirstChild("TeleportUI")
            if teleportUI and teleportUI.Enabled then
                hasLoadingUI = true
                uiReason = "TeleportUI visible"
            end
        end
    end)
    
    if hasLoadingUI then
        return true, uiReason
    end
    
    if not LocalPlayer.Character then
        return true, "Character not loaded"
    end
    
    return false, "Not loading"
end

getgenv()._LoadingScreenMonitor_getLoadingDuration = function()
    local monitor = getgenv().LoadingScreenMonitor
    
    if monitor.loadingStartTime == 0 then
        return 0
    end
    
    return tick() - monitor.loadingStartTime
end

getgenv()._LoadingScreenMonitor_checkForFreeze = function()
    local monitor = getgenv().LoadingScreenMonitor
    
    local duration = getgenv()._LoadingScreenMonitor_getLoadingDuration()
    
    if duration > monitor.maxLoadingTime then
        return true, duration
    end
    
    return false, duration
end

getgenv()._LoadingScreenMonitor_updateConfig = function(key, value)
    local config = getgenv().LoadingScreenMonitorConfig
    local monitor = getgenv().LoadingScreenMonitor
    
    if config[key] ~= nil then
        config[key] = value
        
        if key == "maxLoadingTime" then
            monitor.maxLoadingTime = value
        elseif key == "checkInterval" then
            monitor.checkInterval = value
        end
        
        getgenv().Config.loadingScreenMonitor = getgenv().Config.loadingScreenMonitor or {}
        getgenv().Config.loadingScreenMonitor[key] = value
        getgenv().SaveConfig(getgenv().Config)
        
        warn(string.format("[LoadingScreenMonitor] Config updated: %s = %s", key, tostring(value)))
        return true
    end
    
    return false
end

getgenv()._LoadingScreenMonitor_getConfig = function()
    return getgenv().LoadingScreenMonitorConfig
end

local savedRestartRecoveryConfig = getgenv().Config.restartRecovery or {}
getgenv().RestartRecoveryConfig = {
    enabled = savedRestartRecoveryConfig.enabled ~= false,
    maxRetries = savedRestartRecoveryConfig.maxRetries or 3,
    retryDelay = savedRestartRecoveryConfig.retryDelay or 5,
    characterLoadTimeout = savedRestartRecoveryConfig.characterLoadTimeout or 15,
    autoExecuteOnRecover = savedRestartRecoveryConfig.autoExecuteOnRecover ~= false
}

getgenv().RestartRecovery = getgenv().RestartRecovery or {
    maxRetries = getgenv().RestartRecoveryConfig.maxRetries,
    retryDelay = getgenv().RestartRecoveryConfig.retryDelay,
    currentAttempt = 0,
    characterLoadTimeout = getgenv().RestartRecoveryConfig.characterLoadTimeout,
    isRecovering = false
}

getgenv()._RestartRecovery_attemptRecovery = function(reason)
    local recovery = getgenv().RestartRecovery
    local config = getgenv().RestartRecoveryConfig
    
    if not config.enabled then
        warn("[RestartRecovery] Recovery is disabled in config")
        return false
    end
    
    if recovery.isRecovering then
        warn("[RestartRecovery] Recovery already in progress")
        return false
    end
    
    recovery.isRecovering = true
    recovery.currentAttempt = 0
    
    warn(string.format("[RestartRecovery] Starting recovery process. Reason: %s", reason or "Unknown"))
    
    local success = false
    
    for attempt = 1, recovery.maxRetries do
        recovery.currentAttempt = attempt
        
        warn(string.format("[RestartRecovery] Recovery attempt %d/%d", attempt, recovery.maxRetries))
        
        if attempt > 1 then
            task.wait(recovery.retryDelay)
        end
        
        if attempt == 1 then
            success = getgenv()._RestartRecovery_performRecoveryTeleport()
        elseif attempt == 2 then
            warn("[RestartRecovery] Attempt 2: Forcing connection cleanup before teleport")
            pcall(function()
                if getgenv().ConnectionManager then
                    getgenv().ConnectionManager:cleanup()
                end
            end)
            success = getgenv()._RestartRecovery_performRecoveryTeleport()
        elseif attempt == 3 then
            warn("[RestartRecovery] Attempt 3: Full memory cleanup before teleport")
            pcall(function()
                if getgenv().ConnectionManager then
                    getgenv().ConnectionManager:cleanup()
                end
                collectgarbage("collect")
            end)
            success = getgenv()._RestartRecovery_performRecoveryTeleport()
        end
        
        if success then
            local charLoaded = getgenv()._RestartRecovery_waitForCharacterLoad(recovery.characterLoadTimeout)
            
            if charLoaded then
                warn(string.format("[RestartRecovery] Recovery successful on attempt %d", attempt))
                getgenv()._RestartRecovery_notifyRecoveryStatus(true, "Recovery successful")
                
                getgenv()._DiagnosticsLogger_logRecoveryAction(
                    reason,
                    "recovery_teleport",
                    "success",
                    {attempt = attempt, totalAttempts = recovery.maxRetries}
                )
                
                recovery.isRecovering = false
                return true
            else
                warn(string.format("[RestartRecovery] Character failed to load after teleport (attempt %d)", attempt))
            end
        else
            warn(string.format("[RestartRecovery] Teleport failed (attempt %d)", attempt))
        end
    end
    
    warn(string.format("[RestartRecovery] All %d recovery attempts failed", recovery.maxRetries))
    getgenv()._RestartRecovery_notifyRecoveryStatus(false, "Recovery failed after " .. recovery.maxRetries .. " attempts")
    
    getgenv()._DiagnosticsLogger_logRecoveryAction(
        reason,
        "recovery_teleport",
        "failed",
        {attempts = recovery.maxRetries, reason = "all_attempts_exhausted"}
    )
    
    recovery.isRecovering = false
    
    return false
end

getgenv()._RestartRecovery_queueAutoExecute = function()
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local config = getgenv().RestartRecoveryConfig
    
    if not config.autoExecuteOnRecover then
        return true
    end
    
    if not queueonteleport then
        warn("[RestartRecovery] queueonteleport not available")
        return false
    end
    
    local scriptSource = game:HttpGet("https://github.com/biggaboy212/Maclib/releases/latest/download/maclib.txt")
    
    if not scriptSource or scriptSource == "" then
        warn("[RestartRecovery] Failed to fetch script source for auto-execute")
        return false
    end
    
    local success = pcall(function()
        queueonteleport(scriptSource)
    end)
    
    if success then
        return true
    else
        warn("[RestartRecovery] Failed to queue script for auto-execute")
        return false
    end
end

getgenv()._RestartRecovery_performRecoveryTeleport = function()
    local TeleportService = game:GetService("TeleportService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    if not LocalPlayer then
        warn("[RestartRecovery] LocalPlayer not found")
        return false
    end
    
    getgenv()._RestartRecovery_queueAutoExecute()
    
    local gameId = 12886143095
    
    local success = pcall(function()
        TeleportService:Teleport(gameId, LocalPlayer)
    end)
    
    if success then
        return true
    else
        warn("[RestartRecovery] TeleportService:Teleport failed")
        return false
    end
end

getgenv()._RestartRecovery_waitForCharacterLoad = function(timeout)
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    if not LocalPlayer then
        return false
    end
    
    local startTime = tick()
    timeout = timeout or getgenv().RestartRecovery.characterLoadTimeout
    
    while (tick() - startTime) < timeout do
        if LocalPlayer.Character then
            local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local timeTaken = tick() - startTime
                return true, timeTaken
            end
        end
        
        task.wait(0.5)
    end
    
    return false, timeout
end

getgenv()._RestartRecovery_notifyRecoveryStatus = function(success, message)
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    if not LocalPlayer then
        return
    end
    
    pcall(function()
        local StarterGui = game:GetService("StarterGui")
        StarterGui:SetCore("SendNotification", {
            Title = success and "Recovery Success" or "Recovery Failed",
            Text = message or (success and "Successfully recovered from loading screen freeze" or "Failed to recover"),
            Duration = success and 5 or 10
        })
    end)
    
    if success then
        warn("[RestartRecovery] " .. (message or "Recovery successful"))
    else
        warn("[RestartRecovery] CRITICAL: " .. (message or "Recovery failed"))
    end
end

getgenv()._RestartRecovery_updateConfig = function(key, value)
    local config = getgenv().RestartRecoveryConfig
    local recovery = getgenv().RestartRecovery
    
    if config[key] ~= nil then
        config[key] = value
        
        if key == "maxRetries" then
            recovery.maxRetries = value
        elseif key == "retryDelay" then
            recovery.retryDelay = value
        elseif key == "characterLoadTimeout" then
            recovery.characterLoadTimeout = value
        end
        
        getgenv().Config.restartRecovery = getgenv().Config.restartRecovery or {}
        getgenv().Config.restartRecovery[key] = value
        getgenv().SaveConfig(getgenv().Config)
        
        warn(string.format("[RestartRecovery] Config updated: %s = %s", key, tostring(value)))
        return true
    end
    
    return false
end

getgenv()._RestartRecovery_getConfig = function()
    return getgenv().RestartRecoveryConfig
end

getgenv().StateVerification = getgenv().StateVerification or {
    verificationTimeout = 10,
    requiredChecks = {"character", "gameStarted", "workspace"}
}

getgenv()._StateVerification_verifyCharacter = function()
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    if not LocalPlayer then
        return false, "LocalPlayer not found"
    end
    
    if not LocalPlayer.Character then
        return false, "Character does not exist"
    end
    
    if not LocalPlayer.Character.Parent then
        return false, "Character has no Parent"
    end
    
    local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    if not humanoid then
        return false, "Humanoid not found"
    end
    
    if humanoid.Health <= 0 then
        return false, "Humanoid health is 0"
    end
    
    return true, "Character valid"
end

getgenv()._StateVerification_verifyGameStarted = function()
    local RS = game:GetService("ReplicatedStorage")
    
    local gameStarted = RS:FindFirstChild("GameStarted")
    
    return true, "GameStarted value accessible"
end

getgenv()._StateVerification_verifyWorkspace = function()
    local workspace = game:GetService("Workspace")
    
    local hasMap = workspace:FindFirstChild("Map") ~= nil
    local hasTowers = workspace:FindFirstChild("Towers") ~= nil
    local hasEnemies = workspace:FindFirstChild("Enemies") ~= nil

    
    local foundObjects = {}
    if hasMap then table.insert(foundObjects, "Map") end
    if hasTowers then table.insert(foundObjects, "Towers") end
    if hasEnemies then table.insert(foundObjects, "Enemies") end
    
    return true, "Workspace contains: " .. table.concat(foundObjects, ", ")
end

getgenv()._StateVerification_performFullVerification = function()
    local verification = getgenv().StateVerification
    local results = {}
    local allPassed = true
    
    local charValid, charReason = getgenv()._StateVerification_verifyCharacter()
    table.insert(results, {
        checkName = "Character",
        passed = charValid,
        reason = charReason,
        timestamp = tick()
    })
    if not charValid then
        allPassed = false
    end
    
    local gameStartedValid, gameStartedReason = getgenv()._StateVerification_verifyGameStarted()
    table.insert(results, {
        checkName = "GameStarted",
        passed = gameStartedValid,
        reason = gameStartedReason,
        timestamp = tick()
    })
    if not gameStartedValid then
        allPassed = false
    end
    
    local workspaceValid, workspaceReason = getgenv()._StateVerification_verifyWorkspace()
    table.insert(results, {
        checkName = "Workspace",
        passed = workspaceValid,
        reason = workspaceReason,
        timestamp = tick()
    })
    if not workspaceValid then
        allPassed = false
    end
    
    for _, result in ipairs(results) do
        local status = result.passed and "✓" or "✗"
        local logLevel = result.passed and "INFO" or "WARN"
        local message = string.format("[StateVerification] %s %s: %s", status, result.checkName, result.reason)
        
        if result.passed then
            warn(message)
        else
            warn(message)
        end
    end
    
    return allPassed, results
end

getgenv()._StateVerification_waitForValidState = function(timeout)
    local verification = getgenv().StateVerification
    timeout = timeout or verification.verificationTimeout
    
    local startTime = tick()
    
    warn(string.format("[StateVerification] Waiting for valid state (timeout: %.1fs)", timeout))
    
    while (tick() - startTime) < timeout do
        local allPassed, results = getgenv()._StateVerification_performFullVerification()
        
        if allPassed then
            local timeTaken = tick() - startTime
            warn(string.format("[StateVerification] All verifications passed (%.2fs)", timeTaken))
            return true, timeTaken
        end
        
        task.wait(1)
    end
    
    local timeTaken = tick() - startTime
    
    return false, timeTaken
end

getgenv().DiagnosticsLogger = getgenv().DiagnosticsLogger or {
    restartHistory = {},
    recoveryHistory = {},
    freezeHistory = {},
    memorySnapshots = {},
    maxHistorySize = 20
}

getgenv()._DiagnosticsLogger_logSeamlessRestart = function(count, maxRounds, detectionMethod)
    local logger = getgenv().DiagnosticsLogger
    
    local entry = {
        timestamp = tick(),
        count = count,
        maxRounds = maxRounds,
        method = detectionMethod,
        memoryBefore = collectgarbage("count")
    }
    
    table.insert(logger.restartHistory, entry)
    
    if #logger.restartHistory > logger.maxHistorySize then
        table.remove(logger.restartHistory, 1)
    end

    
    return entry
end

getgenv()._DiagnosticsLogger_logLoadingScreenFreeze = function(duration, playerState)
    local logger = getgenv().DiagnosticsLogger
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    local stateDetails = {
        duration = duration,
        hasCharacter = LocalPlayer.Character ~= nil,
        characterParent = LocalPlayer.Character and LocalPlayer.Character.Parent ~= nil or false,
        hasHumanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") ~= nil or false,
        humanoidHealth = 0,
        loadingUIVisible = false,
        teleportUIVisible = false,
        timestamp = tick()
    }
    
    pcall(function()
        if LocalPlayer.Character then
            local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            if humanoid then
                stateDetails.humanoidHealth = humanoid.Health
            end
        end
    end)
    
    pcall(function()
        local loadingUI = LocalPlayer.PlayerGui:FindFirstChild("LoadingUI")
        if loadingUI then
            stateDetails.loadingUIVisible = loadingUI.Enabled
        end
        
        local teleportUI = LocalPlayer.PlayerGui:FindFirstChild("TeleportUI")
        if teleportUI then
            stateDetails.teleportUIVisible = teleportUI.Enabled
        end
    end)
    
    table.insert(logger.freezeHistory, stateDetails)
    
    if #logger.freezeHistory > logger.maxHistorySize then
        table.remove(logger.freezeHistory, 1)
    end
    
    warn(string.format("[Diagnostics] Loading screen freeze | Duration: %.1fs | Character: %s | Humanoid: %s (HP: %.1f) | LoadingUI: %s | TeleportUI: %s",
        duration,
        tostring(stateDetails.hasCharacter),
        tostring(stateDetails.hasHumanoid),
        stateDetails.humanoidHealth,
        tostring(stateDetails.loadingUIVisible),
        tostring(stateDetails.teleportUIVisible)))
    
    return stateDetails
end

getgenv()._DiagnosticsLogger_logRecoveryAction = function(reason, action, result, details)
    local logger = getgenv().DiagnosticsLogger
    
    local entry = {
        timestamp = tick(),
        reason = reason,
        action = action,
        result = result,
        details = details or {},
        memoryAfter = collectgarbage("count")
    }
    
    table.insert(logger.recoveryHistory, entry)
    
    if #logger.recoveryHistory > logger.maxHistorySize then
        table.remove(logger.recoveryHistory, 1)
    end
    
    local resultIcon = result == "success" and "✓" or "✗"
    warn(string.format("[Diagnostics] Recovery action %s | Reason: %s | Action: %s | Result: %s | Memory: %.2f MB",
        resultIcon,
        reason,
        action,
        result,
        entry.memoryAfter / 1024))
    
    if details and type(details) == "table" then
        for key, value in pairs(details) do
            warn(string.format("[Diagnostics]   %s: %s", key, tostring(value)))
        end
    end
    
    return entry
end

getgenv()._DiagnosticsLogger_trackAverageRestartTime = function()
    local logger = getgenv().DiagnosticsLogger
    
    if #logger.restartHistory < 2 then
        return 0
    end
    
    local totalTime = 0
    local count = 0
    
    for i = 2, #logger.restartHistory do
        local timeDiff = logger.restartHistory[i].timestamp - logger.restartHistory[i-1].timestamp
        totalTime = totalTime + timeDiff
        count = count + 1
    end
    
    local avgTime = totalTime / count
    
    warn(string.format("[Diagnostics] Average time between restarts: %.1fs (based on %d restarts)", avgTime, count))
    
    return avgTime
end

getgenv()._DiagnosticsLogger_logMemoryUsage = function(phase)
    local logger = getgenv().DiagnosticsLogger
    
    local memoryKB = collectgarbage("count")
    local memoryMB = memoryKB / 1024
    
    local snapshot = {
        timestamp = tick(),
        phase = phase,
        memoryKB = memoryKB,
        memoryMB = memoryMB
    }
    
    table.insert(logger.memorySnapshots, snapshot)
    
    if #logger.memorySnapshots > logger.maxHistorySize then
        table.remove(logger.memorySnapshots, 1)
    end
    
    warn(string.format("[Diagnostics] Memory usage [%s]: %.2f MB (%.0f KB)", phase, memoryMB, memoryKB))
    
    if #logger.memorySnapshots >= 2 then
        local previous = logger.memorySnapshots[#logger.memorySnapshots - 1]
        local diff = memoryKB - previous.memoryKB
        local diffMB = diff / 1024
        
        if math.abs(diff) > 100 then
            local changeIcon = diff > 0 and "↑" or "↓"
            warn(string.format("[Diagnostics]   %s %.2f MB since %s", changeIcon, math.abs(diffMB), previous.phase))
        end
    end
    
    return snapshot
end

getgenv()._DiagnosticsLogger_getDiagnosticsSummary = function()
    local logger = getgenv().DiagnosticsLogger
    
    local summary = {
        totalRestarts = #logger.restartHistory,
        totalRecoveries = #logger.recoveryHistory,
        totalFreezes = #logger.freezeHistory,
        averageRestartTime = 0,
        currentMemoryMB = collectgarbage("count") / 1024,
        successfulRecoveries = 0,
        failedRecoveries = 0
    }
    
    if #logger.restartHistory >= 2 then
        summary.averageRestartTime = getgenv()._DiagnosticsLogger_trackAverageRestartTime()
    end
    
    for _, recovery in ipairs(logger.recoveryHistory) do
        if recovery.result == "success" then
            summary.successfulRecoveries = summary.successfulRecoveries + 1
        else
            summary.failedRecoveries = summary.failedRecoveries + 1
        end
    end
    
    return summary
end

getgenv().DiagnosticsLogger.discountHistory = getgenv().DiagnosticsLogger.discountHistory or {}
getgenv().DiagnosticsLogger.saveHistory = getgenv().DiagnosticsLogger.saveHistory or {}
getgenv().DiagnosticsLogger.crashWarnings = getgenv().DiagnosticsLogger.crashWarnings or {}
getgenv().DiagnosticsLogger.discountErrors = getgenv().DiagnosticsLogger.discountErrors or {}

getgenv()._DiagnosticsLogger_logDiscountCalculation = function(unitName, multiplier, enchant, success)
    if not getgenv().DebugMode then
        return
    end
    
    local logger = getgenv().DiagnosticsLogger
    
    local entry = {
        timestamp = tick(),
        unitName = unitName,
        multiplier = multiplier,
        enchant = enchant or "none",
        success = success
    }
    
    table.insert(logger.discountHistory, entry)
    
    if #logger.discountHistory > logger.maxHistorySize then
        table.remove(logger.discountHistory, 1)
    end
    
    if success then
        if multiplier < 1.0 then
            debugPrint(string.format("[Diagnostics] Discount: %s | Enchant: %s | Multiplier: %.2fx", 
                unitName, enchant, multiplier))
        else
            debugPrint(string.format("[Diagnostics] Discount: %s | No discount (%.2fx)", 
                unitName, multiplier))
        end
    else
        debugPrint(string.format("[Diagnostics] Discount: %s | Check failed, using default (%.2fx)", 
            unitName, multiplier))
    end
    
    return entry
end

getgenv()._DiagnosticsLogger_logDiscountError = function(unitName, errorMessage)
    if not getgenv().DebugMode then
        return
    end
    
    local logger = getgenv().DiagnosticsLogger
    
    local entry = {
        timestamp = tick(),
        unitName = unitName,
        error = errorMessage
    }
    
    table.insert(logger.discountErrors, entry)
    
    if #logger.discountErrors > logger.maxHistorySize then
        table.remove(logger.discountErrors, 1)
    end
    
    debugPrint(string.format("[Diagnostics] Discount Error: %s | Error: %s", unitName, errorMessage))
    
    return entry
end

getgenv()._DiagnosticsLogger_logSaveOperation = function(macroName, success, errorMessage, attempt, maxAttempts)
    if not getgenv().DebugMode then
        return
    end
    
    local logger = getgenv().DiagnosticsLogger
    
    local entry = {
        timestamp = tick(),
        macroName = macroName,
        success = success,
        error = errorMessage,
        attempt = attempt,
        maxAttempts = maxAttempts
    }
    
    table.insert(logger.saveHistory, entry)
    
    if #logger.saveHistory > logger.maxHistorySize then
        table.remove(logger.saveHistory, 1)
    end
    
    if success then
        if attempt and attempt > 1 then
            debugPrint(string.format("[Diagnostics] Save: %s | Success on attempt %d/%d", 
                macroName, attempt, maxAttempts))
        else
            debugPrint(string.format("[Diagnostics] Save: %s | Success", macroName))
        end
    else
        if attempt then
            debugPrint(string.format("[Diagnostics] Save: %s | Failed attempt %d/%d | Error: %s", 
                macroName, attempt, maxAttempts, errorMessage or "unknown"))
        else
            debugPrint(string.format("[Diagnostics] Save: %s | Failed | Error: %s", 
                macroName, errorMessage or "unknown"))
        end
    end
    
    return entry
end

getgenv()._DiagnosticsLogger_logCrashWarning = function(warningType, details)
    local logger = getgenv().DiagnosticsLogger
    
    local entry = {
        timestamp = tick(),
        warningType = warningType,
        details = details or {},
        memoryMB = collectgarbage("count") / 1024
    }
    
    table.insert(logger.crashWarnings, entry)
    
    if #logger.crashWarnings > logger.maxHistorySize then
        table.remove(logger.crashWarnings, 1)
    end
    
    warn(string.format("[Diagnostics] Crash Warning: %s | Memory: %.2f MB", warningType, entry.memoryMB))
    
    if details and type(details) == "table" then
        for key, value in pairs(details) do
            if getgenv().DebugMode then
                debugPrint(string.format("[Diagnostics]   %s: %s", key, tostring(value)))
            end
        end
    end
    
    return entry
end


local ErrorHandler = {
    logLevel = "INFO",
    suppressPatterns = {
        "HttpService", 
        "MarketplaceService",
        "TeleportService"
    }
}

function ErrorHandler:log(level, message, data)
    if level == "DEBUG" and self.logLevel ~= "DEBUG" then
        return
    end
    
    for _, pattern in ipairs(self.suppressPatterns) do
        if message and message:find(pattern) then
            return
        end
    end
    
    local prefix = string.format("[%s]", level)
    local output = prefix .. " " .. tostring(message)
    
    if data then
        output = output .. " | Data: " .. tostring(data)
    end
    
    if level == "ERROR" then
        warn(output)
    else
        print(output)
    end
end

function ErrorHandler:wrap(func, context)
    return function(...)
        local success, result = pcall(func, ...)
        if not success then
            self:log("ERROR", string.format("%s failed: %s", context or "Operation", tostring(result)))
            return nil, result
        end
        return result
    end
end

function ErrorHandler:wrapAsync(func, context)
    local success, result = pcall(func)
    if not success then
        self:log("ERROR", string.format("%s failed: %s", context or "Operation", tostring(result)))
        return false, result
    end
    return true, result
end

function ErrorHandler:notify(window, title, message, isCritical)
    if window and window.Notify then
        pcall(function()
            window:Notify({
                Title = title or "Error",
                Description = message or "An error occurred",
                Lifetime = isCritical and 10 or 5,
                Style = "Cancel"
            })
        end)
    end
    
    if isCritical then
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = title or "Critical Error",
                Text = message or "A critical error occurred",
                Duration = 10
            })
        end)
    end
end

function ErrorHandler:notifyCritical(window, title, message)
    self:notify(window, title, message, true)
    self:log("ERROR", "CRITICAL: " .. (title or "Error") .. " - " .. (message or "Unknown"))
end

getgenv().ConnectionStability = getgenv().ConnectionStability or {
    lastRemoteCallTime = 0,
    minCallDelay = 0.15,
    callQueue = {},
    isProcessing = false,
    errorDialogActive = false,
    pausedUntil = 0,
    version = "1.1.0"
}

print("[ALS] ✅ Connection Stability System v" .. getgenv().ConnectionStability.version .. " loaded")
print("[ALS] ✅ Macro fixes v1.1.0 - Improved restart detection and duplicate prevention")

getgenv()._ConnectionStability_safeRemoteCall = function(remote, method, ...)
    local stability = getgenv().ConnectionStability
    local args = {...}
    
    if tick() < stability.pausedUntil then
        warn("[Connection] Calls paused due to connection error, waiting...")
        task.wait(stability.pausedUntil - tick())
    end
    
    local timeSinceLastCall = tick() - stability.lastRemoteCallTime
    if timeSinceLastCall < stability.minCallDelay then
        task.wait(stability.minCallDelay - timeSinceLastCall)
    end
    
    stability.lastRemoteCallTime = tick()
    
    getgenv()._SkipRecordingNextCall = true
    
    local success, result
    if method == "InvokeServer" then
        success, result = pcall(function()
            return remote:InvokeServer(unpack(args))
        end)
    else
        success, result = pcall(function()
            remote:FireServer(unpack(args))
            return true
        end)
    end
    
    getgenv()._SkipRecordingNextCall = false
    
    if not success then
        warn("[Connection] Remote call failed: " .. tostring(result))
    end
    
    return success, result
end

getgenv()._SafeClickButton = function(button, callback)
    getgenv()._SkipRecordingNextCall = true
    local success, result = pcall(callback or function()
        if getconnections then
            local events = {"Activated", "MouseButton1Click", "MouseButton1Down", "MouseButton1Up"}
            for _, eventName in ipairs(events) do
                local connections = getconnections(button[eventName])
                if connections then
                    for _, conn in ipairs(connections) do
                        if conn and conn.Fire then
                            conn:Fire()
                        end
                    end
                end
            end
        end
    end)
    getgenv()._SkipRecordingNextCall = false
    return success, result
end

task.spawn(function()
    while task.wait(1) do
        if getgenv()._SkipRecordingNextCall then
            getgenv()._SkipRecordingNextCall = false
        end
    end
end)

task.spawn(function()
    while task.wait(0.5) do
        pcall(function()
            if not LocalPlayer or not LocalPlayer.PlayerGui then return end
            
            local errorDialog = LocalPlayer.PlayerGui:FindFirstChild("ErrorPrompt") or
                               LocalPlayer.PlayerGui:FindFirstChild("ErrorDialog")
            
            if errorDialog and errorDialog.Enabled then
                local textFound = false
                
                for _, descendant in pairs(errorDialog:GetDescendants()) do
                    if descendant:IsA("TextLabel") or descendant:IsA("TextButton") then
                        local text = descendant.Text:lower()
                        if text:find("internet") or text:find("connection") or text:find("network") then
                            textFound = true
                            warn("[Connection] Connection error dialog detected! Auto-dismissing...")
                            
                            getgenv().ConnectionStability.errorDialogActive = true
                            getgenv().ConnectionStability.pausedUntil = tick() + 5
                            
                            for _, button in pairs(errorDialog:GetDescendants()) do
                                if button:IsA("TextButton") then
                                    local btnText = button.Text:lower()
                                    if btnText:find("ok") or btnText:find("dismiss") or btnText:find("close") then
                                        task.spawn(function()
                                            pcall(function()
                                                for i = 1, 3 do
                                                    if button and button.Parent then
                                                        local VIM = game:GetService("VirtualInputManager")
                                                        local GuiService = game:GetService("GuiService")
                                                        
                                                        GuiService.SelectedObject = button
                                                        task.wait(0.1)
                                                        VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                                                        task.wait(0.05)
                                                        VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                                                        task.wait(0.2)
                                                    end
                                                end
                                            end)
                                        end)
                                        break
                                    end
                                end
                            end
                            break
                        end
                    end
                end
                
                if textFound then
                    task.wait(2)
                    if errorDialog and errorDialog.Enabled then
                        pcall(function()
                            errorDialog.Enabled = false
                        end)
                    end
                end
            end
        end)
    end
end)

task.spawn(function()
    local characterWaitTime = 0
    local maxCharacterWait = 30
    
    pcall(function()
        if getgenv()._LoadingScreenMonitor_startMonitoring then
            getgenv()._LoadingScreenMonitor_startMonitoring()
        end
    end)
    
    pcall(function()
        if getgenv()._CrashMonitor_startMonitoring then
            getgenv()._CrashMonitor_startMonitoring()
        end
    end)
    
    while not LocalPlayer.Character and characterWaitTime < maxCharacterWait do
        task.wait(0.5)
        characterWaitTime = characterWaitTime + 0.5
        
        local loadingUI = LocalPlayer.PlayerGui:FindFirstChild("LoadingUI") or 
                          LocalPlayer.PlayerGui:FindFirstChild("TeleportUI")
        
        if loadingUI and loadingUI.Enabled then
            characterWaitTime = 0 
        end
        
        local isFrozen, freezeDuration = getgenv()._LoadingScreenMonitor_checkForFreeze()
        if isFrozen then
            warn(string.format("[ALS] Loading screen freeze detected during initial load (%.1fs)", freezeDuration))
            break
        end
    end
    
    getgenv()._LoadingScreenMonitor_stopMonitoring()
    
    if not LocalPlayer.Character and characterWaitTime >= maxCharacterWait then
        warn("[ALS] Character not loaded after " .. maxCharacterWait .. "s, attempting recovery...")
        
        local recoverySuccess = getgenv()._RestartRecovery_attemptRecovery("initial_load_timeout")
        
        if not recoverySuccess then
            warn("[ALS] Recovery failed, script may not work properly")
        end
    end
    
    if LocalPlayer.Character then
        warn("[ALS] Character loaded successfully, verifying game state...")
        
        local stateValid, timeTaken = getgenv()._StateVerification_waitForValidState(10)
        
        if stateValid then
            warn(string.format("[ALS] Initial load complete and verified (%.2fs)", timeTaken))
        end
    end
    
    task.wait(1)
end)

task.spawn(function()
    while true do
        task.wait(5)
        
        local isLoading, reason = getgenv()._LoadingScreenMonitor_isPlayerLoading()
        
        if isLoading then
            warn("[LoadingScreenMonitor] Detected loading state during gameplay: " .. (reason or "Unknown"))
            
            getgenv()._LoadingScreenMonitor_startMonitoring()
            
            local maxWait = 45
            local waited = 0
            
            while waited < maxWait do
                task.wait(2)
                waited = waited + 2
                
                local stillLoading = getgenv()._LoadingScreenMonitor_isPlayerLoading()
                if not stillLoading then
                    warn("[LoadingScreenMonitor] Loading completed after " .. waited .. "s")
                    getgenv()._LoadingScreenMonitor_stopMonitoring()
                    break
                end
                
                if waited >= 30 then
                    warn("[LoadingScreenMonitor] Loading screen stuck for " .. waited .. "s, attempting recovery...")
                    getgenv()._LoadingScreenMonitor_stopMonitoring()
                    getgenv()._RestartRecovery_attemptRecovery("loading_screen_stuck_during_gameplay")
                    break
                end
            end
        end
    end
end)

getgenv()._safeGetConnections = function(signal)
    if not getconnections then
        return {}
    end
    local success, result = pcall(function()
        return getconnections(signal)
    end)
    if success and result then
        return result
    end
    return {}
end

local PlatformDetector = {
    executor = "Unknown",
    isMobile = false,
    capabilities = {
        hasFileSystem = false,
        hasHTTP = false,
        hasVirtualInput = false,
        hasClipboard = false,
        hasConnectionIntrospection = false
    },
    detected = false
}

function PlatformDetector:detect()
    if self.detected then
        return self
    end
    
    ErrorHandler:wrapAsync(function()
        if identifyexecutor then
            self.executor = identifyexecutor() or "Unknown"
        elseif KRNL_LOADED then
            self.executor = "KRNL"
        elseif syn then
            self.executor = "Synapse X"
        elseif SENTINEL_V2 then
            self.executor = "Sentinel"
        elseif getexecutorname then
            self.executor = getexecutorname() or "Unknown"
        end
    end, "Executor detection")
    
    ErrorHandler:wrapAsync(function()
        local UserInputService = game:GetService("UserInputService")
        self.isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
    end, "Mobile detection")
    
    ErrorHandler:wrapAsync(function()
        if isfolder and makefolder and isfile and readfile and writefile then
            self.capabilities.hasFileSystem = true
        end
    end, "File system capability check")
    
    ErrorHandler:wrapAsync(function()
        if game.HttpGet then
            self.capabilities.hasHTTP = true
        end
    end, "HTTP capability check")
    
    ErrorHandler:wrapAsync(function()
        local VirtualInputManager = game:GetService("VirtualInputManager")
        if VirtualInputManager then
            self.capabilities.hasVirtualInput = true
        end
    end, "VirtualInput capability check")
    
    ErrorHandler:wrapAsync(function()
        if setclipboard then
            self.capabilities.hasClipboard = true
        end
    end, "Clipboard capability check")
    
    ErrorHandler:wrapAsync(function()
        if getconnections then
            self.capabilities.hasConnectionIntrospection = true
        end
    end, "Connection introspection capability check")
    
    self.detected = true
    
    ErrorHandler:log("INFO", string.format("Platform detected: %s | Mobile: %s", 
        self.executor, 
        tostring(self.isMobile)))
    ErrorHandler:log("DEBUG", "Capabilities: " .. game:GetService("HttpService"):JSONEncode(self.capabilities))
    
    return self
end

function PlatformDetector:hasCapability(feature)
    if not self.detected then
        self:detect()
    end
    return self.capabilities[feature] == true
end

function PlatformDetector:getExecutor()
    if not self.detected then
        self:detect()
    end
    return self.executor
end

function PlatformDetector:isMobilePlatform()
    if not self.detected then
        self:detect()
    end
    return self.isMobile
end

function PlatformDetector:getCapabilityReport()
    if not self.detected then
        self:detect()
    end
    
    local report = "\n=== Platform Capabilities ===\n"
    report = report .. string.format("Executor: %s\n", self.executor)
    report = report .. string.format("Mobile: %s\n", tostring(self.isMobile))
    report = report .. "\nCapabilities:\n"
    
    for capability, available in pairs(self.capabilities) do
        local status = available and "✓" or "✗"
        report = report .. string.format("  %s %s\n", status, capability)
    end
    
    report = report .. "============================\n"
    return report
end

PlatformDetector:detect()

local MobileOptimizer = {
    isMobile = false,
    pollingInterval = 0.5, 
    maxConcurrentOperations = 10,
    activeOperations = 0,
    initialized = false
}

function MobileOptimizer:init()
    if self.initialized then
        return self
    end
    
    self.isMobile = PlatformDetector:isMobilePlatform()
    
    if self.isMobile then
        self.pollingInterval = 1.0 
        
        self.maxConcurrentOperations = 3
    else
        self.pollingInterval = 0.5
        self.maxConcurrentOperations = 10
    end
    
    self.initialized = true
    return self
end

function MobileOptimizer:getPollingInterval(baseInterval)
    if not self.initialized then
        self:init()
    end
    
    if self.isMobile then
        return baseInterval * 2 
    end
    
    return baseInterval
end

function MobileOptimizer:canStartOperation()
    if not self.initialized then
        self:init()
    end
    
    return self.activeOperations < self.maxConcurrentOperations
end

function MobileOptimizer:startOperation()
    if not self.initialized then
        self:init()
    end
    
    if self.activeOperations >= self.maxConcurrentOperations then
        ErrorHandler:log("WARN", string.format("Max concurrent operations reached (%d/%d)", 
            self.activeOperations, self.maxConcurrentOperations))
        return false
    end
    
    self.activeOperations = self.activeOperations + 1
    ErrorHandler:log("DEBUG", string.format("Operation started (%d/%d active)", 
        self.activeOperations, self.maxConcurrentOperations))
    return true
end

function MobileOptimizer:endOperation()
    if not self.initialized then
        self:init()
    end
    
    if self.activeOperations > 0 then
        self.activeOperations = self.activeOperations - 1
        ErrorHandler:log("DEBUG", string.format("Operation ended (%d/%d active)", 
            self.activeOperations, self.maxConcurrentOperations))
    end
end

function MobileOptimizer:wrapOperation(func)
    if not self.initialized then
        self:init()
    end
    
    return function(...)
        while not self:canStartOperation() do
            task.wait(0.1)
        end
        
        self:startOperation()
        
        local success, result = pcall(func, ...)
        
        self:endOperation()
        
        if not success then
            ErrorHandler:log("ERROR", "Operation failed: " .. tostring(result))
            return nil
        end
        
        return result
    end
end

function MobileOptimizer:getStats()
    if not self.initialized then
        self:init()
    end
    
    return {
        isMobile = self.isMobile,
        pollingInterval = self.pollingInterval,
        maxConcurrentOperations = self.maxConcurrentOperations,
        activeOperations = self.activeOperations
    }
end

MobileOptimizer:init()

local GameStateDetector = {
    isInLobby = nil,
    isInGame = false,
    gameStarted = false,
    detected = false,
    initializationTimeout = 3, 
    retryAttempts = 3,
    retryDelay = 0.5,
    pendingInitializations = {},
    gameStateChangeCallbacks = {}
}

function GameStateDetector:detect()
    if self.detected then
        return self
    end
    
    local detectionStartTime = tick()
    
    ErrorHandler:wrapAsync(function()
        local workspace = game:GetService("Workspace")
        local MarketplaceService = game:GetService("MarketplaceService")
        
        local hasLobbyFolder = workspace:FindFirstChild("Lobby") ~= nil
        
        local placeName = ""
        pcall(function()
            placeName = MarketplaceService:GetProductInfo(game.PlaceId).Name or ""
        end)
        local placeNameHasLobby = placeName:lower():find("lobby") ~= nil
        
        local hasMap = workspace:FindFirstChild("Map") ~= nil
        local hasTowers = workspace:FindFirstChild("Towers") ~= nil
        local hasEnemies = workspace:FindFirstChild("Enemies") ~= nil
        
        if hasLobbyFolder or placeNameHasLobby then
            self.isInLobby = true
            self.isInGame = false
        elseif hasMap or hasTowers or hasEnemies then
            self.isInLobby = false
            self.isInGame = true
        else
            self.isInLobby = true
            self.isInGame = false
        end
        
        ErrorHandler:log("INFO", string.format("Game state detected: %s (took %.2fs)", 
            self.isInLobby and "Lobby" or "In-Game",
            tick() - detectionStartTime))
        
        if hasMap or hasTowers or hasEnemies then
            ErrorHandler:log("DEBUG", string.format("Game indicators: Map=%s, Towers=%s, Enemies=%s", 
                tostring(hasMap), tostring(hasTowers), tostring(hasEnemies)))
        end
    end, "Game state detection")
    
    self.detected = true
    return self
end

function GameStateDetector:isLobby()
    if not self.detected then
        self:detect()
    end
    return self.isInLobby == true
end

function GameStateDetector:isGame()
    if not self.detected then
        self:detect()
    end
    return self.isInGame == true
end

function GameStateDetector:waitForGameStart(timeout)
    timeout = timeout or self.initializationTimeout
    local startTime = tick()
    
    ErrorHandler:log("INFO", "Waiting for game to start...")
    
    while (tick() - startTime) < timeout do
        local success, hasStarted = pcall(function()
            local workspace = game:GetService("Workspace")
            local RS = game:GetService("ReplicatedStorage")
            
            local hasTowers = workspace:FindFirstChild("Towers") ~= nil
            local hasMap = workspace:FindFirstChild("Map") ~= nil
            local hasGamemode = RS:FindFirstChild("Gamemode") ~= nil
            
            return hasTowers or hasMap or hasGamemode
        end)
        
        if success and hasStarted then
            self.gameStarted = true
            self.isInGame = true
            self.isInLobby = false
            ErrorHandler:log("INFO", string.format("Game started (detected in %.2fs)", tick() - startTime))
            
            self:triggerGameStateCallbacks("gameStarted")
            
            return true
        end
        
        task.wait(0.1)
    end
    
    ErrorHandler:log("WARN", string.format("Game start detection timed out after %.1fs", timeout))
    return false
end

function GameStateDetector:registerInitialization(name, initFunc, options)
    options = options or {}
    
    local initialization = {
        name = name,
        func = initFunc,
        requiresGame = options.requiresGame or false,
        retryOnFailure = options.retryOnFailure ~= false, 
        timeout = options.timeout or self.initializationTimeout,
        initialized = false,
        attempts = 0
    }
    
    table.insert(self.pendingInitializations, initialization)
    
    ErrorHandler:log("DEBUG", string.format("Registered initialization: %s (requiresGame: %s)", 
        name, tostring(initialization.requiresGame)))
    
    return initialization
end

function GameStateDetector:initializeWithRetry(initialization)
    if initialization.initialized then
        return true
    end
    
    local maxAttempts = initialization.retryOnFailure and self.retryAttempts or 1
    
    for attempt = 1, maxAttempts do
        initialization.attempts = attempt
        
        if attempt > 1 then
            ErrorHandler:log("INFO", string.format("Retrying initialization: %s (attempt %d/%d)", 
                initialization.name, attempt, maxAttempts))
            task.wait(self.retryDelay)
        end
        
        local startTime = tick()
        local success, result = ErrorHandler:wrapAsync(function()
            return initialization.func()
        end, string.format("Initialize %s", initialization.name))
        
        local duration = tick() - startTime
        
        if success then
            initialization.initialized = true
            ErrorHandler:log("INFO", string.format("✓ Initialized: %s (%.2fs, attempt %d)", 
                initialization.name, duration, attempt))
            return true
        else
            ErrorHandler:log("WARN", string.format("✗ Failed to initialize: %s (%.2fs, attempt %d): %s", 
                initialization.name, duration, attempt, tostring(result)))
            
            if duration >= initialization.timeout then
                ErrorHandler:log("ERROR", string.format("Initialization timeout: %s", initialization.name))
                break
            end
        end
    end
    
    ErrorHandler:log("ERROR", string.format("Failed to initialize after %d attempts: %s", 
        maxAttempts, initialization.name))
    
    return false
end

function GameStateDetector:runPendingInitializations()
    if #self.pendingInitializations == 0 then
        return
    end
    
    ErrorHandler:log("INFO", string.format("Running %d pending initializations...", #self.pendingInitializations))
    
    local immediateInits = {}
    local delayedInits = {}
    
    for _, init in ipairs(self.pendingInitializations) do
        if init.requiresGame then
            table.insert(delayedInits, init)
        else
            table.insert(immediateInits, init)
        end
    end
    
    for _, init in ipairs(immediateInits) do
        self:initializeWithRetry(init)
    end
    
    if #delayedInits > 0 then
        if self:isLobby() then
            ErrorHandler:log("INFO", string.format("Delaying %d game-dependent initializations until game starts", 
                #delayedInits))
            
            task.spawn(function()
                if self:waitForGameStart() then
                    ErrorHandler:log("INFO", "Running delayed initializations...")
                    for _, init in ipairs(delayedInits) do
                        self:initializeWithRetry(init)
                    end
                else
                    ErrorHandler:log("WARN", "Game did not start in time, running delayed initializations anyway")
                    for _, init in ipairs(delayedInits) do
                        self:initializeWithRetry(init)
                    end
                end
            end)
        else
            for _, init in ipairs(delayedInits) do
                self:initializeWithRetry(init)
            end
        end
    end
end

function GameStateDetector:registerGameStateCallback(event, callback)
    if not self.gameStateChangeCallbacks[event] then
        self.gameStateChangeCallbacks[event] = {}
    end
    
    table.insert(self.gameStateChangeCallbacks[event], callback)
    
    ErrorHandler:log("DEBUG", string.format("Registered callback for event: %s", event))
end

function GameStateDetector:triggerGameStateCallbacks(event)
    if not self.gameStateChangeCallbacks[event] then
        return
    end
    
    ErrorHandler:log("DEBUG", string.format("Triggering %d callbacks for event: %s", 
        #self.gameStateChangeCallbacks[event], event))
    
    for _, callback in ipairs(self.gameStateChangeCallbacks[event]) do
        pcall(callback)
    end
end

function GameStateDetector:getReport()
    local report = "\n=== Game State Report ===\n"
    report = report .. string.format("State: %s\n", self.isInLobby and "Lobby" or (self.isInGame and "In-Game" or "Unknown"))
    report = report .. string.format("Game Started: %s\n", tostring(self.gameStarted))
    report = report .. string.format("Detected: %s\n", tostring(self.detected))
    
    report = report .. "\n=== Pending Initializations ===\n"
    report = report .. string.format("Total: %d\n", #self.pendingInitializations)
    
    local initialized = 0
    local failed = 0
    for _, init in ipairs(self.pendingInitializations) do
        if init.initialized then
            initialized = initialized + 1
        elseif init.attempts > 0 then
            failed = failed + 1
        end
    end
    
    report = report .. string.format("Initialized: %d\n", initialized)
    report = report .. string.format("Failed: %d\n", failed)
    report = report .. string.format("Pending: %d\n", #self.pendingInitializations - initialized - failed)
    
    report = report .. "========================\n"
    return report
end

GameStateDetector:detect()

local ConnectionManager = {
    connections = {},     
    groups = {},        
    towerConnections = {}, 
    nextId = 1,        
    cleanupInterval = 10, 
    stats = {
        totalTracked = 0,
        totalCleaned = 0,
        lastCleanup = tick()
    }
}

function ConnectionManager:track(connection, options)
    if not connection then
        ErrorHandler:log("WARN", "Attempted to track nil connection")
        return nil
    end
    
    options = options or {}
    local id = self.nextId
    self.nextId = self.nextId + 1
    
    local entry = {
        id = id,
        connection = connection,
        group = options.group,
        tower = options.tower,
        createdAt = tick(),
        context = options.context or "Unknown"
    }
    
    self.connections[id] = entry
    self.stats.totalTracked = self.stats.totalTracked + 1
    
    if options.group then
        if not self.groups[options.group] then
            self.groups[options.group] = {}
        end
        table.insert(self.groups[options.group], id)
    end
    
    if options.tower then
        if not self.towerConnections[options.tower] then
            self.towerConnections[options.tower] = {}
        end
        table.insert(self.towerConnections[options.tower], id)
    end
    
    ErrorHandler:log("DEBUG", string.format("Tracked connection #%d: %s", id, entry.context))
    
    return connection
end

function ConnectionManager:trackTower(tower, connection, context)
    if not tower or not connection then
        ErrorHandler:log("WARN", "Invalid tower or connection in trackTower")
        return nil
    end
    
    return self:track(connection, {
        tower = tower,
        context = context or ("Tower: " .. tostring(tower.Name))
    })
end

function ConnectionManager:trackGroup(groupName, connection, context)
    if not groupName or not connection then
        ErrorHandler:log("WARN", "Invalid group or connection in trackGroup")
        return nil
    end
    
    return self:track(connection, {
        group = groupName,
        context = context or ("Group: " .. groupName)
    })
end

function ConnectionManager:disconnectGroup(groupName)
    if not self.groups[groupName] then
        ErrorHandler:log("DEBUG", "Group not found: " .. tostring(groupName))
        return 0
    end
    
    local disconnected = 0
    for _, id in ipairs(self.groups[groupName]) do
        if self.connections[id] then
            pcall(function()
                if self.connections[id].connection then
                    self.connections[id].connection:Disconnect()
                end
            end)
            self.connections[id] = nil
            disconnected = disconnected + 1
        end
    end
    
    self.groups[groupName] = nil
    ErrorHandler:log("INFO", string.format("Disconnected group '%s': %d connections", groupName, disconnected))
    
    return disconnected
end

function ConnectionManager:disconnectTower(tower)
    if not tower or not self.towerConnections[tower] then
        return 0
    end
    
    local disconnected = 0
    for _, id in ipairs(self.towerConnections[tower]) do
        if self.connections[id] then
            pcall(function()
                if self.connections[id].connection then
                    self.connections[id].connection:Disconnect()
                end
            end)
            self.connections[id] = nil
            disconnected = disconnected + 1
        end
    end
    
    self.towerConnections[tower] = nil
    ErrorHandler:log("DEBUG", string.format("Disconnected tower connections: %d", disconnected))
    
    return disconnected
end

function ConnectionManager:cleanup()
    local cleaned = 0
    local now = tick()
    
    for id, entry in pairs(self.connections) do
        local shouldRemove = false
        
        pcall(function()
            if entry.connection and entry.connection.Connected == false then
                shouldRemove = true
            end
        end)
        
        if entry.tower then
            pcall(function()
                if not entry.tower or not entry.tower.Parent then
                    shouldRemove = true
                end
            end)
        end
        
        if shouldRemove then
            pcall(function()
                if entry.connection then
                    entry.connection:Disconnect()
                end
            end)
            self.connections[id] = nil
            cleaned = cleaned + 1
        end
    end
    
    for tower, ids in pairs(self.towerConnections) do
        local validIds = {}
        for _, id in ipairs(ids) do
            if self.connections[id] then
                table.insert(validIds, id)
            end
        end
        
        if #validIds == 0 then
            self.towerConnections[tower] = nil
        else
            self.towerConnections[tower] = validIds
        end
    end
    
    for groupName, ids in pairs(self.groups) do
        local validIds = {}
        for _, id in ipairs(ids) do
            if self.connections[id] then
                table.insert(validIds, id)
            end
        end
        
        if #validIds == 0 then
            self.groups[groupName] = nil
        else
            self.groups[groupName] = validIds
        end
    end
    
    self.stats.totalCleaned = self.stats.totalCleaned + cleaned
    self.stats.lastCleanup = now
    
    if cleaned > 0 then
        ErrorHandler:log("DEBUG", string.format("Cleaned up %d dead connections", cleaned))
    end
    
    return cleaned
end

function ConnectionManager:getStats()
    local activeConnections = 0
    for _ in pairs(self.connections) do
        activeConnections = activeConnections + 1
    end
    
    local activeTowers = 0
    for _ in pairs(self.towerConnections) do
        activeTowers = activeTowers + 1
    end
    
    local activeGroups = 0
    for _ in pairs(self.groups) do
        activeGroups = activeGroups + 1
    end
    
    return {
        active = activeConnections,
        towers = activeTowers,
        groups = activeGroups,
        totalTracked = self.stats.totalTracked,
        totalCleaned = self.stats.totalCleaned,
        lastCleanup = self.stats.lastCleanup
    }
end

function ConnectionManager:disconnectAll()
    local disconnected = 0
    
    for id, entry in pairs(self.connections) do
        pcall(function()
            if entry.connection then
                entry.connection:Disconnect()
            end
        end)
        disconnected = disconnected + 1
    end
    
    self.connections = {}
    self.groups = {}
    self.towerConnections = {}
    
    ErrorHandler:log("INFO", string.format("Disconnected all connections: %d total", disconnected))
    
    return disconnected
end

function ConnectionManager:startAutoCleanup()
    task.spawn(function()
        while true do
            task.wait(self.cleanupInterval)
            pcall(function()
                self:cleanup()
            end)
        end
    end)
end

local MemoryManager = {
    baseline = 0,
    baselineSet = false,
    lastCleanup = tick(),
    cleanupInterval = 10, 
    limits = {
        cashHistory = 5,
        macroData = 500,
        macroActions = 200,
        webhookHashes = 3,
        smartCardPicked = 3,
        slowerCardPicked = 3
    },
    stats = {
        totalCleanups = 0,
        lastCleanupTime = 0,
        itemsCleaned = 0
    }
}

function MemoryManager:getMemoryUsageMB()
    local stats = game:GetService("Stats")
    local memoryMB = 0
    pcall(function()
        memoryMB = stats:GetTotalMemoryUsageMb()
    end)
    if memoryMB == 0 then
        pcall(function()
            memoryMB = stats.MemoryUsageMb
        end)
    end
    return memoryMB
end

function MemoryManager:setBaseline()
    if self.baselineSet then
        return self.baseline
    end
    
    pcall(function() collectgarbage("collect") end)
    task.wait(0.1)
    
    self.baseline = self:getMemoryUsageMB()
    self.baselineSet = true
    
    ErrorHandler:log("INFO", string.format("Memory baseline set: %.1f MB", self.baseline))
    
    return self.baseline
end

function MemoryManager:enforceLimit(dataStructure, limit, keepRecent)
    if not dataStructure or type(dataStructure) ~= "table" then
        return 0
    end
    
    local currentSize = #dataStructure
    if currentSize <= limit then
        return 0
    end
    
    local itemsToRemove = currentSize - limit
    
    if keepRecent then
        local temp = {}
        local startIdx = math.max(1, currentSize - limit + 1)
        for i = startIdx, currentSize do
            table.insert(temp, dataStructure[i])
        end
        
        for i = currentSize, 1, -1 do
            dataStructure[i] = nil
        end
        for i, item in ipairs(temp) do
            dataStructure[i] = item
        end
    else
        for i = 1, itemsToRemove do
            table.remove(dataStructure, 1)
        end
    end
    
    return itemsToRemove
end

function MemoryManager:trimMacroCashHistory()
    if not getgenv().MacroCashHistory or type(getgenv().MacroCashHistory) ~= "table" then
        return 0
    end
    
    local currentSize = #getgenv().MacroCashHistory
    if currentSize <= self.limits.cashHistory then
        return 0
    end
    
    local temp = {}
    for i = 1, self.limits.cashHistory do
        temp[i] = getgenv().MacroCashHistory[i]
    end
    getgenv().MacroCashHistory = temp
    
    local removed = currentSize - self.limits.cashHistory
    ErrorHandler:log("DEBUG", string.format("Trimmed MacroCashHistory: %d -> %d entries", currentSize, self.limits.cashHistory))
    
    return removed
end

function MemoryManager:trimMacroDataV2()
    if not getgenv().MacroDataV2 or type(getgenv().MacroDataV2) ~= "table" then
        return 0
    end
    
    if getgenv().MacroRecordingV2 then
        return 0
    end
    
    local currentSize = #getgenv().MacroDataV2
    if currentSize <= self.limits.macroData then
        return 0
    end
    
    local temp = {}
    local startIdx = math.max(1, currentSize - (self.limits.macroData / 2))
    for i = startIdx, currentSize do
        table.insert(temp, getgenv().MacroDataV2[i])
    end
    getgenv().MacroDataV2 = temp
    
    local removed = currentSize - #temp
    ErrorHandler:log("DEBUG", string.format("Trimmed MacroDataV2: %d -> %d steps", currentSize, #temp))
    
    return removed
end

function MemoryManager:trimMacroActionsV2()
    if not getgenv().MacroActionsV2 or type(getgenv().MacroActionsV2) ~= "table" then
        return 0
    end
    
    if getgenv().MacroRecordingV2 then
        return 0
    end
    
    local currentSize = #getgenv().MacroActionsV2
    if currentSize <= self.limits.macroActions then
        return 0
    end
    
    local temp = {}
    local startIdx = math.max(1, currentSize - (self.limits.macroActions / 2))
    for i = startIdx, currentSize do
        table.insert(temp, getgenv().MacroActionsV2[i])
    end
    getgenv().MacroActionsV2 = temp
    
    local removed = currentSize - #temp
    ErrorHandler:log("DEBUG", string.format("Trimmed MacroActionsV2: %d -> %d actions", currentSize, #temp))
    
    return removed
end

function MemoryManager:trimWebhookHashList()
    if not getgenv()._lastWebhookHashList or type(getgenv()._lastWebhookHashList) ~= "table" then
        return 0
    end
    
    local currentSize = #getgenv()._lastWebhookHashList
    if currentSize <= self.limits.webhookHashes then
        return 0
    end
    
    local removed = 0
    while #getgenv()._lastWebhookHashList > self.limits.webhookHashes do
        table.remove(getgenv()._lastWebhookHashList, 1)
        removed = removed + 1
    end
    
    ErrorHandler:log("DEBUG", string.format("Trimmed webhook hash list: %d -> %d entries", currentSize, self.limits.webhookHashes))
    
    return removed
end

function MemoryManager:trimSmartCardPicked()
    if not getgenv().SmartCardPicked or type(getgenv().SmartCardPicked) ~= "table" then
        return 0
    end
    
    local currentSize = #getgenv().SmartCardPicked
    if currentSize <= self.limits.smartCardPicked then
        return 0
    end
    
    getgenv().SmartCardPicked = {}
    
    ErrorHandler:log("DEBUG", string.format("Cleared SmartCardPicked: %d entries", currentSize))
    
    return currentSize
end

function MemoryManager:trimSlowerCardPicked()
    if not getgenv().SlowerCardPicked or type(getgenv().SlowerCardPicked) ~= "table" then
        return 0
    end
    
    local currentSize = #getgenv().SlowerCardPicked
    if currentSize <= self.limits.slowerCardPicked then
        return 0
    end
    
    getgenv().SlowerCardPicked = {}
    
    ErrorHandler:log("DEBUG", string.format("Cleared SlowerCardPicked: %d entries", currentSize))
    
    return currentSize
end

function MemoryManager:cleanWukongTrackedClones()
    if not getgenv().WukongTrackedClones or type(getgenv().WukongTrackedClones) ~= "table" then
        return 0
    end
    
    local removed = 0
    local toRemove = {}
    
    for cloneId, _ in pairs(getgenv().WukongTrackedClones) do
        if type(cloneId) ~= "string" then
            table.insert(toRemove, cloneId)
        end
    end
    
    for _, key in ipairs(toRemove) do
        getgenv().WukongTrackedClones[key] = nil
        removed = removed + 1
    end
    
    if removed > 0 then
        ErrorHandler:log("DEBUG", string.format("Cleaned WukongTrackedClones: %d invalid entries", removed))
    end
    
    return removed
end

function MemoryManager:cleanTowerTrackerPendingActions()
    if not getgenv()._TowerTrackerPendingActions or type(getgenv()._TowerTrackerPendingActions) ~= "table" then
        return 0
    end
    
    local removed = 0
    local now = tick()
    local staleThreshold = 30 
    
    for key, timestamp in pairs(getgenv()._TowerTrackerPendingActions) do
        if type(timestamp) == "number" and (now - timestamp) > staleThreshold then
            getgenv()._TowerTrackerPendingActions[key] = nil
            removed = removed + 1
        end
    end
    
    if removed > 0 then
        ErrorHandler:log("DEBUG", string.format("Cleaned TowerTrackerPendingActions: %d stale entries", removed))
    end
    
    return removed
end

function MemoryManager:cleanMacroPlaybackData()
    if not getgenv().MacroPlaybackActive and getgenv().MacroPlaybackMacroData then
        getgenv().MacroPlaybackMacroData = nil
        ErrorHandler:log("DEBUG", "Cleaned inactive MacroPlaybackMacroData")
        return 1
    end
    
    return 0
end

function MemoryManager:cleanup()
    local startTime = tick()
    local totalCleaned = 0
    
    totalCleaned = totalCleaned + self:trimMacroCashHistory()
    totalCleaned = totalCleaned + self:trimMacroDataV2()
    totalCleaned = totalCleaned + self:trimMacroActionsV2()
    totalCleaned = totalCleaned + self:trimWebhookHashList()
    totalCleaned = totalCleaned + self:trimSmartCardPicked()
    totalCleaned = totalCleaned + self:trimSlowerCardPicked()
    
    totalCleaned = totalCleaned + self:cleanWukongTrackedClones()
    totalCleaned = totalCleaned + self:cleanTowerTrackerPendingActions()
    totalCleaned = totalCleaned + self:cleanMacroPlaybackData()
    
    self.stats.totalCleanups = self.stats.totalCleanups + 1
    self.stats.lastCleanupTime = tick() - startTime
    self.stats.itemsCleaned = self.stats.itemsCleaned + totalCleaned
    self.lastCleanup = tick()
    
    if totalCleaned > 50 then
        pcall(function() collectgarbage("collect") end)
        ErrorHandler:log("DEBUG", string.format("Memory cleanup: %d items removed, GC triggered", totalCleaned))
    elseif totalCleaned > 0 then
        ErrorHandler:log("DEBUG", string.format("Memory cleanup: %d items removed", totalCleaned))
    end
    
    return totalCleaned
end

function MemoryManager:getReport()
    local report = "\n=== Memory Manager Report ===\n"
    
    local currentMem = self:getMemoryUsageMB()
    report = report .. string.format("Current Memory: %.1f MB\n", currentMem)
    
    if self.baselineSet then
        report = report .. string.format("Baseline Memory: %.1f MB\n", self.baseline)
        report = report .. string.format("Memory Growth: +%.1f MB\n", currentMem - self.baseline)
    end
    
    report = report .. "\n=== Data Structure Sizes ===\n"
    report = report .. string.format("MacroCashHistory: %d / %d\n", 
        getgenv().MacroCashHistory and #getgenv().MacroCashHistory or 0, 
        self.limits.cashHistory)
    report = report .. string.format("MacroDataV2: %d / %d\n", 
        getgenv().MacroDataV2 and #getgenv().MacroDataV2 or 0, 
        self.limits.macroData)
    report = report .. string.format("MacroActionsV2: %d / %d\n", 
        getgenv().MacroActionsV2 and #getgenv().MacroActionsV2 or 0, 
        self.limits.macroActions)
    report = report .. string.format("WebhookHashList: %d / %d\n", 
        getgenv()._lastWebhookHashList and #getgenv()._lastWebhookHashList or 0, 
        self.limits.webhookHashes)
    report = report .. string.format("SmartCardPicked: %d / %d\n", 
        getgenv().SmartCardPicked and #getgenv().SmartCardPicked or 0, 
        self.limits.smartCardPicked)
    report = report .. string.format("SlowerCardPicked: %d / %d\n", 
        getgenv().SlowerCardPicked and #getgenv().SlowerCardPicked or 0, 
        self.limits.slowerCardPicked)
    
    local wukongCount = 0
    if getgenv().WukongTrackedClones then
        for _ in pairs(getgenv().WukongTrackedClones) do
            wukongCount = wukongCount + 1
        end
    end
    report = report .. string.format("WukongTrackedClones: %d\n", wukongCount)
    
    local pendingCount = 0
    if getgenv()._TowerTrackerPendingActions then
        for _ in pairs(getgenv()._TowerTrackerPendingActions) do
            pendingCount = pendingCount + 1
        end
    end
    report = report .. string.format("TowerTrackerPendingActions: %d\n", pendingCount)
    
    report = report .. "\n=== Cleanup Statistics ===\n"
    report = report .. string.format("Total Cleanups: %d\n", self.stats.totalCleanups)
    report = report .. string.format("Items Cleaned: %d\n", self.stats.itemsCleaned)
    report = report .. string.format("Last Cleanup: %.3fs ago\n", tick() - self.lastCleanup)
    report = report .. string.format("Last Cleanup Time: %.3fs\n", self.stats.lastCleanupTime)
    
    report = report .. "============================\n"
    
    return report
end

function MemoryManager:startAutoCleanup()
    task.spawn(function()
        while true do
            task.wait(self.cleanupInterval)
            pcall(function()
                self:cleanup()
            end)
        end
    end)
end


local UIFactory = {
    config = nil,
    saveCallback = nil,
    initialized = false
}

function UIFactory:init(config, saveCallback)
    self.config = config
    self.saveCallback = saveCallback
    self.initialized = true
end

function UIFactory:createElement(elementType, section, options)
    if not self.initialized then
        ErrorHandler:log("ERROR", "UIFactory not initialized. Call UIFactory:init() first")
        return nil
    end
    
    if not section then
        ErrorHandler:log("ERROR", "Section is required for createElement")
        return nil
    end
    
    options = options or {}
    local name = tostring(options.name or elementType)
    local flag = options.flag
    local callback = options.callback
    local default = options.default
    local autoSave = options.autoSave ~= false 
    
    if elementType == "Toggle" then
        return self:_createToggle(section, name, flag, callback, default, autoSave)
    elseif elementType == "Input" then
        return self:_createInput(section, name, flag, options, autoSave)
    elseif elementType == "Dropdown" then
        return self:_createDropdown(section, name, flag, options, autoSave)
    elseif elementType == "Slider" then
        return self:_createSlider(section, name, flag, options, autoSave)
    elseif elementType == "Button" then
        return self:_createButton(section, name, flag, callback)
    elseif elementType == "Keybind" then
        return self:_createKeybind(section, name, flag, options, autoSave)
    elseif elementType == "Colorpicker" then
        return self:_createColorpicker(section, name, flag, options, autoSave)
    else
        ErrorHandler:log("ERROR", "Unknown element type: " .. tostring(elementType))
        return nil
    end
end

function UIFactory:_createToggle(section, name, flag, callback, default, autoSave)
    default = default or false
    
    local savedValue = default
    if autoSave and flag and self.config and self.config.toggles then
        local saved = self.config.toggles[flag]
        if saved ~= nil then
            savedValue = saved
        end
    end
    
    return ErrorHandler:wrap(function()
        return section:Toggle({
            Name = name,
            Default = savedValue,
            Callback = function(value)
                if autoSave and flag and self.config then
                    self.config.toggles[flag] = value
                    if self.saveCallback then
                        self.saveCallback(self.config)
                    end
                end
                
                if callback then
                    callback(value)
                end
            end,
        }, flag)
    end, "Create Toggle: " .. name)()
end

function UIFactory:_createInput(section, name, flag, options, autoSave)
    local placeholder = options.placeholder or ""
    local charType = options.charType or options.acceptedCharacters or "All"
    local default = options.default or ""
    local callback = options.callback
    local onChanged = options.onChanged
    
    local savedValue = default
    if autoSave and flag and self.config and self.config.inputs then
        local saved = self.config.inputs[flag]
        if saved ~= nil then
            savedValue = saved
        end
    end
    
    local inputElement = ErrorHandler:wrap(function()
        return section:Input({
            Name = name,
            Placeholder = placeholder,
            AcceptedCharacters = charType,
            Callback = function(value)
                if autoSave and flag and self.config then
                    self.config.inputs[flag] = value
                    if self.saveCallback then
                        self.saveCallback(self.config)
                    end
                end
                
                if callback then
                    callback(value)
                end
            end,
            onChanged = onChanged
        }, flag)
    end, "Create Input: " .. name)()
    
    if inputElement and savedValue and savedValue ~= "" then
        pcall(function()
            inputElement:UpdateText(tostring(savedValue))
        end)
    end
    
    return inputElement
end

function UIFactory:_createDropdown(section, name, flag, options, autoSave)
    local dropdownOptions = options.options or {}
    local multi = options.multi or false
    local required = options.required or false
    local search = options.search ~= false 
    local default = options.default or (multi and {} or 1)
    local callback = options.callback
    
    local savedValue = default
    if autoSave and flag and self.config and self.config.dropdowns then
        local saved = self.config.dropdowns[flag]
        if saved ~= nil then
            savedValue = saved
        end
    end
    
    local defaultValue = savedValue
    if multi and type(savedValue) == "table" then
        local isDictionary = false
        for k, v in pairs(savedValue) do
            if type(v) == "boolean" then
                isDictionary = true
                break
            end
        end
        
        if isDictionary then
            defaultValue = {}
            for optionName, isSelected in pairs(savedValue) do
                if isSelected == true then
                    table.insert(defaultValue, optionName)
                end
            end
        end
    elseif not multi and type(savedValue) == "string" then
        defaultValue = 1
        for i, option in ipairs(dropdownOptions) do
            if option == savedValue then
                defaultValue = i
                break
            end
        end
    elseif not multi and type(savedValue) == "number" then
        defaultValue = savedValue
    end
    
    return ErrorHandler:wrap(function()
        return section:Dropdown({
            Name = name,
            Search = search,
            Options = dropdownOptions,
            Multi = multi,
            Required = required,
            Default = defaultValue,
            Callback = function(value)
                if autoSave and flag and self.config then
                    self.config.dropdowns[flag] = value
                    if self.saveCallback then
                        self.saveCallback(self.config)
                    end
                end
                
                if callback then
                    callback(value)
                end
            end,
        }, flag)
    end, "Create Dropdown: " .. name)()
end

function UIFactory:_createSlider(section, name, flag, options, autoSave)
    local minimum = options.minimum or options.min or 0
    local maximum = options.maximum or options.max or 100
    local default = options.default or minimum
    local displayMethod = options.displayMethod or "Default"
    local precision = options.precision
    local callback = options.callback
    local onInputComplete = options.onInputComplete
    
    if autoSave and flag and self.config and self.config.inputs then
        local saved = self.config.inputs[flag]
        if saved ~= nil then
            saved = tonumber(saved)
            if saved then
                default = saved
            end
        end
    end
    
    local sliderConfig = {
        Name = name,
        Minimum = minimum,
        Maximum = maximum,
        Default = default,
        DisplayMethod = displayMethod,
        Callback = function(value)
            if autoSave and flag and self.config then
                self.config.inputs[flag] = value
                if self.saveCallback then
                    self.saveCallback(self.config)
                end
            end
            
            if callback then
                callback(value)
            end
        end,
    }
    
    if precision then
        sliderConfig.Precision = precision
    end
    
    if onInputComplete then
        sliderConfig.onInputComplete = onInputComplete
    end
    
    return ErrorHandler:wrap(function()
        return section:Slider(sliderConfig, flag)
    end, "Create Slider: " .. name)()
end

function UIFactory:_createButton(section, name, flag, callback)
    return ErrorHandler:wrap(function()
        return section:Button({
            Name = name,
            Callback = function()
                if callback then
                    callback()
                end
            end,
        }, flag)
    end, "Create Button: " .. name)()
end

function UIFactory:_createKeybind(section, name, flag, options, autoSave)
    local default = options.default
    local blacklist = options.blacklist or {}
    local callback = options.callback
    local onBinded = options.onBinded
    local onBindHeld = options.onBindHeld
    
    if autoSave and flag and self.config and self.config.inputs then
        local saved = self.config.inputs[flag]
        if saved ~= nil then
            default = saved
        end
    end
    
    return ErrorHandler:wrap(function()
        return section:Keybind({
            Name = name,
            Default = default,
            Blacklist = blacklist,
            Callback = function(binded)
                if autoSave and flag and self.config then
                    self.config.inputs[flag] = binded
                    if self.saveCallback then
                        self.saveCallback(self.config)
                    end
                end
                
                if callback then
                    callback(binded)
                end
            end,
            onBinded = onBinded,
            onBindHeld = onBindHeld
        }, flag)
    end, "Create Keybind: " .. name)()
end

function UIFactory:_createColorpicker(section, name, flag, options, autoSave)
    local default = options.default or Color3.fromRGB(255, 255, 255)
    local alpha = options.alpha
    local callback = options.callback
    
    if autoSave and flag and self.config and self.config.inputs then
        local saved = self.config.inputs[flag]
        if saved ~= nil and type(saved) == "table" then
            if saved.color then
                default = Color3.fromRGB(saved.color.r or 255, saved.color.g or 255, saved.color.b or 255)
            end
            if saved.alpha ~= nil then
                alpha = saved.alpha
            end
        end
    end
    
    return ErrorHandler:wrap(function()
        return section:Colorpicker({
            Name = name,
            Default = default,
            Alpha = alpha,
            Callback = function(color, alphaValue)
                if autoSave and flag and self.config then
                    self.config.inputs[flag] = {
                        color = {
                            r = math.round(color.R * 255),
                            g = math.round(color.G * 255),
                            b = math.round(color.B * 255)
                        },
                        alpha = alphaValue
                    }
                    if self.saveCallback then
                        self.saveCallback(self.config)
                    end
                end
                
                if callback then
                    callback(color, alphaValue)
                end
            end,
        }, flag)
    end, "Create Colorpicker: " .. name)()
end

function UIFactory:createMutuallyExclusive(section, toggleConfigs)
    if not toggleConfigs or type(toggleConfigs) ~= "table" or #toggleConfigs < 2 then
        ErrorHandler:log("ERROR", "createMutuallyExclusive requires at least 2 toggle configs")
        return {}
    end
    
    local toggles = {}
    local toggleRefs = {}
    
    for i, config in ipairs(toggleConfigs) do
        local toggle = self:createElement("Toggle", section, {
            name = config.name,
            flag = config.flag,
            default = config.default,
            autoSave = config.autoSave,
            callback = function(value)
                if value then
                    for j, otherToggle in ipairs(toggleRefs) do
                        if i ~= j and otherToggle then
                            pcall(function()
                                otherToggle:UpdateState(false)
                            end)
                            if config.flag and self.config and self.config.toggles then
                                self.config.toggles[toggleConfigs[j].flag] = false
                            end
                        end
                    end
                    
                    if self.saveCallback then
                        self.saveCallback(self.config)
                    end
                end
                
                if config.callback then
                    config.callback(value)
                end
            end
        })
        
        table.insert(toggles, toggle)
        table.insert(toggleRefs, toggle)
    end
    
    return toggles
end


getgenv().ErrorHandler = ErrorHandler
getgenv().PlatformDetector = PlatformDetector
getgenv().ConnectionManager = ConnectionManager
getgenv().MemoryManager = MemoryManager
getgenv().UIFactory = UIFactory

getgenv().GetMemoryReport = function()
    return getMemoryReport()
end

getgenv().ForceMemoryCleanup = function()
    local cleaned = MemoryManager:cleanup()
    print(string.format("[MemoryManager] Manual cleanup: %d items removed", cleaned))
    return cleaned
end

getgenv().GetGameState = function()
    print(GameStateDetector:getReport())
    return {
        isInLobby = GameStateDetector:isLobby(),
        isInGame = GameStateDetector:isGame(),
        gameStarted = GameStateDetector.gameStarted
    }
end

getgenv().ForceGameStartDetection = function()
    print("[GameStateDetector] Forcing game start detection...")
    local result = GameStateDetector:waitForGameStart(5)
    print(string.format("[GameStateDetector] Game start detection: %s", result and "Success" or "Failed"))
    return result
end

getgenv().RetryFailedInitializations = function()
    print("[GameStateDetector] Retrying failed initializations...")
    local retried = 0
    for _, init in ipairs(GameStateDetector.pendingInitializations) do
        if not init.initialized and init.attempts > 0 then
            print(string.format("  Retrying: %s", init.name))
            GameStateDetector:initializeWithRetry(init)
            retried = retried + 1
        end
    end
    print(string.format("[GameStateDetector] Retried %d initializations", retried))
    return retried
end


ConnectionManager:startAutoCleanup()
MemoryManager:startAutoCleanup()

task.delay(2, function()
    MemoryManager:setBaseline()
end)

task.spawn(function()
    GameStateDetector:runPendingInitializations()
end)

if not getgenv()._GlobalConnections then
    getgenv()._GlobalConnections = {}
end

if not getgenv()._MemoryProfiler then
    getgenv()._MemoryProfiler = {
        features = {},
        baseline = 0,
        lastCheck = tick(),
        baselineSet = false
    }
end

local function getMemoryUsageMB()
    return MemoryManager:getMemoryUsageMB()
end

local function startMemoryTracking(featureName)
    if not getgenv()._MemoryProfiler.baselineSet then
        MemoryManager:setBaseline()
        getgenv()._MemoryProfiler.baseline = MemoryManager.baseline
        getgenv()._MemoryProfiler.baselineSet = true
    end
    
    pcall(function() collectgarbage("collect") end)
    task.wait(0.05)
    
    local memBefore = getMemoryUsageMB()
    getgenv()._MemoryProfiler.features[featureName] = {
        startMemory = memBefore,
        currentMemory = memBefore,
        peakMemory = memBefore,
        enabled = true,
        startTime = tick()
    }
    
    return memBefore
end

local function updateMemoryTracking(featureName)
    if not getgenv()._MemoryProfiler.features[featureName] then return end
    
    local currentMem = getMemoryUsageMB()
    local feature = getgenv()._MemoryProfiler.features[featureName]
    
    feature.currentMemory = currentMem
    if currentMem > feature.peakMemory then
        feature.peakMemory = currentMem
    end
end

local function stopMemoryTracking(featureName)
    if not getgenv()._MemoryProfiler.features[featureName] then return end
    
    getgenv()._MemoryProfiler.features[featureName].enabled = false
    getgenv()._MemoryProfiler.features[featureName].endTime = tick()
end

local function getMemoryReport()
    local report = ""
    
    report = report .. MemoryManager:getReport()
    
    local cmStats = ConnectionManager:getStats()
    report = report .. "\n=== Connection Manager ===\n"
    report = report .. string.format("Active Connections: %d\n", cmStats.active)
    report = report .. string.format("Tower Connections: %d\n", cmStats.towers)
    report = report .. string.format("Named Groups: %d\n", cmStats.groups)
    report = report .. string.format("Total Tracked: %d\n", cmStats.totalTracked)
    report = report .. string.format("Total Cleaned: %d\n", cmStats.totalCleaned)
    
    report = report .. "\n=== Legacy Tracking ===\n"
    report = report .. string.format("Global Connections: %d\n", #(getgenv()._GlobalConnections or {}))
    
    local towerConns = 0
    if getgenv()._TowerUpgradeConnections then
        for _ in pairs(getgenv()._TowerUpgradeConnections) do
            towerConns = towerConns + 1
        end
    end
    report = report .. string.format("Tower Upgrade Conns: %d\n", towerConns)
    
    report = report .. "============================\n"
    
    return report
end

local function trackConnection(connection, context)
    if connection then
        table.insert(getgenv()._GlobalConnections, connection)
        ConnectionManager:track(connection, { context = context or "Legacy" })
    end
    return connection
end

task.spawn(function()
    while true do
        task.wait(10)
        pcall(function()
            
            local cleaned = 0
            for i = #getgenv()._GlobalConnections, 1, -1 do
                local conn = getgenv()._GlobalConnections[i]
                if conn and conn.Connected == false then
                    table.remove(getgenv()._GlobalConnections, i)
                    cleaned = cleaned + 1
                end
            end
            
            if getgenv()._TowerUpgradeConnections then
                local cleaned = 0
                local toRemove = {}
                for tower, conn in pairs(getgenv()._TowerUpgradeConnections) do
                    if not tower or not tower.Parent or not conn or not conn.Connected then
                        if conn and conn.Connected then
                            pcall(function() conn:Disconnect() end)
                        end
                        table.insert(toRemove, tower)
                        cleaned = cleaned + 1
                    end
                end
                for _, tower in ipairs(toRemove) do
                    getgenv()._TowerUpgradeConnections[tower] = nil
                end
                if cleaned > 0 then
                    debugPrint("[Memory] Cleaned " .. cleaned .. " dead tower connections")
                end
            end
            
            if getgenv()._TowerUpgradeConnections and type(getgenv()._TowerUpgradeConnections) == "table" then
                local count = 0
                for _ in pairs(getgenv()._TowerUpgradeConnections) do
                    count = count + 1
                end
                if count > 100 then
                    debugPrint("[Memory] WARNING: " .. count .. " tower connections tracked!")
                end
            end
            
            if getgenv()._PositionHolograms then
                for key, hologramData in pairs(getgenv()._PositionHolograms) do
                    if hologramData.part and not hologramData.part.Parent then
                        if hologramData.part then pcall(function() hologramData.part:Destroy() end) end
                        if hologramData.beam then pcall(function() hologramData.beam:Destroy() end) end
                        getgenv()._PositionHolograms[key] = nil
                    end
                end
            end
            
            local heartbeatConns = 0
            if getconnections then
                for _, conn in pairs(getconnections(game:GetService("RunService").Heartbeat)) do
                    if conn.Function then
                        heartbeatConns = heartbeatConns + 1
                    end
                end
                
                if heartbeatConns > 30 then
                    local disconnected = 0
                    for _, conn in pairs(getconnections(game:GetService("RunService").Heartbeat)) do
                        if disconnected >= 15 then break end
                        pcall(function()
                            if conn.Function and not conn.Disabled then
                                conn:Disable()
                                disconnected = disconnected + 1
                            end
                        end)
                    end
                end
            end
            

            
            local workspace = game:GetService("Workspace")
            local debrisFolder = workspace:FindFirstChild("Debris")
            if debrisFolder then
                local debrisCount = #debrisFolder:GetChildren()
                if debrisCount > 30 then
                    for _, item in pairs(debrisFolder:GetChildren()) do
                        pcall(function() item:Destroy() end)
                    end
                    debugPrint("[Memory] Cleared " .. debrisCount .. " debris items")
                end
            end
            
            local effectsCleared = 0
            for _, obj in pairs(workspace:GetChildren()) do
                pcall(function()
                    if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") or 
                       obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") then
                        obj:Destroy()
                        effectsCleared = effectsCleared + 1
                    end
                end)
            end
            if effectsCleared > 0 then
                debugPrint("[Memory] Cleared " .. effectsCleared .. " loose effects")
            end
            
            pcall(function() collectgarbage("collect") end)
            
            
            if tick() - getgenv()._MemoryProfiler.lastCheck > 60 then
                getgenv()._MemoryProfiler.lastCheck = tick()
                print(getMemoryReport()) 
            end
        end)
    end
end)

if not getgenv()._AutoRejoinSetup then
    getgenv()._AutoRejoinSetup = true
    
    local TeleportService = game:GetService("TeleportService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local GuiService = game:GetService("GuiService")
    
    local function autoRejoin()
        print("[Auto Rejoin] Reconnecting to game...")
        
        pcall(function()
            if queueteleport then
                queueteleport('loadstring(game:HttpGet("https://raw.githubusercontent.com/Byorl/ALS-Scripts/refs/heads/main/ALS%20Halloween%20UI.lua"))()')
            elseif queue_on_teleport then
                queue_on_teleport('loadstring(game:HttpGet("https://raw.githubusercontent.com/Byorl/ALS-Scripts/refs/heads/main/ALS%20Halloween%20UI.lua"))()')
            end
        end)
        
        task.wait(0.5)
        
        local GAME_PLACE_ID = 12886143095
        
        local success, err = pcall(function()
            TeleportService:Teleport(GAME_PLACE_ID, LocalPlayer)
        end)
        
        if not success then
            debugPrint("[Auto Rejoin] Retrying in 3s...")
            task.wait(3)
            
            pcall(function()
                TeleportService:Teleport(GAME_PLACE_ID, LocalPlayer)
            end)
        end
    end
    
    if not getgenv()._AutoRejoinConnections then
        getgenv()._AutoRejoinConnections = {}
    end
    
    table.insert(getgenv()._AutoRejoinConnections, game:GetService("CoreGui").ChildAdded:Connect(function(child)
        if child.Name == "RobloxPromptGui" then
            task.wait(0.5)
            
            local found = child:FindFirstChild("promptOverlay", true)
            if found then
                for _, descendant in pairs(found:GetDescendants()) do
                    if descendant:IsA("TextLabel") then
                        local text = descendant.Text:lower()
                        
                        if text:find("disconnect") or 
                           text:find("error") or 
                           text:find("kick") or 
                           text:find("lost connection") or
                           text:find("failed to connect") or
                           text:find("connection attempt failed") or
                           text:find("error code") then
                            
                            print("[Auto Rejoin] Connection lost - rejoining...")
                            task.wait(1)
                            autoRejoin()
                            break
                        end
                    end
                end
            end
        end
    end))
    
    table.insert(getgenv()._AutoRejoinConnections, game:GetService("GuiService").ErrorMessageChanged:Connect(function()
        print("[Auto Rejoin] Error detected - rejoining...")
        task.wait(1)
        autoRejoin()
    end))
    
    table.insert(getgenv()._AutoRejoinConnections, LocalPlayer.OnTeleport:Connect(function(State)
        if State == Enum.TeleportState.Failed then
            print("[Auto Rejoin] Teleport failed - rejoining...")
            task.wait(2)
            autoRejoin()
        end
    end))
end

if getgenv().ALSScriptLoaded then
    warn("[ALS] Script already running! Please rejoin the game to reload.")
    return
end
getgenv().ALSScriptLoaded = true

local httpGet = game.HttpGet or game.httpGet or syn and syn.request or http and http.request or request
if not httpGet then
    return
end

local MacLib
local loadSuccess, loadError = pcall(function()
    local url = "https://github.com/biggaboy212/Maclib/releases/latest/download/maclib.txt"
    
    local response
    local httpSuccess, httpResult = ErrorHandler:wrapAsync(function()
        if game.HttpGet then
            response = game:HttpGet(url)
        elseif httpGet then
            local result = httpGet({
                Url = url,
                Method = "GET"
            })
            response = result.Body or result
        end
        return response
    end, "Download MacLib")
    
    if not httpSuccess or not response or response == "" then
        ErrorHandler:log("ERROR", "Failed to download MacLib - HTTP request failed")
        error("Failed to download MacLib. Your executor may not support HttpGet or GitHub is blocked.")
    end
    
    local loadFunc, loadErr = loadstring(response)
    if not loadFunc then
        warn("[ALS] MacLib compilation error: " .. tostring(loadErr))
        warn("[ALS] This is usually caused by:")
        warn("[ALS] 1. Executor compatibility issues")
        warn("[ALS] 2. Corrupted download")
        warn("[ALS] 3. Outdated executor")
        error("Failed to compile MacLib: " .. tostring(loadErr))
    end
    
    local executeSuccess, executeResult = pcall(function()
        return loadFunc()
    end)
    
    if not executeSuccess then
        warn("[ALS] MacLib execution error: " .. tostring(executeResult))
        error("Failed to execute MacLib: " .. tostring(executeResult))
    end
    
    MacLib = executeResult
end)

if not loadSuccess or not MacLib then
    ErrorHandler:log("ERROR", "CRITICAL: Failed to load MacLib: " .. tostring(loadError))
    warn("[ALS] ❌ Failed to load MacLib: " .. tostring(loadError))
    warn("[ALS] ")
    warn("[ALS] Possible solutions:")
    warn("[ALS] 1. Try a different executor (Wave, Solara, Electron)")
    warn("[ALS] 2. Rejoin the game")
    warn("[ALS] 3. Check if your executor is up to date")
    warn("[ALS] 4. Disable any antivirus that might be blocking downloads")
    warn("[ALS] ")
    warn("[ALS] If the error mentions 'Expected identifier', this is a MacLib")
    warn("[ALS] compatibility issue with your executor.")
    
    pcall(function()
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "ALS Script - Critical Error",
            Text = "Failed to load MacLib. Check console (F9) for details.",
            Duration = 15
        })
    end)
    return
end

if not MacLib.Window then
    warn("[ALS] ❌ MacLib loaded but missing Window function")
    warn("[ALS] This indicates a corrupted or incompatible MacLib version")
    return
end

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local HttpService = game:GetService("HttpService")
local RS = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")
local VIM = game:GetService("VirtualInputManager")

task.spawn(function()
    pcall(function()
        local afkFolder = RS:WaitForChild("Remotes", 5):FindFirstChild("AFK")
        if afkFolder then
            local changeState = afkFolder:FindFirstChild("ChangeState")
            local teleport = afkFolder:FindFirstChild("Teleport")
            
            if changeState then
                changeState:Destroy()
            end
            if teleport then
                teleport:Destroy()
            end
        end
    end)
end)

local isMobile = UserInputService.TouchEnabled
local MOBILE_DELAY_MULTIPLIER = isMobile and 1.5 or 1.0

local isMac = false
pcall(function()
    local platform = game:GetService("UserInputService"):GetPlatform()
    isMac = tostring(platform):find("OSX") or tostring(platform):find("Mac")
end)

getgenv()._checkIfInLobby = function()
    local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
    if not playerGui then return false end
    
    local lobbyUI = playerGui:FindFirstChild("LobbyUI")
    return lobbyUI ~= nil
end

if not isMac then
    pcall(function()
        local httpService = game:GetService("HttpService")
        local userAgent = httpService:GetUserAgent()
        isMac = userAgent:find("Mac") or userAgent:find("Darwin")
    end)
end

getgenv().IsMacPlatform = isMac

if isMac then
    print("[ALS] 🍎 Mac platform detected - Enabling performance optimizations")
    print("[ALS] 🍎 Reduced update frequencies:")
    print("[ALS] 🍎 - Game state: 2s (was 1s)")
    print("[ALS] 🍎 - Tower tracking: 1s (was 0.5s)")
    print("[ALS] 🍎 - Enemy removal: 1s (was 0.5s)")
    print("[ALS] 🍎 - Particle cleanup: 4s (was 2s)")
    
    task.spawn(function()
        task.wait(3)
        if getgenv().RemoveEnemiesEnabled then
            print("[ALS] ⚠️ Mac Warning: Enemy removal is enabled. This may cause lag/crashes.")
            print("[ALS] 💡 Tip: Disable 'Remove Enemies' if experiencing issues")
        end
    end)
end

local ConfigManager = {
    userId = tostring(LocalPlayer.UserId),
    configFolder = "ALSHalloweenEvent",
    configFile = "config.json",
    config = nil,
    saveDebounceTime = 0.5,
    lastSaveTime = 0,
    pendingSave = false,
    saveScheduled = false,
    configVersion = 2, 
    
    defaultConfig = {
        version = 2,
        toggles = {},
        inputs = {},
        dropdowns = {},
        abilities = {},
        autoJoin = {},
        portals = {
            priorities = {
                ["Tower Limit"] = 1,
                ["Immunity"] = 2,
                ["Speedy"] = 3,
                ["No Hit"] = 4,
                ["Flight"] = 5,
                ["Short Range"] = 6,
                ["High Cost"] = 7
            }
        },
        loadingScreenMonitor = {
            enabled = true,
            maxLoadingTime = 30,
            checkInterval = 2,
            enableRecovery = true
        },
        restartRecovery = {
            enabled = true,
            maxRetries = 3,
            retryDelay = 5,
            characterLoadTimeout = 15,
            autoExecuteOnRecover = true
        }
    }
}

function ConfigManager:getConfigPath()
    return self.configFolder .. "/" .. self.userId .. "/" .. self.configFile
end

function ConfigManager:getUserFolder()
    return self.configFolder .. "/" .. self.userId
end

function ConfigManager:ensureFolders()
    if not PlatformDetector:hasCapability("hasFileSystem") then
        ErrorHandler:log("WARN", "File system not available, config will not persist")
        return false
    end
    
    local success, err = ErrorHandler:wrapAsync(function()
        if not isfolder(self.configFolder) then 
            makefolder(self.configFolder) 
        end
        
        local userFolder = self:getUserFolder()
        if not isfolder(userFolder) then 
            makefolder(userFolder) 
        end
    end, "Config folder creation")
    
    return success
end

function ConfigManager:migrateConfig(data)
    local version = data.version or 1
    
    if version < 2 then
        data.portals = data.portals or {}
        data.portals.priorities = data.portals.priorities or {
            ["Tower Limit"] = 1,
            ["Immunity"] = 2,
            ["Speedy"] = 3,
            ["No Hit"] = 4,
            ["Flight"] = 5,
            ["Short Range"] = 6,
            ["High Cost"] = 7
        }
        ErrorHandler:log("INFO", "Migrated config from version 1 to 2")
    end
    
    data.version = self.configVersion
    
    return data
end

function ConfigManager:validateConfig(data)
    if type(data) ~= "table" then
        return false, "Config is not a table"
    end
    
    local requiredFields = {"toggles", "inputs", "dropdowns", "abilities", "autoJoin", "loadingScreenMonitor", "restartRecovery"}
    for _, field in ipairs(requiredFields) do
        if type(data[field]) ~= "table" then
            data[field] = {}
        end
    end
    
    return true, data
end

function ConfigManager:load()
    if self.config then
        return self.config
    end
    
    if not self:ensureFolders() then
        self.config = self:deepCopy(self.defaultConfig)
        ErrorHandler:log("INFO", "Using default config (file system unavailable)")
        return self.config
    end
    
    local configPath = self:getConfigPath()
    
    if isfile(configPath) then
        local success, result = ErrorHandler:wrapAsync(function()
            local fileContent = readfile(configPath)
            
            local data = HttpService:JSONDecode(fileContent)
            
            local valid, validatedData = self:validateConfig(data)
            if not valid then
                error("Invalid config structure: " .. tostring(validatedData))
            end
            
            validatedData = self:migrateConfig(validatedData)
            
            return validatedData
        end, "Config loading")
        
        if success and result then
            self.config = result
            ErrorHandler:log("INFO", "Config loaded successfully")
            return self.config
        else
            ErrorHandler:log("ERROR", "Config corrupted, creating backup and using defaults")
            
            pcall(function()
                local backupPath = configPath .. ".backup." .. tostring(os.time())
                if isfile(configPath) then
                    local content = readfile(configPath)
                    writefile(backupPath, content)
                    ErrorHandler:log("INFO", "Corrupted config backed up to: " .. backupPath)
                end
            end)
        end
    end
    
    self.config = self:deepCopy(self.defaultConfig)
    ErrorHandler:log("INFO", "Using default config")
    
    self:saveImmediate()
    
    return self.config
end

function ConfigManager:deepCopy(original)
    local copy
    if type(original) == 'table' then
        copy = {}
        for key, value in next, original, nil do
            copy[self:deepCopy(key)] = self:deepCopy(value)
        end
    else
        copy = original
    end
    return copy
end

function ConfigManager:saveImmediate()
    if not PlatformDetector:hasCapability("hasFileSystem") then
        return false
    end
    
    if not self.config then
        ErrorHandler:log("WARN", "No config to save")
        return false
    end
    
    self:ensureFolders()
    
    local success, err = ErrorHandler:wrapAsync(function()
        local json = HttpService:JSONEncode(self.config)
        writefile(self:getConfigPath(), json)
    end, "Config save")
    
    if success then
        self.lastSaveTime = tick()
        self.pendingSave = false
        ErrorHandler:log("DEBUG", "Config saved successfully")
        return true
    else
        ErrorHandler:log("ERROR", "Config save failed: " .. tostring(err))
        return false
    end
end

function ConfigManager:save()
    self.pendingSave = true
    
    if self.saveScheduled then
        return
    end
    
    self.saveScheduled = true
    
    task.spawn(function()
        local timeSinceLastSave = tick() - self.lastSaveTime
        if timeSinceLastSave < self.saveDebounceTime then
            task.wait(self.saveDebounceTime - timeSinceLastSave)
        end
        
        if self.pendingSave then
            self:saveImmediate()
        end
        
        self.saveScheduled = false
    end)
end

function ConfigManager:get(category, key, default)
    if not self.config then
        self:load()
    end
    
    if not self.config[category] then
        return default
    end
    
    local value = self.config[category][key]
    if value == nil then
        return default
    end
    
    return value
end

function ConfigManager:set(category, key, value)
    if not self.config then
        self:load()
    end
    
    if not self.config[category] then
        self.config[category] = {}
    end
    
    self.config[category][key] = value
    
    self:save()
end

function ConfigManager:getConfig()
    if not self.config then
        self:load()
    end
    return self.config
end

function ConfigManager:reload()
    self.config = nil
    return self:load()
end

local loadedConfig = ConfigManager:load()

getgenv().Config = loadedConfig
getgenv().SaveConfig = function(config)
    ConfigManager.config = config
    ConfigManager:save()
end
getgenv().LoadConfig = function()
    return ConfigManager:reload()
end

getgenv().ConfigManager = ConfigManager

local CONFIG_FOLDER = ConfigManager.configFolder

local saveConfig = getgenv().SaveConfig

getgenv().DebugMode = ConfigManager:get("toggles", "DebugMode", false)

UIFactory:init(getgenv().Config, function(config)
    ConfigManager.config = config
    ConfigManager:save()
end)


local function safeGarbageCollect()
    pcall(function()
        gcinfo()
    end)
end

if not getgenv()._ConnectionManager then
    getgenv()._ConnectionManager = {
        connections = {},
        add = function(self, name, connection)
            if self.connections[name] then
                pcall(function() self.connections[name]:Disconnect() end)
            end
            self.connections[name] = connection
        end,
        remove = function(self, name)
            if self.connections[name] then
                pcall(function() self.connections[name]:Disconnect() end)
                self.connections[name] = nil
            end
        end,
        cleanup = function(self)
            for name, conn in pairs(self.connections) do
                pcall(function() conn:Disconnect() end)
            end
            self.connections = {}
        end
    }
end

local ConnectionManager = getgenv().ConnectionManager


local platformInfo = PlatformDetector:detect()

local defaultWidth = 720
local defaultHeight = 480
local customWidth = tonumber(getgenv().Config.inputs.UIWidth) or defaultWidth
local customHeight = tonumber(getgenv().Config.inputs.UIHeight) or defaultHeight

if customWidth < 400 or customWidth > 1920 then customWidth = defaultWidth end
if customHeight < 300 or customHeight > 1080 then customHeight = defaultHeight end

local dragStyle = PlatformDetector:isMobilePlatform() and 2 or 1
ErrorHandler:log("INFO", string.format("UI DragStyle: %d (Mobile: %s)", dragStyle, tostring(PlatformDetector:isMobilePlatform())))

local enableBlur = not PlatformDetector:isMobilePlatform()

local Window = ErrorHandler:wrap(function()
    return MacLib:Window({
        Title = "Byorl Last Stand",
        Subtitle = "Anime Last Stand Automation",
        Size = UDim2.fromOffset(customWidth, customHeight),
        DragStyle = dragStyle,
        DisabledWindowControls = {},
        ShowUserInfo = false,
        Keybind = Enum.KeyCode.LeftControl,
        AcrylicBlur = enableBlur,
    })
end, "Window creation")()

if not Window then
    ErrorHandler:log("ERROR", "Failed to create Window - MacLib may not be loaded correctly")
    error("[ALS] Failed to create Window")
    return
end


local globalSettings = {}

ErrorHandler:wrap(function()
    globalSettings.UIBlurToggle = Window:GlobalSetting({
        Name = "UI Blur",
        Default = false,
        Callback = function(bool)
            Window:SetAcrylicBlurState(bool)
            Window:Notify({
                Title = Window.Settings.Title,
                Description = (bool and "Enabled" or "Disabled") .. " UI Blur",
                Lifetime = 5
            })
        end,
    })
end, "Create UI Blur global setting")()

ErrorHandler:wrap(function()
    globalSettings.NotificationToggler = Window:GlobalSetting({
        Name = "Notifications",
        Default = Window:GetNotificationsState(),
        Callback = function(bool)
            Window:SetNotificationsState(bool)
            Window:Notify({
                Title = Window.Settings.Title,
                Description = (bool and "Enabled" or "Disabled") .. " Notifications",
                Lifetime = 5
            })
        end,
    })
end, "Create Notifications global setting")()

ErrorHandler:wrap(function()
    globalSettings.ShowUserInfo = Window:GlobalSetting({
        Name = "Show User Info",
        Default = Window:GetUserInfoState(),
        Callback = function(bool)
            Window:SetUserInfoState(bool)
            Window:Notify({
                Title = Window.Settings.Title,
                Description = (bool and "Showing" or "Redacted") .. " User Info",
                Lifetime = 5
            })
        end,
    })
end, "Create Show User Info global setting")()


Window.onUnloaded(function()
    debugPrint("[Cleanup] Unloading script...")
    
    getgenv().ALSScriptLoaded = false
    getgenv().MacroPlayEnabled = false
    getgenv().MacroRecordingV2 = false
    getgenv().AutoAbilitiesEnabled = false
    
    pcall(function()
        local stats = ConnectionManager:getStats()
        debugPrint(string.format("[Cleanup] Disconnecting %d active connections...", stats.active))
        ConnectionManager:disconnectAll()
    end)
    
    pcall(function()
        if cashConnection then cashConnection:Disconnect() end
        if cashTrackingConnection then cashTrackingConnection:Disconnect() end
        for tower, conn in pairs(towerTracker.upgradeConnections or {}) do
            if conn then conn:Disconnect() end
        end
    end)
    
    pcall(function()
        if getgenv()._GlobalConnections then
            for _, conn in pairs(getgenv()._GlobalConnections) do
                if conn and conn.Disconnect then
                    conn:Disconnect()
                end
            end
            getgenv()._GlobalConnections = {}
        end
    end)
    
    pcall(function()
        if getgenv()._AutoRejoinConnections then
            for _, conn in pairs(getgenv()._AutoRejoinConnections) do
                if conn and conn.Disconnect then
                    conn:Disconnect()
                end
            end
            getgenv()._AutoRejoinConnections = {}
        end
    end)
    
    pcall(function()
        if getgenv()._PositionHolograms then
            for _, hologramData in pairs(getgenv()._PositionHolograms) do
                if hologramData.part then hologramData.part:Destroy() end
                if hologramData.beam then hologramData.beam:Destroy() end
            end
            getgenv()._PositionHolograms = {}
        end
    end)
    
    pcall(function()
        if getgenv()._DynamicSummonSections then
            getgenv()._DynamicSummonSections = {}
        end
    end)
    
    if ConnectionManager then
        ConnectionManager:cleanup()
    end
    
    pcall(function()
        if getgenv()._LoadingScreenMonitor_stopMonitoring then
            getgenv()._LoadingScreenMonitor_stopMonitoring()
        end
    end)
    
    pcall(function()
        if getgenv()._CrashMonitor_stopMonitoring then
            getgenv()._CrashMonitor_stopMonitoring()
        end
    end)
    
    pcall(function()
        if getgenv().RestartRecovery then
            getgenv().RestartRecovery.isRecovering = false
            getgenv().RestartRecovery.currentAttempt = 0
        end
    end)
    
    pcall(function()
        if getgenv().SeamlessRestartManager then
            getgenv().SeamlessRestartManager.isRestarting = false
        end
    end)
    
    pcall(cleanupTowerTracker)
    
    getgenv().MacroTowerInfoCache = nil
    getgenv().MacroRemoteCache = nil
    getgenv().MacroCashHistory = nil
    getgenv().MacroDataV2 = nil
    getgenv().MacroActionsV2 = nil
    getgenv().MacroPlaybackMacroData = nil
    getgenv().WukongTrackedClones = nil
    getgenv().SmartCardPicked = nil
    getgenv().SlowerCardPicked = nil
    getgenv()._lastWebhookHashList = nil
    getgenv()._AbilityUIElements = nil
    
    for i = 1, 3 do
        safeGarbageCollect()
    end
    
    debugPrint("[Cleanup] Complete")
end)

task.spawn(function()
    local lastPing = 0
    local highPingCount = 0
    local connectionCheckCount = 0
    local startTime = tick()
    local lastMemoryCleanup = tick()
    
    while task.wait(5) do
        pcall(function()
            connectionCheckCount = connectionCheckCount + 1
            local uptime = (tick() - startTime) / 3600
            
            local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
            
            if ping > 1000 then
                highPingCount = highPingCount + 1
                warn("[Network] High ping: " .. math.floor(ping) .. "ms (" .. highPingCount .. "/3)")
                
                if highPingCount >= 3 then
                    warn("[Network] Persistent high ping - cleaning memory")
                    safeGarbageCollect()
                    highPingCount = 0
                end
            else
                highPingCount = 0
            end
            
            if connectionCheckCount % 720 == 0 then
                print(string.format("[Status] Uptime: %.1fh | Ping: %dms", uptime, math.floor(ping)))
            end
            
            if uptime > 2 and (tick() - lastMemoryCleanup) > 1800 then
                debugPrint("[Memory] 30min cleanup cycle")
                safeGarbageCollect()
                lastMemoryCleanup = tick()
            end
            
            lastPing = ping
        end)
    end
end)

task.wait(2)

local function isTeleportUIVisible()
    local tpUI = LocalPlayer.PlayerGui:FindFirstChild("TeleportUI")
    if not tpUI then return false end
    
    local ok, visible = pcall(function()
        return tpUI.Enabled
    end)
    return ok and visible
end

local function isPlayerInValidState()
    local character = LocalPlayer.Character
    if not character then return false end
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end
    return true
end

local maxWaitTime = 0
local maxWait = 60
local lastStateCheck = tick()
repeat
    task.wait(0.2)
    maxWaitTime = maxWaitTime + 0.2
    
    if tick() - lastStateCheck > 10 then
        lastStateCheck = tick()
        if isTeleportUIVisible() and not isPlayerInValidState() then
            warn("[ALS] Still loading after " .. math.floor(maxWaitTime) .. "s, attempting recovery...")
            local TeleportService = game:GetService("TeleportService")
            pcall(function()
                TeleportService:Teleport(12886143095, LocalPlayer)
            end)
            task.wait(5)
        end
    end
until (not isTeleportUIVisible() and isPlayerInValidState()) or maxWaitTime > maxWait

if maxWaitTime > maxWait and not isPlayerInValidState() then
    warn("[ALS] Failed to load properly after " .. maxWait .. "s, forcing rejoin...")
    local TeleportService = game:GetService("TeleportService")
    pcall(function()
        TeleportService:Teleport(12886143095, LocalPlayer)
    end)
    task.wait(10)
end

task.wait(1)

if not getgenv().Config.hasJoinedDiscord then
    Window:Dialog({
        Title = "Join Our Discord!",
        Description = "Have you joined the Byorl Last Stand Discord server? Get updates, support, and connect with the community!",
        Buttons = {
            {
                Name = "Yes, I'm in!",
                Callback = function()
                    getgenv().Config.hasJoinedDiscord = true
                    saveConfig(getgenv().Config)
                    Window:Notify({
                        Title = "Byorl Last Stand",
                        Description = "Awesome! Thanks for being part of the community!",
                        Lifetime = 3
                    })
                end,
            },
            {
                Name = "Not yet",
                Callback = function()
                    getgenv().Config.hasJoinedDiscord = true
                    saveConfig(getgenv().Config)
                    
                    if setclipboard then
                        setclipboard("https://discord.gg/V3WcdHpd3J")
                    end
                    
                    Window:Notify({
                        Title = "Byorl Last Stand",
                        Description = "Discord link copied! Opening in browser...",
                        Lifetime = 5
                    })
                    
                    task.wait(0.5)
                    
                    local success = pcall(function()
                        if request then
                            request({
                                Url = "https://discord.gg/V3WcdHpd3J",
                                Method = "GET"
                            })
                        end
                    end)
                    
                    if not success then
                        Window:Notify({
                            Title = "Byorl Last Stand",
                            Description = "Link copied to clipboard: discord.gg/V3WcdHpd3J",
                            Lifetime = 5
                        })
                    end
                end,
            }
        }
    })
end

getgenv()._AbilityUIBuilt = false
getgenv()._AbilityUIBuilding = false

local function shouldFilterMessage(msg)
    local msgLower = msg:lower()
    
    if msgLower:find("playermodule") 
        or msgLower:find("cameramodule") 
        or msgLower:find("zoomcontroller")
        or msgLower:find("popper")
        or msgLower:find("poppercam")
        or msgLower:find("imagelabel")
        or msgLower:find("not a valid member")
        or msgLower:find("is not a valid member")
        or msgLower:find("attempt to perform arithmetic")
        or msgLower:find("playerscripts")
        or msgLower:find("byorials")
        or msgLower:find("stack begin")
        or msgLower:find("stack end")
        or msgLower:find("runservice")
        or msgLower:find("firerenderstepearlyfunctions")
        or msgLower:find("firerenderstep")
        or msgLower:find("metamethod")
        or msgLower:find("__namecall")
        or msgLower:find("unexpected error while invoking callback")
        or msgLower:find("frogionsol") then
        return true
    end
    
    return false
end

local oldLogWarn = logwarn or warn
local oldLogError = logerror or error

local function createFilteredLogger(originalLogger)
    return function(...)
        local args = {...}
        local msg = ""
        for i, v in ipairs(args) do
            msg = msg .. tostring(v)
        end
        if not shouldFilterMessage(msg) then
            originalLogger(...)
        end
    end
end

if logwarn then logwarn = createFilteredLogger(oldLogWarn) end
warn = createFilteredLogger(oldLogWarn)
if logerror then logerror = createFilteredLogger(oldLogError) end

local oldErrorHandler = geterrorhandler and geterrorhandler()
if seterrorhandler then
    seterrorhandler(function(msg)
        if not shouldFilterMessage(tostring(msg)) then
            if oldErrorHandler then
                oldErrorHandler(msg)
            else
                oldLogError(msg)
            end
        end
    end)
end

local function cleanupBeforeTeleport()    
    pcall(function()
        if Window and Window.Unload then
            Window:Unload()
        end
    end)
    
    pcall(function()
        getgenv().AutoAbilitiesEnabled = nil
        getgenv().CardSelectionEnabled = nil
        getgenv().SlowerCardSelectionEnabled = nil
    end)
    
    pcall(function()
        if cashConnection then cashConnection:Disconnect() end
        if cashTrackingConnection then cashTrackingConnection:Disconnect() end
        for tower, conn in pairs(towerTracker.upgradeConnections or {}) do
            if conn then conn:Disconnect() end
        end
    end)
    
    pcall(function()
        if getconnections then
            for _, service in pairs({RunService.Heartbeat, RunService.RenderStepped, RunService.Stepped}) do
                for _, connection in pairs(getconnections(service)) do
                    if connection.Disable then connection:Disable() end
                    if connection.Disconnect then connection:Disconnect() end
                end
            end
        end
    end)
    
    pcall(function()
        getgenv().MacroTowerInfoCache = nil
        getgenv().MacroRemoteCache = nil
        getgenv().MacroCashHistory = nil
        if not getgenv().MacroRecordingV2 then
            getgenv().MacroDataV2 = nil
        end
        towerTracker = {
            placeCounts = {},
            upgradeLevels = {},
            lastPlaceTime = {},
            lastUpgradeTime = {},
            pendingActions = {},
            upgradeConnections = {}
        }
    end)

    
    task.wait(0.2)
end

getgenv().CleanupBeforeTeleport = cleanupBeforeTeleport

MacLib:SetFolder(CONFIG_FOLDER)


local TabGroup1 = ErrorHandler:wrap(function()
    return Window:TabGroup()
end, "Create TabGroup1")()

local TabGroup2 = ErrorHandler:wrap(function()
    return Window:TabGroup()
end, "Create TabGroup2")()

local TabGroup3 = ErrorHandler:wrap(function()
    return Window:TabGroup()
end, "Create TabGroup3")()

if not TabGroup1 or not TabGroup2 or not TabGroup3 then
    ErrorHandler:log("ERROR", "Failed to create tab groups")
    error("[ALS] Failed to create tab groups")
    return
end


local Tabs = {}

Tabs.Main = ErrorHandler:wrap(function()
    return TabGroup1:Tab({ 
        Name = "Main", 
        Image = "rbxassetid://10734950309" 
    })
end, "Create Main tab")()

Tabs.AutoPlay = ErrorHandler:wrap(function()
    return TabGroup1:Tab({ 
        Name = "Auto Play", 
        Image = "rbxassetid://10723407389" 
    })
end, "Create AutoPlay tab")()

Tabs.Macro = ErrorHandler:wrap(function()
    return TabGroup1:Tab({ 
        Name = "Macro", 
        Image = "rbxassetid://10734923549" 
    })
end, "Create Macro tab")()

Tabs.Abilities = ErrorHandler:wrap(function()
    return TabGroup1:Tab({ 
        Name = "Abilities", 
        Image = "rbxassetid://10747373176" 
    })
end, "Create Abilities tab")()

Tabs.Portals = ErrorHandler:wrap(function()
    return TabGroup1:Tab({ 
        Name = "Portals", 
        Image = "rbxassetid://10723407389" 
    })
end, "Create Portals tab")()

Tabs.Event = ErrorHandler:wrap(function()
    return TabGroup2:Tab({ 
        Name = "Event", 
        Image = "rbxassetid://10734952273" 
    })
end, "Create Event tab")()

Tabs.Event2 = ErrorHandler:wrap(function()
    return TabGroup2:Tab({ 
        Name = "Event 2", 
        Image = "rbxassetid://10734952273" 
    })
end, "Create Event2 tab")()

Tabs.SlimeRush = ErrorHandler:wrap(function()
    return TabGroup2:Tab({ 
        Name = "Slime Rush", 
        Image = "rbxassetid://10734923549" 
    })
end, "Create SlimeRush tab")()

Tabs.BossRush = ErrorHandler:wrap(function()
    return TabGroup2:Tab({ 
        Name = "Boss Rush", 
        Image = "rbxassetid://10734923549" 
    })
end, "Create BossRush tab")()

Tabs.Breach = ErrorHandler:wrap(function()
    return TabGroup2:Tab({ 
        Name = "Breach", 
        Image = "rbxassetid://10747374131" 
    })
end, "Create Breach tab")()

Tabs.FinalExpedition = ErrorHandler:wrap(function()
    return TabGroup2:Tab({ 
        Name = "Final Expedition", 
        Image = "rbxassetid://10723407389" 
    })
end, "Create FinalExpedition tab")()

Tabs.InfinityCastle = ErrorHandler:wrap(function()
    return TabGroup2:Tab({ 
        Name = "Infinity Castle", 
        Image = "rbxassetid://10734923549" 
    })
end, "Create InfinityCastle tab")()

Tabs.Webhook = ErrorHandler:wrap(function()
    return TabGroup3:Tab({ 
        Name = "Webhook", 
        Image = "rbxassetid://10734952273" 
    })
end, "Create Webhook tab")()

Tabs.SeamlessFix = ErrorHandler:wrap(function()
    return TabGroup3:Tab({ 
        Name = "Automation", 
        Image = "rbxassetid://10734923549" 
    })
end, "Create SeamlessFix tab")()

Tabs.Misc = ErrorHandler:wrap(function()
    return TabGroup3:Tab({ 
        Name = "Misc", 
        Image = "rbxassetid://10734949856" 
    })
end, "Create Misc tab")()

Tabs.Settings = ErrorHandler:wrap(function()
    return TabGroup3:Tab({ 
        Name = "Settings", 
        Image = "rbxassetid://10734949856" 
    })
end, "Create Settings tab")()

local tabCount = 0
for name, tab in pairs(Tabs) do
    if tab then
        tabCount = tabCount + 1
    else
        ErrorHandler:log("WARN", "Failed to create tab: " .. name)
    end
end



local ToggleGui, ToggleButton

ErrorHandler:wrap(function()
    ToggleGui = Instance.new("ScreenGui")
    ToggleGui.Name = "ALS_Fluent_Toggle"
    ToggleGui.ResetOnSpawn = false
    ToggleGui.IgnoreGuiInset = true
    ToggleGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    ToggleGui.Parent = game:GetService("CoreGui")
    
    ToggleButton = Instance.new("TextButton")
    ToggleButton.Name = "ToggleButton"
    ToggleButton.Size = UDim2.new(0, 100, 0, 100)
    ToggleButton.Position = UDim2.new(1, -10, 0.5, 0)
    ToggleButton.AnchorPoint = Vector2.new(1, 0.5)
    ToggleButton.BackgroundColor3 = Color3.fromRGB(85, 85, 100)
    ToggleButton.BorderSizePixel = 0
    ToggleButton.Text = "Byorl\nLast\nStand"
    ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    ToggleButton.TextSize = 16
    ToggleButton.Font = Enum.Font.GothamBold
    ToggleButton.Active = true
    ToggleButton.Draggable = true
    ToggleButton.Parent = ToggleGui
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 12)
    corner.Parent = ToggleButton
    
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(100, 100, 120)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(75, 75, 90))
    })
    gradient.Rotation = 90
    gradient.Parent = ToggleButton
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(130, 130, 160)
    stroke.Thickness = 2
    stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    stroke.Parent = ToggleButton
    
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "Shadow"
    shadow.BackgroundTransparency = 1
    shadow.Position = UDim2.new(0.5, 0, 0.5, 0)
    shadow.Size = UDim2.new(1, 20, 1, 20)
    shadow.AnchorPoint = Vector2.new(0.5, 0.5)
    shadow.Image = "rbxassetid://5554236805"
    shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
    shadow.ImageTransparency = 0.5
    shadow.ZIndex = -1
    shadow.Parent = ToggleButton
    
    ToggleButton.MouseEnter:Connect(function()
        game:GetService("TweenService"):Create(ToggleButton, TweenInfo.new(0.2), {
            BackgroundColor3 = Color3.fromRGB(105, 105, 125)
        }):Play()
        game:GetService("TweenService"):Create(stroke, TweenInfo.new(0.2), {
            Color = Color3.fromRGB(150, 150, 190)
        }):Play()
    end)
    
    ToggleButton.MouseLeave:Connect(function()
        game:GetService("TweenService"):Create(ToggleButton, TweenInfo.new(0.2), {
            BackgroundColor3 = Color3.fromRGB(85, 85, 100)
        }):Play()
        game:GetService("TweenService"):Create(stroke, TweenInfo.new(0.2), {
            Color = Color3.fromRGB(130, 130, 160)
        }):Play()
    end)
    
end, "Create toggle button GUI")()

local function getCurrentMenuKey()
    local keyName = getgenv().Config.inputs["MenuKeybind"] or "LeftControl"
    local success, keyCode = pcall(function()
        return Enum.KeyCode[keyName]
    end)
    return success and keyCode or Enum.KeyCode.LeftControl
end

local function toggleUI()
    ErrorHandler:wrap(function()
        local currentKey = getCurrentMenuKey()
        VIM:SendKeyEvent(true, currentKey, false, game)
        task.wait(0.05)
        VIM:SendKeyEvent(false, currentKey, false, game)
    end, "Toggle UI")()
end

if ToggleButton then
    ConnectionManager:track(
        ToggleButton.MouseButton1Click:Connect(toggleUI),
        { group = "UI", context = "Toggle button click" }
    )
end


local Sections = {}

local function createSection(tab, tabName, side)
    return ErrorHandler:wrap(function()
        if not tab then
            ErrorHandler:log("WARN", string.format("Tab %s is nil, cannot create section", tabName))
            return nil
        end
        return tab:Section({ Side = side })
    end, string.format("Create %s %s section", tabName, side))()
end

Sections.MainLeft = createSection(Tabs.Main, "Main", "Left")
Sections.MainRight = createSection(Tabs.Main, "Main", "Right")

Sections.AutoPlayLeft = createSection(Tabs.AutoPlay, "AutoPlay", "Left")
Sections.AutoPlayRight = createSection(Tabs.AutoPlay, "AutoPlay", "Right")

Sections.MacroLeft = createSection(Tabs.Macro, "Macro", "Left")
Sections.MacroRight = createSection(Tabs.Macro, "Macro", "Right")

Sections.PortalsLeft = createSection(Tabs.Portals, "Portals", "Left")
Sections.PortalsRight = createSection(Tabs.Portals, "Portals", "Right")

Sections.BossRushLeft = createSection(Tabs.BossRush, "BossRush", "Left")
Sections.BossRushRight = createSection(Tabs.BossRush, "BossRush", "Right")

Sections.BreachLeft = createSection(Tabs.Breach, "Breach", "Left")
Sections.BreachRight = createSection(Tabs.Breach, "Breach", "Right")

Sections.FinalExpeditionLeft = createSection(Tabs.FinalExpedition, "FinalExpedition", "Left")
Sections.FinalExpeditionRight = createSection(Tabs.FinalExpedition, "FinalExpedition", "Right")

Sections.InfinityCastleLeft = createSection(Tabs.InfinityCastle, "InfinityCastle", "Left")
Sections.InfinityCastleRight = createSection(Tabs.InfinityCastle, "InfinityCastle", "Right")

Sections.EventLeft = createSection(Tabs.Event, "Event", "Left")
Sections.EventRight = createSection(Tabs.Event, "Event", "Right")

Sections.Event2Left = createSection(Tabs.Event2, "Event2", "Left")
Sections.Event2Right = createSection(Tabs.Event2, "Event2", "Right")

Sections.SlimeRushLeft = createSection(Tabs.SlimeRush, "SlimeRush", "Left")
Sections.SlimeRushRight = createSection(Tabs.SlimeRush, "SlimeRush", "Right")

Sections.WebhookLeft = createSection(Tabs.Webhook, "Webhook", "Left")

Sections.SeamlessFixLeft = createSection(Tabs.SeamlessFix, "SeamlessFix", "Left")
Sections.SeamlessFixRight = createSection(Tabs.SeamlessFix, "SeamlessFix", "Right")

Sections.MiscLeft = createSection(Tabs.Misc, "Misc", "Left")
Sections.MiscRight = createSection(Tabs.Misc, "Misc", "Right")

Sections.SettingsLeft = createSection(Tabs.Settings, "Settings", "Left")
Sections.SettingsRight = createSection(Tabs.Settings, "Settings", "Right")

local sectionCount = 0
for name, section in pairs(Sections) do
    if section then
        sectionCount = sectionCount + 1
    else
        ErrorHandler:log("WARN", "Failed to create section: " .. name)
    end
end


ErrorHandler:wrap(function()
    if Tabs.Main then
        Tabs.Main:Select()
    end
end, "Select Main tab")()




local function createUIElementWithRetry(elementType, section, config, retryAttempts)
    retryAttempts = retryAttempts or 3
    local retryDelay = 0.5
    
    for attempt = 1, retryAttempts do
        local success, element = pcall(function()
            return UIFactory:createElement(elementType, section, config)
        end)
        
        if success and element then
            if attempt > 1 then
                ErrorHandler:log("INFO", string.format("✓ Created %s '%s' on attempt %d", 
                    elementType, config.name or "Unknown", attempt))
            end
            return element
        else
            ErrorHandler:log("WARN", string.format("Failed to create %s '%s' (attempt %d/%d): %s", 
                elementType, config.name or "Unknown", attempt, retryAttempts, tostring(element)))
            
            if attempt < retryAttempts then
                task.wait(retryDelay)
            end
        end
    end
    
    ErrorHandler:log("ERROR", string.format("Failed to create %s '%s' after %d attempts", 
        elementType, config.name or "Unknown", retryAttempts))
    
    return nil
end


local function createToggle(section, name, flag, callback, default)
    return UIFactory:createElement("Toggle", section, {
        name = name or "Toggle",
        flag = flag,
        callback = callback,
        default = default or false,
        autoSave = true
    })
end

local function createToggleNoSave(section, name, flag, callback, default)
    return UIFactory:createElement("Toggle", section, {
        name = name or "Toggle",
        flag = flag,
        callback = callback,
        default = default or false,
        autoSave = false
    })
end

local function createInput(section, name, flag, placeholder, charType, callback, default)
    return UIFactory:createElement("Input", section, {
        name = name or "Input",
        flag = flag,
        placeholder = placeholder or "",
        charType = charType or "All",
        callback = callback,
        default = default or "",
        autoSave = true
    })
end

local function createDropdown(section, name, flag, options, multi, callback, default)
    return UIFactory:createElement("Dropdown", section, {
        name = name or "Dropdown",
        flag = flag,
        options = options or {},
        multi = multi or false,
        callback = callback,
        default = default or (multi and {} or 1),
        autoSave = true
    })
end

local function createSlider(section, name, flag, minimum, maximum, default, callback, displayMethod, precision)
    return UIFactory:createElement("Slider", section, {
        name = name or "Slider",
        flag = flag,
        minimum = minimum or 0,
        maximum = maximum or 100,
        default = default or minimum,
        displayMethod = displayMethod or "Default",
        precision = precision,
        callback = callback,
        autoSave = true
    })
end

local function createMutuallyExclusiveToggle(section, name, flag, otherToggle, otherFlag, callback, default)
    local toggle = UIFactory:createElement("Toggle", section, {
        name = name,
        flag = flag,
        default = default or false,
        autoSave = true,
        callback = function(value)
            if callback then 
                callback(value) 
            end
            
            if value and otherToggle then
                getgenv().Config.toggles[otherFlag] = false
                saveConfig(getgenv().Config)
                pcall(function()
                    otherToggle:UpdateState(false)
                end)
            end
        end
    })
    
    return toggle
end


local function createCardPriorityInputs(section, cardTable, targetPriorityTable, keyPrefix)
    if not cardTable or type(cardTable) ~= "table" then return end
    keyPrefix = keyPrefix or "Card_"
    
    local cardNames = {}
    for name in pairs(cardTable) do
        if name and name ~= "" then
            table.insert(cardNames, name)
        end
    end
    table.sort(cardNames, function(a, b)
        return (cardTable[a] or 999) < (cardTable[b] or 999)
    end)
    
    for _, cardName in ipairs(cardNames) do
        if cardName and cardName ~= "" then
            local configKey = keyPrefix .. tostring(cardName)
            local defaultValue = getgenv().Config.inputs[configKey] or tostring(cardTable[cardName] or 999)
            
            createInput(
                section,
                tostring(cardName),
                configKey,
                "Priority (1-999)",
                "Numeric",
                function(value)
                    local num = tonumber(value)
                    if num then
                        targetPriorityTable[cardName] = num
                    end
                end,
                tostring(defaultValue)
            )
            
            targetPriorityTable[cardName] = tonumber(defaultValue) or cardTable[cardName] or 999
        end
    end
end

getgenv().CreateToggle = createToggle
getgenv().CreateInput = createInput
getgenv().CreateDropdown = createDropdown
getgenv().CreateSlider = createSlider
getgenv().CreateMutuallyExclusiveToggle = createMutuallyExclusiveToggle


local MACRO_FOLDER = ConfigManager:getUserFolder() .. "/macros"
local SETTINGS_FILE = MACRO_FOLDER .. "/settings.json"
local OLD_MACRO_FOLDER = ConfigManager.configFolder .. "/macros"
local OLD_SETTINGS_FILE = OLD_MACRO_FOLDER .. "/settings.json"

if not isfolder(MACRO_FOLDER) then makefolder(MACRO_FOLDER) end

local function migrateMacrosToUserFolder()
    if not isfolder(OLD_MACRO_FOLDER) then
        return
    end
    
    local migratedCount = 0
    
    pcall(function()
        local oldFiles = listfiles(OLD_MACRO_FOLDER)
        if oldFiles then
            for _, filePath in ipairs(oldFiles) do
                local fileName = filePath:match("([^/\\]+)$")
                
                if fileName and fileName:match("%.json$") and fileName ~= "settings.json" then
                    local newFilePath = MACRO_FOLDER .. "/" .. fileName
                    
                    if not isfile(newFilePath) then
                        local content = readfile(filePath)
                        writefile(newFilePath, content)
                        migratedCount = migratedCount + 1
                        warn(string.format("[Macro Migration] Migrated: %s", fileName))
                    end
                end
            end
        end
    end)
    
    pcall(function()
        if isfile(OLD_SETTINGS_FILE) and not isfile(SETTINGS_FILE) then
            local content = readfile(OLD_SETTINGS_FILE)
            writefile(SETTINGS_FILE, content)
            warn("[Macro Migration] Migrated settings.json")
        end
    end)
    
    if migratedCount > 0 then
        warn(string.format("[Macro Migration] Successfully migrated %d macro(s) to user folder", migratedCount))
    end
end

migrateMacrosToUserFolder()

getgenv().Macros = {}
getgenv().MacroMaps = {}

local function loadMacroSettings()
    local settings = {
        playMacroEnabled = false,
        selectedMacro = nil,
        macroMaps = {},
        stepDelay = 0
    }
    pcall(function()
        if isfile(SETTINGS_FILE) then
            local data = HttpService:JSONDecode(readfile(SETTINGS_FILE))
            if type(data) == "table" then
                settings = data
            end
        end
    end)
    return settings
end

local function saveMacroSettings()
    pcall(function()
        local settings = {
            playMacroEnabled = getgenv().MacroPlayEnabled or false,
            selectedMacro = getgenv().CurrentMacro,
            macroMaps = getgenv().MacroMaps or {},
            stepDelay = getgenv().MacroStepDelay or 0
        }
        writefile(SETTINGS_FILE, HttpService:JSONEncode(settings))
    end)
end

local function saveMacro(name, data)
    local filePath = MACRO_FOLDER .. "/" .. name .. ".json"
    local maxRetries = 1
    local retryDelay = 1
    
    for attempt = 1, maxRetries + 1 do
        local success, err = pcall(function()
            local jsonData = HttpService:JSONEncode(data)
            writefile(filePath, jsonData)
            
            task.wait(0.1)
            
            if not isfile(filePath) then
                error("File verification failed: file does not exist after write")
            end
            
            local readSuccess, readData = pcall(function()
                return readfile(filePath)
            end)
            
            if not readSuccess then
                error("File verification failed: cannot read file - " .. tostring(readData))
            end
            
            local decodeSuccess, decodedData = pcall(function()
                return HttpService:JSONDecode(readData)
            end)
            
            if not decodeSuccess then
                error("File verification failed: invalid JSON - " .. tostring(decodedData))
            end
            
            getgenv().Macros[name] = data
        end)
        
        if success then
            getgenv()._DiagnosticsLogger_logSaveOperation(name, true, nil, attempt, maxRetries + 1)
            if attempt > 1 then
                debugPrint("[Macro] Save succeeded on retry attempt " .. attempt)
            end
            return true
        else
            local isLastAttempt = (attempt == maxRetries + 1)
            
            getgenv()._DiagnosticsLogger_logSaveOperation(name, false, tostring(err), attempt, maxRetries + 1)
            
            if isLastAttempt then
                warn("[Macro] Failed to save '" .. name .. "' after " .. (maxRetries + 1) .. " attempts")
                warn("[Macro] Error: " .. tostring(err))
                
                if Window and Window.Notify then
                    pcall(function()
                        Window:Notify({
                            Title = "Macro Save Failed",
                            Description = "Failed to save '" .. name .. "'. Check console for details.",
                            Lifetime = 8,
                            Style = "Cancel"
                        })
                    end)
                end
                
                return false
            else
                warn("[Macro] Save attempt " .. attempt .. " failed: " .. tostring(err))
                warn("[Macro] Retrying in " .. retryDelay .. " second(s)...")
                task.wait(retryDelay)
            end
        end
    end
    
    return false
end

local function convertOldMacroFormat(oldData)
    local newData = {}
    local sortedKeys = {}
    
    for key in pairs(oldData) do
        if key ~= "Data" and tonumber(key) then
            table.insert(sortedKeys, tonumber(key))
        end
    end
    table.sort(sortedKeys)
    
    for _, key in ipairs(sortedKeys) do
        local step = oldData[tostring(key)]
        if step and step.type and step.unit then
            local newStep = {
                Wave = 1,
                Time = 0,
                IsInvoke = false
            }
            
            if step.type == "SpawnUnit" then
                newStep.RemoteName = "PlaceTower"
                newStep.ActionType = "Place"
                
                local cframeArray = {}
                if step.cframe then
                    for num in string.gmatch(step.cframe, "[^,%s]+") do
                        local value = tonumber(num)
                        if value then
                            table.insert(cframeArray, value)
                        end
                    end
                end
                
                if #cframeArray >= 12 then
                    newStep.Args = {step.unit, cframeArray}
                    newStep.TowerName = step.unit
                    newStep.Cost = tonumber(step.money) or 0
                    table.insert(newData, newStep)
                else
                    warn("[Macro Converter] Invalid CFrame for SpawnUnit: " .. step.unit)
                end
                
            elseif step.type == "UpgradeUnit" then
                newStep.RemoteName = "Upgrade"
                newStep.ActionType = "Upgrade"
                newStep.Args = {}
                newStep.IsInvoke = true
                newStep.TowerName = step.unit
                newStep.Cost = tonumber(step.money) or 0
                
                local cframeArray = {}
                if step.cframe then
                    for num in string.gmatch(step.cframe, "[^,%s]+") do
                        local value = tonumber(num)
                        if value then
                            table.insert(cframeArray, value)
                        end
                    end
                end
                
                if #cframeArray >= 12 then
                    newStep.CFrame = cframeArray
                end
                
                table.insert(newData, newStep)
                
            elseif step.type == "SellUnit" then
                newStep.RemoteName = "Sell"
                newStep.ActionType = "Sell"
                newStep.Args = {}
                newStep.IsInvoke = true
                newStep.TowerName = step.unit
                newStep.Cost = 0
                
                local cframeArray = {}
                if step.cframe then
                    for num in string.gmatch(step.cframe, "[^,%s]+") do
                        local value = tonumber(num)
                        if value then
                            table.insert(cframeArray, value)
                        end
                    end
                end
                
                if #cframeArray >= 12 then
                    newStep.CFrame = cframeArray
                end
                
                table.insert(newData, newStep)
            else
                warn("[Macro Converter] Unknown step type: " .. tostring(step.type))
            end
        end
    end
    
    return newData
end

local function isOldMacroFormat(data)
    if type(data) ~= "table" then return false end
    
    if data.Data and data.Data.Map and data.Data.RecordMode then
        return true
    end
    
    for key, value in pairs(data) do
        if tonumber(key) and type(value) == "table" and value.type and value.money then
            return true
        end
    end
    
    return false
end

local function loadMacros()
    getgenv().Macros = {}
    if not isfolder(MACRO_FOLDER) then return end
    local files = listfiles(MACRO_FOLDER)
    if not files then return end
    local convertedCount = 0
    local loadedCount = 0
    
    for _, file in pairs(files) do
        if file:sub(-5) == ".json" then
            local fileName = file:match("([^/\\]+)%.json$")
            
            if fileName ~= "settings" and fileName ~= "playback_state" then
                local ok, data = pcall(function() 
                    return HttpService:JSONDecode(readfile(file)) 
                end)
                if ok and type(data) == "table" then
                    local isSettings = (data.playMacroEnabled ~= nil or data.selectedMacro ~= nil or data.macroMaps ~= nil)
                    if not isSettings then
                        if isOldMacroFormat(data) then
                            debugPrint("[Macro] Converting old format: " .. fileName)
                            local convertedData = convertOldMacroFormat(data)
                            if #convertedData > 0 then
                                getgenv().Macros[fileName] = convertedData
                                saveMacro(fileName, convertedData)
                                convertedCount = convertedCount + 1
                                loadedCount = loadedCount + 1
                                print("[Macro] ✅ Loaded (converted): " .. fileName .. " (" .. #convertedData .. " steps)")
                            else
                                warn("[Macro] ❌ Failed to convert: " .. fileName .. " (0 steps after conversion)")
                            end
                        else
                            if type(data) == "table" then
                                getgenv().Macros[fileName] = data
                                loadedCount = loadedCount + 1
                                if #data > 0 then
                                    print("[Macro] ✅ Loaded: " .. fileName .. " (" .. #data .. " steps)")
                                end
                            else
                                warn("[Macro] ❌ Skipped: " .. fileName .. " (invalid format)")
                            end
                        end
                    end
                else
                    warn("[Macro] ❌ Failed to decode: " .. fileName)
                end
            end
        end
    end
    
    
    if convertedCount > 0 then
        Window:Notify({
            Title = "Macro Converter",
            Description = "Converted " .. convertedCount .. " old format macro(s)",
            Lifetime = 5
        })
    end
end

local function loadMacro(macroName)
    if not macroName or macroName == "" then return nil end
    
    if getgenv().Macros and getgenv().Macros[macroName] then
        return getgenv().Macros[macroName]
    end
    
    local filePath = MACRO_FOLDER .. "/" .. macroName .. ".json"
    if isfile(filePath) then
        local ok, data = pcall(function()
            return HttpService:JSONDecode(readfile(filePath))
        end)
        if ok and type(data) == "table" then
            if isOldMacroFormat(data) then
                debugPrint("[Macro] Converting: " .. macroName)
                local convertedData = convertOldMacroFormat(data)
                
                if #convertedData > 0 then
                    getgenv().Macros[macroName] = convertedData
                    saveMacro(macroName, convertedData)
                    
                    Window:Notify({
                        Title = "Macro Converter",
                        Description = "Converted: " .. macroName .. " (" .. #convertedData .. " steps)",
                        Lifetime = 5
                    })
                    
                    return convertedData
                end
            end
            return data
        end
    end
    
    return nil
end

local function getMacroNames()
    local names = {}
    for name in pairs(getgenv().Macros) do 
        table.insert(names, name) 
    end
    table.sort(names)
    return names
end

local savedMacroSettings = loadMacroSettings()
getgenv().MacroMaps = savedMacroSettings.macroMaps or {}
getgenv().MacroStepDelay = savedMacroSettings.stepDelay or 0
getgenv().CurrentMacro = savedMacroSettings.selectedMacro

getgenv().MacroPlayEnabled = getgenv().Config.toggles.MacroPlayToggle or false

loadMacros()

getgenv().LoadMacroSettings = loadMacroSettings
getgenv().SaveMacroSettings = saveMacroSettings
getgenv().LoadMacros = loadMacros
getgenv().SaveMacro = saveMacro
getgenv().GetMacroNames = getMacroNames

getgenv().MacroStatusText = "Idle"
getgenv().MacroActionText = ""
getgenv().MacroUnitText = ""
getgenv().MacroWaitingText = ""
getgenv().MacroCurrentStep = 0
getgenv().MacroTotalSteps = 0
getgenv().MacroLastStatusUpdate = 0

local cachedLabels = {}
getgenv().UpdateMacroStatus = function()
    local now = tick()
    if now - getgenv().MacroLastStatusUpdate < 0.033 then 
        return 
    end
    getgenv().MacroLastStatusUpdate = now
    
    pcall(function()
        if not cachedLabels.status then cachedLabels.status = getgenv().MacroStatusLabel end
        if not cachedLabels.step then cachedLabels.step = getgenv().MacroStepLabel end
        if not cachedLabels.action then cachedLabels.action = getgenv().MacroActionLabel end
        if not cachedLabels.unit then cachedLabels.unit = getgenv().MacroUnitLabel end
        if not cachedLabels.waiting then cachedLabels.waiting = getgenv().MacroWaitingLabel end
        
        if cachedLabels.status and cachedLabels.status.UpdateName then
            cachedLabels.status:UpdateName("Status: " .. (getgenv().MacroStatusText or "Idle"))
        end
        
        if cachedLabels.step and cachedLabels.step.UpdateName then
            cachedLabels.step:UpdateName("📝 Step: " .. (getgenv().MacroCurrentStep or 0) .. "/" .. (getgenv().MacroTotalSteps or 0))
        end
        
        if cachedLabels.action and cachedLabels.action.UpdateName then
            cachedLabels.action:UpdateName("⚡ Action: " .. (getgenv().MacroActionText ~= "" and getgenv().MacroActionText or "None"))
        end
        
        if cachedLabels.unit and cachedLabels.unit.UpdateName then
            cachedLabels.unit:UpdateName("🗼 Unit: " .. (getgenv().MacroUnitText ~= "" and getgenv().MacroUnitText or "None"))
        end
        
        if cachedLabels.waiting and cachedLabels.waiting.UpdateName then
            cachedLabels.waiting:UpdateName("⏳ Waiting: " .. (getgenv().MacroWaitingText ~= "" and getgenv().MacroWaitingText or "None"))
        end
    end)
end


getgenv().MacroCurrentCash = 0
getgenv().MacroLastCash = 0
getgenv().MacroCashHistory = {}
local MAX_CASH_HISTORY = 5

local cashConnection
pcall(function()
    if LocalPlayer:FindFirstChild("Cash") then
        getgenv().MacroCurrentCash = LocalPlayer.Cash.Value
        cashConnection = ConnectionManager:trackGroup("MacroSystem",
            LocalPlayer.Cash:GetPropertyChangedSignal("Value"):Connect(function()
                getgenv().MacroCurrentCash = LocalPlayer.Cash.Value
            end),
            "Macro Cash Tracking"
        )
    end
end)

local cashTrackingActive = false
local cashTrackingConnection
local function trackCash()
    if cashTrackingActive then return end
    cashTrackingActive = true
    
    pcall(function()
        if LocalPlayer:FindFirstChild("Cash") then
            getgenv().MacroLastCash = LocalPlayer.Cash.Value
            
            cashTrackingConnection = ConnectionManager:trackGroup("MacroSystem",
                LocalPlayer.Cash:GetPropertyChangedSignal("Value"):Connect(function()
                    local currentCash = tonumber(LocalPlayer.Cash.Value) or 0
                    local lastCash = tonumber(getgenv().MacroLastCash) or 0
                    
                    if lastCash > 0 and currentCash < lastCash then
                        local decrease = lastCash - currentCash
                        
                        if not getgenv().MacroCashHistory or type(getgenv().MacroCashHistory) ~= "table" then
                            getgenv().MacroCashHistory = {}
                        end
                        
                        table.insert(getgenv().MacroCashHistory, 1, {
                            time = tick(),
                            decrease = decrease,
                            before = lastCash,
                            after = currentCash
                        })
                        
                        if #getgenv().MacroCashHistory > MAX_CASH_HISTORY then
                            table.remove(getgenv().MacroCashHistory)
                        end
                    end
                    
                    getgenv().MacroLastCash = currentCash
                end),
                "Macro Cash History Tracking"
            )
        end
    end)
end

getgenv().GetRecentCashDecrease = function(withinSeconds)
    withinSeconds = withinSeconds or 1
    local now = tick()
    for _, entry in ipairs(getgenv().MacroCashHistory) do
        if (now - entry.time) <= withinSeconds then
            return entry.decrease
        end
    end
    return 0
end

trackCash()


local function isKilled()
    return getgenv().MacroSystemKillSwitch == true
end

getgenv().IsKilled = isKilled

getgenv().MacroTowerInfoCache = {}
getgenv().MacroRemoteCache = {}

local function cacheTowerInfo()
    if next(getgenv().MacroTowerInfoCache) then return end
    
    pcall(function()
        local modules = RS:FindFirstChild("Modules")
        if not modules then return end
        local towerInfoPath = modules:FindFirstChild("TowerInfo")
        if not towerInfoPath then return end
        for _, mod in pairs(towerInfoPath:GetChildren()) do
            if mod:IsA("ModuleScript") then
                local ok, data = pcall(function() 
                    return require(mod) 
                end)
                if ok then 
                    getgenv().MacroTowerInfoCache[mod.Name] = data 
                end
            end
        end
    end)
end


local ClientDataCache = {
    module = nil,
    lastUpdate = 0,
    cacheTimeout = 5
}

local function getClientData()
    local currentTime = tick()
    
    if ClientDataCache.module and (currentTime - ClientDataCache.lastUpdate) < ClientDataCache.cacheTimeout then
        return ClientDataCache.module
    end
    
    local ok, data = pcall(function()
        local modules = RS:FindFirstChild("Modules")
        if not modules then return nil end
        local modulePath = modules:FindFirstChild("ClientData")
        if modulePath and modulePath:IsA("ModuleScript") then
            return require(modulePath)
        end
        return nil
    end)
    
    if ok and data then
        ClientDataCache.module = data
        ClientDataCache.lastUpdate = currentTime
        return data
    end
    
    return ClientDataCache.module
end

getgenv().GetUnitEnchantDiscountSafe = function(unitName)
    local startTime = tick()
    local maxExecutionTime = 0.1
    
    local success, result = pcall(function()
        if (tick() - startTime) > maxExecutionTime then
            return 1.0, false, nil
        end
        
        local clientData = getClientData()
        
        if not clientData then
            return 1.0, false, nil
        end
        
        if not clientData.Slots or not clientData.UnitData then
            return 1.0, false, nil
        end
        
        for slotName, slotData in pairs(clientData.Slots) do
            if (tick() - startTime) > maxExecutionTime then
                return 1.0, false, nil
            end
            
            if slotData and slotData.Value == unitName and slotData.UnitID then
                local unitData = clientData.UnitData[slotData.UnitID]
                if unitData and unitData.Enchant then
                    local enchant = unitData.Enchant
                    if enchant == "Midas" or enchant == "Efficiency" then
                        getgenv()._DiagnosticsLogger_logDiscountCalculation(unitName, 0.8, enchant, true)
                        return 0.8, true, enchant
                    end
                end
                break
            end
        end
        
        getgenv()._DiagnosticsLogger_logDiscountCalculation(unitName, 1.0, nil, true)
        return 1.0, true, nil
    end)
    
    if not success then
        getgenv()._DiagnosticsLogger_logDiscountError(unitName, tostring(result))
        return 1.0, false
    end
    
    return result
end

local function getUnitEnchantDiscount(unitName)
    local multiplier, success = getgenv().GetUnitEnchantDiscountSafe(unitName)
    return multiplier
end

getgenv().CrashMonitor = getgenv().CrashMonitor or {
    isMonitoring = false,
    monitoringTask = nil,
    startTime = 0,
    memoryHistory = {},
    connectionHistory = {},
    checkInterval = 30,
    memoryThreshold = 100,
    maxHistorySize = 20
}

getgenv()._CrashMonitor_startMonitoring = function()
    local monitor = getgenv().CrashMonitor
    
    if monitor.isMonitoring then
        return
    end
    
    monitor.isMonitoring = true
    monitor.startTime = tick()
    
    if monitor.monitoringTask then
        pcall(function()
            task.cancel(monitor.monitoringTask)
        end)
    end
    
    monitor.monitoringTask = task.spawn(function()
        while monitor.isMonitoring do
            task.wait(monitor.checkInterval)
            
            pcall(function()
                local currentMemory = collectgarbage("count") / 1024
                local currentTime = tick()
                
                local connectionCount = 0
                pcall(function()
                    if getgenv()._GlobalConnections then
                        connectionCount = #getgenv()._GlobalConnections
                    end
                end)
                
                local memoryEntry = {
                    time = currentTime,
                    memory = currentMemory,
                    connections = connectionCount
                }
                
                table.insert(monitor.memoryHistory, memoryEntry)
                
                if #monitor.memoryHistory > monitor.maxHistorySize then
                    table.remove(monitor.memoryHistory, 1)
                end
                
                if #monitor.memoryHistory >= 2 then
                    local oldestEntry = monitor.memoryHistory[1]
                    local timeDiff = currentTime - oldestEntry.time
                    local memoryGrowth = currentMemory - oldestEntry.memory
                    
                    if timeDiff >= 60 and memoryGrowth > monitor.memoryThreshold then
                        warn(string.format("[CrashMonitor] Excessive memory growth detected: %.2f MB in %.1fs", 
                            memoryGrowth, timeDiff))
                        
                        getgenv()._DiagnosticsLogger_logCrashWarning("excessive_memory_growth", {
                            memoryGrowth = memoryGrowth,
                            timeDiff = timeDiff,
                            currentMemory = currentMemory,
                            connections = connectionCount
                        })
                        
                        if getgenv().DebugMode then
                            debugPrint(string.format("[CrashMonitor] Current: %.2f MB | Connections: %d", 
                                currentMemory, connectionCount))
                        end
                        
                        getgenv()._CrashMonitor_performCleanup()
                    end
                end
                
                if getgenv().DebugMode then
                    debugPrint(string.format("[CrashMonitor] Memory: %.2f MB | Connections: %d", 
                        currentMemory, connectionCount))
                end
            end)
        end
    end)
end

getgenv()._CrashMonitor_stopMonitoring = function()
    local monitor = getgenv().CrashMonitor
    
    if not monitor.isMonitoring then
        return
    end
    
    monitor.isMonitoring = false
    
    if monitor.monitoringTask then
        pcall(function()
            task.cancel(monitor.monitoringTask)
        end)
        monitor.monitoringTask = nil
    end
end

getgenv()._CrashMonitor_performCleanup = function()
    pcall(function()
        if ConnectionManager then
            ConnectionManager:cleanup()
        end
    end)
    
    pcall(function()
        if MemoryManager then
            MemoryManager:cleanup()
        end
    end)
    
    pcall(function()
        collectgarbage("collect")
    end)
    
    if getgenv().DebugMode then
        local newMemory = collectgarbage("count") / 1024
        debugPrint(string.format("[CrashMonitor] Cleanup complete. Memory: %.2f MB", newMemory))
    end
end

getgenv()._CrashMonitor_getStats = function()
    local monitor = getgenv().CrashMonitor
    
    local currentMemory = collectgarbage("count") / 1024
    local connectionCount = 0
    
    pcall(function()
        if getgenv()._GlobalConnections then
            connectionCount = #getgenv()._GlobalConnections
        end
    end)
    
    return {
        isMonitoring = monitor.isMonitoring,
        uptime = monitor.startTime > 0 and (tick() - monitor.startTime) or 0,
        currentMemory = currentMemory,
        connectionCount = connectionCount,
        historySize = #monitor.memoryHistory,
        checkInterval = monitor.checkInterval
    }
end

local function getEZATowerName(baseTowerName)
    local clientData = getClientData()
    if not clientData or not clientData.Slots then return baseTowerName end
    
    for slotName, slotData in pairs(clientData.Slots) do
        if slotData and slotData.Value == baseTowerName and slotData.UnitID then
            if clientData.UnitData and clientData.UnitData[slotData.UnitID] then
                if clientData.UnitData[slotData.UnitID].EZA == true then
                    return baseTowerName .. "EZA"
                end
            elseif clientData[slotData.UnitID] then
                if clientData[slotData.UnitID].EZA == true then
                    return baseTowerName .. "EZA"
                end
            end
        end
    end
    
    return baseTowerName
end

getgenv().GetPlaceCost = function(towerName)
    if not getgenv().MacroTowerInfoCache then
        return 0
    end
    
    local towerNameToCheck = getEZATowerName(towerName)
    
    if not getgenv().MacroTowerInfoCache[towerNameToCheck] then 
        return 0 
    end
    
    if getgenv().MacroTowerInfoCache[towerNameToCheck][0] then
        return getgenv().MacroTowerInfoCache[towerNameToCheck][0].Cost or 0
    end
    
    return 0
end

getgenv().GetUpgradeCost = function(towerName, currentLevel)
    if not getgenv().MacroTowerInfoCache then
        return 0
    end
    
    local towerNameToCheck = getEZATowerName(towerName)
    
    if not getgenv().MacroTowerInfoCache[towerNameToCheck] then 
        return 0 
    end
    
    local nextLevel = (currentLevel or 0) + 1
    if getgenv().MacroTowerInfoCache[towerNameToCheck][nextLevel] then
        return getgenv().MacroTowerInfoCache[towerNameToCheck][nextLevel].Cost or 0
    end
    
    return 0
end

local function getTowerInfo(unitName)
    local ok, data = pcall(function()
        local modules = RS:FindFirstChild("Modules")
        if not modules then return nil end
        local towerInfoPath = modules:FindFirstChild("TowerInfo")
        if not towerInfoPath then return nil end
        local towerModule = towerInfoPath:FindFirstChild(unitName)
        if towerModule and towerModule:IsA("ModuleScript") then
            return require(towerModule)
        end
        return nil
    end)
    return ok and data or nil
end

local function getAllAbilities(unitName)
    if not unitName or unitName == "" then return {} end
    local towerInfo = getTowerInfo(unitName)
    if not towerInfo then return {} end
    local abilities = {}
    local seenAbilities = {}
    
    for level = 0, 50 do
        if towerInfo[level] then
            if towerInfo[level].Ability then
                local a = towerInfo[level].Ability
                local nm = a.Name
                
                if not seenAbilities[nm] then
                    seenAbilities[nm] = true
                    
                    local hasRealAttribute = false
                    if a.AttributeRequired and type(a.AttributeRequired) == "table" then
                        if a.AttributeRequired.Name ~= "JUST_TO_DISPLAY_IN_LOBBY" then
                            hasRealAttribute = true
                        end
                    elseif a.AttributeRequired and type(a.AttributeRequired) ~= "table" then
                        hasRealAttribute = true
                    end
                    abilities[nm] = {
                        name = nm,
                        cooldown = a.Cd,
                        requiredLevel = level,
                        isGlobal = a.IsCdGlobal or false,
                        isAttribute = hasRealAttribute
                    }
                end
            end
            
            if towerInfo[level].Abilities then
                for idx, a in pairs(towerInfo[level].Abilities) do
                    local nm = a.Name
                    
                    if not seenAbilities[nm] then
                        seenAbilities[nm] = true
                        
                        local hasRealAttribute = false
                        if a.AttributeRequired and type(a.AttributeRequired) == "table" then
                            if a.AttributeRequired.Name ~= "JUST_TO_DISPLAY_IN_LOBBY" then
                                hasRealAttribute = true
                            end
                        elseif a.AttributeRequired and type(a.AttributeRequired) ~= "table" then
                            hasRealAttribute = true
                        end
                        abilities[nm] = {
                            name = nm,
                            cooldown = a.Cd,
                            requiredLevel = level,
                            isGlobal = a.IsCdGlobal or false,
                            isAttribute = hasRealAttribute
                        }
                    end
                end
            end
        end
    end
    
    return abilities
end

getgenv().AutoAbilitiesEnabled = getgenv().Config.toggles.AutoAbilityToggle or false
getgenv().UnitAbilities = getgenv().UnitAbilities or {}
getgenv().EZAUnitMapping = getgenv().EZAUnitMapping or {}

getgenv().AutoReadyEnabled = getgenv().Config.toggles.AutoReady or false
getgenv().AutoNextEnabled = getgenv().Config.toggles.AutoNext or false
getgenv().AutoLeaveEnabled = getgenv().Config.toggles.AutoLeave or false
getgenv().AutoEnchantEnabled = false
getgenv().AutoEnchantUnit = getgenv().Config.inputs.AutoEnchantUnit or ""
getgenv().AutoEnchantMaterial = getgenv().Config.inputs.AutoEnchantMaterial or "Pearl"
getgenv().AutoEnchantDesiredEnchants = getgenv().Config.inputs.AutoEnchantDesiredEnchants or {}
getgenv().AutoFastRetryEnabled = getgenv().Config.toggles.AutoRetry or false
getgenv().AutoSmartEnabled = getgenv().Config.toggles.AutoSmart or false

getgenv().AutoEventEnabled = getgenv().Config.toggles.AutoEventToggle or false
getgenv().BingoEnabled = getgenv().Config.toggles.BingoToggle or false
getgenv().CapsuleEnabled = getgenv().Config.toggles.CapsuleToggle or false

getgenv().AutoEvent2Enabled = getgenv().Config.toggles.AutoEvent2Toggle or false
getgenv().AutoCandyEnabled = getgenv().Config.toggles.AutoCandyToggle or false
getgenv().Capsule2Enabled = getgenv().Config.toggles.Capsule2Toggle or false

getgenv().RemoveEnemiesEnabled = getgenv().Config.toggles.RemoveEnemiesToggle or false
getgenv().AntiAFKEnabled = getgenv().Config.toggles.AntiAFKToggle or false
getgenv().BlackScreenEnabled = getgenv().Config.toggles.BlackScreenToggle or false
getgenv().FPSBoostEnabled = getgenv().Config.toggles.FPSBoostToggle or false

getgenv().BossRushEnabled = getgenv().Config.toggles.BossRushToggle or false

getgenv().SeamlessFixEnabled = getgenv().Config.toggles.SeamlessFixToggle or false
getgenv().SeamlessRounds = tonumber(getgenv().Config.inputs.SeamlessRounds) or 4
getgenv().AutoExecuteTeleportEnabled = getgenv().Config.toggles.AutoExecuteTeleport or false
getgenv().AutoExecuteEnabled = getgenv().Config.toggles.AutoExecuteToggle or false

local queueteleport = queue_on_teleport or queueonteleport or (syn and syn.queue_on_teleport) or (fluxus and fluxus.queue_on_teleport) or (Xeno and Xeno.queue_on_teleport)

if queueteleport then
    local scriptToQueue = 'repeat task.wait() until game:IsLoaded() and game.Players.LocalPlayer; task.wait(2); loadstring(game:HttpGet("https://raw.githubusercontent.com/Byorl/ALS-Scripts/refs/heads/main/ALS%20Halloween%20UI.lua"))()'
    
    LocalPlayer.OnTeleport:Connect(function(State)
        if getgenv().AutoExecuteEnabled then
            pcall(function()
                queueteleport(scriptToQueue)
                print("[ALS] ✅ Auto Execute queued via OnTeleport")
            end)
        end
    end)
    
    task.spawn(function()
        while true do
            task.wait(5)
            if getgenv().AutoExecuteEnabled then
                pcall(function()
                    queueteleport(scriptToQueue)
                end)
            end
        end
    end)
    
    if getgenv().AutoExecuteEnabled then
        print("[ALS] ✅ Auto Execute active (will re-queue every 5s)")
    end
else
    if getgenv().AutoExecuteEnabled then
        warn("[ALS] ⚠️ Auto Execute enabled but queue_on_teleport not supported by your executor")
    end
end

if getgenv().SeamlessFixEnabled then
    task.spawn(function()
        task.wait(2)
        task.spawn(function()
            pcall(function()
                local remotes = RS:FindFirstChild("Remotes")
                local setSettings = remotes and remotes:FindFirstChild("SetSettings")
                if setSettings then 
                    setSettings:InvokeServer("SeamlessRetry")
                end
            end)
        end)
    end)
end

getgenv().WebhookEnabled = getgenv().Config.toggles.WebhookToggle or false
getgenv().WebhookProcessing = false
getgenv().WebhookIncludePlayerCount = getgenv().Config.toggles.WebhookIncludePlayerCount or false
getgenv().WebhookIncludePlayerNames = getgenv().Config.toggles.WebhookIncludePlayerNames or false

getgenv().GetClientData = getClientData
getgenv().GetTowerInfo = getTowerInfo
getgenv().GetAllAbilities = getAllAbilities

local function cacheRemotes()
    if next(getgenv().MacroRemoteCache) then return true end
    
    pcall(function()
        for _, v in pairs(RS:GetDescendants()) do
            if v:IsA("RemoteEvent") or v:IsA("RemoteFunction") then
                getgenv().MacroRemoteCache[v.Name:lower()] = v
            end
        end
    end)
    
    local count = 0
    for _ in pairs(getgenv().MacroRemoteCache) do 
        count = count + 1 
    end
    
    return count > 0
end

local function ensureCachesReady()
    cacheTowerInfo()
    
    local attempts = 0
    while not cacheRemotes() and attempts < 10 do
        task.wait(0.5)
        attempts = attempts + 1
    end
    
    if attempts >= 10 then
        warn("[Macro] Warning: Remote cache may be incomplete")
    end
end

getgenv().CacheTowerInfo = cacheTowerInfo
getgenv().CacheRemotes = cacheRemotes
getgenv().EnsureCachesReady = ensureCachesReady

getgenv().AbilityRecordingEnabled = true

getgenv()._cacheAbilityRemotes = function()
    local success, err = pcall(function()
        local remotes = RS:WaitForChild("Remotes", 10)
        if not remotes then
            warn("[Macro] Error: ReplicatedStorage.Remotes not found - ability recording disabled")
            getgenv().AbilityRecordingEnabled = false
            return
        end
        
        local abilityRemote = remotes:WaitForChild("Ability", 5)
        if abilityRemote and abilityRemote:IsA("RemoteFunction") then
            getgenv().MacroRemoteCache["ability"] = abilityRemote
            debugPrint("[Macro] Ability remote cached successfully")
        else
            warn("[Macro] Error: Ability remote not found or wrong type - ability recording disabled")
            getgenv().AbilityRecordingEnabled = false
        end
        
        local abilitySelectionRemote = remotes:WaitForChild("AbilitySelection", 5)
        if abilitySelectionRemote and abilitySelectionRemote:IsA("RemoteEvent") then
            getgenv().MacroRemoteCache["abilityselection"] = abilitySelectionRemote
            debugPrint("[Macro] AbilitySelection remote cached successfully")
        else
            warn("[Macro] Error: AbilitySelection remote not found or wrong type - card selection recording disabled")
        end
    end)
    
    if not success then
        warn("[Macro] Error caching ability remotes: " .. tostring(err))
        getgenv().AbilityRecordingEnabled = false
    end
end

task.spawn(function()
    task.wait(3)
    ensureCachesReady()
    getgenv()._cacheAbilityRemotes()
end)


getgenv().MacroGameState = {
    currentWave = 0,
    isInGame = false,
    hasStartButton = false,
    hasEndGameUI = false,
    gameEnded = false,
    lastWaveChange = 0,
    matchStartTime = 0,
    lastGameEndedState = false,
    lastEndGameUIState = false,
    seamlessTransition = false,
    towerCount = 0,
    lastTowerCount = 0
}

local function updateGameState()
    pcall(function()
        local restartDetected = false
        local restartMethod = ""
        
        local wave = RS:FindFirstChild("Wave")
        if wave and wave.Value then
            local newWave = wave.Value
            if newWave ~= getgenv().MacroGameState.currentWave then
                getgenv().MacroGameState.lastWaveChange = tick()
                
                if getgenv().MacroGameState.currentWave > 10 and newWave <= 5 then
                    restartDetected = true
                    restartMethod = "Wave Reset"
                end
                
                getgenv().MacroGameState.currentWave = newWave
            end
        end
        
        local towerCount = 0
        if workspace:FindFirstChild("Towers") then
            for _, tower in pairs(workspace.Towers:GetChildren()) do
                local owner = tower:FindFirstChild("Owner")
                if owner and owner.Value == LocalPlayer then
                    towerCount = towerCount + 1
                end
            end
        end
        
        if getgenv().MacroGameState.lastTowerCount > 0 and towerCount == 0 and not getgenv().MacroGameState.hasStartButton then
            if not restartDetected then
                restartDetected = true
                restartMethod = "Tower Reset"
            end
        end
        
        getgenv().MacroGameState.lastTowerCount = towerCount
        getgenv().MacroGameState.towerCount = towerCount
        
        local hasStart = false
        pcall(function()
            local bottom = LocalPlayer.PlayerGui:FindFirstChild("Bottom")
            if bottom and bottom:FindFirstChild("Frame") then
                for _, child in ipairs(bottom.Frame:GetChildren()) do
                    if child:IsA("Frame") then
                        for _, subChild in ipairs(child:GetChildren()) do
                            if subChild:IsA("TextButton") and subChild.Visible then
                                for _, element in ipairs(subChild:GetChildren()) do
                                    if element:IsA("TextLabel") and element.Text == "Start" then
                                        hasStart = true
                                        return
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end)
        getgenv().MacroGameState.hasStartButton = hasStart
        
        local endGameUI = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
        local currentEndGameUIState = endGameUI and endGameUI.Enabled or false
        
        if getgenv().MacroGameState.lastEndGameUIState and not currentEndGameUIState then
            if not restartDetected then
                restartDetected = true
                restartMethod = "EndGameUI Removed"
            end
            getgenv().MacroGameState.gameEnded = false
            getgenv().MacroGameState.hasEndGameUI = false
        end
        
        getgenv().MacroGameState.hasEndGameUI = currentEndGameUIState
        getgenv().MacroGameState.lastEndGameUIState = currentEndGameUIState
        
        local gameEndedValue = RS:FindFirstChild("GameEnded")
        local currentGameEnded = gameEndedValue and gameEndedValue.Value or false
        
        if currentGameEnded and not getgenv().MacroGameState.lastGameEndedState then
            getgenv().MacroGameState.gameEnded = true
            getgenv().MacroGameState.seamlessTransition = false
            
            getgenv().BulmaWishUsedThisRound = false
            getgenv().WukongTrackedClones = {}
            getgenv()._WukongLastSynthesisTime = 0
            getgenv().SkeletonKnightLastUse = 0
            getgenv().AlucardHypnosisLastUse = 0
            getgenv().SmartCardPicked = {}
            getgenv().SmartCardLastPromptId = nil
            getgenv().SlowerCardPicked = {}
            getgenv().SlowerCardLastPromptId = nil
            getgenv().OneEyeDevilCurrentIndex = 0  
            
            pcall(function()
                MemoryManager:cleanup()
            end)
            
            if getgenv()._EtoEvoAbilityUsed then
                getgenv()._EtoEvoAbilityUsed = {}
            end
            
            if getgenv().FinalExpChestRewards then
                getgenv().FinalExpChestRewards = nil
            end
            
            pcall(function()
                for i = 1, 3 do
                    safeGarbageCollect()
                    task.wait(0.1)
                end
            end)
            
        end
        
        if not currentGameEnded and getgenv().MacroGameState.lastGameEndedState then
            if not restartDetected then
                restartDetected = true
                restartMethod = "GameEnded Reset"
            end
        end
        
        if restartDetected then
            getgenv().MacroGameState.seamlessTransition = true
            getgenv().MacroGameState.matchStartTime = tick()
            getgenv().MacroGameState.gameEnded = false
        end
        
        getgenv().MacroGameState.lastGameEndedState = currentGameEnded
        getgenv().MacroGameState.isInGame = not getgenv().MacroGameState.hasStartButton and not getgenv().MacroGameState.hasEndGameUI and not currentGameEnded
        
        if getgenv().MacroGameState.seamlessTransition and getgenv().MacroGameState.isInGame then
            task.delay(2, function()
                getgenv().MacroGameState.seamlessTransition = false
            end)
        end
    end)
end

task.spawn(function()
    local baseInterval = getgenv().IsMacPlatform and 2 or 1
    local updateInterval = MobileOptimizer:getPollingInterval(baseInterval)
    ErrorHandler:log("DEBUG", string.format("Game state update interval: %.1fs", updateInterval))
    
    while true do
        task.wait(updateInterval) 
        updateGameState()
    end
end)

getgenv().MacroRecordingV2 = false
getgenv().MacroDataV2 = {}
getgenv().MacroRecordingStartTime = 0

getgenv()._GetEZADisplayName = function(actualTowerName)
    if getgenv().EZAUnitMapping then
        for ezaName, actualName in pairs(getgenv().EZAUnitMapping) do
            if actualName == actualTowerName then
                return ezaName
            end
        end
    end
    
    local clientData = getgenv().GetClientData and getgenv().GetClientData()
    if clientData and clientData.Slots then
        for _, slotName in ipairs({"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}) do
            local slotData = clientData.Slots[slotName]
            if slotData and slotData.Value == actualTowerName and slotData.UnitID then
                local unitData = (clientData.UnitData and clientData.UnitData[slotData.UnitID]) or clientData[slotData.UnitID]
                if unitData and unitData.EZA == true then
                    return actualTowerName .. "EZA"
                end
            end
        end
    end
    
    return actualTowerName
end

getgenv()._GetActualTowerName = function(displayName)
    if getgenv().EZAUnitMapping and getgenv().EZAUnitMapping[displayName] then
        return getgenv().EZAUnitMapping[displayName]
    end
    
    if displayName:match("EZA$") then
        local actualName = displayName:gsub("EZA$", "")
        return actualName
    end
    
    return displayName
end

local towerTracker = {
    placeCounts = {},
    upgradeLevels = {},
    lastPlaceTime = {},
    lastUpgradeTime = {},
    pendingActions = {},
    upgradeConnections = {}
}

getgenv()._TowerTrackerPendingActions = towerTracker.pendingActions
getgenv()._TowerUpgradeConnections = towerTracker.upgradeConnections

local function cleanupTowerTracker()
    if towerTracker.upgradeConnections then
        for tower, conn in pairs(towerTracker.upgradeConnections) do
            pcall(function() conn:Disconnect() end)
        end
    end
    towerTracker.placeCounts = {}
    towerTracker.upgradeLevels = {}
    towerTracker.lastPlaceTime = {}
    towerTracker.lastUpgradeTime = {}
    towerTracker.pendingActions = {}
    towerTracker.upgradeConnections = {}
    
    getgenv()._TowerTrackerPendingActions = towerTracker.pendingActions
    getgenv()._TowerUpgradeConnections = towerTracker.upgradeConnections
end

local function setupTowerUpgradeListener(tower)
    
    if not tower or not tower.Parent or not tower:FindFirstChild("Upgrade") or towerTracker.upgradeConnections[tower] then 
        return 
    end
    
    local currentLevel = tower.Upgrade.Value
    towerTracker.upgradeLevels[tower] = currentLevel
    
    local connection = tower.Upgrade:GetPropertyChangedSignal("Value"):Connect(function()
        if not getgenv().MacroRecordingV2 then return end
        
        local success, err = pcall(function()
            if not tower or not tower.Parent or not tower:FindFirstChild("Upgrade") then return end
            
            local towerName = tower.Name
            local currentLevel = tower.Upgrade.Value
            local now = tick()
            
            if towerName == "NarutoBaryonClone" or towerName == "WukongClone" then return end
            
            local oldLevel = towerTracker.upgradeLevels[tower] or 0
            if currentLevel <= oldLevel then return end
            
            local levelsGained = currentLevel - oldLevel
            
            towerTracker.upgradeLevels[tower] = currentLevel
            towerTracker.lastUpgradeTime[tower] = now
            
            local displayName = getgenv()._GetEZADisplayName(towerName)
            
            for i = 1, levelsGained do
                local upgradeLevel = oldLevel + i - 1
                local cost = 0
                
                if getgenv().GetRecentCashDecrease then
                    cost = getgenv().GetRecentCashDecrease(0.3)
                end
                
                if cost == 0 and getgenv().GetUpgradeCost then
                    cost = getgenv().GetUpgradeCost(towerName, upgradeLevel)
                end
                
                if #getgenv().MacroDataV2 >= 5000 then
                    warn("[Macro] Recording limit reached (5000 steps). Stopping recording.")
                    getgenv().MacroRecordingV2 = false
                    return
                end
                
                table.insert(getgenv().MacroDataV2, {
                    RemoteName = "Upgrade",
                    Args = {},
                    Time = now - getgenv().MacroRecordingStartTime,
                    IsInvoke = true,
                    Cost = cost,
                    TowerName = displayName,
                    ActionType = "Upgrade",
                    Wave = getgenv().MacroGameState.currentWave
                })
            end
            
            getgenv().MacroStatusText = "Recording"
            getgenv().MacroCurrentStep = #getgenv().MacroDataV2
            getgenv().MacroTotalSteps = #getgenv().MacroDataV2
            getgenv().MacroActionText = "Upgrade"
            getgenv().MacroUnitText = displayName
            
            if getgenv().UpdateMacroStatus then
                getgenv().UpdateMacroStatus()
            end

        end)
        
        if not success then
            warn("[Macro Debug] Error in upgrade listener:", err)
        end
    end)
    
    towerTracker.upgradeConnections[tower] = connection
    
    local ancestryConnection
    ancestryConnection = tower.AncestryChanged:Connect(function()
        if not tower:IsDescendantOf(game) then
            if towerTracker.upgradeConnections[tower] then
                towerTracker.upgradeConnections[tower]:Disconnect()
                towerTracker.upgradeConnections[tower] = nil
            end
            if towerTracker.upgradeLevels[tower] then
                towerTracker.upgradeLevels[tower] = nil
            end
            if towerTracker.lastUpgradeTime[tower] then
                towerTracker.lastUpgradeTime[tower] = nil
            end
            if ancestryConnection then
                ancestryConnection:Disconnect()
                ancestryConnection = nil
            end
        end
    end)
    
    trackConnection(ancestryConnection)
end

task.spawn(function()
    local maxWait = 0
    while not workspace:FindFirstChild("Towers") and maxWait < 30 do
        task.wait(0.5)
        maxWait = maxWait + 0.5
    end
    
    if not workspace:FindFirstChild("Towers") then
        return
    end
    
    trackConnection(workspace.Towers.ChildAdded:Connect(function(tower)
        task.spawn(function()
            for attempt = 1, 10 do
                task.wait(0.1)
                local owner = tower:FindFirstChild("Owner")
                if owner and owner.Value == LocalPlayer then
                    setupTowerUpgradeListener(tower)
                    return
                end
                if owner then return end
            end
        end)
    end))
    
    task.wait(0.5)
    for _, tower in pairs(workspace.Towers:GetChildren()) do
        local owner = tower:FindFirstChild("Owner")
        if owner and owner.Value == LocalPlayer then
            setupTowerUpgradeListener(tower)
        end
    end
end)

local originalNamecall
local namecallHook

getgenv().recordAbilityUsage = function(tower, abilityName)
    local success, err = pcall(function()
        if not getgenv().MacroRecordingV2 then return end
        
        local now = tick()
        local towerName = tower.Name
        if getgenv().MacroRecordAbilities == false then
            return
        end
        
        local elapsedTime = now - getgenv().MacroRecordingStartTime
        local currentWave = getgenv().MacroGameState.currentWave
        
        if #getgenv().MacroDataV2 >= 5000 then
            warn("[Macro] Recording limit reached (5000 steps). Stopping recording.")
            getgenv().MacroRecordingV2 = false
            return
        end
        
        table.insert(getgenv().MacroDataV2, {
            RemoteName = "Ability",
            Args = {nil, abilityName},
            Time = elapsedTime,
            IsInvoke = true,
            Cost = 0,
            TowerName = towerName,
            ActionType = "Ability",
            Wave = currentWave,
            AbilityName = abilityName
        })
        
        getgenv().MacroStatusText = "Recording"
        getgenv().MacroCurrentStep = #getgenv().MacroDataV2
        getgenv().MacroTotalSteps = #getgenv().MacroDataV2
        getgenv().MacroActionText = "Ability"
        getgenv().MacroUnitText = towerName
        
        if getgenv().UpdateMacroStatus then
            getgenv().UpdateMacroStatus()
        end
    end)
    
    if not success then
        warn("[Macro] Error recording ability usage - Tower: " .. tostring(tower and tower.Name or "unknown") .. ", Ability: " .. tostring(abilityName) .. " - " .. tostring(err))
    end
end

getgenv().recordCardSelection = function(numericArg, cardName)
    local success, err = pcall(function()
        if not getgenv().MacroRecordingV2 then return end
        
        local now = tick()
        local elapsedTime = now - getgenv().MacroRecordingStartTime
        local currentWave = getgenv().MacroGameState.currentWave
        
        local cardNameNoSpaces = cardName:gsub(" ", "")
        
        if #getgenv().MacroDataV2 >= 5000 then
            warn("[Macro] Recording limit reached (5000 steps). Stopping recording.")
            getgenv().MacroRecordingV2 = false
            return
        end
        
        table.insert(getgenv().MacroDataV2, {
            RemoteName = "AbilitySelection",
            Args = {numericArg, cardNameNoSpaces},
            Time = elapsedTime,
            IsInvoke = false,
            Cost = 0,
            CardName = cardNameNoSpaces,
            ActionType = "AbilitySelection",
            Wave = currentWave
        })
        
        getgenv().MacroStatusText = "Recording"
        getgenv().MacroCurrentStep = #getgenv().MacroDataV2
        getgenv().MacroTotalSteps = #getgenv().MacroDataV2
        getgenv().MacroActionText = "Card Selection"
        getgenv().MacroUnitText = cardNameNoSpaces
        
        if getgenv().UpdateMacroStatus then
            getgenv().UpdateMacroStatus()
        end
    end)
    
    if not success then
        warn("[Macro] Error recording card selection - Arg: " .. tostring(numericArg) .. ", Card: " .. tostring(cardName) .. " - " .. tostring(err))
    end
end

local function processRemoteCall(remoteName, method, args)
    local now = tick()
    local remoteNameLower = remoteName:lower()
    
    if remoteNameLower:find("place") or remoteNameLower:find("tower") then
        if args[1] and type(args[1]) == "string" then
            local towerName = args[1]
            
            if towerTracker.lastPlaceTime[towerName] and (now - towerTracker.lastPlaceTime[towerName]) < 0.5 then
                return
            end
            
            towerTracker.lastPlaceTime[towerName] = now
            task.wait(0.7)
            
            local countBefore = towerTracker.placeCounts[towerName] or 0
            local countAfter = 0
            
            for _, tower in pairs(workspace.Towers:GetChildren()) do
                local owner = tower:FindFirstChild("Owner")
                if tower.Name == towerName and owner and owner.Value == LocalPlayer then
                    countAfter = countAfter + 1
                end
            end
            
            if countAfter > countBefore then
                local cost = 0
                
                if getgenv().GetPlaceCost then
                    cost = getgenv().GetPlaceCost(towerName)
                end
                
                if cost == 0 and getgenv().GetRecentCashDecrease then
                    cost = getgenv().GetRecentCashDecrease(0.3)
                end
                
                local savedArgs = {args[1]}
                if args[2] and typeof(args[2]) == "CFrame" then
                    savedArgs[2] = {args[2]:GetComponents()}
                end
                
                if #getgenv().MacroDataV2 >= 5000 then
                    warn("[Macro] Recording limit reached (5000 steps). Stopping recording.")
                    getgenv().MacroRecordingV2 = false
                    return
                end
                
                if #getgenv().MacroDataV2 >= 5000 then
                    warn("[Macro] Recording limit reached (5000 steps). Stopping recording.")
                    getgenv().MacroRecordingV2 = false
                    return
                end
                
                table.insert(getgenv().MacroDataV2, {
                    RemoteName = remoteName,
                    Args = savedArgs,
                    Time = now - getgenv().MacroRecordingStartTime,
                    IsInvoke = (method == "InvokeServer"),
                    Cost = cost,
                    TowerName = towerName,
                    ActionType = "Place",
                    Wave = getgenv().MacroGameState.currentWave
                })
                
                towerTracker.placeCounts[towerName] = countAfter
                
                getgenv().MacroStatusText = "Recording"
                getgenv().MacroCurrentStep = #getgenv().MacroDataV2
                getgenv().MacroTotalSteps = #getgenv().MacroDataV2
                getgenv().MacroActionText = "Place"
                getgenv().MacroUnitText = towerName
                
                if getgenv().UpdateMacroStatus then
                    getgenv().UpdateMacroStatus()
                end
                
            end
        end
    end
    
    if remoteNameLower:find("upgrade") then
        if args[1] and typeof(args[1]) == "Instance" then
            local tower = args[1]
            local towerName = tower.Name
            
            if towerName ~= "NarutoBaryonClone" and towerName ~= "WukongClone" then
                local upgradeKey = tower .. "_" .. now
                if not towerTracker.pendingActions[upgradeKey] then
                    towerTracker.pendingActions[upgradeKey] = now
                    
                    task.spawn(function()
                        if towerTracker.pendingActions[upgradeKey] then
                            local currentLevel = 0
                            pcall(function()
                                if tower and tower:FindFirstChild("Upgrade") then
                                    currentLevel = tower.Upgrade.Value
                                end
                            end)
                            
                            local cost = 0
                            
                            if getgenv().GetUpgradeCost then
                                cost = getgenv().GetUpgradeCost(towerName, currentLevel)
                            end
                            
                            if cost == 0 and getgenv().GetRecentCashDecrease then
                                cost = getgenv().GetRecentCashDecrease(0.3)
                            end
                            
                            if #getgenv().MacroDataV2 >= 5000 then
                                warn("[Macro] Recording limit reached (5000 steps). Stopping recording.")
                                getgenv().MacroRecordingV2 = false
                                return
                            end
                            
                            table.insert(getgenv().MacroDataV2, {
                                RemoteName = "Upgrade",
                                Args = {nil},
                                Time = now - getgenv().MacroRecordingStartTime,
                                IsInvoke = (method == "InvokeServer"),
                                Cost = cost,
                                TowerName = towerName,
                                ActionType = "Upgrade",
                                Wave = getgenv().MacroGameState.currentWave
                            })
                            
                            getgenv().MacroStatusText = "Recording"
                            getgenv().MacroCurrentStep = #getgenv().MacroDataV2
                            getgenv().MacroTotalSteps = #getgenv().MacroDataV2
                            getgenv().MacroActionText = "Upgrade"
                            getgenv().MacroUnitText = towerName
                            
                            if getgenv().UpdateMacroStatus then
                                getgenv().UpdateMacroStatus()
                            end
                            
                        end
                        
                        towerTracker.pendingActions[upgradeKey] = nil
                    end)
                end
            end
        end
    end
    
    if remoteNameLower:find("sell") then
        if args[1] and typeof(args[1]) == "Instance" then
            local tower = args[1]
            local towerName = tower.Name
            
            if #getgenv().MacroDataV2 >= 5000 then
                warn("[Macro] Recording limit reached (5000 steps). Stopping recording.")
                getgenv().MacroRecordingV2 = false
                return
            end
            
            table.insert(getgenv().MacroDataV2, {
                RemoteName = remoteName,
                Args = {nil},
                Time = now - getgenv().MacroRecordingStartTime,
                IsInvoke = (method == "InvokeServer"),
                Cost = 0,
                TowerName = towerName,
                ActionType = "Sell",
                Wave = getgenv().MacroGameState.currentWave
            })
            
            if towerTracker.placeCounts[towerName] then
                towerTracker.placeCounts[towerName] = math.max(0, towerTracker.placeCounts[towerName] - 1)
            end
            
            getgenv().MacroStatusText = "Recording"
            getgenv().MacroCurrentStep = #getgenv().MacroDataV2
            getgenv().MacroTotalSteps = #getgenv().MacroDataV2
            getgenv().MacroActionText = "Sell"
            getgenv().MacroUnitText = towerName
            getgenv().UpdateMacroStatus()
        end
    end
    
    if remoteName == "Ability" and method == "InvokeServer" then
        if args[1] and typeof(args[1]) == "Instance" and args[2] and type(args[2]) == "string" then
            local tower = args[1]
            local abilityName = args[2]
            
            if getgenv().recordAbilityUsage then
                getgenv().recordAbilityUsage(tower, abilityName)
            end
            
            if getgenv().DebugMode then
                print(string.format("[Macro Debug] Ability: %s used %s", tower.Name, abilityName))
            end
        end
    end
    
    if remoteName == "AbilitySelection" and method == "FireServer" then
        if args[1] and type(args[1]) == "number" and args[2] and type(args[2]) == "string" then
            local numericArg = args[1]
            local cardName = args[2]
            
            if getgenv().recordCardSelection then
                getgenv().recordCardSelection(numericArg, cardName)
            end
            
            if getgenv().DebugMode then
                print(string.format("[Macro Debug] Card Selection: %d -> %s", numericArg, cardName))
            end
        end
    end
end

local function setupRecordingHook()
    if namecallHook then return end
    
    if not getrawmetatable or not getnamecallmethod or not setreadonly or not newcclosure then
        warn("[Macro] Executor missing required functions for recording hook (getrawmetatable, getnamecallmethod, setreadonly, or newcclosure)")
        return
    end
    
    local mt = getrawmetatable(game)
    local oldNamecall = mt.__namecall
    setreadonly(mt, false)
    
    local lastRecordedCall = {}
    local DEBOUNCE_TIME = 0.1
    
    mt.__namecall = newcclosure(function(self, ...)
        local method = getnamecallmethod()
        
        local result = {oldNamecall(self, ...)}
        
        local shouldRecord = getgenv().MacroRecordingV2 and 
                            not getgenv()._SkipRecordingNextCall and 
                            (method == "InvokeServer" or method == "FireServer") and
                            not GameStateDetector:isLobby()
        
        if shouldRecord then
            local args = {...}
            task.spawn(function()
                pcall(function()
                    if typeof(self) == "Instance" and (self:IsA("RemoteEvent") or self:IsA("RemoteFunction")) then
                        local remoteName = self.Name
                        local callKey = remoteName .. "_" .. method .. "_" .. tostring(args[1])
                        local now = tick()
                        
                        if lastRecordedCall[callKey] and (now - lastRecordedCall[callKey]) < DEBOUNCE_TIME then
                            return
                        end
                        
                        lastRecordedCall[callKey] = now
                        processRemoteCall(remoteName, method, args)
                    end
                end)
            end)
        end
        
        return table.unpack(result)
    end)
    
    setreadonly(mt, true)
    originalNamecall = oldNamecall
    namecallHook = true
    
    task.spawn(function()
        local lastTowerCount = {}
        local baseInterval = getgenv().IsMacPlatform and 1 or 0.5
        local checkInterval = MobileOptimizer:getPollingInterval(baseInterval)
        ErrorHandler:log("DEBUG", string.format("Tower tracking interval: %.1fs", checkInterval))
        
        while true do
            task.wait(checkInterval) 
            
            if not getgenv().MacroRecordingV2 then
                task.wait(1) 
                continue
            end
            
            pcall(function()
                local currentCounts = {}
                
                for _, tower in pairs(workspace.Towers:GetChildren()) do
                    local owner = tower:FindFirstChild("Owner")
                    if owner and owner.Value == LocalPlayer then
                        local towerName = tower.Name
                        currentCounts[towerName] = (currentCounts[towerName] or 0) + 1
                    end
                end
                
                for towerName, count in pairs(currentCounts) do
                    local lastCount = lastTowerCount[towerName] or 0
                    
                    if count > lastCount then
                        local now = tick()
                        
                        local newestTower = nil
                        for _, tower in pairs(workspace.Towers:GetChildren()) do
                            local owner = tower:FindFirstChild("Owner")
                            if tower.Name == towerName and owner and owner.Value == LocalPlayer then
                                local upgrade = tower:FindFirstChild("Upgrade")
                                if not newestTower or (upgrade and upgrade.Value == 0) then
                                    newestTower = tower
                                end
                            end
                        end
                        
                        if newestTower then
                            local cost = 0
                            
                            if getgenv().GetPlaceCost then
                                cost = getgenv().GetPlaceCost(towerName)
                            end
                            
                            if cost == 0 and getgenv().GetRecentCashDecrease then
                                cost = getgenv().GetRecentCashDecrease(0.3)
                            end
                            
                            if #getgenv().MacroDataV2 >= 5000 then
                                warn("[Macro] Recording limit reached (5000 steps). Stopping recording.")
                                getgenv().MacroRecordingV2 = false
                                return
                            end
                            
                            local displayName = getgenv()._GetEZADisplayName(towerName)
                            
                            if displayName ~= towerName then
                                print("[Macro Recording] EZA unit detected: " .. displayName .. " (actual: " .. towerName .. ")")
                            end
                            
                            local cframe = newestTower:GetPivot()
                            local savedArgs = {towerName, {cframe:GetComponents()}}
                            
                            table.insert(getgenv().MacroDataV2, {
                                RemoteName = "PlaceTower",
                                Args = savedArgs,
                                Time = now - getgenv().MacroRecordingStartTime,
                                IsInvoke = false,
                                Cost = cost,
                                TowerName = displayName,
                                ActionType = "Place",
                                Wave = getgenv().MacroGameState.currentWave
                            })
                            
                            getgenv().MacroStatusText = "Recording"
                            getgenv().MacroCurrentStep = #getgenv().MacroDataV2
                            getgenv().MacroTotalSteps = #getgenv().MacroDataV2
                            getgenv().MacroActionText = "Place"
                            getgenv().MacroUnitText = displayName
                            
                            if getgenv().UpdateMacroStatus then
                                getgenv().UpdateMacroStatus()
                            end
                            
                        end
                    end
                end
                
                lastTowerCount = currentCounts
            end)
        end
    end)
    
    namecallHook = true
end


local function monitorEndGameUI()
    task.spawn(function()
        while true do
            task.wait(0.5)
            
            if getgenv().MacroRecordingV2 and getgenv().MacroGameState.hasEndGameUI then
                getgenv().MacroRecordingV2 = false
                
                cleanupTowerTracker()
                
                pcall(function()
                    if macroRecordToggle then
                        macroRecordToggle:UpdateState(false)
                    end
                end)
                
                if #getgenv().MacroDataV2 > 0 and getgenv().CurrentMacro then
                    local success = getgenv().SaveMacro(getgenv().CurrentMacro, getgenv().MacroDataV2)
                    
                    if success then
                        getgenv().MacroPlayEnabled = true
                        getgenv().Config.toggles.MacroPlayToggle = true
                        getgenv().SaveConfig(getgenv().Config)
                        
                        pcall(function()
                            if getgenv().MacroPlayToggle then
                                getgenv().MacroPlayToggle:UpdateState(true)
                            end
                        end)
                        
                        if Window and Window.Notify then
                            Window:Notify({
                                Title = "Macro Recording",
                                Description = "Saved " .. #getgenv().MacroDataV2 .. " steps. Playback enabled.",
                                Lifetime = 5
                            })
                        end
                    end
                end
                
                getgenv().MacroStatusText = "Idle"
                getgenv().MacroCurrentStep = 0
                getgenv().MacroTotalSteps = 0
                getgenv().MacroActionText = ""
                getgenv().MacroUnitText = ""
                getgenv().UpdateMacroStatus()
                
                towerTracker = {
                    placeCounts = {},
                    upgradeLevels = {},
                    lastPlaceTime = {},
                    lastUpgradeTime = {},
                    pendingActions = {}
                }
            end
        end
    end)
end

getgenv().MacroPlaybackActive = false

getgenv().executeAbilityAction = function(action)
    local success, result = pcall(function()
        if not action.TowerName then
            warn("[Macro] Ability action missing TowerName")
            return false
        end
        
        if not action.AbilityName then
            warn("[Macro] Ability action missing AbilityName")
            return false
        end
        
        local matchingTowers = {}
        
        for _, tower in pairs(workspace.Towers:GetChildren()) do
            if tower.Name == action.TowerName then
                local owner = tower:FindFirstChild("Owner")
                if owner and owner.Value == LocalPlayer then
                    table.insert(matchingTowers, tower)
                end
            end
        end
        
        if #matchingTowers == 0 then
            warn("[Macro] Ability action skipped: Tower " .. action.TowerName .. " not found")
            return false
        end
        
        local tower = matchingTowers[1]
        
        if getgenv().DebugMode and #matchingTowers > 1 then
            debugPrint("[Macro] Multiple towers with name " .. action.TowerName .. " found, using first match: " .. tostring(tower))
        end
        
        if not tower.Parent then
            warn("[Macro] Ability action skipped: Tower " .. action.TowerName .. " was removed/sold")
            return false
        end
        
        local abilityRemote = getgenv().MacroRemoteCache["ability"]
        if not abilityRemote then
            warn("[Macro] Ability remote not found in cache")
            return false
        end
        
        local invokeSuccess, invokeErr = pcall(function()
            abilityRemote:InvokeServer(tower, action.AbilityName)
        end)
        
        if not invokeSuccess then
            warn("[Macro] Failed to invoke ability: " .. tostring(invokeErr))
            return false
        end
        
        debugPrint("[Macro] Used ability " .. action.AbilityName .. " on " .. action.TowerName)
        return true
    end)
    
    if not success then
        warn("[Macro] Error executing ability action - Tower: " .. tostring(action.TowerName) .. ", Ability: " .. tostring(action.AbilityName) .. " - " .. tostring(result))
        return false
    end
    
    return result
end

getgenv().matchCardName = function(recordedName, availableCards)
    if not recordedName or not availableCards then
        return nil
    end
    
    for _, card in ipairs(availableCards) do
        if card.name == recordedName then
            return card
        end
    end
    
    for _, card in ipairs(availableCards) do
        if card.name:gsub(" ", "") == recordedName then
            return card
        end
    end
    
    local recordedLower = recordedName:lower()
    for _, card in ipairs(availableCards) do
        if card.name:lower() == recordedLower then
            return card
        end
    end
    
    return nil
end

getgenv().executeCardSelectionAction = function(action)
    local success, result = pcall(function()
        if not action.Args or not action.Args[1] then
            warn("[Macro] Card selection action missing numeric argument")
            return false
        end
        
        if not action.CardName then
            warn("[Macro] Card selection action missing CardName")
            return false
        end
        
        local availableCards = getAvailableCards()
        if not availableCards or #availableCards == 0 then
            warn("[Macro] Card selection skipped: No cards available in UI")
            return false
        end
        
        local matchedCard = getgenv().matchCardName(action.CardName, availableCards)
        if not matchedCard then
            warn("[Macro] Card selection skipped: Card " .. action.CardName .. " not found")
            return false
        end
        
        local abilitySelectionRemote = getgenv().MacroRemoteCache["abilityselection"]
        if not abilitySelectionRemote then
            warn("[Macro] AbilitySelection remote not found in cache")
            return false
        end
        
        local fireSuccess, fireErr = pcall(function()
            abilitySelectionRemote:FireServer(action.Args[1], matchedCard.name)
        end)
        
        if not fireSuccess then
            warn("[Macro] Failed to fire card selection: " .. tostring(fireErr))
            return false
        end
        
        debugPrint("[Macro] Selected card " .. matchedCard.name)
        return true
    end)
    
    if not success then
        warn("[Macro] Error executing card selection action - Card: " .. tostring(action.CardName) .. ", Arg: " .. tostring(action.Args and action.Args[1]) .. " - " .. tostring(result))
        return false
    end
    
    return result
end

local function executeAction(action, retryCount)
    retryCount = retryCount or 0
    
    if not action.RemoteName then 
        return false, "No remote name"
    end
    
    local remote = getgenv().MacroRemoteCache[action.RemoteName:lower()]
    
    if not remote and action.ActionType == "Place" then
        for name, rem in pairs(getgenv().MacroRemoteCache) do
            if name:find("place") or name:find("tower") then
                remote = rem
                print("[Macro] Using fallback remote for Place: " .. name)
                break
            end
        end
    end
    
    if not remote and action.ActionType == "Upgrade" then
        remote = getgenv().MacroRemoteCache["upgrade"]
        if remote then
            print("[Macro] Using fallback remote for Upgrade: upgrade")
        end
    end
    
    if not remote and action.ActionType == "Sell" then
        remote = getgenv().MacroRemoteCache["sell"]
        if remote then
            print("[Macro] Using fallback remote for Sell: sell")
        end
    end
    
    if not remote then 
        return false, "Remote not found: " .. action.RemoteName
    end
    
    if action.ActionType == "Place" and (not action.Args or not action.Args[1]) then
        return false, "Invalid place action: missing unit name"
    end
    
    if (action.ActionType == "Upgrade" or action.ActionType == "Sell") and not action.TowerName then
        return false, "Invalid action: missing tower name"
    end
    
    if action.ActionType == "Upgrade" then
        local towers = {}
        local allTowers = {}
        
        local towerNameToFind = getgenv()._GetActualTowerName(action.TowerName)
        
        for _, t in pairs(workspace.Towers:GetChildren()) do
            local owner = t:FindFirstChild("Owner")
            if t.Name == towerNameToFind and owner and owner.Value == LocalPlayer then
                table.insert(allTowers, t)
                local upgrade = t:FindFirstChild("Upgrade")
                local maxUpgrade = t:FindFirstChild("MaxUpgrade")
                local currentLevel = upgrade and upgrade.Value or 0
                local maxLevel = maxUpgrade and maxUpgrade.Value or 999
                if currentLevel < maxLevel then
                    table.insert(towers, {tower = t, level = currentLevel})
                end
            end
        end
        
        if #allTowers == 0 then
            return false, "No " .. action.TowerName .. " found"
        end
        
        if #towers == 0 then
            return true, "All " .. action.TowerName .. " already max level"
        end
        
        local selectedTower = nil
        local selectionMethod = "lowest_level"
        local placementCFrame = nil
        
        if not action.CFrame and getgenv().MacroPlaybackMacroData then
            for i = 1, getgenv().MacroCurrentStep - 1 do
                local prevAction = getgenv().MacroPlaybackMacroData[i]
                if prevAction and prevAction.ActionType == "Place" and prevAction.TowerName == action.TowerName then
                    if prevAction.Args and prevAction.Args[2] and type(prevAction.Args[2]) == "table" and #prevAction.Args[2] >= 12 then
                        placementCFrame = prevAction.Args[2]
                        break
                    end
                end
            end
        else
            placementCFrame = action.CFrame
        end
        
        if placementCFrame and type(placementCFrame) == "table" and #placementCFrame >= 12 then
            local success, targetCFrame = pcall(function()
                return CFrame.new(
                    placementCFrame[1], placementCFrame[2], placementCFrame[3],
                    placementCFrame[4], placementCFrame[5], placementCFrame[6],
                    placementCFrame[7], placementCFrame[8], placementCFrame[9],
                    placementCFrame[10], placementCFrame[11], placementCFrame[12]
                )
            end)
            
            if success and targetCFrame then
                local closestTower = nil
                local closestDistance = math.huge
                
                for _, towerData in ipairs(towers) do
                    local t = towerData.tower
                    local hrp = t:FindFirstChild("HumanoidRootPart")
                    if hrp and hrp:IsA("BasePart") then
                        local distance = (hrp.CFrame.Position - targetCFrame.Position).Magnitude
                        if distance < closestDistance then
                            closestDistance = distance
                            closestTower = towerData
                        end
                    end
                end
                
                if closestTower and closestDistance < 10 then
                    selectedTower = closestTower
                    selectionMethod = "cframe_match"
                end
            end
        end
        
        if not selectedTower then
            table.sort(towers, function(a, b)
                return a.level < b.level
            end)
            selectedTower = towers[1]
        end
        
        local tower = selectedTower.tower
        local oldLevel = selectedTower.level
        
        local ezaInfo = ""
        if towerNameToFind ~= action.TowerName then
            ezaInfo = " [EZA: " .. towerNameToFind .. "]"
        end
        
        print("[Macro] Upgrading " .. action.TowerName .. ezaInfo .. " from level " .. oldLevel .. " (method: " .. selectionMethod .. ")")
        
        local method = remote:IsA("RemoteFunction") and "InvokeServer" or "FireServer"
        local callSuccess, callResult = getgenv()._ConnectionStability_safeRemoteCall(remote, method, tower)
        
        if not callSuccess then
            return false, "Failed to call upgrade remote: " .. tostring(callResult)
        end
        
        task.wait(0.5)
        
        local newLevel = tower:FindFirstChild("Upgrade") and tower.Upgrade.Value or oldLevel
        if newLevel > oldLevel then
            print("[Macro] ✅ Upgrade successful (" .. oldLevel .. " → " .. newLevel .. ")")
            return true, "Upgraded to level " .. newLevel
        else
            print("[Macro] ❌ Upgrade failed (level unchanged: " .. oldLevel .. ")")
            if retryCount < 1 then
                task.wait(0.3)
                return executeAction(action, retryCount + 1)
            end
            return false, "Upgrade failed after retry"
        end
        
    elseif action.ActionType == "Sell" then
        local allTowers = {}
        
        local towerNameToFind = getgenv()._GetActualTowerName(action.TowerName)
        
        for _, t in pairs(workspace.Towers:GetChildren()) do
            if t.Name == towerNameToFind and t:FindFirstChild("Owner") and t.Owner.Value == LocalPlayer then
                table.insert(allTowers, t)
            end
        end
        
        if #allTowers == 0 then
            return false, "Tower not found for sell: " .. action.TowerName
        end
        
        local tower = nil
        local placementCFrame = nil
        
        if not action.CFrame and getgenv().MacroPlaybackMacroData then
            for i = 1, getgenv().MacroCurrentStep - 1 do
                local prevAction = getgenv().MacroPlaybackMacroData[i]
                if prevAction and prevAction.ActionType == "Place" and prevAction.TowerName == action.TowerName then
                    if prevAction.Args and prevAction.Args[2] and type(prevAction.Args[2]) == "table" and #prevAction.Args[2] >= 12 then
                        placementCFrame = prevAction.Args[2]
                        break
                    end
                end
            end
        else
            placementCFrame = action.CFrame
        end
        
        if placementCFrame and type(placementCFrame) == "table" and #placementCFrame >= 12 and #allTowers > 1 then
            local success, targetCFrame = pcall(function()
                return CFrame.new(
                    placementCFrame[1], placementCFrame[2], placementCFrame[3],
                    placementCFrame[4], placementCFrame[5], placementCFrame[6],
                    placementCFrame[7], placementCFrame[8], placementCFrame[9],
                    placementCFrame[10], placementCFrame[11], placementCFrame[12]
                )
            end)
            
            if success and targetCFrame then
                local closestTower = nil
                local closestDistance = math.huge
                
                for _, t in ipairs(allTowers) do
                    local hrp = t:FindFirstChild("HumanoidRootPart")
                    if hrp and hrp:IsA("BasePart") then
                        local distance = (hrp.CFrame.Position - targetCFrame.Position).Magnitude
                        if distance < closestDistance then
                            closestDistance = distance
                            closestTower = t
                        end
                    end
                end
                
                if closestTower and closestDistance < 10 then
                    tower = closestTower
                end
            end
        end
        
        if not tower then
            tower = allTowers[1]
        end
        
        if not remote then
            return false, "Sell remote not found"
        end
        
        debugPrint("[Macro] Selling: " .. action.TowerName)
        
        local method = remote:IsA("RemoteFunction") and "InvokeServer" or "FireServer"
        local sellSuccess, sellResult = getgenv()._ConnectionStability_safeRemoteCall(remote, method, tower)
        
        if not sellSuccess then
            return false, "Failed to invoke sell remote: " .. tostring(sellResult)
        end
        
        task.wait(0.3)
        return true, "Sold"
        
    elseif action.ActionType == "Place" then
        local unitNameToPlace = action.Args[1]
        
        if action.TowerName and action.TowerName:match("EZA$") then
            local actualName = getgenv()._GetActualTowerName(action.TowerName)
            if actualName ~= action.TowerName then
                unitNameToPlace = actualName
                print("[Macro] EZA unit detected: " .. action.TowerName .. " → placing as " .. actualName)
            end
        end
        
        local args = {unitNameToPlace}
        if action.Args[2] and type(action.Args[2]) == "table" and #action.Args[2] >= 3 then
            local success, cframe = pcall(function()
                return CFrame.new(unpack(action.Args[2]))
            end)
            if success and cframe then
                args[2] = cframe
            else
                return false, "Invalid position data"
            end
        else
            return false, "Missing position data for placement"
        end
        
        print("[Macro] Placing " .. (action.TowerName or "?") .. " at position")
        
        local actualTowerName = getgenv()._GetActualTowerName(action.TowerName or unitNameToPlace)
        local specificTowerCountBefore = 0
        local towerCountBefore = 0
        
        for _, t in pairs(workspace.Towers:GetChildren()) do
            local owner = t:FindFirstChild("Owner")
            if owner and owner.Value == LocalPlayer then
                towerCountBefore = towerCountBefore + 1
                if t.Name == actualTowerName then
                    specificTowerCountBefore = specificTowerCountBefore + 1
                end
            end
        end
        
        local method = remote:IsA("RemoteFunction") and "InvokeServer" or "FireServer"
        local callSuccess, callResult = getgenv()._ConnectionStability_safeRemoteCall(remote, method, unpack(args))
        
        if not callSuccess then
            return false, "Failed to call placement remote: " .. tostring(callResult)
        end
        
        task.wait(0.8)
        
        local specificTowerCountAfter = 0
        local towerCountAfter = 0
        
        for _, t in pairs(workspace.Towers:GetChildren()) do
            local owner = t:FindFirstChild("Owner")
            if owner and owner.Value == LocalPlayer then
                towerCountAfter = towerCountAfter + 1
                if t.Name == actualTowerName then
                    specificTowerCountAfter = specificTowerCountAfter + 1
                end
            end
        end
        
        if specificTowerCountAfter > specificTowerCountBefore then
            print("[Macro] ✅ Placement successful - " .. actualTowerName .. " (" .. specificTowerCountBefore .. " → " .. specificTowerCountAfter .. ") | Total: " .. towerCountBefore .. " → " .. towerCountAfter)
            return true, "Placed"
        else
            print("[Macro] ❌ Placement failed - " .. actualTowerName .. " count unchanged: " .. specificTowerCountBefore .. " | Total towers: " .. towerCountAfter)
            if retryCount < 1 then
                warn("[Macro] Retrying placement...")
                task.wait(0.5)
                return executeAction(action, retryCount + 1)
            end
            return false, "Placement failed after retry"
        end
    elseif action.ActionType == "Ability" then
        local success = getgenv().executeAbilityAction(action)
        if success then
            return true, "Ability used"
        else
            return false, "Ability execution failed"
        end
    elseif action.ActionType == "AbilitySelection" then
        local success = getgenv().executeCardSelectionAction(action)
        if success then
            return true, "Card selected"
        else
            return false, "Card selection failed"
        end
    end
    
    return false, "Unknown action type"
end

local function detectMacroProgress(macroData)
    local towerStates = {}
    
    for _, tower in pairs(workspace.Towers:GetChildren()) do
        local owner = tower:FindFirstChild("Owner")
        if owner and owner.Value == LocalPlayer then
            local towerName = tower.Name
            local upgrade = tower:FindFirstChild("Upgrade")
            local level = upgrade and upgrade.Value or 0
            
            if not towerStates[towerName] then
                towerStates[towerName] = {count = 0, maxLevel = 0}
            end
            
            towerStates[towerName].count = towerStates[towerName].count + 1
            towerStates[towerName].maxLevel = math.max(towerStates[towerName].maxLevel, level)
            
            local ezaDisplayName = getgenv()._GetEZADisplayName(towerName)
            if ezaDisplayName ~= towerName then
                if not towerStates[ezaDisplayName] then
                    towerStates[ezaDisplayName] = {count = 0, maxLevel = 0}
                end
                towerStates[ezaDisplayName].count = towerStates[ezaDisplayName].count + 1
                towerStates[ezaDisplayName].maxLevel = math.max(towerStates[ezaDisplayName].maxLevel, level)
            end
        end
    end
    
    local lastCompletedStep = 0
    local expectedTowers = {}
    
    for i, action in ipairs(macroData) do
        if action.ActionType == "Place" then
            local towerName = action.TowerName
            expectedTowers[towerName] = (expectedTowers[towerName] or 0) + 1
            
            if towerStates[towerName] and towerStates[towerName].count >= expectedTowers[towerName] then
                lastCompletedStep = i
            else
                break
            end
            
        elseif action.ActionType == "Upgrade" then
            local towerName = action.TowerName
            
            local expectedLevel = 0
            for j = 1, i do
                if macroData[j].ActionType == "Upgrade" and macroData[j].TowerName == towerName then
                    expectedLevel = expectedLevel + 1
                end
            end
            
            if towerStates[towerName] and towerStates[towerName].maxLevel >= expectedLevel then
                lastCompletedStep = i
            else
                break
            end
        end
    end
    
    
    if lastCompletedStep >= #macroData then
        return -1
    end
    
    return lastCompletedStep + 1
end

local function validateMacro(macroData)
    if not macroData or #macroData == 0 then
        return false, "Macro is empty"
    end
    
    local hasPlacement = false
    for _, action in ipairs(macroData) do
        if not action.ActionType then
            return false, "Action missing ActionType"
        end
        
        if action.ActionType == "Place" then
            hasPlacement = true
            if not action.Args or not action.Args[1] then
                return false, "Place action missing unit name"
            end
        end
        
        if not action.RemoteName then
            return false, "Action missing RemoteName"
        end
    end
    
    if not hasPlacement then
        return false, "Macro has no placement actions"
    end
    
    return true, "Valid"
end

getgenv().shouldExecuteAbility = function(action, currentElapsedTime)
    if action.ActionType ~= "Ability" and action.ActionType ~= "AbilitySelection" then
        return false
    end
    
    local timeDifference = currentElapsedTime - action.Time
    
    if timeDifference >= -0.1 then
        return true
    end
    
    return false
end

local function playMacroV2()
    if getgenv()._checkIfInLobby() then
        print("[Macro] ⚠️ Cannot start macro in lobby")
        return
    end
    
    if getgenv().MacroPlaybackActive then 
        print("[Macro] ⚠️ Playback already active")
        return 
    end
    
    if not getgenv().CurrentMacro then
        warn("[Macro] ❌ No macro selected (CurrentMacro is nil)")
        return
    end
    
    if not getgenv().Macros[getgenv().CurrentMacro] then
        warn("[Macro] ❌ Macro not found: " .. tostring(getgenv().CurrentMacro))
        warn("[Macro] Available macros: " .. table.concat(getMacroNames(), ", "))
        return
    end
    
    getgenv().MacroPlaybackActive = true
    
    getgenv().MacroCurrentStep = 0
    getgenv().MacroActionText = ""
    getgenv().MacroUnitText = ""
    getgenv().MacroWaitingText = ""
    
    task.spawn(function()
        local macroData = getgenv().Macros[getgenv().CurrentMacro]
        if not macroData or #macroData == 0 then
            warn("[Macro] ❌ Macro data is empty for: " .. tostring(getgenv().CurrentMacro))
            getgenv().MacroPlaybackActive = false
            return
        end
        
        
        getgenv().MacroPlaybackMacroData = macroData
        getgenv().MacroTotalSteps = #macroData
        
        local valid, err = validateMacro(macroData)
        if not valid then
            getgenv().MacroStatusText = "Invalid Macro"
            getgenv().MacroWaitingText = err
            getgenv().UpdateMacroStatus()
            getgenv().MacroPlaybackActive = false
            return
        end
        
        local step = 1
        
        local gameStarted = false
        pcall(function()
            local gs = RS:FindFirstChild("GameStarted")
            if gs and gs.Value ~= nil then
                gameStarted = gs.Value
            end
        end)
        
        if not getgenv().MacroGameState.hasStartButton and getgenv().MacroGameState.currentWave > 0 and gameStarted then
            step = detectMacroProgress(macroData)
            
            if step == -1 then
                getgenv().MacroStatusText = "Finished Macro"
                getgenv().MacroWaitingText = "All steps complete"
                getgenv().MacroCurrentStep = #macroData
                getgenv().MacroTotalSteps = #macroData
                getgenv().UpdateMacroStatus()
                getgenv().MacroPlaybackActive = false
                return
            end
            
        end
        
        if not gameStarted then
            local waitStartTime = tick()
            
            print("[Macro] Waiting for game to start (GameStarted = false)...")
            
            while getgenv().MacroPlayEnabled do
                local gs = false
                pcall(function()
                    local gameStartedValue = RS:FindFirstChild("GameStarted")
                    if gameStartedValue and gameStartedValue.Value ~= nil then
                        gs = gameStartedValue.Value
                    end
                end)
                
                if gs then
                    gameStarted = true
                    print("[Macro] ✅ Game started (GameStarted = true), beginning macro playback")
                    break
                end
                
                getgenv().MacroStatusText = "Waiting for Start"
                getgenv().MacroWaitingText = "GameStarted = false..."
                getgenv().UpdateMacroStatus()
                
                local elapsed = tick() - waitStartTime
                if elapsed > 300 then
                    warn("[Macro] Timeout waiting for game start (5 min)")
                    getgenv().MacroPlaybackActive = false
                    return
                end
                
                task.wait(0.3)
            end
        end
        
        if not getgenv().MacroPlayEnabled then
            getgenv().MacroPlaybackActive = false
            return
        end
        
        task.wait(1.5)
        
        if not getgenv().MacroPlayEnabled then
            getgenv().MacroPlaybackActive = false
            return
        end
        
        local cashInitAttempts = 0
        while cashInitAttempts < 10 do
            local currentCash = tonumber(getgenv().MacroCurrentCash) or 0
            if currentCash > 0 then
                break
            end
            
            pcall(function()
                if LocalPlayer:FindFirstChild("Cash") then
                    getgenv().MacroCurrentCash = LocalPlayer.Cash.Value
                end
            end)
            
            cashInitAttempts = cashInitAttempts + 1
            task.wait(0.5)
        end
        
        if (tonumber(getgenv().MacroCurrentCash) or 0) == 0 then
            warn("[Macro] Failed to initialize cash after 5 seconds, starting anyway...")
        else
            print("[Macro] Cash initialized: $" .. getgenv().MacroCurrentCash)
        end
        
        getgenv().MacroStatusText = "Playing"
        getgenv().MacroWaitingText = ""
        getgenv().UpdateMacroStatus()
        
        local lastCashCheck = 0
        local lastGameStartedState = true
        local playbackStartTime = tick()
        
        while getgenv().MacroPlayEnabled and step <= #macroData do
            if getgenv().IsKilled and getgenv().IsKilled() then
                break
            end
            
            local gameStarted = true
            pcall(function()
                local gs = RS:FindFirstChild("GameStarted")
                if gs and gs.Value ~= nil then
                    gameStarted = gs.Value
                end
            end)
            
            lastGameStartedState = gameStarted
            
            if getgenv().MacroGameState.gameEnded or getgenv().MacroGameState.hasEndGameUI then
                getgenv().MacroStatusText = "Game Ended"
                getgenv().MacroWaitingText = "Auto-restart will handle next round..."
                getgenv().UpdateMacroStatus()
                getgenv().MacroPlaybackActive = false
                return
            end
            
            if getgenv().MacroGameState.hasStartButton or getgenv().MacroGameState.currentWave == 0 then
                getgenv().MacroStatusText = "Restart Detected"
                getgenv().MacroWaitingText = "Waiting for game start..."
                getgenv().UpdateMacroStatus()
                
                while (getgenv().MacroGameState.hasStartButton or getgenv().MacroGameState.currentWave == 0) and getgenv().MacroPlayEnabled do
                    task.wait(0.1)
                end
                
                if not getgenv().MacroPlayEnabled then
                    break
                end
                
                task.wait(2)
                
                step = 1
                playbackStartTime = tick()
                continue
            end
            
            local action = macroData[step]
            if not action then
                step = step + 1
                continue
            end
            
            local currentElapsedTime = tick() - playbackStartTime
            
            if action.ActionType == "Ability" or action.ActionType == "AbilitySelection" then
                if not getgenv().shouldExecuteAbility(action, currentElapsedTime) then
                    task.wait(0.05)
                    continue
                end
            end
            
            getgenv().MacroCurrentStep = step
            getgenv().MacroTotalSteps = #macroData
            getgenv().MacroActionText = action.ActionType or "Action"
            getgenv().MacroUnitText = action.TowerName or "?"
            
            if action.ActionType == "Ability" or action.ActionType == "AbilitySelection" then
                getgenv().MacroWaitingText = "Using ability..."
            else
                getgenv().MacroWaitingText = ""
            end
            
            getgenv().UpdateMacroStatus()
            
            local cash = tonumber(getgenv().MacroCurrentCash) or 0
            local cost = tonumber(action.Cost) or 0
            
            if cost > 0 and action.TowerName and (action.ActionType == "Place" or action.ActionType == "Upgrade") then
                local enchantMultiplier, discountSuccess = getgenv().GetUnitEnchantDiscountSafe(action.TowerName)
                
                if discountSuccess and enchantMultiplier < 1.0 then
                    local baseCost = 0
                    
                    if action.ActionType == "Place" then
                        baseCost = getgenv().GetPlaceCost(action.TowerName)
                    elseif action.ActionType == "Upgrade" then
                        local currentLevel = action.CurrentLevel or 0
                        baseCost = getgenv().GetUpgradeCost(action.TowerName, currentLevel)
                    end
                    
                    if baseCost > 0 then
                        local expectedDiscountedCost = math.floor(baseCost * enchantMultiplier)
                        local costDifference = math.abs(cost - expectedDiscountedCost)
                        local differencePercent = (costDifference / baseCost) * 100
                        
                        if differencePercent > 10 then
                            if getgenv().DebugMode then
                                debugPrint(string.format("[Playback] Adjusting cost for %s: recorded=%d, expected=%d (%.1f%% diff)", 
                                    action.TowerName, cost, expectedDiscountedCost, differencePercent))
                            end
                            cost = expectedDiscountedCost
                        else
                            if getgenv().DebugMode then
                                debugPrint(string.format("[Playback] Using recorded cost for %s: %d (diff %.1f%%)", 
                                    action.TowerName, cost, differencePercent))
                            end
                        end
                    end
                else
                    if getgenv().DebugMode and not discountSuccess then
                        debugPrint(string.format("[Playback] Discount check failed for %s, using recorded cost: %d", 
                            action.TowerName, cost))
                    end
                end
            end
            
            local shouldSkipStep = false
            
            if cost > 0 and cash < cost then
                getgenv().MacroStatusText = "Waiting Cash"
                getgenv().MacroWaitingText = "$" .. cost .. " (have $" .. cash .. ")"
                getgenv().UpdateMacroStatus()
                
                local cashWaitStart = tick()
                local maxCashWait = 300
                local lastCash = cash
                local noIncomeTime = 0
                
                while getgenv().MacroPlayEnabled do
                    task.wait(0.1)
                    cash = tonumber(getgenv().MacroCurrentCash) or 0
                    
                    if cash >= cost then 
                        break 
                    end
                    
                    if cash > lastCash then
                        noIncomeTime = 0
                    else
                        noIncomeTime = noIncomeTime + 0.1
                    end
                    lastCash = cash
                    
                    local waitTime = tick() - cashWaitStart
                    
                    if waitTime > maxCashWait then
                        shouldSkipStep = true
                        break
                    end
                    
                    if noIncomeTime > 60 and waitTime > 30 then
                        shouldSkipStep = true
                        break
                    end
                    
                    getgenv().MacroWaitingText = "$" .. cost .. " (have $" .. cash .. ") - " .. math.floor(waitTime) .. "s"
                    getgenv().UpdateMacroStatus()
                end
                
                if not getgenv().MacroPlayEnabled then break end
            end
            
            if shouldSkipStep then
                getgenv().MacroStatusText = "Skipping - Not Enough Cash"
                getgenv().MacroWaitingText = "Needed $" .. cost .. ", have $" .. cash
                getgenv().UpdateMacroStatus()
                task.wait(2)
                step = step + 1
                continue
            end
            
            getgenv().MacroStatusText = "Playing"
            getgenv().MacroWaitingText = ""
            getgenv().UpdateMacroStatus()
            
            local actionSuccess = false
            local actionMessage = ""
            
            local success, result, msg = pcall(function()
                return executeAction(action)
            end)
            
            if success and result then
                actionSuccess = true
                actionMessage = msg or "Success"
            else
                actionMessage = msg or "Action failed"
            end
            
            if not actionSuccess then
                getgenv().MacroStatusText = "Step Failed - Continuing"
                getgenv().MacroWaitingText = actionMessage
                getgenv().UpdateMacroStatus()
                task.wait(0.5)
            else
                local nextStep = step + 1
                if nextStep <= #macroData then
                    local nextAction = macroData[nextStep]
                    if nextAction then
                        if nextAction.ActionType == "Upgrade" then
                            getgenv().MacroWaitingText = "Next: Upgrade"
                        elseif nextAction.ActionType == "Place" then
                            getgenv().MacroWaitingText = "Next: Place"
                        elseif nextAction.ActionType == "Ability" then
                            getgenv().MacroWaitingText = "Next: Ability"
                        else
                            getgenv().MacroWaitingText = ""
                        end
                        getgenv().UpdateMacroStatus()
                    end
                end
            end
            
            step = step + 1
            
            task.wait(0.3)
            
            local stepDelay = getgenv().MacroStepDelay or 0
            if stepDelay > 0 then
                task.wait(stepDelay)
            else
                task.wait(0.15)
            end
        end
        
        if step > #macroData then
            getgenv().MacroStatusText = "Macro Complete"
            getgenv().MacroWaitingText = "Waiting for seamless restart..."
            getgenv().MacroCurrentStep = #macroData
            getgenv().MacroTotalSteps = #macroData
            getgenv().MacroActionText = "Complete"
            getgenv().MacroUnitText = ""
            getgenv().UpdateMacroStatus()
            
            print("[Macro] ✅ Macro completed all steps, waiting for seamless restart")
            
            getgenv().MacroPlaybackActive = false
            
            if getgenv().SeamlessFixEnabled then
                print("[Macro] Monitoring for seamless restart...")
                local monitorStartTime = tick()
                local lastGameStartedCheck = true
                
                while getgenv().MacroPlayEnabled and (tick() - monitorStartTime) < 300 do
                    task.wait(0.5)
                    
                    local currentGameStarted = true
                    pcall(function()
                        local gs = RS:FindFirstChild("GameStarted")
                        if gs and gs.Value ~= nil then
                            currentGameStarted = gs.Value
                        end
                    end)
                    
                    if lastGameStartedCheck and not currentGameStarted then
                        print("[Macro] 🔄 Seamless restart detected (GameStarted changed to false)")
                        return
                    end
                    
                    lastGameStartedCheck = currentGameStarted
                end
            end
            
            return
        else
            getgenv().MacroStatusText = "Idle"
            getgenv().MacroCurrentStep = 0
            getgenv().MacroActionText = ""
            getgenv().MacroUnitText = ""
            getgenv().MacroWaitingText = ""
            getgenv().UpdateMacroStatus()
        end
        
        getgenv().MacroPlaybackActive = false
        getgenv().MacroPlaybackMacroData = nil
    end)
end

setupRecordingHook()
monitorEndGameUI()

task.spawn(function()
    local lastRestartAttempt = 0
    local lastEndGameUIState = false
    local restartCooldown = false
    
    while true do
        task.wait(0.3)
        
        local currentEndGameUIState = false
        pcall(function()
            local endGameUI = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
            currentEndGameUIState = endGameUI and endGameUI.Enabled or false
        end)
        
        if lastEndGameUIState and not currentEndGameUIState and getgenv().MacroPlayEnabled and not restartCooldown then
            debugPrint("[Macro] EndGameUI removed, preparing restart...")
            restartCooldown = true
            
            task.wait(3)
            
            if getgenv().MacroPlaybackActive then
                debugPrint("[Macro] Already playing, skipping restart")
                restartCooldown = false
                lastEndGameUIState = currentEndGameUIState
                task.wait(5)
                continue
            end
            
            print("[Macro] Waiting for game to fully restart...")
            local maxWait = 20
            local waited = 0
            local gameReady = false
            
            while waited < maxWait do
                local towerCount = 0
                pcall(function()
                    for _, tower in pairs(workspace.Towers:GetChildren()) do
                        local owner = tower:FindFirstChild("Owner")
                        if owner and owner.Value == LocalPlayer then
                            towerCount = towerCount + 1
                        end
                    end
                end)
                
                local wave = 0
                local gameStarted = false
                local state = -1
                pcall(function()
                    local waveValue = RS:FindFirstChild("Wave")
                    if waveValue then
                        wave = waveValue.Value
                    end
                    
                    local gameStartedValue = RS:FindFirstChild("GameStarted")
                    if gameStartedValue and gameStartedValue.Value ~= nil then
                        gameStarted = gameStartedValue.Value
                    end
                    
                    local stateValue = RS:FindFirstChild("State")
                    if stateValue then
                        state = stateValue.Value
                    end
                end)
                
                if towerCount == 0 and wave == 0 and not gameStarted and state == 0 then
                    gameReady = true
                    print("[Macro] ✅ Game ready - State: 0, Wave: 0, No towers")
                    break
                end
                
                print(string.format("[Macro] Waiting... State: %d, Wave: %d, Towers: %d, GameStarted: %s", state, wave, towerCount, tostring(gameStarted)))
                
                task.wait(0.5)
                waited = waited + 0.5
            end
            
            if not gameReady then
                warn("[Macro] Timeout waiting for game restart, starting anyway...")
            end
            
            getgenv().MacroPlaybackActive = false
            getgenv().MacroStatusText = "Idle"
            getgenv().MacroCurrentStep = 0
            getgenv().MacroActionText = ""
            getgenv().MacroUnitText = ""
            getgenv().MacroWaitingText = ""
            
            getgenv().MacroGameState.gameEnded = false
            getgenv().MacroGameState.hasEndGameUI = false
            getgenv().MacroGameState.lastGameEndedState = false
            
            getgenv().UpdateMacroStatus()
            
            task.wait(1)
            
            debugPrint("[Macro] Starting playback...")
            playMacroV2()
            lastRestartAttempt = tick()
            
            task.delay(5, function()
                restartCooldown = false
            end)
        end
        
        lastEndGameUIState = currentEndGameUIState
        
        if getgenv().MacroPlayEnabled and not getgenv().MacroPlaybackActive and not restartCooldown then
            local now = tick()
            if now - lastRestartAttempt > 5 then
                local shouldRestart = false
                local restartReason = ""
                
                local currentWave = 0
                pcall(function()
                    local wave = RS:FindFirstChild("Wave")
                    if wave and wave.Value then
                        currentWave = wave.Value
                    end
                end)
                
                local gameStarted = false
                pcall(function()
                    local gs = RS:FindFirstChild("GameStarted")
                    if gs and gs.Value ~= nil then
                        gameStarted = gs.Value
                    end
                end)
                
                if currentWave > 0 and gameStarted and not currentEndGameUIState then
                    shouldRestart = true
                    restartReason = string.format("Game active (Wave %d)", currentWave)
                end
                
                if shouldRestart then
                    restartCooldown = true
                    
                    getgenv().MacroCurrentStep = 0
                    getgenv().MacroActionText = ""
                    getgenv().MacroUnitText = ""
                    getgenv().MacroWaitingText = ""
                    getgenv().MacroStatusText = "Idle"
                    
                    getgenv().MacroGameState.gameEnded = false
                    getgenv().MacroGameState.hasEndGameUI = false
                    getgenv().MacroGameState.lastGameEndedState = false
                    
                    getgenv().UpdateMacroStatus()
                    
                    lastRestartAttempt = now
                    playMacroV2()
                    
                    task.delay(3, function()
                        restartCooldown = false
                    end)
                end
            end
        end
    end
end)



local MapData = nil
pcall(function()
    local mapDataModule = RS:FindFirstChild("Modules") and RS.Modules:FindFirstChild("MapData")
    if mapDataModule and mapDataModule:IsA("ModuleScript") then
        MapData = require(mapDataModule)
    end
end)

local function getMapsByMode(mode)
    if not MapData then return {} end
    if mode == "ElementalCaverns" then return {"Light","Nature","Fire","Dark","Water"} end
    if mode == "FinalExpedition" then mode = "Story" end
    local maps = {}
    for mapName, mapInfo in pairs(MapData) do
        if mapInfo.Type and type(mapInfo.Type) == "table" then
            for _, mapType in ipairs(mapInfo.Type) do
                if mapType == mode then table.insert(maps, mapName) break end
            end
        end
    end
    table.sort(maps)
    return maps
end

local savedAutoJoin = getgenv().Config.autoJoin or {}
getgenv().AutoJoinConfig = {
    enabled = savedAutoJoin.enabled or false,
    autoStart = savedAutoJoin.autoStart or false,
    friendsOnly = savedAutoJoin.friendsOnly or false,
    mode = savedAutoJoin.mode or "Story",
    map = savedAutoJoin.map or "",
    act = savedAutoJoin.act or 1,
    difficulty = savedAutoJoin.difficulty or "Normal"
}




local success, err = pcall(function()
    Sections.MainLeft:Header({ Text = "🎮 Game Selection" })
    Sections.MainLeft:SubLabel({ Text = "Choose your game mode and map" })
end)
if not success then
    warn("[UI ERROR] Main tab header failed:", err)
    error("[FATAL] Cannot continue - Main tab header failed: " .. tostring(err))
end

local autoJoinModeList = {"Story", "Infinite", "Challenge", "LegendaryStages", "Raids", "Dungeon", "Survival", "ElementalCaverns", "BossRush", "Siege"}

getgenv()._autoJoinMapDropdown = nil

local modeDefault = 1
if getgenv().AutoJoinConfig.mode then
    for i, modeName in ipairs(autoJoinModeList) do
        if modeName == getgenv().AutoJoinConfig.mode then
            modeDefault = i
            break
        end
    end
end


local autoJoinModeDropdown
local modeSuccess, modeErr = pcall(function()
    autoJoinModeDropdown = createDropdown(
        Sections.MainLeft,
        "Mode",
        "AutoJoinMode",
        autoJoinModeList,
        false,
        function(value)
            getgenv().AutoJoinConfig.mode = value
            getgenv().Config.autoJoin.mode = value
            saveConfig(getgenv().Config)
            
            local maps = getMapsByMode(value)
            if #maps == 0 then
                maps = {"No Maps Available"}
            end
            if getgenv()._autoJoinMapDropdown then
                pcall(function()
                    getgenv()._autoJoinMapDropdown:ClearOptions()
                    getgenv()._autoJoinMapDropdown:InsertOptions(maps)
                    if #maps > 0 then
                        getgenv()._autoJoinMapDropdown:UpdateSelection(1)
                        getgenv().AutoJoinConfig.map = maps[1]
                        getgenv().Config.autoJoin.map = maps[1]
                        saveConfig(getgenv().Config)
                    end
                end)
            end
        end,
        modeDefault
    )
    
    if autoJoinModeDropdown and modeDefault then
        task.spawn(function()
            task.wait(0.1)
            pcall(function()
                autoJoinModeDropdown:UpdateSelection(modeDefault)
            end)
        end)
    end
end)
if not modeSuccess then
    warn("[UI ERROR] Mode dropdown failed:", modeErr)
    error("[FATAL] Cannot continue - Mode dropdown failed: " .. tostring(modeErr))
end

local initialMaps = getMapsByMode(getgenv().AutoJoinConfig.mode)
if #initialMaps == 0 then
    initialMaps = {"No Maps Available"}
end

local mapDefault = 1
if getgenv().AutoJoinConfig.map and getgenv().AutoJoinConfig.map ~= "" then
    for i, mapName in ipairs(initialMaps) do
        if mapName == getgenv().AutoJoinConfig.map then
            mapDefault = i
            break
        end
    end
end


local mapSuccess, mapErr = pcall(function()
    getgenv()._autoJoinMapDropdown = createDropdown(
        Sections.MainLeft,
        "Map",
        "AutoJoinMap",
        initialMaps,
        false,
        function(value)
            getgenv().AutoJoinConfig.map = value
            getgenv().Config.autoJoin.map = value
            saveConfig(getgenv().Config)
        end,
        mapDefault
    )
end)
if not mapSuccess then
    warn("[UI ERROR] Map dropdown failed:", mapErr)
    error("[FATAL] Cannot continue - Map dropdown failed: " .. tostring(mapErr))
end

local actDefault = getgenv().AutoJoinConfig.act or 1

local actSuccess, actErr = pcall(function()
    createDropdown(
        Sections.MainLeft,
        "Act",
        "AutoJoinAct",
        {"1", "2", "3", "4", "5", "6"},
        false,
        function(value)
            getgenv().AutoJoinConfig.act = tonumber(value) or 1
            getgenv().Config.autoJoin.act = tonumber(value) or 1
            saveConfig(getgenv().Config)
        end,
        actDefault
    )
end)
if not actSuccess then
    warn("[UI ERROR] Act dropdown failed:", actErr)
    error("[FATAL] Cannot continue - Act dropdown failed: " .. tostring(actErr))
end

local difficultyList = {"Normal", "Nightmare", "Purgatory", "Insanity"}
local difficultyDefault = 1
if getgenv().AutoJoinConfig.difficulty then
    for i, diff in ipairs(difficultyList) do
        if diff == getgenv().AutoJoinConfig.difficulty then
            difficultyDefault = i
            break
        end
    end
end


local diffSuccess, diffErr = pcall(function()
    createDropdown(
        Sections.MainLeft,
        "Difficulty",
        "AutoJoinDifficulty",
        difficultyList,
        false,
        function(value)
            getgenv().AutoJoinConfig.difficulty = value
            getgenv().Config.autoJoin.difficulty = value
            saveConfig(getgenv().Config)
        end,
        difficultyDefault
    )
end)
if not diffSuccess then
    warn("[UI ERROR] Difficulty dropdown failed:", diffErr)
    error("[FATAL] Cannot continue - Difficulty dropdown failed: " .. tostring(diffErr))
end

local divSuccess, divErr = pcall(function()
    Sections.MainLeft:Divider()
    Sections.MainLeft:Header({ Text = "⚙️ Join Settings" })
    Sections.MainLeft:SubLabel({ Text = "Configure auto-join behavior" })
end)
if not divSuccess then
    warn("[UI ERROR] Join Settings section failed:", divErr)
    error("[FATAL] Cannot continue - Join Settings section failed: " .. tostring(divErr))
end

local enableToggleSuccess, enableToggleErr = pcall(function()
    createToggle(
        Sections.MainLeft,
        "Enable Auto Join",
        "AutoJoinEnabled",
        function(value)
            getgenv().AutoJoinConfig.enabled = value
            getgenv().Config.autoJoin.enabled = value
            saveConfig(getgenv().Config)
            Window:Notify({
                Title = "Auto Join",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().AutoJoinConfig.enabled
    )
end)
if not enableToggleSuccess then
    warn("[UI ERROR] Enable Auto Join toggle failed:", enableToggleErr)
end

local joinDelaySuccess, joinDelayErr = pcall(function()
    createInput(
        Sections.MainLeft,
        "Join Delay (seconds)",
        "AutoJoinDelay",
        "Delay before joining map (0 = instant)",
        "Number",
        function(value)
            local delay = tonumber(value) or 0
            getgenv().AutoJoinDelay = delay
            Window:Notify({
                Title = "Auto Join Delay",
                Description = "Set to " .. delay .. " seconds",
                Lifetime = 2
            })
        end,
        tostring(getgenv().Config.inputs.AutoJoinDelay or 0)
    )
end)
if not joinDelaySuccess then
    warn("[UI ERROR] Auto Join Delay input failed:", joinDelayErr)
end

local friendsSuccess, friendsErr = pcall(function()
    createToggle(
        Sections.MainLeft,
        "Friends Only",
        "AutoJoinFriendsOnly",
        function(value)
            getgenv().AutoJoinConfig.friendsOnly = value
            getgenv().Config.autoJoin.friendsOnly = value
            saveConfig(getgenv().Config)
            
            pcall(function()
                RS.Remotes.Teleporter.InteractEvent:FireServer("FriendsOnly")
            end)
            
            Window:Notify({
                Title = "Friends Only",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().AutoJoinConfig.friendsOnly
    )
end)
if not friendsSuccess then
    warn("[UI ERROR] Friends Only toggle failed:", friendsErr)
    error("[FATAL] Cannot continue - Friends Only toggle failed: " .. tostring(friendsErr))
end

local autoStartSuccess, autoStartErr = pcall(function()
    createToggle(
        Sections.MainLeft,
        "Auto Start",
        "AutoJoinAutoStart",
        function(value)
            getgenv().AutoJoinConfig.autoStart = value
            getgenv().Config.autoJoin.autoStart = value
            saveConfig(getgenv().Config)
            Window:Notify({
                Title = "Auto Start",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().AutoJoinConfig.autoStart
    )
end)
if not autoStartSuccess then
    warn("[UI ERROR] Auto Start toggle failed:", autoStartErr)
    error("[FATAL] Cannot continue - Auto Start toggle failed: " .. tostring(autoStartErr))
end

Sections.MainLeft:Divider()
Sections.MainLeft:Header({ Text = "👥 Party Settings" })
Sections.MainLeft:SubLabel({ Text = "Wait for players or join specific player portals" })

getgenv().WaitForPlayerEnabled = getgenv().Config.toggles.WaitForPlayerEnabled or false
getgenv().WaitForPlayerCount = tonumber(getgenv().Config.inputs.WaitForPlayerCount) or 1
getgenv().JoinPlayerEnabled = getgenv().Config.toggles.JoinPlayerEnabled or false
getgenv().JoinPlayerTarget = getgenv().Config.dropdowns.JoinPlayerTarget or ""

createToggle(
    Sections.MainLeft,
    "Wait for Players",
    "WaitForPlayerEnabled",
    function(value)
        getgenv().WaitForPlayerEnabled = value
        Window:Notify({
            Title = "Wait for Players",
            Description = value and "Enabled - Will wait for " .. getgenv().WaitForPlayerCount .. " players" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().WaitForPlayerEnabled
)

local playerCountOptions = {}
for i = 1, 12 do
    table.insert(playerCountOptions, tostring(i))
end

createDropdown(
    Sections.MainLeft,
    "Player Count",
    "WaitForPlayerCount",
    playerCountOptions,
    false,
    function(value)
        getgenv().WaitForPlayerCount = tonumber(value) or 1
        getgenv().Config.inputs.WaitForPlayerCount = value
        saveConfig(getgenv().Config)
        Window:Notify({
            Title = "Player Count",
            Description = "Will wait for " .. value .. " players",
            Lifetime = 3
        })
    end,
    tostring(getgenv().WaitForPlayerCount)
)

createToggle(
    Sections.MainLeft,
    "Join Player Portal",
    "JoinPlayerEnabled",
    function(value)
        getgenv().JoinPlayerEnabled = value
        Window:Notify({
            Title = "Join Player Portal",
            Description = value and "Enabled - Will join " .. (getgenv().JoinPlayerTarget or "selected player") or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().JoinPlayerEnabled
)

local function getPlayerList()
    local players = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(players, player.DisplayName .. " (@" .. player.Name .. ")")
        end
    end
    if #players == 0 then
        table.insert(players, "No other players")
    end
    return players
end

getgenv()._joinPlayerDropdown = createDropdown(
    Sections.MainLeft,
    "Target Player",
    "JoinPlayerTarget",
    getPlayerList(),
    false,
    function(value)
        getgenv().JoinPlayerTarget = value
        Window:Notify({
            Title = "Target Player",
            Description = "Will join " .. value .. "'s portal",
            Lifetime = 3
        })
    end,
    getgenv().JoinPlayerTarget
)

task.spawn(function()
    while true do
        task.wait(2)
        if getgenv()._joinPlayerDropdown then
            pcall(function()
                local currentPlayers = getPlayerList()
                getgenv()._joinPlayerDropdown:ClearOptions()
                getgenv()._joinPlayerDropdown:InsertOptions(currentPlayers)
            end)
        end
    end
end)

task.spawn(function()
    local pollingInterval = MobileOptimizer:getPollingInterval(0.5)
    
    while true do
        task.wait(pollingInterval)
        
        if getgenv().AutoJoinConfig and getgenv().AutoJoinConfig.enabled then
            pcall(function()
                local mode = getgenv().AutoJoinConfig.mode
                if not mode then return end
                
                local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not hrp then return end
                
                local teleporterFolder = workspace:FindFirstChild("TeleporterFolder")
                if not teleporterFolder then return end
                
                local doorFolder
                
                if mode == "Raid" then
                    doorFolder = teleporterFolder:FindFirstChild("Raids")
                elseif mode == "Siege" then
                    doorFolder = teleporterFolder:FindFirstChild("Siege")
                elseif mode == "Dungeon" then
                    doorFolder = teleporterFolder:FindFirstChild("Dungeon")
                elseif mode == "Survival" then
                    doorFolder = teleporterFolder:FindFirstChild("Survival")
                elseif mode == "Story" or mode == "Infinite" or mode == "LegendaryStages" then
                    doorFolder = teleporterFolder:FindFirstChild("Story")
                elseif mode == "Elemental Cavern" then
                    doorFolder = teleporterFolder:FindFirstChild("ElementalCaverns")
                elseif mode == "Challenge" then
                    doorFolder = teleporterFolder:FindFirstChild("Challenge")
                end
                
                if doorFolder then
                    for _, teleporter in pairs(doorFolder:GetChildren()) do
                        if teleporter:IsA("Model") and teleporter.Name == "Teleporter" then
                            local door = teleporter:FindFirstChild("Door")
                            if door and door:IsA("BasePart") then
                                hrp.CFrame = door.CFrame
                                return
                            end
                        end
                    end
                end
            end)
        end
    end
end)

task.spawn(function()
    local pollingInterval = MobileOptimizer:getPollingInterval(2)
    
    while task.wait(pollingInterval) do
        if not getgenv().AutoJoinConfig or not getgenv().AutoJoinConfig.enabled then
            continue
        end
        
        pcall(function()
            local mode = getgenv().AutoJoinConfig.mode
            local map = getgenv().AutoJoinConfig.map
            local act = getgenv().AutoJoinConfig.act or 1
            local difficulty = getgenv().AutoJoinConfig.difficulty or "Normal"
            
            if not mode or not map then return end
            
            local teleporter = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Teleporter")
            if not teleporter then return end
            
            if getgenv().AutoJoinConfig.friendsOnly then
                ErrorHandler:wrapAsync(function()
                    teleporter.Interact:FireServer("FriendsOnly")
                end, "Set friends only mode")
            end
            
            if mode == "Raid" then
                ErrorHandler:wrapAsync(function()
                    teleporter.Interact:FireServer("Select", map, act)
                end, "Select Raid mode")
                
            elseif mode == "Siege" then
                local siegeDiff = difficulty
                if difficulty == "Purgatory" or difficulty == "Insanity" then
                    siegeDiff = "Bounded"
                elseif difficulty == "Normal" or difficulty == "Nightmare" then
                    siegeDiff = "Normal"
                end
                ErrorHandler:wrapAsync(function()
                    teleporter.Select:FireServer(map, siegeDiff)
                end, "Select Siege mode")
                
            elseif mode == "Dungeon" then
                ErrorHandler:wrapAsync(function()
                    teleporter.Interact:FireServer("Select", map)
                end, "Select Dungeon mode")
                
            elseif mode == "Survival" then
                ErrorHandler:wrapAsync(function()
                    teleporter.Interact:FireServer("Select", map)
                end, "Select Survival mode")
                
            elseif mode == "Story" then
                local storyDiff = difficulty
                if difficulty == "Purgatory" or difficulty == "Insanity" then
                    storyDiff = "Nightmare"
                end
                ErrorHandler:wrapAsync(function()
                    teleporter.Interact:FireServer("Select", map, act, storyDiff, "Story")
                end, "Select Story mode")
                
            elseif mode == "Infinite" then
                local infDiff = difficulty
                if difficulty == "Purgatory" or difficulty == "Insanity" then
                    infDiff = "Nightmare"
                end
                ErrorHandler:wrapAsync(function()
                    teleporter.Interact:FireServer("Select", map, act, infDiff, "Infinite")
                end, "Select Infinite mode")
                
            elseif mode == "Elemental Cavern" then
                ErrorHandler:wrapAsync(function()
                    teleporter.Interact:FireServer("Select", map, difficulty)
                end, "Select Elemental Cavern mode")
                
            elseif mode == "Challenge" then
                ErrorHandler:wrapAsync(function()
                    teleporter.Interact:FireServer("Select", "Challenge", act)
                end, "Select Challenge mode")
            end
            
            if getgenv().AutoJoinConfig.autoStart then
                task.wait(0.5)
                
                local teleporter = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Teleporter")
                if teleporter and teleporter:FindFirstChild("Interact") then
                    ErrorHandler:wrapAsync(function()
                        teleporter.Interact:FireServer("Skip")
                    end, "Auto-start game")
                end
            end
        end)
    end
end)

local gameActionsSuccess, gameActionsErr = pcall(function()
    Sections.MainRight:Header({ Text = "📊 Quick Actions" })
    Sections.MainRight:SubLabel({ Text = "Fast toggles for common actions" })
end)
if not gameActionsSuccess then
    warn("[UI ERROR] Quick Actions header failed:", gameActionsErr)
    error("[FATAL] Cannot continue - Quick Actions header failed: " .. tostring(gameActionsErr))
end

local autoNextSuccess, autoNextErr = pcall(function()
    createToggle(
        Sections.MainRight,
        "Auto Next",
        "AutoNext",
        function(value)
            getgenv().AutoNextEnabled = value
            getgenv().Config.toggles.AutoNext = value
            saveConfig(getgenv().Config)
            Window:Notify({
                Title = "Auto Next",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().AutoNextEnabled
    )
end)
if not autoNextSuccess then
    warn("[UI ERROR] Auto Next toggle failed:", autoNextErr)
    error("[FATAL] Cannot continue - Auto Next toggle failed: " .. tostring(autoNextErr))
end

local autoRetrySuccess, autoRetryErr = pcall(function()
    createToggle(
        Sections.MainRight,
        "Auto Retry",
        "AutoRetry",
        function(value)
            getgenv().AutoFastRetryEnabled = value
            getgenv().Config.toggles.AutoRetry = value
            saveConfig(getgenv().Config)
            Window:Notify({
                Title = "Auto Retry",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().AutoFastRetryEnabled
    )
end)
if not autoRetrySuccess then
    warn("[UI ERROR] Auto Retry toggle failed:", autoRetryErr)
    error("[FATAL] Cannot continue - Auto Retry toggle failed: " .. tostring(autoRetryErr))
end

local autoLeaveSuccess, autoLeaveErr = pcall(function()
    createToggle(
        Sections.MainRight,
        "Auto Leave",
        "AutoLeave",
        function(value)
            getgenv().AutoLeaveEnabled = value
            getgenv().Config.toggles.AutoLeave = value
            saveConfig(getgenv().Config)
            Window:Notify({
                Title = "Auto Leave",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().AutoLeaveEnabled
    )
end)
if not autoLeaveSuccess then
    warn("[UI ERROR] Auto Leave toggle failed:", autoLeaveErr)
    error("[FATAL] Cannot continue - Auto Leave toggle failed: " .. tostring(autoLeaveErr))
end

local autoSmartSuccess, autoSmartErr = pcall(function()
    createToggle(
        Sections.MainRight,
        "Auto Next/Replay/Leave",
        "AutoSmart",
        function(value)
            getgenv().AutoSmartEnabled = value
            getgenv().Config.toggles.AutoSmart = value
            saveConfig(getgenv().Config)
            Window:Notify({
                Title = "Auto Next/Replay/Leave",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().AutoSmartEnabled
    )
end)
if not autoSmartSuccess then
    warn("[UI ERROR] Auto Next/Replay/Leave toggle failed:", autoSmartErr)
    error("[FATAL] Cannot continue - Auto Next/Replay/Leave toggle failed: " .. tostring(autoSmartErr))
end

local autoReadySuccess, autoReadyErr = pcall(function()
    createToggle(
        Sections.MainRight,
        "Auto Ready",
        "AutoReady",
        function(value)
            getgenv().AutoReadyEnabled = value
            Window:Notify({
                Title = "Auto Ready",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().AutoReadyEnabled
    )
end)
if not autoReadySuccess then
    warn("[UI ERROR] Auto Ready toggle failed:", autoReadyErr)
    error("[FATAL] Cannot continue - Auto Ready toggle failed: " .. tostring(autoReadyErr))
end

getgenv()._getPlayerUnits = function()
    local units = {}
    local success = pcall(function()
        local modules = RS:FindFirstChild("Modules")
        if not modules then return end
        
        local UnitNames = nil
        pcall(function()
            local unitNamesModule = modules:FindFirstChild("UnitNames")
            if unitNamesModule and unitNamesModule:IsA("ModuleScript") then
                UnitNames = require(unitNamesModule)
            end
        end)
        
        local clientData = modules:FindFirstChild("ClientData")
        if not clientData then return end
        
        local data = require(clientData)
        if not data or not data.UnitData then return end
        
        for unitID, unitInfo in pairs(data.UnitData) do
            if unitInfo.UnitName and unitInfo.Level and unitInfo.Quirk then
                local inGameName = unitInfo.UnitName
                if UnitNames and UnitNames[unitInfo.UnitName] then
                    inGameName = UnitNames[unitInfo.UnitName]
                end
                
                local displayName = string.format("%s (Lv%d, %s)", inGameName, unitInfo.Level, unitInfo.Quirk)
                table.insert(units, {
                    display = displayName,
                    unitID = unitID,
                    unitName = unitInfo.UnitName,
                    level = unitInfo.Level,
                    quirk = unitInfo.Quirk,
                    enchant = unitInfo.Enchant or "None"
                })
            end
        end
    end)
    
    if not success then
        warn("[AutoEnchant] Failed to retrieve unit data")
    end
    
    return units
end

getgenv()._getUnitEnchant = function(unitID)
    local enchant = "None"
    local success = pcall(function()
        local modules = RS:FindFirstChild("Modules")
        if not modules then return end
        
        local clientData = modules:FindFirstChild("ClientData")
        if not clientData then return end
        
        local data = require(clientData)
        if not data or not data.UnitData or not data.UnitData[unitID] then return end
        
        enchant = data.UnitData[unitID].Enchant or "None"
    end)
    
    if not success then
        warn("[AutoEnchant] Failed to get enchant for unit " .. tostring(unitID))
    end
    
    return enchant
end

getgenv()._findUnitByDisplay = function(displayName)
    local units = getgenv()._getPlayerUnits()
    for _, unit in ipairs(units) do
        if unit.display == displayName then
            return unit
        end
    end
    return nil
end






getgenv().CandyCards = {
    ["Weakened Resolve I"] = 13,
    ["Weakened Resolve II"] = 11,
    ["Weakened Resolve III"] = 4,
    ["Fog of War I"] = 12,
    ["Fog of War II"] = 10,
    ["Fog of War III"] = 5,
    ["Lingering Fear I"] = 6,
    ["Lingering Fear II"] = 2,
    ["Power Reversal I"] = 14,
    ["Power Reversal II"] = 9,
    ["Greedy Vampire's"] = 8,
    ["Hellish Gravity"] = 3,
    ["Deadly Striker"] = 7,
    ["Critical Denial"] = 1,
    ["Trick or Treat Coin Flip"] = 15
}

getgenv().DevilSacrifice = { ["Devil's Sacrifice"] = 999 }

getgenv().OtherCards = {
    ["Bullet Breaker I"] = 999, ["Bullet Breaker II"] = 999, ["Bullet Breaker III"] = 999,
    ["Hell Merchant I"] = 999, ["Hell Merchant II"] = 999, ["Hell Merchant III"] = 999,
    ["Hellish Warp I"] = 999, ["Hellish Warp II"] = 999,
    ["Fiery Surge I"] = 999, ["Fiery Surge II"] = 999,
    ["Grevious Wounds I"] = 999, ["Grevious Wounds II"] = 999,
    ["Scorching Hell I"] = 999, ["Scorching Hell II"] = 999,
    ["Fortune Flow"] = 999, ["Soul Link"] = 999,
    ["Seeting Bloodlust"] = 999
}

getgenv().BossRushGeneral = {
    ["Metal Skin"] = 0, ["Raging Power"] = 0, ["Demon Takeover"] = 0, ["Fortune"] = 0,
    ["Chaos Eater"] = 0, ["Godspeed"] = 0, ["Insanity"] = 0, ["Feeding Madness"] = 0, ["Emotional Damage"] = 0
}

getgenv().BabyloniaCastle = {}

pcall(function()
    local babyloniaModule = RS:FindFirstChild("Modules"):FindFirstChild("CardHandler"):FindFirstChild("BossRushCards"):FindFirstChild("Babylonia Castle")
    if babyloniaModule then
        local cards = require(babyloniaModule)
        for _, card in pairs(cards) do
            if card.CardName then
                getgenv().BabyloniaCastle[card.CardName] = card
            end
        end
    end
end)

local function initializeCardPriorities(sourceTable, targetTable, keyPrefix)
    if not sourceTable then return end
    keyPrefix = keyPrefix or "Card_"
    
    for cardName, defaultPriority in pairs(sourceTable) do
        local configKey = keyPrefix .. cardName
        local savedValue = getgenv().Config.inputs[configKey]
        targetTable[cardName] = savedValue and tonumber(savedValue) or defaultPriority
    end
end

getgenv().CardPriority = getgenv().CardPriority or {}
initializeCardPriorities(getgenv().CandyCards, getgenv().CardPriority)
initializeCardPriorities(getgenv().DevilSacrifice, getgenv().CardPriority)
initializeCardPriorities(getgenv().OtherCards, getgenv().CardPriority)

getgenv().BossRushCardPriority = getgenv().BossRushCardPriority or {}
initializeCardPriorities(getgenv().BossRushGeneral, getgenv().BossRushCardPriority, "BossRush_")
initializeCardPriorities(getgenv().BabyloniaCastle, getgenv().BossRushCardPriority, "BabyloniaCastle_")

getgenv().SlimeRushBuffCards = {
    ["Hasty I"] = 1,
    ["Hasty II"] = 2,
    ["Precision I"] = 3,
    ["Precision II"] = 4,
    ["True Sight I"] = 5,
    ["True Sight II"] = 6,
    ["Momentum"] = 7,
    ["Fiery Surge I"] = 8,
    ["Fiery Surge II"] = 9,
    ["Hellish Warp I"] = 10,
    ["Hellish Warp II"] = 11,
    ["Entrepreneur"] = 12
}

getgenv().SlimeRushDebuffCards = {
    ["Intimidation I"] = 1,
    ["Intimidation II"] = 2,
    ["Blinded I"] = 3,
    ["Blinded II"] = 4,
    ["Restriction I"] = 5,
    ["Restriction II"] = 6,
    ["Obstruction I"] = 7,
    ["Obstruction II"] = 8,
    ["Prevention I"] = 9,
    ["Prevention II"] = 10
}

getgenv().SlimeRushSacrifice = {
    ["Sacrifice"] = 999
}

getgenv().SlimeRushCardPriority = getgenv().SlimeRushCardPriority or {}
initializeCardPriorities(getgenv().SlimeRushBuffCards, getgenv().SlimeRushCardPriority, "SlimeRush_")
initializeCardPriorities(getgenv().SlimeRushDebuffCards, getgenv().SlimeRushCardPriority, "SlimeRush_")
initializeCardPriorities(getgenv().SlimeRushSacrifice, getgenv().SlimeRushCardPriority, "SlimeRush_")

getgenv().CardSelectionEnabled = getgenv().Config.toggles.CardSelectionToggle or false
getgenv().SlimeRushEnabled = getgenv().Config.toggles.SlimeRushToggle or false
getgenv().SlimeRushCardSelectionEnabled = getgenv().Config.toggles.SlimeRushCardToggle or false
getgenv().SlimeRushSlowerCardSelectionEnabled = getgenv().Config.toggles.SlimeRushSlowerCardToggle or false
getgenv().SlimeRushSmartCardSelectionEnabled = getgenv().Config.toggles.SlimeRushSmartCardToggle or false
getgenv().SlowerCardSelectionEnabled = getgenv().Config.toggles.SlowerCardSelectionToggle or false


local savedPortalConfig = getgenv().Config.portals or {}
getgenv().PortalConfig = {
    selectedMap = savedPortalConfig.selectedMap or "",
    tier = savedPortalConfig.tier or 1,
    useBestPortal = savedPortalConfig.useBestPortal or false,
    useSelectedTier = savedPortalConfig.useSelectedTier or false,
    pickPortal = savedPortalConfig.pickPortal or false,
    autoPickReward = savedPortalConfig.autoPickReward or false,
    priorities = savedPortalConfig.priorities or {
        ["Tower Limit"] = 0,
        ["Immunity"] = 0,
        ["Speedy"] = 0,
        ["No Hit"] = 0,
        ["Flight"] = 0,
        ["Short Range"] = 0,
        ["High Cost"] = 0
    }
}
getgenv().Config.portals = getgenv().PortalConfig

Sections.PortalsRight:Header({ Text = "🌀 Portal Selection" })
Sections.PortalsRight:SubLabel({ Text = "Configure automatic portal selection" })

local function getPortalMaps()
    local maps = {}
    pcall(function()
        local mapData = RS:FindFirstChild("Modules") and RS.Modules:FindFirstChild("MapData")
        if mapData and mapData:IsA("ModuleScript") then
            local data = require(mapData)
            for mapName, mapInfo in pairs(data) do
                if mapInfo.Type and type(mapInfo.Type) == "table" then
                    for _, mapType in ipairs(mapInfo.Type) do
                        if mapType == "Portal" then
                            table.insert(maps, mapName)
                            break
                        end
                    end
                end
            end
        end
    end)
    table.sort(maps)
    return #maps > 0 and maps or {"No Portal Maps Found"}
end

local portalMaps = getPortalMaps()
local portalMapDefault = 1
if getgenv().PortalConfig.selectedMap and getgenv().PortalConfig.selectedMap ~= "" then
    for i, mapName in ipairs(portalMaps) do
        if mapName == getgenv().PortalConfig.selectedMap then
            portalMapDefault = i
            break
        end
    end
end

createDropdown(
    Sections.PortalsRight,
    "Select Map",
    "PortalMap",
    portalMaps,
    false,
    function(value)
        getgenv().PortalConfig.selectedMap = value
        getgenv().Config.portals.selectedMap = value
        saveConfig(getgenv().Config)
    end,
    portalMapDefault
)

Sections.PortalsRight:Divider()

Sections.PortalsRight:Header({ Text = "⚙️ Portal Options" })
Sections.PortalsRight:SubLabel({ Text = "Additional portal settings" })

local tierOptions = {}
for i = 1, 10 do
    table.insert(tierOptions, tostring(i))
end

createDropdown(
    Sections.PortalsRight,
    "Portal Tier",
    "PortalTier",
    tierOptions,
    false,
    function(value)
        getgenv().PortalConfig.tier = tonumber(value) or 1
        getgenv().Config.portals.tier = tonumber(value) or 1
        saveConfig(getgenv().Config)
    end,
    getgenv().PortalConfig.tier
)

createToggle(
    Sections.PortalsRight,
    "Use Best Portal (Highest Tier)",
    "UseBestPortal",
    function(value)
        getgenv().PortalConfig.useBestPortal = value
        getgenv().Config.portals.useBestPortal = value
        
        if value and getgenv().PortalConfig.useSelectedTier then
            getgenv().PortalConfig.useSelectedTier = false
            getgenv().Config.portals.useSelectedTier = false
            saveConfig(getgenv().Config)
            pcall(function()
                if MacLib.Flags["UseSelectedTier"] then
                    MacLib.Flags["UseSelectedTier"]:UpdateState(false)
                end
            end)
        end
        
        saveConfig(getgenv().Config)
        Window:Notify({
            Title = "Portal System",
            Description = value and "Will use highest tier portal available" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().PortalConfig.useBestPortal
)

createToggle(
    Sections.PortalsRight,
    "Use Selected Tier",
    "UseSelectedTier",
    function(value)
        getgenv().PortalConfig.useSelectedTier = value
        getgenv().Config.portals.useSelectedTier = value
        
        if value and getgenv().PortalConfig.useBestPortal then
            getgenv().PortalConfig.useBestPortal = false
            getgenv().Config.portals.useBestPortal = false
            saveConfig(getgenv().Config)
            pcall(function()
                if MacLib.Flags["UseBestPortal"] then
                    MacLib.Flags["UseBestPortal"]:UpdateState(false)
                end
            end)
        end
        
        saveConfig(getgenv().Config)
        Window:Notify({
            Title = "Portal System",
            Description = value and "Will use selected map and tier" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().PortalConfig.useSelectedTier or false
)

createToggle(
    Sections.PortalsRight,
    "Auto Pick Portal Reward",
    "AutoPickPortalReward",
    function(value)
        getgenv().PortalConfig.autoPickReward = value
        getgenv().Config.portals.autoPickReward = value
        saveConfig(getgenv().Config)
        Window:Notify({
            Title = "Portal System",
            Description = value and "Auto pick portal reward enabled" or "Auto pick portal reward disabled",
            Lifetime = 3
        })
    end,
    getgenv().PortalConfig.autoPickReward or false
)

Sections.PortalsRight:SubLabel({
    Text = "⚠️ Portal rewards are selected randomly (fast method)"
})

Sections.PortalsRight:Divider()

Sections.PortalsLeft:Header({ Text = "🎯 Challenge Priority" })
Sections.PortalsLeft:SubLabel({ Text = "Assign priority (1-7) to each challenge. 1 = highest priority, 0 = ignore" })

createInput(
    Sections.PortalsLeft,
    "Tower Limit",
    "PortalPriority_TowerLimit",
    "1-7 or 0 to ignore",
    "Numeric",
    function(value)
        local num = tonumber(value) or 0
        getgenv().PortalConfig.priorities["Tower Limit"] = num
        getgenv().Config.portals.priorities["Tower Limit"] = num
        saveConfig(getgenv().Config)
    end,
    tostring(getgenv().PortalConfig.priorities["Tower Limit"])
)

createInput(
    Sections.PortalsLeft,
    "Immunity",
    "PortalPriority_Immunity",
    "1-7 or 0 to ignore",
    "Numeric",
    function(value)
        local num = tonumber(value) or 0
        getgenv().PortalConfig.priorities["Immunity"] = num
        getgenv().Config.portals.priorities["Immunity"] = num
        saveConfig(getgenv().Config)
    end,
    tostring(getgenv().PortalConfig.priorities["Immunity"])
)

createInput(
    Sections.PortalsLeft,
    "Speedy",
    "PortalPriority_Speedy",
    "1-7 or 0 to ignore",
    "Numeric",
    function(value)
        local num = tonumber(value) or 0
        getgenv().PortalConfig.priorities["Speedy"] = num
        getgenv().Config.portals.priorities["Speedy"] = num
        saveConfig(getgenv().Config)
    end,
    tostring(getgenv().PortalConfig.priorities["Speedy"])
)

createInput(
    Sections.PortalsLeft,
    "No Hit",
    "PortalPriority_NoHit",
    "1-7 or 0 to ignore",
    "Numeric",
    function(value)
        local num = tonumber(value) or 0
        getgenv().PortalConfig.priorities["No Hit"] = num
        getgenv().Config.portals.priorities["No Hit"] = num
        saveConfig(getgenv().Config)
    end,
    tostring(getgenv().PortalConfig.priorities["No Hit"])
)

createInput(
    Sections.PortalsLeft,
    "Flight",
    "PortalPriority_Flight",
    "1-7 or 0 to ignore",
    "Numeric",
    function(value)
        local num = tonumber(value) or 0
        getgenv().PortalConfig.priorities["Flight"] = num
        getgenv().Config.portals.priorities["Flight"] = num
        saveConfig(getgenv().Config)
    end,
    tostring(getgenv().PortalConfig.priorities["Flight"])
)

createInput(
    Sections.PortalsLeft,
    "Short Range",
    "PortalPriority_ShortRange",
    "1-7 or 0 to ignore",
    "Numeric",
    function(value)
        local num = tonumber(value) or 0
        getgenv().PortalConfig.priorities["Short Range"] = num
        getgenv().Config.portals.priorities["Short Range"] = num
        saveConfig(getgenv().Config)
    end,
    tostring(getgenv().PortalConfig.priorities["Short Range"])
)

createInput(
    Sections.PortalsLeft,
    "High Cost",
    "PortalPriority_HighCost",
    "1-7 or 0 to ignore",
    "Numeric",
    function(value)
        local num = tonumber(value) or 0
        getgenv().PortalConfig.priorities["High Cost"] = num
        getgenv().Config.portals.priorities["High Cost"] = num
        saveConfig(getgenv().Config)
    end,
    tostring(getgenv().PortalConfig.priorities["High Cost"])
)


do
Sections.InfinityCastleLeft:Header({ Text = "🏯 Auto Join Infinity Castle" })
Sections.InfinityCastleLeft:SubLabel({ Text = "Automatically join Infinity Castle with your preferred difficulty" })

if not getgenv().InfinityCastleAutoJoinEnabled then
    getgenv().InfinityCastleAutoJoinEnabled = getgenv().Config.toggles.InfinityCastleAutoJoinToggle or false
end

if not getgenv().InfinityCastleDifficulty then
    getgenv().InfinityCastleDifficulty = getgenv().Config.inputs.InfinityCastleDifficulty or "Easy"
end

createToggle(
    Sections.InfinityCastleLeft,
    "Auto Join Infinity Castle",
    "InfinityCastleAutoJoinToggle",
    function(value)
        getgenv().InfinityCastleAutoJoinEnabled = value
        Window:Notify({
            Title = "Infinity Castle",
            Description = value and "Auto Join Enabled" or "Auto Join Disabled",
            Lifetime = 3
        })
    end,
    getgenv().InfinityCastleAutoJoinEnabled
)

createDropdown(
    Sections.InfinityCastleLeft,
    "Difficulty",
    "InfinityCastleDifficulty",
    {"Easy", "Hard"},
    false,
    function(value)
        getgenv().InfinityCastleDifficulty = value
        Window:Notify({
            Title = "Infinity Castle",
            Description = "Difficulty set to: " .. value,
            Lifetime = 3
        })
    end,
    getgenv().InfinityCastleDifficulty
)

Sections.InfinityCastleLeft:SubLabel({
    Text = "Select difficulty and enable auto join to automatically enter Infinity Castle"
})

task.spawn(function()
    local pollingInterval = MobileOptimizer:getPollingInterval(2)
    
    while true do
        task.wait(pollingInterval)
        
        if getgenv().InfinityCastleAutoJoinEnabled then
            ErrorHandler:wrapAsync(function()
                local remotes = RS:FindFirstChild("Remotes")
                local infinityCastleRemotes = remotes and remotes:FindFirstChild("InfinityCastle")
                local enterEvent = infinityCastleRemotes and infinityCastleRemotes:FindFirstChild("Enter")
                
                if enterEvent then
                    if getgenv().WaitForPlayerEnabled then
                        local entryUI = nil
                        for _, gui in ipairs(LocalPlayer.PlayerGui:GetChildren()) do
                            if gui.Name:find("Entry") then
                                entryUI = gui
                                break
                            end
                        end
                        
                        if entryUI then
                            local function findTextLabel(parent)
                                for _, child in ipairs(parent:GetDescendants()) do
                                    if child:IsA("TextLabel") and child.Text:find("Players") then
                                        return child
                                    end
                                end
                                return nil
                            end
                            
                            local textLabel = findTextLabel(entryUI)
                            if textLabel then
                                local waitStartTime = tick()
                                local maxWaitTime = 300
                                
                                while tick() - waitStartTime < maxWaitTime do
                                    local text = textLabel.Text
                                    local current, max = text:match("%((%d+)/(%d+)%)")
                                    
                                    if current and max then
                                        local currentPlayers = tonumber(current)
                                        local targetCount = getgenv().WaitForPlayerCount or 1
                                        
                                        if currentPlayers >= targetCount then
                                            print("[Infinity Castle] ✅ " .. currentPlayers .. "/" .. targetCount .. " players ready, joining...")
                                            break
                                        else
                                            print("[Infinity Castle] ⏳ Waiting for players... " .. currentPlayers .. "/" .. targetCount)
                                        end
                                    end
                                    
                                    task.wait(1)
                                end
                            end
                        end
                    end
                    
                    local isHardMode = getgenv().InfinityCastleDifficulty == "Hard"
                    enterEvent:FireServer(isHardMode)
                    
                    Window:Notify({
                        Title = "Infinity Castle",
                        Description = "Joining " .. getgenv().InfinityCastleDifficulty .. " mode...",
                        Lifetime = 3
                    })
                    
                    task.wait(5)
                end
            end)
        end
    end
end)


end

do
Sections.EventLeft:Header({ Text = "🎃 Event Automation" })
Sections.EventLeft:SubLabel({ Text = "Automatically join and start events" })

createToggle(
    Sections.EventLeft,
    "Auto Event Join",
    "AutoEventToggle",
    function(value)
        getgenv().AutoEventEnabled = value
        Window:Notify({
            Title = "Auto Event",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().Config.toggles.AutoEventToggle or false
)

createInput(
    Sections.EventLeft,
    "Join Delay (seconds)",
    "EventJoinDelay",
    "Delay before joining event (0 = instant)",
    "Number",
    function(value)
        local delay = tonumber(value) or 0
        getgenv().EventJoinDelay = delay
        Window:Notify({
            Title = "Event Join Delay",
            Description = "Set to " .. delay .. " seconds",
            Lifetime = 2
        })
    end,
    tostring(getgenv().Config.inputs.EventJoinDelay or 0)
)

local LOBBY_PLACEIDS = {12886143095, 18583778121}
local function checkIsInLobby()
    for _, placeId in ipairs(LOBBY_PLACEIDS) do
        if game.PlaceId == placeId then return true end
    end
    return false
end
local isInLobby = checkIsInLobby()

if isInLobby then
    Sections.EventLeft:Divider()
    
    Sections.EventLeft:Header({ Text = "🎲 Auto Bingo" })
    Sections.EventLeft:SubLabel({ Text = "Complete bingo cards automatically" })
    
    createToggle(
        Sections.EventLeft,
        "Enable Auto Bingo",
        "BingoToggle",
        function(value)
            getgenv().BingoEnabled = value
            Window:Notify({
                Title = "Auto Bingo",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().Config.toggles.BingoToggle or false
    )
    
    Sections.EventLeft:Divider()
    
    Sections.EventLeft:Header({ Text = "🎁 Auto Capsules" })
    Sections.EventLeft:SubLabel({ Text = "Open event capsules automatically" })
    
    createToggle(
        Sections.EventLeft,
        "Enable Auto Capsules",
        "CapsuleToggle",
        function(value)
            getgenv().CapsuleEnabled = value
            Window:Notify({
                Title = "Auto Capsules",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().Config.toggles.CapsuleToggle or false
    )
    
    createToggle(
        Sections.EventLeft,
        "Auto Buy Capsule",
        "AutoBuyCapsuleToggle",
        function(value)
            getgenv().AutoBuyCapsuleEnabled = value
            Window:Notify({
                Title = "Auto Buy Capsule",
                Description = value and "Enabled - Will only purchase, not open" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().Config.toggles.AutoBuyCapsuleToggle or false
    )
    
    Sections.EventLeft:Divider()
    
    Sections.EventLeft:Header({ Text = "💰 Auto Sell Capsule Units" })
    Sections.EventLeft:SubLabel({ Text = "Automatically sell specific units from Event 1 capsules" })
    
    getgenv().AutoSellEvent1CapsuleEnabled = getgenv().Config.toggles.AutoSellEvent1CapsuleEnabled or false
    getgenv().AutoSellEvent1CapsuleUnits = getgenv().Config.dropdowns.AutoSellEvent1CapsuleUnits or {}
    
    if not getgenv()._Event1CapsuleUnitCache then
        getgenv()._Event1CapsuleUnitCache = {}
    end
    
    local function initializeEvent1CapsuleCache()
        local clientData = getgenv().GetClientData and getgenv().GetClientData()
        if clientData and clientData.UnitData then
            getgenv()._Event1CapsuleUnitCache = {}
            for unitID, unitData in pairs(clientData.UnitData) do
                if unitData.UnitName then
                    getgenv()._Event1CapsuleUnitCache[unitID] = {
                        UnitName = unitData.UnitName,
                        ObtainTime = unitData.ObtainTime or 0
                    }
                end
            end
            print("[Auto Sell Event1 Capsule] Cached " .. #getgenv()._Event1CapsuleUnitCache .. " existing units")
        end
    end
    
    task.spawn(function()
        task.wait(3)
        initializeEvent1CapsuleCache()
    end)
    
    local event1CapsuleUnitList = {
        "MobUnevo",
        "LightUnevo",
        "AsuraUnevo",
        "LelouchUnevo",
        "LelouchUnevoShiny"
    }
    
    local function getEvent1UnitDisplayNames()
        local displayNames = {}
        local unitNameModule = getgenv().GetAllAbilities and getgenv().GetAllAbilities()
        
        for _, unitName in ipairs(event1CapsuleUnitList) do
            local displayName = unitName
            if unitNameModule and unitNameModule[unitName] then
                displayName = unitNameModule[unitName].displayName or unitName
            end
            table.insert(displayNames, displayName)
        end
        
        return displayNames
    end
    
    createToggle(
        Sections.EventLeft,
        "Auto Sell Capsule Units",
        "AutoSellEvent1CapsuleEnabled",
        function(value)
            getgenv().AutoSellEvent1CapsuleEnabled = value
            Window:Notify({
                Title = "Auto Sell Event1 Capsule",
                Description = value and "Enabled - Will sell selected units" or "Disabled",
                Lifetime = 3
            })
            
            if value then
                initializeEvent1CapsuleCache()
            end
        end,
        getgenv().AutoSellEvent1CapsuleEnabled
    )
    
    createDropdown(
        Sections.EventLeft,
        "Units to Sell",
        "AutoSellEvent1CapsuleUnits",
        getEvent1UnitDisplayNames(),
        true,
        function(value)
            getgenv().AutoSellEvent1CapsuleUnits = value
            local selectedCount = 0
            for _, selected in pairs(value) do
                if selected then selectedCount = selectedCount + 1 end
            end
            Window:Notify({
                Title = "Auto Sell Units",
                Description = selectedCount .. " units selected for auto-sell",
                Lifetime = 3
            })
        end,
        getgenv().AutoSellEvent1CapsuleUnits
    )
    
    Sections.EventLeft:Divider()
end

local eventHeaderSuccess, eventHeaderErr = pcall(function()
    Sections.EventLeft:Header({ Text = "⚙️ Card Selection Mode" })
    Sections.EventLeft:SubLabel({ Text = "Choose between fast or reliable selection" })
end)
if not eventHeaderSuccess then
    warn("[UI ERROR] Event tab header failed:", eventHeaderErr)
    error("[FATAL] Cannot continue - Event tab header failed: " .. tostring(eventHeaderErr))
end

local fastModeToggle, slowerModeToggle, smartModeToggle

getgenv().SmartCardSelectionEnabled = getgenv().Config.toggles.SmartCardSelectionToggle or false

local fastSuccess, fastErr = pcall(function()
    fastModeToggle = createToggle(
        Sections.EventLeft,
        "⚡ Fast Mode",
        "CardSelectionToggle",
        function(value)
            getgenv().CardSelectionEnabled = value
            if value then
                if slowerModeToggle then
                    getgenv().SlowerCardSelectionEnabled = false
                    getgenv().Config.toggles.SlowerCardSelectionToggle = false
                    pcall(function() slowerModeToggle:UpdateState(false) end)
                end
                if smartModeToggle then
                    getgenv().SmartCardSelectionEnabled = false
                    getgenv().Config.toggles.SmartCardSelectionToggle = false
                    pcall(function() smartModeToggle:UpdateState(false) end)
                end
                getgenv().SaveConfig(getgenv().Config)
            end
            Window:Notify({
                Title = "Card Selection",
                Description = value and "Fast Mode Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().CardSelectionEnabled
    )
end)
if not fastSuccess then
    warn("[UI ERROR] Fast Mode toggle failed:", fastErr)
end

local slowerSuccess, slowerErr = pcall(function()
    slowerModeToggle = createToggle(
        Sections.EventLeft,
        "🐢 Slower Mode (More Reliable)",
        "SlowerCardSelectionToggle",
        function(value)
            getgenv().SlowerCardSelectionEnabled = value
            if value then
                if fastModeToggle then
                    getgenv().CardSelectionEnabled = false
                    getgenv().Config.toggles.CardSelectionToggle = false
                    pcall(function() fastModeToggle:UpdateState(false) end)
                end
                if smartModeToggle then
                    getgenv().SmartCardSelectionEnabled = false
                    getgenv().Config.toggles.SmartCardSelectionToggle = false
                    pcall(function() smartModeToggle:UpdateState(false) end)
                end
                getgenv().SaveConfig(getgenv().Config)
            end
            Window:Notify({
                Title = "Card Selection",
                Description = value and "Slower Mode Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().SlowerCardSelectionEnabled
    )
end)
if not slowerSuccess then
    warn("[UI ERROR] Slower Mode toggle failed:", slowerErr)
end

local smartSuccess, smartErr = pcall(function()
    smartModeToggle = createToggle(
        Sections.EventLeft,
        "🧠 Smart Mode (Wave-Based)",
        "SmartCardSelectionToggle",
        function(value)
            getgenv().SmartCardSelectionEnabled = value
            getgenv().Config.toggles.SmartCardSelectionToggle = value
            if value then
                if fastModeToggle then
                    getgenv().CardSelectionEnabled = false
                    getgenv().Config.toggles.CardSelectionToggle = false
                    pcall(function() fastModeToggle:UpdateState(false) end)
                end
                if slowerModeToggle then
                    getgenv().SlowerCardSelectionEnabled = false
                    getgenv().Config.toggles.SlowerCardSelectionToggle = false
                    pcall(function() slowerModeToggle:UpdateState(false) end)
                end
            end
            getgenv().SaveConfig(getgenv().Config)
            Window:Notify({
                Title = "Card Selection",
                Description = value and "Smart Mode Enabled - Maximizes candy based on wave" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().SmartCardSelectionEnabled
    )
end)
if not smartSuccess then
    warn("[UI ERROR] Smart Mode toggle failed:", smartErr)
end

local paraSuccess, paraErr = pcall(function()
    Sections.EventLeft:SubLabel({ 
        Text = "Lower number = higher priority (1 is best, 999 to skip)"
    })
end)
if not paraSuccess then
    warn("[UI ERROR] Event instructions failed:", paraErr)
end


local candyHeaderSuccess, candyHeaderErr = pcall(function()
    Sections.EventRight:Header({ Text = "🃏 Card Priorities" })
    Sections.EventRight:SubLabel({ Text = "Lower number = higher priority (1 is best, 999 to skip)" })
    Sections.EventRight:Divider()
    Sections.EventRight:Header({ Text = "🍬 Candy Cards" })
end)
if not candyHeaderSuccess then
    warn("[UI ERROR] Candy Cards header failed:", candyHeaderErr)
    error("[FATAL] Cannot continue - Candy Cards header failed: " .. tostring(candyHeaderErr))
end

local candyInputsSuccess, candyInputsErr = pcall(function()
    createCardPriorityInputs(Sections.EventRight, getgenv().CandyCards, getgenv().CardPriority)
end)
if not candyInputsSuccess then
    warn("[UI ERROR] Candy Cards inputs failed:", candyInputsErr)
    error("[FATAL] Cannot continue - Candy Cards inputs failed: " .. tostring(candyInputsErr))
end

Sections.EventRight:Divider()

Sections.EventRight:Header({ Text = "😈 Devil's Sacrifice" })
createCardPriorityInputs(Sections.EventRight, getgenv().DevilSacrifice, getgenv().CardPriority)

Sections.EventRight:Divider()

Sections.EventRight:Header({ Text = "📋 Other Cards" })
createCardPriorityInputs(Sections.EventRight, getgenv().OtherCards, getgenv().CardPriority)



end

do
Sections.Event2Left:Header({ Text = "🎃 Event 2 Automation" })
Sections.Event2Left:SubLabel({ Text = "Halloween Part 2 automation features" })

createToggle(
    Sections.Event2Left,
    "Auto Event Join (Part 2)",
    "AutoEvent2Toggle",
    function(value)
        getgenv().AutoEvent2Enabled = value
        Window:Notify({
            Title = "Auto Event 2",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().Config.toggles.AutoEvent2Toggle or false
)

createToggle(
    Sections.Event2Left,
    "Auto Candy Collector",
    "AutoCandyToggle",
    function(value)
        getgenv().AutoCandyEnabled = value
        Window:Notify({
            Title = "Auto Candy",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().Config.toggles.AutoCandyToggle or false
)

Sections.Event2Left:Divider()

Sections.Event2Left:Header({ Text = "🎁 Auto Capsules (Part 2)" })
Sections.Event2Left:SubLabel({ Text = "Open Halloween Part 2 capsules automatically" })

createToggle(
    Sections.Event2Left,
    "Enable Auto Capsules",
    "Capsule2Toggle",
    function(value)
        getgenv().Capsule2Enabled = value
        Window:Notify({
            Title = "Auto Capsules 2",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().Config.toggles.Capsule2Toggle or false
)

createToggle(
    Sections.Event2Left,
    "Auto Buy Capsule",
    "AutoBuyCapsule2Toggle",
    function(value)
        getgenv().AutoBuyCapsule2Enabled = value
        Window:Notify({
            Title = "Auto Buy Capsule 2",
            Description = value and "Enabled - Will only purchase, not open" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().Config.toggles.AutoBuyCapsule2Toggle or false
)

Sections.Event2Left:Divider()

Sections.Event2Left:Header({ Text = "🔄 Wave Restart" })
Sections.Event2Left:SubLabel({
    Text = "Automatically restart the match when reaching a specific wave"
})

createToggle(
    Sections.Event2Left,
    "Enable Wave Restart",
    "InfiniteRestartToggle",
    function(value)
        getgenv().InfiniteRestartEnabled = value
        Window:Notify({
            Title = "Wave Restart",
            Description = value and "Enabled - Will restart at wave " .. getgenv().InfiniteRestartWave or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().InfiniteRestartEnabled or false
)

createInput(
    Sections.Event2Left,
    "Restart at Wave",
    "InfiniteRestartWave",
    "Enter wave number (e.g., 50)",
    "Numeric",
    function(value)
        getgenv().InfiniteRestartWave = tonumber(value) or 50
        Window:Notify({
            Title = "Wave Restart",
            Description = "Will restart at wave " .. (tonumber(value) or 50),
            Lifetime = 3
        })
    end,
    tostring(getgenv().InfiniteRestartWave or 50)
)

Sections.Event2Right:Divider()
Sections.Event2Right:Header({ Text = "💰 Auto Sell Capsule Units" })
Sections.Event2Right:SubLabel({ Text = "Automatically sell specific units from capsules" })

getgenv().AutoSellCapsuleEnabled = getgenv().Config.toggles.AutoSellCapsuleEnabled or false
getgenv().AutoSellCapsuleUnits = getgenv().Config.dropdowns.AutoSellCapsuleUnits or {}

if not getgenv()._CapsuleUnitCache then
    getgenv()._CapsuleUnitCache = {}
end

local function initializeCapsuleCache()
    local clientData = getgenv().GetClientData and getgenv().GetClientData()
    if clientData and clientData.UnitData then
        getgenv()._CapsuleUnitCache = {}
        for unitID, unitData in pairs(clientData.UnitData) do
            if unitData.UnitName then
                getgenv()._CapsuleUnitCache[unitID] = {
                    UnitName = unitData.UnitName,
                    ObtainTime = unitData.ObtainTime or 0
                }
            end
        end
        print("[Auto Sell Capsule] Cached " .. #getgenv()._CapsuleUnitCache .. " existing units")
    end
end

task.spawn(function()
    task.wait(3)
    initializeCapsuleCache()
end)

local capsuleUnitList = {
    "ZamasuBlackGokuRoseUnevo",
    "AinzAlbedoUnevo",
    "SimonUnevo",
    "GokuVegitaSSJ4Unevo",
    "RimuruGodlyUnevo",
    "RimuruGodlyUnevoShiny"
}

local function getUnitDisplayNames()
    local displayNames = {}
    local unitNameModule = getgenv().GetAllAbilities and getgenv().GetAllAbilities()
    
    for _, unitName in ipairs(capsuleUnitList) do
        local displayName = unitName
        if unitNameModule and unitNameModule[unitName] then
            displayName = unitNameModule[unitName].displayName or unitName
        end
        table.insert(displayNames, displayName)
    end
    
    return displayNames
end

createToggle(
    Sections.Event2Right,
    "Auto Sell Capsule Units",
    "AutoSellCapsuleEnabled",
    function(value)
        getgenv().AutoSellCapsuleEnabled = value
        Window:Notify({
            Title = "Auto Sell Capsule",
            Description = value and "Enabled - Will sell selected units" or "Disabled",
            Lifetime = 3
        })
        
        if value then
            initializeCapsuleCache()
        end
    end,
    getgenv().AutoSellCapsuleEnabled
)

createDropdown(
    Sections.Event2Right,
    "Units to Sell",
    "AutoSellCapsuleUnits",
    getUnitDisplayNames(),
    true,
    function(value)
        getgenv().AutoSellCapsuleUnits = value
        local selectedCount = 0
        for _, selected in pairs(value) do
            if selected then selectedCount = selectedCount + 1 end
        end
        Window:Notify({
            Title = "Auto Sell Units",
            Description = selectedCount .. " units selected for auto-sell",
            Lifetime = 3
        })
    end,
    getgenv().AutoSellCapsuleUnits
)



end

do
Sections.SlimeRushLeft:Header({ Text = "🟢 Slime Rush Settings" })
Sections.SlimeRushLeft:SubLabel({ Text = "Automatic card selection for Slime Rush" })

createToggle(
    Sections.SlimeRushLeft,
    "Enable Slime Rush",
    "SlimeRushToggle",
    function(value)
        getgenv().SlimeRushEnabled = value
        Window:Notify({
            Title = "Slime Rush",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().Config.toggles.SlimeRushToggle or false
)

Sections.SlimeRushLeft:Divider()

Sections.SlimeRushLeft:Header({ Text = "💡 How It Works" })
Sections.SlimeRushLeft:SubLabel({ 
    Text = "The script automatically selects cards by priority (1-999). Cards set to 999 are skipped. Adjust priorities on the right." 
})

Sections.SlimeRushLeft:Divider()

Sections.SlimeRushLeft:Header({ Text = "⚙️ Card Selection Mode" })
Sections.SlimeRushLeft:SubLabel({ Text = "Choose between fast or reliable selection" })

local slimeFastModeToggle, slimeSlowerModeToggle, slimeSmartModeToggle

slimeFastModeToggle = createToggle(
    Sections.SlimeRushLeft,
    "⚡ Fast Mode",
    "SlimeRushCardToggle",
    function(value)
        getgenv().SlimeRushCardSelectionEnabled = value
        if value then
            if slimeSlowerModeToggle then
                getgenv().SlimeRushSlowerCardSelectionEnabled = false
                getgenv().Config.toggles.SlimeRushSlowerCardToggle = false
                pcall(function() slimeSlowerModeToggle:UpdateState(false) end)
            end
            if slimeSmartModeToggle then
                getgenv().SlimeRushSmartCardSelectionEnabled = false
                getgenv().Config.toggles.SlimeRushSmartCardToggle = false
                pcall(function() slimeSmartModeToggle:UpdateState(false) end)
            end
        end
        Window:Notify({
            Title = "Slime Rush Fast Mode",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().SlimeRushCardSelectionEnabled
)

slimeSlowerModeToggle = createToggle(
    Sections.SlimeRushLeft,
    "🐌 Slower Mode (More Reliable)",
    "SlimeRushSlowerCardToggle",
    function(value)
        getgenv().SlimeRushSlowerCardSelectionEnabled = value
        if value then
            if slimeFastModeToggle then
                getgenv().SlimeRushCardSelectionEnabled = false
                getgenv().Config.toggles.SlimeRushCardToggle = false
                pcall(function() slimeFastModeToggle:UpdateState(false) end)
            end
            if slimeSmartModeToggle then
                getgenv().SlimeRushSmartCardSelectionEnabled = false
                getgenv().Config.toggles.SlimeRushSmartCardToggle = false
                pcall(function() slimeSmartModeToggle:UpdateState(false) end)
            end
        end
        Window:Notify({
            Title = "Slime Rush Slower Mode",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().SlimeRushSlowerCardSelectionEnabled
)

slimeSmartModeToggle = createToggle(
    Sections.SlimeRushLeft,
    "🧠 Smart Mode (Maximize Coins)",
    "SlimeRushSmartCardToggle",
    function(value)
        getgenv().SlimeRushSmartCardSelectionEnabled = value
        if value then
            if slimeFastModeToggle then
                getgenv().SlimeRushCardSelectionEnabled = false
                getgenv().Config.toggles.SlimeRushCardToggle = false
                pcall(function() slimeFastModeToggle:UpdateState(false) end)
            end
            if slimeSlowerModeToggle then
                getgenv().SlimeRushSlowerCardSelectionEnabled = false
                getgenv().Config.toggles.SlimeRushSlowerCardToggle = false
                pcall(function() slimeSlowerModeToggle:UpdateState(false) end)
            end
        end
        Window:Notify({
            Title = "Slime Rush Smart Mode",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().SlimeRushSmartCardSelectionEnabled
)

Sections.SlimeRushRight:Header({ Text = "📊 Card Priorities" })
Sections.SlimeRushRight:SubLabel({ 
    Text = "Lower number = higher priority (1 is best, 999 to skip)"
})

Sections.SlimeRushRight:Divider()
Sections.SlimeRushRight:Header({ Text = "✨ Buff Cards" })
createCardPriorityInputs(Sections.SlimeRushRight, getgenv().SlimeRushBuffCards, getgenv().SlimeRushCardPriority, "SlimeRush_")

Sections.SlimeRushRight:Divider()
Sections.SlimeRushRight:Header({ Text = "⚠️ Debuff Cards (Give Coins)" })
createCardPriorityInputs(Sections.SlimeRushRight, getgenv().SlimeRushDebuffCards, getgenv().SlimeRushCardPriority, "SlimeRush_")

Sections.SlimeRushRight:Divider()
Sections.SlimeRushRight:Header({ Text = "💀 Sacrifice (Skip Recommended)" })
createCardPriorityInputs(Sections.SlimeRushRight, getgenv().SlimeRushSacrifice, getgenv().SlimeRushCardPriority, "SlimeRush_")


end

do
Sections.BossRushLeft:Header({ Text = "⚔️ Boss Rush Settings" })
Sections.BossRushLeft:SubLabel({ Text = "Automatic card selection for Boss Rush" })

createToggle(
    Sections.BossRushLeft,
    "Enable Boss Rush",
    "BossRushToggle",
    function(value)
        getgenv().BossRushEnabled = value
        getgenv().Config.toggles.BossRushToggle = value
        saveConfig(getgenv().Config)
        Window:Notify({
            Title = "Boss Rush",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().BossRushEnabled
)

Sections.BossRushLeft:Divider()

Sections.BossRushLeft:Header({ Text = "💡 How It Works" })
Sections.BossRushLeft:SubLabel({ 
    Text = "The script automatically selects cards by priority (1-999). Cards set to 999 are skipped. Adjust priorities on the right." 
})

Sections.BossRushLeft:SubLabel({ 
    Text = "Lower number = higher priority • Set to 999 to avoid" 
})


Sections.BossRushRight:Header({ Text = "🃏 Card Priorities" })
Sections.BossRushRight:SubLabel({ Text = "Set priority for each card (1 = highest, 999 = skip)" })
Sections.BossRushRight:Divider()

Sections.BossRushRight:Header({ Text = "🎯 General Cards" })

createCardPriorityInputs(Sections.BossRushRight, getgenv().BossRushGeneral, getgenv().BossRushCardPriority, "BossRush_")

Sections.BossRushRight:Divider()

Sections.BossRushRight:Header({ Text = "🏰 Babylonia Castle Cards" })

pcall(function()
    local babyloniaModule = RS:FindFirstChild("Modules"):FindFirstChild("CardHandler"):FindFirstChild("BossRushCards"):FindFirstChild("Babylonia Castle")
    if babyloniaModule then
        local cards = require(babyloniaModule)
        for _, card in pairs(cards) do
            local cardName = card.CardName
            local cardType = card.CardType or "Buff"
            local inputKey = "BabyloniaCastle_" .. cardName
            
            if not getgenv().BossRushCardPriority then 
                getgenv().BossRushCardPriority = {} 
            end
            if not getgenv().BossRushCardPriority[cardName] then 
                getgenv().BossRushCardPriority[cardName] = 999 
            end
            
            local defaultValue = getgenv().Config.inputs[inputKey] or "999"
            
            createInput(
                Sections.BossRushRight,
                cardName .. " (" .. cardType .. ")",
                inputKey,
                "Priority (1-999)",
                "Numeric",
                function(value)
                    local num = tonumber(value)
                    if num then
                        getgenv().BossRushCardPriority[cardName] = num
                    end
                end,
                defaultValue
            )
            
            getgenv().BossRushCardPriority[cardName] = tonumber(defaultValue) or 999
        end
    end
end)



local UnitNames = nil
pcall(function()
    local unitNamesModule = RS:FindFirstChild("Modules") and RS.Modules:FindFirstChild("UnitNames")
    if unitNamesModule and unitNamesModule:IsA("ModuleScript") then
        UnitNames = require(unitNamesModule)
    end
end)

local function getUnitDisplayName(unitName)
    if UnitNames and UnitNames[unitName] then
        return UnitNames[unitName]
    end
    return unitName
end

local function getUnitFileName(displayName)
    if UnitNames then
        for fileName, displayNameInModule in pairs(UnitNames) do
            if displayNameInModule == displayName then
                return fileName
            end
        end
    end
    return displayName
end


getgenv().BulmaEnabled = getgenv().Config.toggles.BulmaToggle or false
getgenv().BulmaWishType = getgenv().Config.dropdowns.BulmaWishType or "Power"
getgenv().BulmaWishUsedThisRound = false

getgenv().WukongEnabled = getgenv().Config.toggles.WukongToggle or false
getgenv().WukongTrackedClones = {}

getgenv().SkeletonKnightEnabled = getgenv().Config.toggles.SkeletonKnightToggle or false
getgenv().SkeletonKnightTargetUnit = getgenv().Config.dropdowns.SkeletonKnightTargetUnit or ""
getgenv().SkeletonKnightLastUse = 0

getgenv().AlucardHypnosisEnabled = getgenv().Config.toggles.AlucardHypnosisToggle or false
getgenv().AlucardHypnosisTargetUnit = getgenv().Config.dropdowns.AlucardHypnosisTargetUnit or ""
getgenv().AlucardHypnosisLastUse = 0

getgenv().OneEyeDevilEnabled = getgenv().Config.toggles.OneEyeDevilToggle or false
getgenv().OneEyeDevilCurrentIndex = 0 

getgenv().EventJoinDelay = tonumber(getgenv().Config.inputs.EventJoinDelay) or 0
getgenv().AutoJoinDelay = tonumber(getgenv().Config.inputs.AutoJoinDelay) or 0

getgenv().FinalExpAutoJoinEasyEnabled = getgenv().Config.toggles.FinalExpAutoJoinEasyToggle or false
getgenv().FinalExpAutoJoinHardEnabled = getgenv().Config.toggles.FinalExpAutoJoinHardToggle or false
getgenv().FinalExpAutoSkipShopEnabled = getgenv().Config.toggles.FinalExpAutoSkipShopToggle or false
getgenv().FinalExpAutoSelectModeEnabled = getgenv().Config.toggles.FinalExpAutoSelectModeToggle or false
getgenv().FinalExpSkipRewardsEnabled = getgenv().Config.toggles.FinalExpSkipRewardsToggle or false

getgenv().FinalExpRestPriority = tonumber(getgenv().Config.inputs.FinalExpRestPriority) or 3
getgenv().FinalExpDungeonPriority = tonumber(getgenv().Config.inputs.FinalExpDungeonPriority) or 1
getgenv().FinalExpDoubleDungeonPriority = tonumber(getgenv().Config.inputs.FinalExpDoubleDungeonPriority) or 2
getgenv().FinalExpShopPriority = tonumber(getgenv().Config.inputs.FinalExpShopPriority) or 4

local BLACKLISTED_UNITS = {
    "NarutoBaryonClone"
}

local function isBlacklisted(unitName)
    for _, blacklisted in ipairs(BLACKLISTED_UNITS) do
        if unitName == blacklisted or unitName:find(blacklisted) then
            return true
        end
    end
    return false
end

if not getgenv()._AbilityUIElements then
    getgenv()._AbilityUIElements = {Left = {}, Right = {}}
end

local function clearAbilityUI()
    for side, elements in pairs(getgenv()._AbilityUIElements) do
        for _, element in ipairs(elements) do
            pcall(function()
                if element and element.Remove then
                    element:Remove()
                elseif element and element.SetVisibility then
                    element:SetVisibility(false)
                end
            end)
        end
    end
    getgenv()._AbilityUIElements = {Left = {}, Right = {}}
end


local function buildAutoAbilityUI()
    if getgenv()._AbilityUIBuilding then return end
    if getgenv()._AbilityUIBuilt then return end
    getgenv()._AbilityUIBuilding = true
    
    clearAbilityUI()
    
    local clientData = getClientData()
    if not clientData or not clientData.Slots then
        Window:Notify({
            Title = "Auto Ability",
            Description = "ClientData not available yet, retrying...",
            Lifetime = 3
        })
        getgenv()._AbilityUIBuilt = false
        getgenv()._AbilityUIBuilding = false
        return
    end
    
    local anyBuilt = false
    local success, err = pcall(function()
        if not Tabs or not Tabs.Abilities then
            warn("[Ability UI] Tabs.Abilities not found!")
            return
        end
        local unitsToShow = {}
        
        local sortedSlots = {"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}
        for slotIndex, slotName in ipairs(sortedSlots) do
            local slotData = clientData.Slots[slotName]
            if slotData and slotData.Value then
                local unitNameToUse = slotData.Value
                local isEZA = false
                                
                if slotData.UnitID then
                    if clientData.UnitData and clientData.UnitData[slotData.UnitID] then
                        local unitData = clientData.UnitData[slotData.UnitID]
                        if unitData.EZA == true then
                            isEZA = true
                            unitNameToUse = slotData.Value .. "EZA"
                        end
                    elseif clientData[slotData.UnitID] then
                        local unitData = clientData[slotData.UnitID]
                        if unitData.EZA == true then
                            isEZA = true
                            unitNameToUse = slotData.Value .. "EZA"
                        end
                    end
                end
                
                if isEZA then
                    getgenv().EZAUnitMapping[unitNameToUse] = slotData.Value
                end
                
                table.insert(unitsToShow, {
                    name = unitNameToUse,
                    originalName = slotData.Value,
                    slot = slotName,
                    level = slotData.Level or 0,
                    slotIndex = slotIndex,
                    isSpawned = false,
                    isEZA = isEZA
                })
            end
        end
        
        for _, unitInfo in ipairs(unitsToShow) do
            local unitName = unitInfo.name
            
            if isBlacklisted(unitName) then
                continue
            end
            
            if unitName == "Bulma" then
                continue
            end
            
            if unitName == "EtoEvo" then
                continue
            end
            
            if unitInfo.originalName == "Skull_Knight_Evo" and unitInfo.isEZA then
                continue
            end
            
            local abilities = getAllAbilities(unitName)
            
            if next(abilities) then
                local tabSide = "Right"
                local sideKey = tabSide
                
                local displayName = getUnitDisplayName(unitInfo.originalName or unitName)
                if unitInfo.isEZA then
                    displayName = displayName .. " ⚡"
                end
                
                local unitSection = Tabs.Abilities:Section({ Side = tabSide })
                table.insert(getgenv()._AbilityUIElements[sideKey], unitSection)
                
                local headerText = "📦 " .. displayName
                local sublabelText = unitInfo.slot .. " • Level " .. tostring(unitInfo.level)
                if unitInfo.isEZA then
                    sublabelText = sublabelText .. " • EZA"
                end
                
                unitSection:Header({ Text = headerText })
                unitSection:SubLabel({ Text = sublabelText })
                unitSection:Divider()
                
                anyBuilt = true
                
                local targetSection = unitSection
                
                if not getgenv().UnitAbilities then getgenv().UnitAbilities = {} end
                if not getgenv().UnitAbilities[unitName] then getgenv().UnitAbilities[unitName] = {} end
                if not getgenv().Config.abilities then getgenv().Config.abilities = {} end
                if not getgenv().Config.abilities[unitName] then getgenv().Config.abilities[unitName] = {} end
                    
                    local sortedAbilities = {}
                    for abilityName, data in pairs(abilities) do
                        table.insert(sortedAbilities, { name = abilityName, data = data })
                    end
                    table.sort(sortedAbilities, function(a, b)
                        local aLevel = (a.data and a.data.requiredLevel) or 0
                        local bLevel = (b.data and b.data.requiredLevel) or 0
                        return aLevel < bLevel
                    end)
                    
                    for _, ab in ipairs(sortedAbilities) do
                        local abilityName = ab.name
                        local abilityData = ab.data
                        
                        if unitName == "JinMoriGodly" and abilityName == "Clone Synthesis" then
                            continue
                        end
                        
                        local saved = getgenv().Config.abilities and 
                                     getgenv().Config.abilities[unitName] and 
                                     getgenv().Config.abilities[unitName][abilityName]
                        
                        local waveInputFlag = unitName .. "_" .. abilityName .. "_Wave"
                        local savedWave = getgenv().Config.inputs[waveInputFlag]
                        if savedWave and savedWave ~= "" then
                            savedWave = tonumber(savedWave)
                        else
                            savedWave = nil
                        end
                        
                        if not getgenv().UnitAbilities[unitName][abilityName] then
                            getgenv().UnitAbilities[unitName][abilityName] = {
                                enabled = (saved and saved.enabled) or false,
                                onlyOnBoss = (saved and saved.onlyOnBoss) or false,
                                specificWave = savedWave or (saved and saved.specificWave) or nil,
                                requireBossInRange = (saved and saved.requireBossInRange) or false,
                                useOnWave = (saved and saved.useOnWave) or false
                            }
                        end
                        
                        local cfg = getgenv().UnitAbilities[unitName][abilityName]
                        local defaultToggle = cfg.enabled
                        
                        local abilityIcon = abilityData.isAttribute and "🔒" or "⚡"
                        local abilityInfo = abilityIcon .. " " .. abilityName .. " (CD: " .. tostring(abilityData.cooldown) .. "s)"
                        
                        createToggle(
                            targetSection,
                            abilityInfo,
                            unitName .. "_" .. abilityName .. "_Toggle",
                            function(v)
                                cfg.enabled = v
                                getgenv().Config.abilities[unitName] = getgenv().Config.abilities[unitName] or {}
                                getgenv().Config.abilities[unitName][abilityName] = getgenv().Config.abilities[unitName][abilityName] or {}
                                getgenv().Config.abilities[unitName][abilityName].enabled = v
                                getgenv().SaveConfig(getgenv().Config)
                                
                                Window:Notify({
                                    Title = "Auto Ability",
                                    Description = abilityName .. " " .. (v and "Enabled" or "Disabled"),
                                    Lifetime = 2
                                })
                            end,
                            defaultToggle
                        )
                        
                        local modifierKey = unitName .. "_" .. abilityName .. "_Modifiers"
                        
                        local savedDropdown = getgenv().Config.dropdowns[modifierKey]
                        local defaultValue
                        
                        if savedDropdown and type(savedDropdown) == "table" then
                            defaultValue = {}
                            for optionName, isSelected in pairs(savedDropdown) do
                                if isSelected == true then
                                    table.insert(defaultValue, optionName)
                                end
                            end
                        else
                            defaultValue = {}
                            if cfg.onlyOnBoss then table.insert(defaultValue, "Only On Boss") end
                            if cfg.requireBossInRange then table.insert(defaultValue, "Boss In Range") end
                            if cfg.useOnWave then table.insert(defaultValue, "On Wave") end
                        end
                        
                        createDropdown(
                            targetSection,
                            "  > Conditions",
                            modifierKey,
                            {"Only On Boss", "Boss In Range", "On Wave"},
                            true,
                            function(Value)
                                local selectedSet = {}
                                if type(Value) == "table" then
                                    for k, v in pairs(Value) do
                                        if v == true then
                                            selectedSet[k] = true
                                        end
                                    end
                                end
                                
                                cfg.onlyOnBoss = selectedSet["Only On Boss"] == true
                                cfg.requireBossInRange = selectedSet["Boss In Range"] == true
                                cfg.useOnWave = selectedSet["On Wave"] == true
                                
                                getgenv().Config.abilities[unitName] = getgenv().Config.abilities[unitName] or {}
                                local store = getgenv().Config.abilities[unitName]
                                store[abilityName] = store[abilityName] or {}
                                store[abilityName].onlyOnBoss = cfg.onlyOnBoss
                                store[abilityName].requireBossInRange = cfg.requireBossInRange
                                store[abilityName].useOnWave = cfg.useOnWave
                                
                                getgenv().SaveConfig(getgenv().Config)
                            end,
                            defaultValue
                        )
                        
                        local waveFlag = unitName .. "_" .. abilityName .. "_Wave"
                        local waveDefault = ""
                        if cfg.specificWave then
                            waveDefault = tostring(cfg.specificWave)
                        elseif getgenv().Config.inputs[waveFlag] and getgenv().Config.inputs[waveFlag] ~= "" then
                            waveDefault = tostring(getgenv().Config.inputs[waveFlag])
                        end
                        
                        createInput(
                            targetSection,
                            "  > Wave Number",
                            waveFlag,
                            "Required if 'On Wave' selected",
                            "Numeric",
                            function(text)
                                local num = tonumber(text)
                                cfg.specificWave = num
                                getgenv().Config.abilities[unitName] = getgenv().Config.abilities[unitName] or {}
                                getgenv().Config.abilities[unitName][abilityName] = getgenv().Config.abilities[unitName][abilityName] or {}
                                getgenv().Config.abilities[unitName][abilityName].specificWave = num
                                getgenv().SaveConfig(getgenv().Config)
                            end,
                            waveDefault
                        )
                    end
                    
                    if unitName == "EscanorGodly" then
                        local success, err = pcall(function()
                            local clientData = getClientData()
                            
                            if clientData and clientData.UnitData and clientData.Slots then
                                local escanorUnitID = nil
                                for slotName, slotData in pairs(clientData.Slots) do
                                    if slotData.Value == "EscanorGodly" and slotData.UnitID then
                                        escanorUnitID = slotData.UnitID
                                        break
                                    end
                                end
                                
                                if escanorUnitID and clientData.UnitData[escanorUnitID] then
                                    local unitData = clientData.UnitData[escanorUnitID]
                                    
                                    if unitData.EquippedSoul == "SoulOfTheScarredSun" then
                                        local soulAbilityName = "Who Decided That?"
                                        
                                        if not getgenv().UnitAbilities[unitName][soulAbilityName] then
                                            local saved = getgenv().Config.abilities and 
                                                         getgenv().Config.abilities[unitName] and 
                                                         getgenv().Config.abilities[unitName][soulAbilityName]
                                            
                                            local waveInputFlag = unitName .. "_" .. soulAbilityName .. "_Wave"
                                            local savedWave = getgenv().Config.inputs[waveInputFlag]
                                            if savedWave and savedWave ~= "" then
                                                savedWave = tonumber(savedWave)
                                            else
                                                savedWave = nil
                                            end
                                            
                                            getgenv().UnitAbilities[unitName][soulAbilityName] = {
                                                enabled = (saved and saved.enabled) or false,
                                                onlyOnBoss = (saved and saved.onlyOnBoss) or false,
                                                specificWave = savedWave or (saved and saved.specificWave) or nil,
                                                requireBossInRange = (saved and saved.requireBossInRange) or false,
                                                useOnWave = (saved and saved.useOnWave) or false
                                            }
                                        end
                                        
                                        local cfg = getgenv().UnitAbilities[unitName][soulAbilityName]
                                        
                                        targetSection:Divider()
                                        targetSection:SubLabel({ Text = "🔥 Soul Ability (SoulOfTheScarredSun)" })
                                        
                                        createToggle(
                                            targetSection,
                                            "⚡ Who Decided That? (CD: 999999s)",
                                            unitName .. "_" .. soulAbilityName .. "_Toggle",
                                            function(v)
                                                cfg.enabled = v
                                                getgenv().Config.abilities[unitName] = getgenv().Config.abilities[unitName] or {}
                                                getgenv().Config.abilities[unitName][soulAbilityName] = getgenv().Config.abilities[unitName][soulAbilityName] or {}
                                                getgenv().Config.abilities[unitName][soulAbilityName].enabled = v
                                                getgenv().SaveConfig(getgenv().Config)
                                                
                                                Window:Notify({
                                                    Title = "Auto Ability",
                                                    Description = soulAbilityName .. " " .. (v and "Enabled" or "Disabled"),
                                                    Lifetime = 2
                                                })
                                            end,
                                            cfg.enabled
                                        )
                                        
                                        local modifierKey = unitName .. "_" .. soulAbilityName .. "_Modifiers"
                                        local savedDropdown = getgenv().Config.dropdowns[modifierKey]
                                        local defaultValue
                                        
                                        if savedDropdown and type(savedDropdown) == "table" then
                                            defaultValue = {}
                                            for optionName, isSelected in pairs(savedDropdown) do
                                                if isSelected == true then
                                                    table.insert(defaultValue, optionName)
                                                end
                                            end
                                        else
                                            defaultValue = {}
                                            if cfg.onlyOnBoss then table.insert(defaultValue, "Only On Boss") end
                                            if cfg.requireBossInRange then table.insert(defaultValue, "Boss In Range") end
                                            if cfg.useOnWave then table.insert(defaultValue, "On Wave") end
                                        end
                                        
                                        createDropdown(
                                            targetSection,
                                            "  > Conditions",
                                            modifierKey,
                                            {"Only On Boss", "Boss In Range", "On Wave"},
                                            true,
                                            function(Value)
                                                local selectedSet = {}
                                                if type(Value) == "table" then
                                                    for k, v in pairs(Value) do
                                                        if v == true then
                                                            selectedSet[k] = true
                                                        end
                                                    end
                                                end
                                                
                                                cfg.onlyOnBoss = selectedSet["Only On Boss"] == true
                                                cfg.requireBossInRange = selectedSet["Boss In Range"] == true
                                                cfg.useOnWave = selectedSet["On Wave"] == true
                                                
                                                getgenv().Config.abilities[unitName] = getgenv().Config.abilities[unitName] or {}
                                                local store = getgenv().Config.abilities[unitName]
                                                store[soulAbilityName] = store[soulAbilityName] or {}
                                                store[soulAbilityName].onlyOnBoss = cfg.onlyOnBoss
                                                store[soulAbilityName].requireBossInRange = cfg.requireBossInRange
                                                store[soulAbilityName].useOnWave = cfg.useOnWave
                                                
                                                getgenv().SaveConfig(getgenv().Config)
                                            end,
                                            defaultValue
                                        )
                                        
                                        local waveFlag = unitName .. "_" .. soulAbilityName .. "_Wave"
                                        local waveDefault = ""
                                        if cfg.specificWave then
                                            waveDefault = tostring(cfg.specificWave)
                                        elseif getgenv().Config.inputs[waveFlag] and getgenv().Config.inputs[waveFlag] ~= "" then
                                            waveDefault = tostring(getgenv().Config.inputs[waveFlag])
                                        end
                                        
                                        createInput(
                                            targetSection,
                                            "  > Wave Number",
                                            waveFlag,
                                            "Required if 'On Wave' selected",
                                            "Numeric",
                                            function(text)
                                                local num = tonumber(text)
                                                cfg.specificWave = num
                                                getgenv().Config.abilities[unitName] = getgenv().Config.abilities[unitName] or {}
                                                getgenv().Config.abilities[unitName][soulAbilityName] = getgenv().Config.abilities[unitName][soulAbilityName] or {}
                                                getgenv().Config.abilities[unitName][soulAbilityName].specificWave = num
                                                getgenv().SaveConfig(getgenv().Config)
                                            end,
                                            waveDefault
                                        )
                                    else
                                        debugPrint("[Soul Check] Soul not equipped")
                                    end
                                else
                                    debugPrint("[Soul Check] UnitID not found")
                                end
                            else
                                debugPrint("[Soul Check] Missing data")
                            end
                        end)
                        
                        if not success then
                            warn("[Soul Check] Error:", err)
                        end
                    end
                end
            end
    end)
    
    if not success then
        warn("[Auto Ability UI] build failed: " .. tostring(err))
    end
    
    pcall(function()
        local clientData = getClientData()
        if clientData and clientData.Slots then
            local hasBulma = false
            for _, slotName in ipairs({"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}) do
                local slotData = clientData.Slots[slotName]
                if slotData and slotData.Value == "Bulma" then
                    hasBulma = true
                    break
                end
            end
            
            local hasBulma = false
            local hasWukong = false
            local hasSkeletonKnightEZA = false
            
            for _, slotName in ipairs({"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}) do
                local slotData = clientData.Slots[slotName]
                if slotData and slotData.Value then
                    if slotData.Value == "Bulma" then
                        hasBulma = true
                    elseif slotData.Value == "JinMoriGodly" then
                        hasWukong = true
                    elseif slotData.Value == "Skull_Knight_Evo" and slotData.UnitID then
                        if clientData.UnitData and clientData.UnitData[slotData.UnitID] then
                            if clientData.UnitData[slotData.UnitID].EZA == true then
                                hasSkeletonKnightEZA = true
                            end
                        elseif clientData[slotData.UnitID] then
                            if clientData[slotData.UnitID].EZA == true then
                                hasSkeletonKnightEZA = true
                            end
                        end
                    end
                end
            end
            
            local hasEtoEvo = false
            for slotName, slotData in pairs(clientData.Slots) do
                if slotData.Value == "EtoEvo" then
                    hasEtoEvo = true
                    break
                end
            end
            
            local hasGriffithEclipse = false
            for slotName, slotData in pairs(clientData.Slots) do
                if slotData.Value == "GriffithEclipse" then
                    hasGriffithEclipse = true
                    break
                end
            end
            
            local hasAlucardEvo = false
            for slotName, slotData in pairs(clientData.Slots) do
                if slotData.Value == "Alucard2Evo" then
                    hasAlucardEvo = true
                    break
                end
            end
            
            local specialSection = Tabs.Abilities:Section({ Side = "Left" })
            table.insert(getgenv()._AbilityUIElements["Left"], specialSection)
            
            specialSection:Header({ Text = "🔮 Auto Units" })
            specialSection:SubLabel({ Text = "Toggles work when units are equipped" })
            specialSection:Divider()
            
            do
                    createToggle(
                        specialSection,
                        "Bulma Auto-Wish",
                        "BulmaToggle",
                        function(value)
                            getgenv().BulmaEnabled = value
                            Window:Notify({
                                Title = "Bulma Auto-Wish",
                                Description = value and "Enabled" or "Disabled",
                                Lifetime = 2
                            })
                        end,
                        getgenv().BulmaEnabled
                    )
                    
                    
                    createDropdown(
                        specialSection,
                        "  > Wish Type",
                        "BulmaWishType",
                        {"Power", "Wealth", "Time"},
                        false,
                        function(value)
                            getgenv().BulmaWishType = value
                            Window:Notify({
                                Title = "Bulma Auto-Wish",
                                Description = "Wish type set to: " .. value,
                                Lifetime = 2
                            })
                        end,
                        getgenv().BulmaWishType or "Power"
                    )
                end
                
                specialSection:Divider()
                
                do
                    createToggle(
                        specialSection,
                        "Auto Wukong (Jin Mori)",
                        "WukongToggle",
                        function(value)
                            getgenv().WukongEnabled = value
                            Window:Notify({
                                Title = "Auto Wukong",
                                Description = value and "Enabled" or "Disabled",
                                Lifetime = 2
                            })
                        end,
                        getgenv().WukongEnabled
                    )
                end
                
                specialSection:Divider()
                
                do
                    createToggle(
                        specialSection,
                        "Auto Skeleton Knight (Savior)",
                        "SkeletonKnightToggle",
                        function(value)
                            getgenv().SkeletonKnightEnabled = value
                            Window:Notify({
                                Title = "Auto Skeleton Knight",
                                Description = value and "Enabled" or "Disabled",
                                Lifetime = 2
                            })
                        end,
                        getgenv().SkeletonKnightEnabled
                    )
                    
                    specialSection:SubLabel({ Text = "Select target from placed towers (auto-updates every 5s)" })
                    
                    local function getAvailableTargets()
                        local targets = {}
                        
                        local towers = workspace:FindFirstChild("Towers")
                        if towers then
                            for _, tower in pairs(towers:GetChildren()) do
                                local owner = tower:FindFirstChild("Owner")
                                if owner and owner.Value == LocalPlayer then
                                    local towerName = tower.Name
                                    
                                    if towerName ~= "Skull_Knight_EvoEZA" and towerName ~= "Skull_Knight_Evo" and towerName ~= "NarutoBaryonClone" then
                                        local baseName = towerName:gsub("EZA$", "")
                                        local displayName = getUnitDisplayName(baseName)
                                        
                                        local alreadyExists = false
                                        for _, existing in ipairs(targets) do
                                            if existing == displayName then
                                                alreadyExists = true
                                                break
                                            end
                                        end
                                        
                                        if not alreadyExists then
                                            table.insert(targets, displayName)
                                        end
                                    end
                                end
                            end
                        end
                        
                        table.sort(targets)
                        
                        if #targets == 0 then
                            table.insert(targets, "Place a unit first")
                        end
                        
                        return targets
                    end
                    
                    local targets = getAvailableTargets()
                    
                    
                    if not getgenv().SkeletonKnightTargetUnit or getgenv().SkeletonKnightTargetUnit == "" then
                        getgenv().SkeletonKnightTargetUnit = targets[1]
                    end
                    
                    local skeletonDropdown = createDropdown(
                        specialSection,
                        "  > Target Unit",
                        "SkeletonKnightTargetUnit",
                        targets,
                        false,
                        function(value)
                            getgenv().SkeletonKnightTargetUnit = value
                            Window:Notify({
                                Title = "Auto Skeleton Knight",
                                Description = "Target: " .. value,
                                Lifetime = 2
                            })
                        end,
                        getgenv().SkeletonKnightTargetUnit
                    )
                    
                    task.spawn(function()
                        while task.wait(5) do
                            if not skeletonDropdown then break end
                            pcall(function()
                                local newTargets = getAvailableTargets()
                                if #newTargets > 0 and newTargets[1] ~= "Place a unit first" then
                                    skeletonDropdown:ClearOptions()
                                    skeletonDropdown:InsertOptions(newTargets)
                                end
                            end)
                        end
                    end)
                end
                
                specialSection:Divider()
                
                do
                    createToggle(
                        specialSection,
                        "Auto True Dracula Hypnosis",
                        "AlucardHypnosisToggle",
                        function(value)
                            getgenv().AlucardHypnosisEnabled = value
                            Window:Notify({
                                Title = "Auto True Dracula Hypnosis",
                                Description = value and "Enabled" or "Disabled",
                                Lifetime = 2
                            })
                        end,
                        getgenv().AlucardHypnosisEnabled
                    )
                    
                    specialSection:SubLabel({ Text = "Select target from placed towers (auto-updates every 5s)" })
                    
                    local function getAvailableTargetsAlucard()
                        local targets = {}
                        
                        local towers = workspace:FindFirstChild("Towers")
                        if towers then
                            for _, tower in pairs(towers:GetChildren()) do
                                local owner = tower:FindFirstChild("Owner")
                                if owner and owner.Value == LocalPlayer then
                                    local towerName = tower.Name
                                    
                                    if towerName ~= "Alucard2Evo" and towerName ~= "NarutoBaryonClone" then
                                        local baseName = towerName:gsub("EZA$", "")
                                        local displayName = getUnitDisplayName(baseName)
                                        
                                        local alreadyExists = false
                                        for _, existing in ipairs(targets) do
                                            if existing == displayName then
                                                alreadyExists = true
                                                break
                                            end
                                        end
                                        
                                        if not alreadyExists then
                                            table.insert(targets, displayName)
                                        end
                                    end
                                end
                            end
                        end
                        
                        table.sort(targets)
                        
                        if #targets == 0 then
                            table.insert(targets, "Place a unit first")
                        end
                        
                        return targets
                    end
                    
                    local targetsAlucard = getAvailableTargetsAlucard()
                    
                    if not getgenv().AlucardHypnosisTargetUnit or getgenv().AlucardHypnosisTargetUnit == "" then
                        getgenv().AlucardHypnosisTargetUnit = targetsAlucard[1]
                    end
                    
                    local alucardDropdown = createDropdown(
                        specialSection,
                        "  > Target Unit",
                        "AlucardHypnosisTargetUnit",
                        targetsAlucard,
                        false,
                        function(value)
                            getgenv().AlucardHypnosisTargetUnit = value
                            Window:Notify({
                                Title = "Auto True Dracula Hypnosis",
                                Description = "Target: " .. value,
                                Lifetime = 2
                            })
                        end,
                        getgenv().AlucardHypnosisTargetUnit
                    )
                    
                    task.spawn(function()
                        local lastTargets = {}
                        for _, v in ipairs(targetsAlucard) do
                            lastTargets[v] = true
                        end
                        
                        while task.wait(15) do
                            if not alucardDropdown then break end
                            pcall(function()
                                local newTargets = getAvailableTargetsAlucard()
                                if #newTargets > 0 and newTargets[1] ~= "Place a unit first" then
                                    local changed = false
                                    local newTargetsSet = {}
                                    for _, v in ipairs(newTargets) do
                                        newTargetsSet[v] = true
                                        if not lastTargets[v] then
                                            changed = true
                                        end
                                    end
                                    
                                    for k in pairs(lastTargets) do
                                        if not newTargetsSet[k] then
                                            changed = true
                                        end
                                    end
                                    
                                    if changed then
                                        local currentSelection = getgenv().AlucardHypnosisTargetUnit
                                        alucardDropdown:ClearOptions()
                                        alucardDropdown:InsertOptions(newTargets)
                                        
                                        if newTargetsSet[currentSelection] then
                                            alucardDropdown:UpdateSelection(currentSelection)
                                        else
                                            getgenv().AlucardHypnosisTargetUnit = newTargets[1]
                                            alucardDropdown:UpdateSelection(newTargets[1])
                                        end
                                        
                                        lastTargets = newTargetsSet
                                    end
                                end
                            end)
                        end
                    end)
                end
                
                specialSection:Divider()
                
                do
                    createToggle(
                        specialSection,
                        "Auto One Eye Devil (EtoEvo)",
                        "OneEyeDevilToggle",
                        function(value)
                            getgenv().OneEyeDevilEnabled = value
                            Window:Notify({
                                Title = "Auto One Eye Devil",
                                Description = value and "Enabled - Cycling Ocular Sigils" or "Disabled",
                                Lifetime = 2
                            })
                        end,
                        getgenv().OneEyeDevilEnabled
                    )
                end
                
                specialSection:Divider()
                
                do
                    createToggle(
                        specialSection,
                        "Auto Griffith Light (Umbral Prince)",
                        "GriffithLightToggle",
                        function(value)
                            getgenv().GriffithLightEnabled = value
                            Window:Notify({
                                Title = "Auto Griffith Light",
                                Description = value and "Enabled - Will use Light Sacrifice at 50k+" or "Disabled",
                                Lifetime = 2
                            })
                        end,
                        getgenv().GriffithLightEnabled
                    )
                end
        end
    end)
    
    if not success then
        warn("[Ability UI] Build failed:", err)
        Window:Notify({
            Title = "Auto Ability Error",
            Description = "Failed to build UI. Check console for details.",
            Lifetime = 5
        })
    end
    
    getgenv()._AbilityUIBuilt = anyBuilt
    getgenv()._AbilityUIBuilding = false
end

task.spawn(function()
    task.wait(2 * MOBILE_DELAY_MULTIPLIER)
    local maxRetries, retryDelay = 10, 3 * MOBILE_DELAY_MULTIPLIER
    
    for i = 1, maxRetries do
        pcall(function()
            local cd = getClientData()
            if cd and cd.Slots then
                buildAutoAbilityUI()
            else
                if i <= 3 then
                    Window:Notify({
                        Title = "Auto Ability",
                        Description = "Loading units... (" .. i .. "/" .. maxRetries .. ")",
                        Lifetime = 2
                    })
                end
            end
        end)
        
        if getgenv()._AbilityUIBuilt then break end
        task.wait(retryDelay)
    end
    
    if not getgenv()._AbilityUIBuilt then
        pcall(function()
            local fallbackSection = Tabs.Abilities:Section({ Side = "Left" })
            fallbackSection:Header({ Text = "⚠️ No Units Found" })
            fallbackSection:SubLabel({ Text = "Make sure you have units equipped in your slots." })
            fallbackSection:Divider()
            fallbackSection:SubLabel({ Text = "If you do have units equipped, try:" })
            fallbackSection:SubLabel({ Text = "1. Rejoining the game" })
            fallbackSection:SubLabel({ Text = "2. Reloading the script" })
            fallbackSection:SubLabel({ Text = "3. Checking console for errors (F9)" })
        end)
    end
    
    task.spawn(function()
        task.wait(5)
        
        if not getgenv()._DynamicSummonSections then
            getgenv()._DynamicSummonSections = {}
        end
        
        local SUMMON_BLACKLIST = {
            "NarutoBaryonClone",
            "JinMoriGodlyClone",
            "Skull_Knight_EvoEZA"
        }
        
        local function isSummonBlacklisted(unitName)
            for _, blacklisted in ipairs(SUMMON_BLACKLIST) do
                if unitName == blacklisted then
                    return true
                end
            end
            return false
        end
        
        local function isSummonUnit(unitName)
            if isSummonBlacklisted(unitName) then
                return false
            end
            
            local clientData = getClientData()
            if not clientData or not clientData.Slots then return false end
            
            for _, slotData in pairs(clientData.Slots) do
                if slotData and slotData.Value == unitName then
                    return false
                end
            end
            
            return true
        end
        
        local trackedSummons = {}
        
        
        while true do
            task.wait(2)
            
            if not Tabs or not Tabs.Abilities then
                task.wait(5)
                continue
            end
            
            local towers = workspace:FindFirstChild("Towers")
            if not towers then
                task.wait(2)
                continue
            end
            
            local currentSummons = {}
            
            for _, tower in pairs(towers:GetChildren()) do
                local owner = tower:FindFirstChild("Owner")
                if owner and owner.Value == LocalPlayer then
                    local unitName = tower.Name
                    
                    if isSummonUnit(unitName) and not isSummonBlacklisted(unitName) then
                        currentSummons[unitName] = true
                        
                        if not trackedSummons[unitName] and not getgenv()._DynamicSummonSections[unitName] then
                            
                            local abilities = getAllAbilities(unitName)
                            
                            if next(abilities) then
                                local displayName = getUnitDisplayName(unitName)
                                
                                if not getgenv()._AbilityUIElements then
                                    getgenv()._AbilityUIElements = {Left = {}, Right = {}}
                                end
                                
                                local summonSection = Tabs.Abilities:Section({ Side = "Right" })
                                table.insert(getgenv()._AbilityUIElements["Right"], summonSection)
                                
                                local headerElement = summonSection:Header({ Text = "🔮 " .. displayName .. " (Summon)" })
                                local sublabelElement = summonSection:SubLabel({ Text = "Auto-detected summon unit" })
                                local dividerElement = summonSection:Divider()
                                
                                local sectionElements = {headerElement, sublabelElement, dividerElement}
                                
                                if not getgenv().UnitAbilities then getgenv().UnitAbilities = {} end
                                if not getgenv().UnitAbilities[unitName] then getgenv().UnitAbilities[unitName] = {} end
                                if not getgenv().Config.abilities then getgenv().Config.abilities = {} end
                                if not getgenv().Config.abilities[unitName] then getgenv().Config.abilities[unitName] = {} end
                                
                                local sortedAbilities = {}
                                for abilityName, data in pairs(abilities) do
                                    table.insert(sortedAbilities, { name = abilityName, data = data })
                                end
                                table.sort(sortedAbilities, function(a, b)
                                    local aLevel = (a.data and a.data.requiredLevel) or 0
                                    local bLevel = (b.data and b.data.requiredLevel) or 0
                                    return aLevel < bLevel
                                end)
                                
                                for _, ab in ipairs(sortedAbilities) do
                                    local abilityName = ab.name
                                    local abilityData = ab.data
                                    
                                    if not getgenv().UnitAbilities[unitName][abilityName] then
                                        local saved = getgenv().Config.abilities and 
                                                     getgenv().Config.abilities[unitName] and 
                                                     getgenv().Config.abilities[unitName][abilityName]
                                        
                                        getgenv().UnitAbilities[unitName][abilityName] = {
                                            enabled = (saved and saved.enabled) or false,
                                            onlyOnBoss = (saved and saved.onlyOnBoss) or false,
                                            specificWave = (saved and saved.specificWave) or nil,
                                            requireBossInRange = (saved and saved.requireBossInRange) or false,
                                            useOnWave = (saved and saved.useOnWave) or false
                                        }
                                    end
                                    
                                    local cfg = getgenv().UnitAbilities[unitName][abilityName]
                                    
                                    local cdText = abilityData.cooldown and ("CD: " .. abilityData.cooldown .. "s") or ""
                                    local globalText = abilityData.isGlobal and " (Global)" or ""
                                    
                                    local toggleElement = createToggle(
                                        summonSection,
                                        "⚡ " .. abilityName .. " (" .. cdText .. ")" .. globalText,
                                        unitName .. "_" .. abilityName .. "_Toggle",
                                        function(v)
                                            cfg.enabled = v
                                            getgenv().Config.abilities[unitName] = getgenv().Config.abilities[unitName] or {}
                                            getgenv().Config.abilities[unitName][abilityName] = getgenv().Config.abilities[unitName][abilityName] or {}
                                            getgenv().Config.abilities[unitName][abilityName].enabled = v
                                            getgenv().SaveConfig(getgenv().Config)
                                        end,
                                        cfg.enabled
                                    )
                                    table.insert(sectionElements, toggleElement)
                                end
                                
                                if not getgenv()._DynamicSummonSections then
                                    getgenv()._DynamicSummonSections = {}
                                end
                                
                                getgenv()._DynamicSummonSections[unitName] = {
                                    section = summonSection,
                                    elements = sectionElements
                                }
                                trackedSummons[unitName] = true
                                
                                Window:Notify({
                                    Title = "Summon Detected",
                                    Description = displayName .. " abilities added!",
                                    Lifetime = 3
                                })
                            end
                        end
                    end
                end
            end
            
            for unitName, _ in pairs(trackedSummons) do
                if not currentSummons[unitName] then
                    
                    if getgenv()._DynamicSummonSections and getgenv()._DynamicSummonSections[unitName] then
                        pcall(function()
                            local sectionData = getgenv()._DynamicSummonSections[unitName]
                            
                            if sectionData and sectionData.elements then
                                for _, element in ipairs(sectionData.elements) do
                                    pcall(function()
                                        if element and element.SetVisiblity then
                                            element:SetVisiblity(false)
                                        elseif element and element.SetVisibility then
                                            element:SetVisibility(false)
                                        end
                                    end)
                                end
                            end
                            
                            if sectionData and sectionData.section then
                                for i = #getgenv()._AbilityUIElements["Right"], 1, -1 do
                                    if getgenv()._AbilityUIElements["Right"][i] == sectionData.section then
                                        table.remove(getgenv()._AbilityUIElements["Right"], i)
                                        break
                                    end
                                end
                            end
                        end)
                        getgenv()._DynamicSummonSections[unitName] = nil
                    end
                    
                    if getgenv().UnitAbilities and getgenv().UnitAbilities[unitName] then
                        getgenv().UnitAbilities[unitName] = nil
                    end
                    
                    trackedSummons[unitName] = nil
                end
            end
        end
    end)
end)


getgenv().AutoPlayConfig = getgenv().AutoPlayConfig or {
    enabled = false,
    autoPlace = false,
    autoUpgrade = false,
    autoUpgradePriority = false,
    focusFarm = false,
    hologram = false,
    placeBeforeUpgrade = false,
    pathPercentage = 1,
    distanceFromPath = 0,
    placeCaps = {1, 1, 1, 1, 1, 1},
    upgradeCaps = {0, 0, 0, 0, 0, 0},
    upgradePriorities = {1, 2, 3, 4, 5, 6},
    autoPlaceAtPosition = false,
    positionHologram = false,
    unitPositions = {}
}

getgenv().Config.autoPlay = getgenv().Config.autoPlay or {}
getgenv().Config.autoPlay.unitPositions = getgenv().Config.autoPlay.unitPositions or {}

getgenv().AutoPlayConfig.autoPlace = getgenv().Config.toggles.AutoPlayPlace or false
getgenv().AutoPlayConfig.autoUpgrade = getgenv().Config.toggles.AutoPlayUpgrade or false
getgenv().AutoPlayConfig.autoUpgradePriority = getgenv().Config.toggles.AutoPlayUpgradePriority or false
getgenv().AutoPlayConfig.focusFarm = getgenv().Config.toggles.AutoPlayFocusFarm or false
getgenv().AutoPlayConfig.hologram = getgenv().Config.toggles.AutoPlayHologram or false
getgenv().AutoPlayConfig.placeBeforeUpgrade = getgenv().Config.toggles.AutoPlayPlaceBeforeUpgrade or false
getgenv().AutoPlayConfig.autoPlaceAtPosition = getgenv().Config.toggles.AutoPlayPlaceAtPosition or false
getgenv().AutoPlayConfig.positionHologram = getgenv().Config.toggles.AutoPlayPositionHologram or false
getgenv().AutoPlayConfig.pathPercentage = tonumber(getgenv().Config.inputs.AutoPlayPathPercentage) or 1
getgenv().AutoPlayConfig.distanceFromPath = tonumber(getgenv().Config.inputs.AutoPlayDistanceFromPath) or 0

for i = 1, 6 do
    if getgenv().Config.autoPlay.unitPositions[i] then
        local savedPos = getgenv().Config.autoPlay.unitPositions[i]
        getgenv().AutoPlayConfig.unitPositions[i] = Vector3.new(savedPos.X, savedPos.Y, savedPos.Z)
    end
end

for i = 1, 6 do
    local savedCap = tonumber(getgenv().Config.inputs["AutoPlayPlaceCap" .. i])
    if savedCap then
        getgenv().AutoPlayConfig.placeCaps[i] = savedCap
    end
end

for i = 1, 6 do
    local savedCap = tonumber(getgenv().Config.inputs["AutoPlayUpgradeCap" .. i])
    if savedCap then
        getgenv().AutoPlayConfig.upgradeCaps[i] = savedCap
    end
end

for i = 1, 6 do
    local savedPriority = tonumber(getgenv().Config.inputs["AutoPlayUpgradePriority" .. i])
    if savedPriority then
        getgenv().AutoPlayConfig.upgradePriorities[i] = savedPriority
    end
end

Sections.AutoPlayLeft:Header({ Text = "🤖 Auto Play" })
Sections.AutoPlayLeft:SubLabel({ Text = "Automated tower placement and upgrades" })

Sections.AutoPlayLeft:Divider()
Sections.AutoPlayLeft:Header({ Text = "📍 Placement Settings" })

createToggle(
    Sections.AutoPlayLeft,
    "Enable Auto Place",
    "AutoPlayPlace",
    function(value)
        getgenv().AutoPlayConfig.autoPlace = value
    end,
    getgenv().AutoPlayConfig.autoPlace
)

createToggle(
    Sections.AutoPlayLeft,
    "Enable Auto Place at Position",
    "AutoPlayPlaceAtPosition",
    function(value)
        getgenv().AutoPlayConfig.autoPlaceAtPosition = value
        
        if value then
            Window:Notify({
                Title = "Auto Place at Position",
                Description = "Will place units at saved positions. Make sure to save positions first!",
                Lifetime = 4
            })
        end
    end,
    getgenv().AutoPlayConfig.autoPlaceAtPosition
)

Sections.AutoPlayLeft:SubLabel({ Text = "Independent toggle - uses saved positions instead of path. No need to enable 'Auto Place'" })

Sections.AutoPlayLeft:Divider()
Sections.AutoPlayLeft:Header({ Text = "⬆️ Upgrade Settings" })

local autoUpgradeToggle, autoUpgradePriorityToggle

autoUpgradeToggle = createToggle(
    Sections.AutoPlayLeft,
    "Enable Auto Upgrade",
    "AutoPlayUpgrade",
    function(value)
        getgenv().AutoPlayConfig.autoUpgrade = value
        if value and getgenv().AutoPlayConfig.autoUpgradePriority then
            getgenv().AutoPlayConfig.autoUpgradePriority = false
            getgenv().Config.toggles.AutoPlayUpgradePriority = false
            saveConfig(getgenv().Config)
            if autoUpgradePriorityToggle then
                pcall(function() autoUpgradePriorityToggle:UpdateState(false) end)
            end
        end
    end,
    getgenv().AutoPlayConfig.autoUpgrade
)

autoUpgradePriorityToggle = createToggle(
    Sections.AutoPlayLeft,
    "Auto Upgrade Priority",
    "AutoPlayUpgradePriority",
    function(value)
        getgenv().AutoPlayConfig.autoUpgradePriority = value
        if value and getgenv().AutoPlayConfig.autoUpgrade then
            getgenv().AutoPlayConfig.autoUpgrade = false
            getgenv().Config.toggles.AutoPlayUpgrade = false
            saveConfig(getgenv().Config)
            if autoUpgradeToggle then
                pcall(function() autoUpgradeToggle:UpdateState(false) end)
            end
        end
    end,
    getgenv().AutoPlayConfig.autoUpgradePriority
)

createToggle(
    Sections.AutoPlayLeft,
    "Place Units before Upgrading",
    "AutoPlayPlaceBeforeUpgrade",
    function(value)
        getgenv().AutoPlayConfig.placeBeforeUpgrade = value
    end,
    getgenv().AutoPlayConfig.placeBeforeUpgrade
)

Sections.AutoPlayLeft:Divider()
Sections.AutoPlayLeft:Header({ Text = "⚙️ Additional Options" })

createToggle(
    Sections.AutoPlayLeft,
    "Focus Farm Units",
    "AutoPlayFocusFarm",
    function(value)
        getgenv().AutoPlayConfig.focusFarm = value
    end,
    getgenv().AutoPlayConfig.focusFarm
)

Sections.AutoPlayLeft:SubLabel({ Text = "Prioritize placing farm units first" })

createToggle(
    Sections.AutoPlayLeft,
    "Enable Hologram",
    "AutoPlayHologram",
    function(value)
        getgenv().AutoPlayConfig.hologram = value
    end,
    getgenv().AutoPlayConfig.hologram
)

Sections.AutoPlayLeft:SubLabel({ Text = "Show placement preview markers" })

Sections.AutoPlayLeft:Divider()
Sections.AutoPlayLeft:Header({ Text = "🎯 Path & Distance" })

local pathSlider
local function updatePathSliderMax()
    local waypoints = {}
    pcall(function()
        local waypointsFolder = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Waypoints")
        if waypointsFolder then
            for _, wp in pairs(waypointsFolder:GetChildren()) do
                if wp:IsA("BasePart") then
                    local num = tonumber(wp.Name)
                    if num and num >= 1 then
                        table.insert(waypoints, num)
                    end
                end
            end
        end
    end)
    
    local maxWaypoint = #waypoints > 0 and math.max(table.unpack(waypoints)) or 50
    
    if pathSlider then
        pcall(function()
            pathSlider:UpdateValue(math.min(getgenv().AutoPlayConfig.pathPercentage or 1, maxWaypoint))
        end)
    end
end

pathSlider = createSlider(
    Sections.AutoPlayLeft,
    "Path Waypoint",
    "AutoPlayPathPercentage",
    1,
    50,
    getgenv().AutoPlayConfig.pathPercentage or 1,
    function(value)
        getgenv().AutoPlayConfig.pathPercentage = value
    end,
    "Default",
    1
)

task.spawn(function()
    task.wait(2)
    updatePathSliderMax()
end)

createSlider(
    Sections.AutoPlayLeft,
    "Distance from Path",
    "AutoPlayDistanceFromPath",
    0,
    25,
    getgenv().AutoPlayConfig.distanceFromPath,
    function(value)
        getgenv().AutoPlayConfig.distanceFromPath = math.floor(value)
    end,
    "Default",
    0
)

Sections.AutoPlayLeft:SubLabel({ Text = "Only used when not in position mode" })

Sections.AutoPlayLeft:Divider()
Sections.AutoPlayLeft:Header({ Text = "📍 Custom Unit Positions" })
Sections.AutoPlayLeft:SubLabel({ Text = "Stand where you want each unit, then click Set Position" })

if not getgenv()._PositionHolograms then
    getgenv()._PositionHolograms = {}
end

if not getgenv().AutoPlayConfig.unitPositions then
    getgenv().AutoPlayConfig.unitPositions = {}
end

local function getUnitNameForSlot(slotIndex)
    local clientData = getClientData()
    if not clientData or not clientData.Slots then return nil end
    
    local sortedSlots = {"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}
    local slotData = clientData.Slots[sortedSlots[slotIndex]]
    
    if slotData and slotData.Value and slotData.Value ~= "" then
        return slotData.Value
    end
    
    return nil
end

local function updatePositionHologram(slotIndex)
    if not getgenv().AutoPlayConfig.positionHologram then return end
    
    pcall(function()
        if getgenv()._PositionHolograms[slotIndex] then
            if getgenv()._PositionHolograms[slotIndex].part then
                getgenv()._PositionHolograms[slotIndex].part:Destroy()
            end
            if getgenv()._PositionHolograms[slotIndex].beam then
                getgenv()._PositionHolograms[slotIndex].beam:Destroy()
            end
            getgenv()._PositionHolograms[slotIndex] = nil
        end
        
        local pos = getgenv().AutoPlayConfig.unitPositions[slotIndex]
        if pos then
            local part = Instance.new("Part")
            part.Size = Vector3.new(0.5, 0.5, 0.5)
            part.Position = pos + Vector3.new(0, 2, 0)
            part.Anchored = true
            part.CanCollide = false
            part.Transparency = 0.5
            part.Color = Color3.fromRGB(0, 255, 100)
            part.Material = Enum.Material.Neon
            part.Shape = Enum.PartType.Ball
            part.Parent = workspace
            
            local beam = Instance.new("Part")
            beam.Size = Vector3.new(0.2, 4, 0.2)
            beam.Position = pos
            beam.Anchored = true
            beam.CanCollide = false
            beam.Transparency = 0.6
            beam.Color = Color3.fromRGB(0, 255, 100)
            beam.Material = Enum.Material.Neon
            beam.Parent = workspace
            
            local billboard = Instance.new("BillboardGui")
            billboard.Size = UDim2.new(0, 120, 0, 30)
            billboard.StudsOffset = Vector3.new(0, 3, 0)
            billboard.AlwaysOnTop = true
            billboard.Parent = part
            
            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(1, 0, 1, 0)
            label.BackgroundTransparency = 0.3
            label.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            
            local unitName = getUnitNameForSlot(slotIndex)
            if unitName then
                label.Text = unitName .. " (Slot " .. slotIndex .. ")"
            else
                label.Text = "Unit " .. slotIndex
            end
            
            label.TextColor3 = Color3.fromRGB(0, 255, 100)
            label.TextScaled = true
            label.Font = Enum.Font.GothamBold
            label.Parent = billboard
            
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 4)
            corner.Parent = label
            
            getgenv()._PositionHolograms[slotIndex] = {
                part = part,
                beam = beam
            }
        end
    end)
end

createToggle(
    Sections.AutoPlayLeft,
    "Enable Position Hologram",
    "AutoPlayPositionHologram",
    function(value)
        getgenv().AutoPlayConfig.positionHologram = value
        if not value then
            if getgenv()._PositionHolograms then
                for _, hologramData in pairs(getgenv()._PositionHolograms) do
                    pcall(function()
                        if hologramData.part then hologramData.part:Destroy() end
                        if hologramData.beam then hologramData.beam:Destroy() end
                    end)
                end
                getgenv()._PositionHolograms = {}
            end
        else
            task.spawn(function()
                if not getgenv()._PositionHolograms then
                    getgenv()._PositionHolograms = {}
                end
                for i = 1, 6 do
                    local pos = getgenv().AutoPlayConfig.unitPositions[i]
                    if pos then
                        updatePositionHologram(i)
                    end
                end
            end)
        end
    end,
    getgenv().AutoPlayConfig.positionHologram
)

Sections.AutoPlayLeft:SubLabel({ Text = "Shows markers at saved positions" })

for i = 1, 6 do
    Sections.AutoPlayLeft:Label({ Text = "Slot " .. i })
    
    Sections.AutoPlayLeft:Button({
        Name = "  Set Position",
        Callback = function()
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                local pos = char.HumanoidRootPart.Position
                getgenv().AutoPlayConfig.unitPositions[i] = pos
                
                getgenv().Config.autoPlay.unitPositions[i] = {X = pos.X, Y = pos.Y, Z = pos.Z}
                saveConfig(getgenv().Config)
                
                updatePositionHologram(i)
                
                Window:Notify({
                    Title = "Position Set",
                    Description = "Unit " .. i .. " position saved!",
                    Lifetime = 2
                })
            else
                Window:Notify({
                    Title = "Error",
                    Description = "Character not found!",
                    Lifetime = 2
                })
            end
        end
    })
    
    Sections.AutoPlayLeft:Button({
        Name = "  Reset Position",
        Callback = function()
            getgenv().AutoPlayConfig.unitPositions[i] = nil
            
            getgenv().Config.autoPlay.unitPositions[i] = nil
            saveConfig(getgenv().Config)
            
            if getgenv()._PositionHolograms[i] then
                pcall(function()
                    if getgenv()._PositionHolograms[i].part then
                        getgenv()._PositionHolograms[i].part:Destroy()
                    end
                    if getgenv()._PositionHolograms[i].beam then
                        getgenv()._PositionHolograms[i].beam:Destroy()
                    end
                end)
                getgenv()._PositionHolograms[i] = nil
            end
            
            Window:Notify({
                Title = "Position Reset",
                Description = "Unit " .. i .. " position cleared!",
                Lifetime = 2
            })
        end
    })
    
    if i < 6 then
        Sections.AutoPlayLeft:Spacer()
    end
end

Sections.AutoPlayRight:Header({ Text = "⚙️ Auto Place & Upgrade Settings" })
Sections.AutoPlayRight:SubLabel({ Text = "Configure placement and upgrade caps per slot" })

getgenv().AutoPlaySliders = {
    placeCaps = {},
    upgradeCaps = {}
}


for i = 1, 6 do
    getgenv().AutoPlaySliders.placeCaps[i] = createSlider(
        Sections.AutoPlayRight,
        "Place Cap " .. i,
        "AutoPlayPlaceCap" .. i,
        0,
        5,
        getgenv().AutoPlayConfig.placeCaps[i],
        function(value)
            getgenv().AutoPlayConfig.placeCaps[i] = math.floor(value)
        end,
        "Default",
        0
    )
end

Sections.AutoPlayRight:Divider()

for i = 1, 6 do
    local savedValue = getgenv().Config.inputs["AutoPlayUpgradeCap" .. i]
    local defaultValue = savedValue and tonumber(savedValue) or 0
    
    getgenv().AutoPlaySliders.upgradeCaps[i] = createSlider(
        Sections.AutoPlayRight,
        "Upgrade Cap " .. i,
        "AutoPlayUpgradeCap" .. i,
        0,
        20,
        defaultValue,
        function(value)
            getgenv().AutoPlayConfig.upgradeCaps[i] = math.floor(value)
        end,
        "Default",
        0
    )
end

Sections.AutoPlayRight:Divider()

Sections.AutoPlayRight:SubLabel({ Text = "Priority: 1 = Highest (upgrades first), 6 = Lowest" })

for i = 1, 6 do
    if not getgenv().AutoPlayConfig.upgradePriorities then
        getgenv().AutoPlayConfig.upgradePriorities = {1, 2, 3, 4, 5, 6}
    end
    
    local savedPriority = getgenv().Config.inputs["AutoPlayUpgradePriority" .. i]
    local defaultPriority = savedPriority and tonumber(savedPriority) or i
    
    createSlider(
        Sections.AutoPlayRight,
        "Upgrade Priority " .. i,
        "AutoPlayUpgradePriority" .. i,
        1,
        6,
        defaultPriority,
        function(value)
            getgenv().AutoPlayConfig.upgradePriorities[i] = math.floor(value)
        end,
        "Default",
        0
    )
end



Sections.MacroLeft:Header({ Text = "📁 Macro Management" })
Sections.MacroLeft:SubLabel({ Text = "Create, select, and manage your macros" })

getgenv()._macroDropdown = createDropdown(
    Sections.MacroLeft,
    "Select Macro",
    "MacroSelect",
    getMacroNames(),
    false,
    function(value)
        getgenv().CurrentMacro = value
        if value and getgenv().Macros[value] then
            getgenv().MacroData = getgenv().Macros[value]
            getgenv().MacroTotalSteps = #getgenv().MacroData
            Window:Notify({
                Title = "Macro System",
                Description = "Selected: " .. value,
                Lifetime = 2
            })
        end
        saveMacroSettings()
        getgenv().UpdateMacroStatus()
    end,
    getgenv().CurrentMacro
)

getgenv()._macroCreateInput = createInput(
    Sections.MacroLeft,
    "Create New Macro",
    "MacroCreateNew",
    "Enter macro name and press Enter",
    "All",
    function(value)
        if not value or value == "" then
            Window:Notify({
                Title = "Macro System",
                Description = "Please enter a macro name",
                Lifetime = 3
            })
            return
        end
        
        if getgenv().Macros[value] then
            Window:Notify({
                Title = "Macro System",
                Description = "Macro '" .. value .. "' already exists",
                Lifetime = 3
            })
            return
        end
        
        local success = saveMacro(value, {})
        if success then
            loadMacros()
            local macroNames = getMacroNames()
            if getgenv()._macroDropdown then
                pcall(function()
                    getgenv()._macroDropdown:ClearOptions()
                    getgenv()._macroDropdown:InsertOptions(macroNames)
                    getgenv()._macroDropdown:UpdateSelection(value)
                end)
            end
            getgenv().CurrentMacro = value
            getgenv().MacroData = {}
            getgenv().MacroTotalSteps = 0
            
            if macroCreateInput and macroCreateInput.UpdateText then
                pcall(function()
                    macroCreateInput:UpdateText("")
                end)
                task.wait(0.1)
                pcall(function()
                    macroCreateInput:UpdateText("")
                end)
            end
            
            Window:Notify({
                Title = "Macro System",
                Description = "Created: " .. value,
                Lifetime = 3
            })
        else
            Window:Notify({
                Title = "Macro System",
                Description = "Failed to create macro",
                Lifetime = 3
            })
        end
    end,
    ""
)

Sections.MacroLeft:Button({
    Name = "🔄 Refresh Macro List",
    Callback = function()
        loadMacros()
        local macroNames = getMacroNames()
        if getgenv()._macroDropdown then
            pcall(function()
                getgenv()._macroDropdown:ClearOptions()
                getgenv()._macroDropdown:InsertOptions(macroNames)
            end)
        end
        Window:Notify({
            Title = "Macro System",
            Description = "Loaded " .. #macroNames .. " macro(s)",
            Lifetime = 2
        })
    end,
})

Sections.MacroLeft:Button({
    Name = "⚙️ Equip Macro Units",
    Callback = function()
        local selectedMacro = getgenv().CurrentMacro
        if not selectedMacro or selectedMacro == "" then
            Window:Notify({
                Title = "Equip Macro Units",
                Description = "Please select a macro first!",
                Lifetime = 3
            })
            return
        end
        
        local macroData = getgenv().MacroData or loadMacro(selectedMacro)
        if not macroData or #macroData == 0 then
            Window:Notify({
                Title = "Equip Macro Units",
                Description = "Failed to load macro data!",
                Lifetime = 3
            })
            return
        end
        
        local summonBlacklist = {
            ["TuskSummon_Act4"] = true,
            ["NarutoBaryonClone"] = true,
        }
        
        local macroUnits = {}
        local unitSet = {}
        for _, action in ipairs(macroData) do
            if action.ActionType == "Place" and action.TowerName then
                local towerName = action.TowerName
                
                local isSummon = summonBlacklist[towerName] or 
                                 towerName:find("Summon") or 
                                 towerName:find("Clone")
                
                if not isSummon and not unitSet[towerName] then
                    unitSet[towerName] = true
                    table.insert(macroUnits, towerName)
                end
            end
        end
        
        if #macroUnits == 0 then
            Window:Notify({
                Title = "Equip Macro Units",
                Description = "No units found in macro!",
                Lifetime = 3
            })
            return
        end
        
        local clientData = getClientData()
        if not clientData or not clientData.UnitData or not clientData.Slots then
            Window:Notify({
                Title = "Equip Macro Units",
                Description = "Failed to get client data!",
                Lifetime = 3
            })
            return
        end
        
        local unitIDs = {}
        for unitID, unitInfo in pairs(clientData.UnitData) do
            for _, macroUnit in ipairs(macroUnits) do
                if unitInfo.UnitName == macroUnit then
                    unitIDs[macroUnit] = unitID
                    break
                end
            end
        end
        
        local missingUnits = {}
        for _, macroUnit in ipairs(macroUnits) do
            if not unitIDs[macroUnit] then
                table.insert(missingUnits, macroUnit)
            end
        end
        
        if #missingUnits > 0 then
            Window:Notify({
                Title = "Equip Macro Units",
                Description = "Missing units: " .. table.concat(missingUnits, ", "),
                Lifetime = 5
            })
            return
        end
        
        local equipRemote = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Equip")
        if not equipRemote then
            Window:Notify({
                Title = "Equip Macro Units",
                Description = "Equip remote not found!",
                Lifetime = 3
            })
            return
        end
        
        debugPrint("[Equip] Unequipping all units...")
        local unequipped = 0
        for unitID, unitInfo in pairs(clientData.UnitData) do
            if unitInfo.Equipped then
                pcall(function()
                    equipRemote:InvokeServer(unitID)
                    unequipped = unequipped + 1
                end)
            end
        end
        
        debugPrint("[Equip] Unequipped " .. unequipped .. " units")
        
        debugPrint("[Equip] Equipping macro units...")
        local equipped = 0
        for i, macroUnit in ipairs(macroUnits) do
            if i <= 6 then
                local unitID = unitIDs[macroUnit]
                if unitID then
                    pcall(function()
                        equipRemote:InvokeServer(unitID)
                        equipped = equipped + 1
                    end)
                end
            end
        end
        
        Window:Notify({
            Title = "Equip Macro Units",
            Description = "Equipped " .. equipped .. " unit(s) for " .. selectedMacro,
            Lifetime = 3
        })
    end,
})

Sections.MacroLeft:Button({
    Name = "🗑️ Delete Macro",
    Callback = function()
        local selectedMacro = getgenv().CurrentMacro
        if not selectedMacro or selectedMacro == "" then
            Window:Notify({
                Title = "Delete Macro",
                Description = "Please select a macro first!",
                Lifetime = 3
            })
            return
        end
        
        local macroPath = CONFIG_FOLDER .. "/macros/" .. selectedMacro .. ".json"
        
        local success = pcall(function()
            if isfile(macroPath) then
                delfile(macroPath)
            end
        end)
        
        if success then
            getgenv().Macros[selectedMacro] = nil
            getgenv().CurrentMacro = nil
            
            Window:Notify({
                Title = "Delete Macro",
                Description = "Deleted macro: " .. selectedMacro,
                Lifetime = 3
            })
            
            if getgenv().MacroDropdown then
                pcall(function()
                    getgenv().MacroDropdown:UpdateOptions(getMacroNames())
                    getgenv().MacroDropdown:UpdateValue("None")
                end)
            end
        else
            Window:Notify({
                Title = "Delete Macro",
                Description = "Failed to delete macro!",
                Lifetime = 3
            })
        end
    end,
})

Sections.MacroLeft:Divider()

Sections.MacroLeft:Header({ Text = "📥 Macro Import" })
Sections.MacroLeft:SubLabel({ Text = "Import macros from Discord links" })

getgenv()._macroImportInput = createInput(
    Sections.MacroLeft,
    "Import Link",
    "MacroImportLink",
    "Paste Discord link here",
    "All",
    function(value) end,
    ""
)

Sections.MacroLeft:Button({
    Name = "📥 Import Macro",
    Callback = function()
        local importLink = getgenv().Config.inputs.MacroImportLink or ""
        
        if not importLink or importLink == "" then
            Window:Notify({
                Title = "Macro Import",
                Description = "Please paste a link in the input box!",
                Lifetime = 3
            })
            return
        end
        
        if not importLink:match("cdn%.discordapp%.com") and not importLink:match("cdn%.discord%.com") then
            Window:Notify({
                Title = "Macro Import",
                Description = "Invalid Discord link!",
                Lifetime = 3
            })
            return
        end
        
        Window:Notify({
            Title = "Macro Import",
            Description = "Downloading macro...",
            Lifetime = 2
        })
        
        local success, result = ErrorHandler:wrapAsync(function()
            return game:HttpGet(importLink)
        end, "Download macro from Discord")
        
        if not success or not result then
            ErrorHandler:notify(Window, "Macro Import", "Failed to download macro from Discord link")
            return
        end
        
        local macroData
        success, macroData = pcall(function()
            return HttpService:JSONDecode(result)
        end)
        
        if not success or not macroData then
            Window:Notify({
                Title = "Macro Import",
                Description = "Invalid macro file format!",
                Lifetime = 3
            })
            return
        end
        
        local macroName = importLink:match("/([^/]+)%.json") or "Imported_Macro_" .. os.time()
        macroName = macroName:gsub("%%20", " ")
        
        if getgenv().Macros[macroName] then
            macroName = macroName .. "_" .. os.time()
        end
        
        local saveSuccess = saveMacro(macroName, macroData)
        
        if saveSuccess then
            loadMacros()
            local macroNames = getMacroNames()
            if getgenv()._macroDropdown then
                pcall(function()
                    getgenv()._macroDropdown:ClearOptions()
                    getgenv()._macroDropdown:InsertOptions(macroNames)
                    getgenv()._macroDropdown:UpdateSelection(macroName)
                end)
            end
            
            getgenv().CurrentMacro = macroName
            getgenv().MacroData = macroData
            getgenv().MacroTotalSteps = #macroData
            
            if macroImportInput and macroImportInput.UpdateText then
                pcall(function()
                    macroImportInput:UpdateText("")
                end)
            end
            
            Window:Notify({
                Title = "Macro Import",
                Description = "✅ Imported: " .. macroName,
                Lifetime = 3
            })
        else
            Window:Notify({
                Title = "Macro Import",
                Description = "Failed to save imported macro!",
                Lifetime = 3
            })
        end
    end,
})

Sections.MacroLeft:Divider()

Sections.MacroLeft:Header({ Text = "🎬 Recording & Playback" })
Sections.MacroLeft:SubLabel({ Text = "Record new macros or play existing ones" })

getgenv().MacroRecordToggle = createToggleNoSave(
    Sections.MacroLeft,
    "Record Macro",
    "MacroRecordToggle",
    function(value)
        if value then
            if not getgenv().CurrentMacro or getgenv().CurrentMacro == "" then
                Window:Notify({
                    Title = "Macro System",
                    Description = "Please select or create a macro first",
                    Lifetime = 3
                })
                pcall(function()
                    getgenv().MacroRecordToggle:UpdateState(false)
                end)
                return
            end
            
            getgenv().MacroRecordingV2 = true
            getgenv().MacroDataV2 = {}
            getgenv().MacroRecordingStartTime = tick()
            getgenv().MacroStatusText = "Recording"
            getgenv().MacroCurrentStep = 0
            getgenv().MacroTotalSteps = 0
            
            pcall(function()
                local workspace = game:GetService("Workspace")
                if workspace:FindFirstChild("Towers") then
                    local towerCount = 0
                    print("[Macro] Scanning for existing towers...")
                    for _, tower in pairs(workspace.Towers:GetChildren()) do
                        print("[Macro Debug] Found tower: " .. tower.Name)
                        local owner = tower:FindFirstChild("Owner")
                        if owner then
                            print("[Macro Debug]   Owner: " .. tostring(owner.Value) .. ", LocalPlayer: " .. tostring(LocalPlayer))
                        end
                        if owner and owner.Value == LocalPlayer then
                            if tower:FindFirstChild("Upgrade") then
                                if not towerTracker.upgradeConnections[tower] then
                                    print("[Macro] Setting up listener for existing tower: " .. tower.Name)
                                    setupTowerUpgradeListener(tower)
                                end
                                towerTracker.upgradeLevels[tower] = tower.Upgrade.Value
                                towerCount = towerCount + 1
                                print("[Macro] Initialized upgrade level for " .. tower.Name .. ": " .. tower.Upgrade.Value)
                            else
                                print("[Macro Debug]   No Upgrade found for " .. tower.Name)
                            end
                        end
                    end
                    print("[Macro] Recording started - initialized " .. towerCount .. " existing towers")
                else
                    print("[Macro] Warning: workspace.Towers not found")
                end
            end)
            
            if getgenv().UpdateMacroStatus then
                getgenv().UpdateMacroStatus()
            end
            
            Window:Notify({
                Title = "Macro Recording",
                Description = "Recording started for: " .. getgenv().CurrentMacro,
                Lifetime = 3
            })
        else
            getgenv().MacroRecordingV2 = false
            
            if #getgenv().MacroDataV2 > 0 and getgenv().CurrentMacro then
                local success = saveMacro(getgenv().CurrentMacro, getgenv().MacroDataV2)
                if success then
                    loadMacros()
                    local macroNames = getMacroNames()
                    if getgenv()._macroDropdown then
                        pcall(function()
                            getgenv()._macroDropdown:ClearOptions()
                            getgenv()._macroDropdown:InsertOptions(macroNames)
                            getgenv()._macroDropdown:UpdateSelection(getgenv().CurrentMacro)
                        end)
                    end
                    
                    Window:Notify({
                        Title = "Macro Recording",
                        Description = "Saved " .. #getgenv().MacroDataV2 .. " steps to " .. getgenv().CurrentMacro,
                        Lifetime = 5
                    })
                else
                    Window:Notify({
                        Title = "Macro Recording",
                        Description = "Failed to save macro",
                        Lifetime = 3
                    })
                end
            else
                Window:Notify({
                    Title = "Macro Recording",
                    Description = "Recording stopped (no actions recorded)",
                    Lifetime = 3
                })
            end
            
            getgenv().MacroStatusText = "Idle"
            getgenv().MacroCurrentStep = 0
            getgenv().MacroTotalSteps = 0
        end
        getgenv().UpdateMacroStatus()
    end,
    false
)

getgenv().MacroPlayToggle = createToggle(
    Sections.MacroLeft,
    "Play Macro",
    "MacroPlayToggle",
    function(value)
        
        if value then
            if not getgenv().CurrentMacro or getgenv().CurrentMacro == "" then
                Window:Notify({
                    Title = "Macro System",
                    Description = "Please select a macro first",
                    Lifetime = 3
                })
                getgenv().MacroPlayEnabled = false
                pcall(function()
                    getgenv().MacroPlayToggle:UpdateState(false)
                end)
                return
            end
            
            if not getgenv().Macros[getgenv().CurrentMacro] or #getgenv().Macros[getgenv().CurrentMacro] == 0 then
                Window:Notify({
                    Title = "Macro System",
                    Description = "Selected macro is empty",
                    Lifetime = 3
                })
                getgenv().MacroPlayEnabled = false
                pcall(function()
                    getgenv().MacroPlayToggle:UpdateState(false)
                end)
                return
            end
            
            getgenv().MacroPlayEnabled = true
            getgenv().MacroStatusText = "Playing"
            Window:Notify({
                Title = "Macro Playback",
                Description = "Started: " .. getgenv().CurrentMacro .. " (" .. #getgenv().Macros[getgenv().CurrentMacro] .. " steps)",
                Lifetime = 3
            })
        else
            getgenv().MacroPlayEnabled = false
            getgenv().MacroStatusText = "Idle"
            Window:Notify({
                Title = "Macro Playback",
                Description = "Stopped",
                Lifetime = 3
            })
        end
        saveMacroSettings()
        getgenv().UpdateMacroStatus()
    end,
    getgenv().MacroPlayEnabled or false
)

createInput(
    Sections.MacroLeft,
    "Step Delay (seconds)",
    "MacroStepDelay",
    "Additional delay between steps",
    "Numeric",
    function(value)
        local delay = tonumber(value) or 0
        getgenv().MacroStepDelay = delay
        saveMacroSettings()
    end,
    tostring(getgenv().MacroStepDelay or 0)
)

createToggle(
    Sections.MacroLeft,
    "Record Abilities",
    "MacroRecordAbilities",
    function(value)
        getgenv().MacroRecordAbilities = value
        saveMacroSettings()
        Window:Notify({
            Title = "Macro Recording",
            Description = value and "Abilities will be recorded" or "Abilities will NOT be recorded",
            Lifetime = 3
        })
    end,
    getgenv().MacroRecordAbilities ~= false
)

Sections.MacroLeft:Divider()

Sections.MacroLeft:Header({ Text = "📊 Macro Status" })
Sections.MacroLeft:SubLabel({ Text = "Real-time playback information" })

getgenv().MacroStatusLabel = Sections.MacroLeft:Label({ Text = "Status: Idle" })
getgenv().MacroStepLabel = Sections.MacroLeft:Label({ Text = "📝 Step: 0/0" })
getgenv().MacroActionLabel = Sections.MacroLeft:Label({ Text = "⚡ Action: None" })
getgenv().MacroUnitLabel = Sections.MacroLeft:Label({ Text = "🗼 Unit: None" })
getgenv().MacroWaitingLabel = Sections.MacroLeft:Label({ Text = "⏳ Waiting: None" })


Sections.MacroRight:Header({ Text = "🗺️ Macro Maps" })
Sections.MacroRight:SubLabel({
    Text = "Assign macros to specific maps. When you join a game, the assigned macro will auto-load."
})

local selectedGamemode = "Story"
local mapElementsByGamemode = {}

local function updateMacroMapDisplay()
    for gamemode, elements in pairs(mapElementsByGamemode) do
        for _, element in pairs(elements) do
            pcall(function()
                if element and element.SetVisibility then
                    element:SetVisibility(false)
                end
            end)
        end
    end
    
    if mapElementsByGamemode[selectedGamemode] then
        for _, element in pairs(mapElementsByGamemode[selectedGamemode]) do
            pcall(function()
                if element and element.SetVisibility then
                    element:SetVisibility(true)
                end
            end)
        end
        return
    end
    
    mapElementsByGamemode[selectedGamemode] = {}
    local elements = mapElementsByGamemode[selectedGamemode]
    
    local maps = getMapsByMode(selectedGamemode)
    
    if #maps == 0 then
        local label = Sections.MacroRight:SubLabel({
            Text = "No maps available for " .. selectedGamemode
        })
        table.insert(elements, label)
        return
    end
    
    local divider = Sections.MacroRight:Divider()
    local header = Sections.MacroRight:SubLabel({ Text = "📍 " .. selectedGamemode .. " Maps" })
    table.insert(elements, divider)
    table.insert(elements, header)
    
    for _, mapName in ipairs(maps) do
        local key = selectedGamemode .. "_" .. mapName
        local currentMacro = getgenv().MacroMaps[key] or "None"
        
        local macroNames = getMacroNames()
        table.insert(macroNames, 1, "None")
        
        local dropdown = createDropdown(
            Sections.MacroRight,
            mapName,
            "MacroMap_" .. key,
            macroNames,
            false,
            function(value)
                if value ~= "None" then
                    getgenv().MacroMaps[key] = value
                    Window:Notify({
                        Title = "Macro Maps",
                        Description = mapName .. " → " .. value,
                        Lifetime = 2
                    })
                else
                    getgenv().MacroMaps[key] = nil
                    Window:Notify({
                        Title = "Macro Maps",
                        Description = mapName .. " cleared",
                        Lifetime = 2
                    })
                end
                saveMacroSettings()
            end,
            currentMacro
        )
        
        table.insert(elements, dropdown)
    end
end

local savedGamemode = getgenv().Config.dropdowns.MacroMapsGamemode or "Story"
selectedGamemode = savedGamemode

getgenv()._gamemodeDropdown = createDropdown(
    Sections.MacroRight,
    "Select Gamemode",
    "MacroMapsGamemode",
    {"Story", "Infinite", "Challenge", "LegendaryStages", "Raids", "Dungeon", "Survival", "ElementalCaverns", "Event", "MidnightHunt", "BowlDefense", "SlimeRush", "BossRush", "Siege", "Breach", "FinalExpedition"},
    false,
    function(value)
        selectedGamemode = value
        task.spawn(function()
            updateMacroMapDisplay()
        end)
    end,
    savedGamemode
)

task.spawn(function()
    task.wait(0.2)
    updateMacroMapDisplay()
end)




local function getMapsByGamemode(mode)
    if not MapData then return {} end
    if mode == "ElementalCaverns" then return {"Light","Nature","Fire","Dark","Water"} end
    if mode == "FinalExpedition" then mode = "Story" end
    local maps = {}
    for mapName, mapInfo in pairs(MapData) do
        if mapInfo.Type and type(mapInfo.Type) == "table" then
            for _, mapType in ipairs(mapInfo.Type) do
                if mapType == mode then 
                    table.insert(maps, mapName) 
                    break 
                end
            end
        end
    end
    table.sort(maps)
    return maps
end


Sections.WebhookLeft:Header({ Text = "🔔 Discord Integration" })
Sections.WebhookLeft:SubLabel({ Text = "Send game notifications to Discord" })

getgenv().WebhookEnabled = getgenv().Config.toggles.WebhookToggle or false
getgenv().WebhookURL = getgenv().Config.inputs.WebhookURL or ""
getgenv().DiscordUserID = getgenv().Config.inputs.DiscordUserID or ""
getgenv().PingOnSecretDrop = getgenv().Config.toggles.PingOnSecretToggle or false

createToggle(
    Sections.WebhookLeft,
    "Enable Webhook Notifications",
    "WebhookToggle",
    function(value)
        getgenv().WebhookEnabled = value
        if value then
            if (getgenv().WebhookURL == "" or not string.match(getgenv().WebhookURL, "^https://discord%.com/api/webhooks/")) then
                Window:Notify({
                    Title = "Webhook",
                    Description = "Please enter a valid webhook URL first",
                    Lifetime = 5
                })
                getgenv().WebhookEnabled = false
                getgenv().Config.toggles.WebhookToggle = false
                getgenv().SaveConfig(getgenv().Config)
            else
                Window:Notify({
                    Title = "Webhook",
                    Description = "Enabled",
                    Lifetime = 3
                })
            end
        else
            Window:Notify({
                Title = "Webhook",
                Description = "Disabled",
                Lifetime = 3
            })
        end
    end,
    getgenv().WebhookEnabled
)

Sections.WebhookLeft:Divider()

Sections.WebhookLeft:Header({ Text = "⚙️ Configuration" })
Sections.WebhookLeft:SubLabel({ Text = "Enter your Discord webhook details" })

createInput(
    Sections.WebhookLeft,
    "Webhook URL",
    "WebhookURL",
    "https://discord.com/api/webhooks/...",
    "All",
    function(value)
        getgenv().WebhookURL = value or ""
    end,
    getgenv().WebhookURL
)

createInput(
    Sections.WebhookLeft,
    "Discord User ID",
    "DiscordUserID",
    "123456789012345678",
    "Numeric",
    function(value)
        getgenv().DiscordUserID = value or ""
    end,
    getgenv().DiscordUserID
)

Sections.WebhookLeft:Divider()

Sections.WebhookLeft:Header({ Text = "🔔 Notification Preferences" })
Sections.WebhookLeft:SubLabel({ Text = "Customize when you get pinged" })

createToggle(
    Sections.WebhookLeft,
    "Ping on Secret Drop",
    "PingOnSecretToggle",
    function(value)
        getgenv().PingOnSecretDrop = value
        Window:Notify({
            Title = "Ping on Secret",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().PingOnSecretDrop
)

Sections.WebhookLeft:Divider()

Sections.WebhookLeft:Header({ Text = "👥 Server Information" })
Sections.WebhookLeft:SubLabel({ Text = "Include player information in webhooks" })

getgenv().WebhookIncludePlayerCount = getgenv().Config.toggles.WebhookIncludePlayerCount or false
getgenv().WebhookIncludePlayerNames = getgenv().Config.toggles.WebhookIncludePlayerNames or false

createToggle(
    Sections.WebhookLeft,
    "Include Player Count",
    "WebhookIncludePlayerCount",
    function(value)
        getgenv().WebhookIncludePlayerCount = value
        Window:Notify({
            Title = "Player Count",
            Description = value and "Will show in webhooks" or "Hidden from webhooks",
            Lifetime = 3
        })
    end,
    getgenv().WebhookIncludePlayerCount
)

createToggle(
    Sections.WebhookLeft,
    "Display Player Names",
    "WebhookIncludePlayerNames",
    function(value)
        getgenv().WebhookIncludePlayerNames = value
        Window:Notify({
            Title = "Player Names",
            Description = value and "Will show in webhooks" or "Hidden from webhooks",
            Lifetime = 3
        })
    end,
    getgenv().WebhookIncludePlayerNames
)


Sections.MiscLeft:Header({ Text = "⚡ Performance" })
Sections.MiscLeft:SubLabel({ Text = "Boost FPS and reduce lag" })

local isInLobby = GameStateDetector:isLobby()

if not isInLobby then
    createToggle(
        Sections.MiscLeft,
        "FPS Boost",
        "FPSBoostToggle",
        function(value)
            getgenv().FPSBoostEnabled = value
            Window:Notify({
                Title = "FPS Boost",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().FPSBoostEnabled
    )
else
    getgenv().FPSBoostEnabled = false
end

createToggle(
    Sections.MiscLeft,
    "Remove Enemies & Units",
    "RemoveEnemiesToggle",
    function(value)
        getgenv().RemoveEnemiesEnabled = value
        Window:Notify({
            Title = "Remove Enemies",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().RemoveEnemiesEnabled
)

createToggle(
    Sections.MiscLeft,
    "Black Screen Mode",
    "BlackScreenToggle",
    function(value)
        getgenv().BlackScreenEnabled = value
        Window:Notify({
            Title = "Black Screen",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
        pcall(function()
            local Lighting = game:GetService("Lighting")
            if value then
                Lighting.Brightness = 0
                Lighting.ClockTime = 0
                Lighting.FogEnd = 0
                Lighting.GlobalShadows = false
                Lighting.OutdoorAmbient = Color3.fromRGB(0, 0, 0)
            else
                Lighting.Brightness = 2
                Lighting.ClockTime = 14
                Lighting.FogEnd = 100000
                Lighting.GlobalShadows = true
                Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
            end
        end)
    end,
    getgenv().BlackScreenEnabled
)

Sections.MiscLeft:Divider()

Sections.MiscLeft:Header({ Text = "🛡️ Safety" })
Sections.MiscLeft:SubLabel({ Text = "Stay safe and avoid detection" })

createToggle(
    Sections.MiscLeft,
    "Anti-AFK",
    "AntiAFKToggle",
    function(value)
        getgenv().AntiAFKEnabled = value
        Window:Notify({
            Title = "Anti-AFK",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().AntiAFKEnabled
)

createToggle(
    Sections.MiscLeft,
    "Auto Hide UI on Load",
    "AutoHideUI",
    function(value)
        getgenv().AutoHideUIEnabled = value
        Window:Notify({
            Title = "Auto Hide UI",
            Description = value and "Enabled - UI will minimize on next load" or "Disabled",
            Lifetime = 3
        })
    end,
    false
)

createToggle(
    Sections.MiscLeft,
    "Auto Execute on Teleport",
    "AutoExecuteToggle",
    function(value)
        getgenv().AutoExecuteEnabled = value
        
        local queueteleport = queue_on_teleport or queueonteleport or (syn and syn.queue_on_teleport) or (fluxus and fluxus.queue_on_teleport) or (Xeno and Xeno.queue_on_teleport)
        
        if value and queueteleport then
            local scriptToQueue = 'repeat task.wait() until game:IsLoaded() and game.Players.LocalPlayer; task.wait(2); loadstring(game:HttpGet("https://raw.githubusercontent.com/Byorl/ALS-Scripts/refs/heads/main/ALS%20Halloween%20UI.lua"))()'
            pcall(function()
                queueteleport(scriptToQueue)
            end)
            print("[ALS] ✅ Auto Execute enabled and queued")
        elseif value and not queueteleport then
            warn("[ALS] ⚠️ Auto Execute not supported by your executor")
        end
        
        Window:Notify({
            Title = "Auto Execute",
            Description = value and "Enabled - Script will auto-load on teleport" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().AutoExecuteEnabled
)

Sections.MiscLeft:Divider()

Sections.MiscLeft:Header({ Text = "🎯 Placement" })
Sections.MiscLeft:SubLabel({ Text = "Advanced tower placement options" })

if not getgenv().PlaceAnywhereEnabled then
    getgenv().PlaceAnywhereEnabled = getgenv().Config.toggles.PlaceAnywhereToggle or false
end

createToggle(
    Sections.MiscLeft,
    "Place Anywhere",
    "PlaceAnywhereToggle",
    function(value)
        getgenv().PlaceAnywhereEnabled = value
        Window:Notify({
            Title = "Place Anywhere",
            Description = value and "Enabled - Click on units to place them" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().PlaceAnywhereEnabled
)

Sections.MiscLeft:SubLabel({
    Text = "Click on any unit preview in workspace to place it at that location"
})

if not isInLobby then
    local Mouse = LocalPlayer:GetMouse()
    local UIS = game:GetService("UserInputService")
    
    local function getUnitAtMouse()
        local target = Mouse.Target
        if not target then return nil end
        
        local current = target
        while current and current ~= workspace do
            if current:IsA("Model") and current.Parent == workspace then
                local hrp = current:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local towerInfo = RS:FindFirstChild("Modules") and RS.Modules:FindFirstChild("TowerInfo")
                    if towerInfo and towerInfo:FindFirstChild(current.Name) then
                        return current.Name, hrp.CFrame
                    end
                end
            end
            current = current.Parent
        end
        
        return nil
    end
    
    Mouse.Button1Down:Connect(function()
        if not getgenv().PlaceAnywhereEnabled then return end
        
        ErrorHandler:wrapAsync(function()
            local unitName, unitCFrame = getUnitAtMouse()
            if unitName and unitCFrame then
                local placeRemote = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("PlaceTower")
                if placeRemote then
                    placeRemote:FireServer(unitName, unitCFrame)
                    debugPrint("[Place Anywhere] Placed " .. unitName)
                    
                    Window:Notify({
                        Title = "Place Anywhere",
                        Description = "Placed " .. unitName,
                        Lifetime = 2
                    })
                end
            end
        end)
    end)
    
    UIS.TouchTap:Connect(function(touchPositions, gameProcessedEvent)
        if not getgenv().PlaceAnywhereEnabled or gameProcessedEvent then return end
        
        ErrorHandler:wrapAsync(function()
            local unitName, unitCFrame = getUnitAtMouse()
            if unitName and unitCFrame then
                local placeRemote = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("PlaceTower")
                if placeRemote then
                    placeRemote:FireServer(unitName, unitCFrame)
                    debugPrint("[Place Anywhere] Placed " .. unitName)
                    
                    Window:Notify({
                        Title = "Place Anywhere",
                        Description = "Placed " .. unitName,
                        Lifetime = 2
                    })
                end
            end
        end)
    end)
end

if not getgenv().AutoVolcanoEnabled then
    getgenv().AutoVolcanoEnabled = getgenv().Config.toggles.AutoVolcanoToggle or false
end

createToggle(
    Sections.MiscLeft,
    "Auto Volcano",
    "AutoVolcanoToggle",
    function(value)
        getgenv().AutoVolcanoEnabled = value
        Window:Notify({
            Title = "Auto Volcano",
            Description = value and "Enabled - Auto-activating volcanoes" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().AutoVolcanoEnabled
)

if not isInLobby then
    task.spawn(function()
        local pollingInterval = MobileOptimizer:getPollingInterval(2)
        
        while true do
            task.wait(pollingInterval)
            
            if getgenv().AutoVolcanoEnabled then
                ErrorHandler:wrapAsync(function()
                    local gamemode = RS:FindFirstChild("Gamemode")
                    local mapName = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("MapName")
                    
                    if gamemode and gamemode.Value == "Dungeon" and mapName and mapName.Value == "Infernal Volcano" then
                        local volcano = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Volcanoes") and workspace.Map.Volcanoes:FindFirstChild("Volcano")
                        
                        if volcano then
                            local remotes = RS:FindFirstChild("Remotes")
                            local volcanoRemote = remotes and remotes:FindFirstChild("VolcanoRemote")
                            
                            if volcanoRemote then
                                volcanoRemote:FireServer(volcano)
                                debugPrint("[Auto Volcano] Activated")
                            end
                        end
                    end
                end)
            end
        end
    end)
end

if not getgenv().AutoOrbEnabled then
    getgenv().AutoOrbEnabled = getgenv().Config.toggles.AutoOrbToggle or false
end

createToggle(
    Sections.MiscLeft,
    "Auto Orb",
    "AutoOrbToggle",
    function(value)
        getgenv().AutoOrbEnabled = value
        Window:Notify({
            Title = "Auto Orb",
            Description = value and "Enabled - Auto-collecting orbs" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().AutoOrbEnabled
)

if not isInLobby then
    task.spawn(function()
        local pollingInterval = MobileOptimizer:getPollingInterval(1)
        
        while true do
            task.wait(pollingInterval)
            
            if getgenv().AutoOrbEnabled then
                ErrorHandler:wrapAsync(function()
                    local gamemode = RS:FindFirstChild("Gamemode")
                    local mapName = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("MapName")
                    
                    local shouldCollect = false
                    
                    if gamemode then
                        if gamemode.Value == "BossRush" then
                            shouldCollect = true
                        elseif gamemode.Value == "Dungeon" and mapName and mapName.Value == "Warehouse" then
                            shouldCollect = true
                        end
                    end
                    
                    if shouldCollect then
                        local orb = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("ActiveOrbs") and workspace.Map.ActiveOrbs:FindFirstChild("Orb")
                        
                        if orb then
                            local remotes = RS:FindFirstChild("Remotes")
                            local interactEvent = remotes and remotes:FindFirstChild("Interact")
                            
                            if interactEvent then
                                interactEvent:FireServer(orb)
                                debugPrint("[Auto Orb] Collected")
                            end
                        end
                    end
                end)
            end
        end
    end)
end

if not getgenv().AntiMagicZoneEnabled then
    getgenv().AntiMagicZoneEnabled = getgenv().Config.toggles.AntiMagicZoneToggle or false
end

createToggle(
    Sections.MiscLeft,
    "Anti Magic Zone",
    "AntiMagicZoneToggle",
    function(value)
        getgenv().AntiMagicZoneEnabled = value
        Window:Notify({
            Title = "Anti Magic Zone",
            Description = value and "Enabled - Teleporting away from magic zones" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().AntiMagicZoneEnabled
)

if not isInLobby then
    task.spawn(function()
        local pollingInterval = MobileOptimizer:getPollingInterval(10)
        
        while true do
            task.wait(pollingInterval)
            
            if getgenv().AntiMagicZoneEnabled then
                pcall(function()
                    local gamemode = RS:FindFirstChild("Gamemode")
                    
                    if gamemode and gamemode.Value == "BossRush" then
                        local zoneHitbox = workspace:FindFirstChild("EffectZones") and workspace.EffectZones:FindFirstChild("ZoneHitbox")
                        
                        if zoneHitbox and zoneHitbox:IsA("BasePart") then
                            local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                            
                            if hrp then
                                hrp.CFrame = zoneHitbox.CFrame
                                debugPrint("[Anti Magic Zone] Teleported")
                            end
                        end
                    end
                end)
            end
        end
    end)
end


Sections.MiscRight:Header({ Text = "ℹ️ Information" })
Sections.MiscRight:SubLabel({ Text = "Important notes and warnings" })

Sections.MiscRight:Divider()

Sections.MiscRight:SubLabel({
    Text = "⚠️ Do NOT enable Auto Execute if you already have this script in your executor's auto-execute folder!"
})

Sections.MiscRight:SubLabel({
    Text = "💡 FPS Boost is only available in-game. Remove Enemies and Black Screen Mode provide performance boosts."
})


Sections.SettingsLeft:Header({ Text = "⚙️ UI Settings" })

createToggle(
    Sections.SettingsLeft,
    "Debug Mode",
    "DebugMode",
    function(value)
        getgenv().DebugMode = value
        Window:Notify({
            Title = "Debug Mode",
            Description = (value and "Enabled" or "Disabled") .. " - Shows detailed console logs",
            Lifetime = 3
        })
    end,
    false
)

Sections.SettingsLeft:SubLabel({ Text = "Enable to see detailed console logs for troubleshooting" })

Sections.SettingsLeft:Divider()

local function getValidKeyCode(keyName, fallback)
    if not keyName or keyName == "" then return Enum.KeyCode[fallback] end
    local success, keyCode = pcall(function()
        return Enum.KeyCode[keyName]
    end)
    if success and keyCode then
        return keyCode
    else
        getgenv().Config.inputs["MenuKeybind"] = fallback
        getgenv().SaveConfig(getgenv().Config)
        return Enum.KeyCode[fallback]
    end
end

local menuKeybind = Sections.SettingsLeft:Keybind({
    Name = "Menu Toggle",
    Default = getValidKeyCode(getgenv().Config.inputs["MenuKeybind"], "LeftControl"),
    Callback = function(key)
        Window:SetKeybind(key)
        getgenv().Config.inputs["MenuKeybind"] = key.Name
        getgenv().SaveConfig(getgenv().Config)
        Window:Notify({
            Title = "Keybind Updated",
            Description = "Menu toggle set to " .. key.Name,
            Lifetime = 3
        })
    end,
}, "MenuKeybind")

if getgenv().Config.inputs["MenuKeybind"] then
    pcall(function()
        local validKey = getValidKeyCode(getgenv().Config.inputs["MenuKeybind"], "LeftControl")
        Window:SetKeybind(validKey)
    end)
end

Sections.SettingsLeft:Divider()

Sections.SettingsLeft:Header({ Text = "🖥️ UI Size (Restart Required)" })
Sections.SettingsLeft:SubLabel({ Text = "Custom window size - changes apply on next script load" })

createInput(
    Sections.SettingsLeft,
    "Width",
    "UIWidth",
    "Default: 580 (mobile) or 868 (desktop)",
    "Numeric",
    function(value)
        local width = tonumber(value)
        if width and width >= 400 and width <= 1920 then
            getgenv().Config.inputs.UIWidth = width
            saveConfig(getgenv().Config)
            Window:Notify({
                Title = "UI Width",
                Description = "Set to " .. width .. " (restart to apply)",
                Lifetime = 3
            })
        end
    end,
    tostring(getgenv().Config.inputs.UIWidth or (isMobile and 580 or 868))
)

createInput(
    Sections.SettingsLeft,
    "Height",
    "UIHeight",
    "Default: 480 (mobile) or 650 (desktop)",
    "Numeric",
    function(value)
        local height = tonumber(value)
        if height and height >= 300 and height <= 1080 then
            getgenv().Config.inputs.UIHeight = height
            saveConfig(getgenv().Config)
            Window:Notify({
                Title = "UI Height",
                Description = "Set to " .. height .. " (restart to apply)",
                Lifetime = 3
            })
        end
    end,
    tostring(getgenv().Config.inputs.UIHeight or (isMobile and 480 or 650))
)

Sections.SettingsLeft:Divider()

Sections.SettingsLeft:Header({ Text = "💾 Configuration" })

Sections.SettingsLeft:Button({
    Name = "💾 Save Config",
    Callback = function()
        local success = saveConfig(getgenv().Config)
        if success then
            Window:Notify({
                Title = "Config",
                Description = "Settings saved successfully!",
                Lifetime = 3
            })
        else
            Window:Notify({
                Title = "Config",
                Description = "Failed to save settings!",
                Lifetime = 5
            })
        end
    end
})

Sections.SettingsLeft:Button({
    Name = "📁 Load Config",
    Callback = function()
        getgenv().Config = loadConfig()
        Window:Notify({
            Title = "Config",
            Description = "Config loaded! Restart script to apply.",
            Lifetime = 5
        })
    end
})

Sections.SettingsRight:Header({ Text = "🔧 Utility Actions" })

Sections.SettingsRight:Button({
    Name = "📊 Memory Report",
    Callback = function()
        local report = getMemoryReport()
        print(report)
        
        Window:Notify({
            Title = "Memory Report",
            Description = "Check console (F9) for report",
            Lifetime = 3
        })
    end
})

Sections.SettingsRight:Button({
    Name = "🔌 Connection Manager Stats",
    Callback = function()
        local stats = ConnectionManager:getStats()
        local report = string.format(
            "\n=== Connection Manager Stats ===\n" ..
            "Active Connections: %d\n" ..
            "Tower Connections: %d\n" ..
            "Named Groups: %d\n" ..
            "Total Tracked: %d\n" ..
            "Total Cleaned: %d\n" ..
            "Last Cleanup: %.1fs ago\n" ..
            "================================\n",
            stats.active,
            stats.towers,
            stats.groups,
            stats.totalTracked,
            stats.totalCleaned,
            tick() - stats.lastCleanup
        )
        print(report)
        
        Window:Notify({
            Title = "Connection Manager",
            Description = string.format("%d active, %d cleaned", stats.active, stats.totalCleaned),
            Lifetime = 3
        })
    end
})

Sections.SettingsRight:Button({
    Name = "🧹 Force Memory Cleanup",
    Callback = function()
        local beforeMem = getMemoryUsageMB()
        
        pcall(function() collectgarbage("collect") end)
        task.wait(0.1)
        pcall(function() collectgarbage("collect") end)
        
        local afterMem = getMemoryUsageMB()
        local freed = beforeMem - afterMem
        
        Window:Notify({
            Title = "Memory Cleanup",
            Description = string.format("Freed %.1f MB", freed),
            Lifetime = 3
        })
        
        print(getMemoryReport())
    end
})

Sections.SettingsRight:Button({
    Name = "🌐 Server Hop (Safe)",
    Callback = function()
        Window:Notify({
            Title = "Server Hop",
            Description = "Cleaning up and hopping to new server...",
            Lifetime = 3
        })
        task.spawn(function()
            pcall(function()
                if getgenv().MacroEnabled then
                    getgenv().MacroEnabled = false
                end
                if getgenv().AutoJoinEnabled then
                    getgenv().AutoJoinEnabled = false
                end
            end)
            
            task.wait(1)
            cleanupBeforeTeleport()
            task.wait(1)
            
            local maxRetries = 3
            local retryDelay = 2
            
            for attempt = 1, maxRetries do
                local ok, err = pcall(function()
                    TeleportService:Teleport(game.PlaceId, LocalPlayer)
                end)
                
                if ok then
                    print("[Server Hop] Teleport initiated (Attempt " .. attempt .. ")")
                    break
                else
                    warn("[Server Hop] Attempt " .. attempt .. "/" .. maxRetries .. " failed:", err)
                    
                    if attempt < maxRetries then
                        print("[Server Hop] Retrying in " .. retryDelay .. "s...")
                        task.wait(retryDelay)
                        retryDelay = retryDelay * 2
                    else
                        Window:Notify({
                            Title = "Server Hop",
                            Description = "Failed after " .. maxRetries .. " attempts",
                            Lifetime = 5
                        })
                    end
                end
            end
        end)
    end
})



getgenv().BreachAutoJoin = getgenv().BreachAutoJoin or {}
getgenv().BreachEnabled = getgenv().Config.toggles.BreachToggle or false

Sections.BreachLeft:Header({ Text = "🛡️ Breach Auto-Join" })
Sections.BreachLeft:SubLabel({ Text = "Automatically join specific Breach modes" })

createToggle(
    Sections.BreachLeft,
    "Enable Breach Auto-Join",
    "BreachToggle",
    function(value)
        getgenv().BreachEnabled = value
        Window:Notify({
            Title = "Breach Auto-Join",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().BreachEnabled
)

Sections.BreachLeft:Divider()

Sections.BreachLeft:Header({ Text = "📋 Available Breaches" })
Sections.BreachLeft:SubLabel({ Text = "Select which breaches to auto-join" })

local breachesLoaded = false
pcall(function()
    local mapParamsModule = RS:FindFirstChild("Modules") and RS.Modules:FindFirstChild("Breach") and RS.Modules.Breach:FindFirstChild("MapParameters")
    if mapParamsModule and mapParamsModule:IsA("ModuleScript") then
        local mapParams = require(mapParamsModule)
        if mapParams and next(mapParams) then
            local breachList = {}
            for breachName, breachInfo in pairs(mapParams) do
                table.insert(breachList, { name = breachName, disabled = breachInfo.Disabled or false })
            end
            table.sort(breachList, function(a,b) return a.name < b.name end)
            
            for _, breach in ipairs(breachList) do
                local breachKey = "Breach_" .. breach.name
                local savedState = getgenv().Config.toggles[breachKey] or false
                
                if not getgenv().BreachAutoJoin[breach.name] then
                    getgenv().BreachAutoJoin[breach.name] = savedState
                end
                
                local statusText = breach.disabled and " [DISABLED]" or ""
                createToggle(
                    Sections.BreachLeft,
                    breach.name .. statusText,
                    breachKey,
                    function(value)
                        getgenv().BreachAutoJoin[breach.name] = value
                    end,
                    savedState
                )
            end
            breachesLoaded = true
        end
    end
end)

if not breachesLoaded then
    Sections.BreachLeft:SubLabel({
        Text = "⚠️ Could not load breach data. The module may not be available."
    })
end


Sections.BreachRight:Header({ Text = "👹 Sukuna's Fingers" })
Sections.BreachRight:SubLabel({ Text = "Automatically unleash Sukuna's fingers" })

getgenv().AutoUnleashSukunaEnabled = getgenv().Config.toggles.AutoUnleashSukunaToggle or false

createToggle(
    Sections.BreachRight,
    "Auto Unleash Sukuna's Fingers",
    "AutoUnleashSukunaToggle",
    function(value)
        getgenv().AutoUnleashSukunaEnabled = value
        Window:Notify({
            Title = "Sukuna's Fingers",
            Description = value and "Auto-unleash enabled" or "Auto-unleash disabled",
            Lifetime = 3
        })
    end,
    getgenv().AutoUnleashSukunaEnabled
)

Sections.BreachRight:Divider()

Sections.BreachRight:SubLabel({
    Text = "When enabled, the script will automatically teleport to and interact with the shrine to unleash Sukuna's fingers."
})


do
Sections.FinalExpeditionLeft:Header({ Text = "🏔️ Auto Join" })
Sections.FinalExpeditionLeft:SubLabel({ Text = "Automatically join Final Expedition with your preferred difficulty" })

createToggle(
    Sections.FinalExpeditionLeft,
    "Auto Join Easy",
    "FinalExpAutoJoinEasyToggle",
    function(value)
        getgenv().FinalExpAutoJoinEasyEnabled = value
        if value and getgenv().FinalExpAutoJoinHardEnabled then
            getgenv().FinalExpAutoJoinHardEnabled = false
            getgenv().Config.toggles.FinalExpAutoJoinHardToggle = false
            saveConfig(getgenv().Config)
            pcall(function()
                if getgenv().FinalExpAutoJoinHardToggle then
                    getgenv().FinalExpAutoJoinHardToggle:UpdateState(false)
                end
            end)
        end
        Window:Notify({
            Title = "Final Expedition",
            Description = value and "Auto Join Easy Enabled" or "Auto Join Easy Disabled",
            Lifetime = 3
        })
    end,
    getgenv().FinalExpAutoJoinEasyEnabled
)

getgenv()._finalExpHardToggle = createToggle(
    Sections.FinalExpeditionLeft,
    "Auto Join Hard",
    "FinalExpAutoJoinHardToggle",
    function(value)
        getgenv().FinalExpAutoJoinHardEnabled = value
        if value and getgenv().FinalExpAutoJoinEasyEnabled then
            getgenv().FinalExpAutoJoinEasyEnabled = false
            getgenv().Config.toggles.FinalExpAutoJoinEasyToggle = false
            saveConfig(getgenv().Config)
            pcall(function()
                if getgenv().FinalExpAutoJoinEasyToggle then
                    getgenv().FinalExpAutoJoinEasyToggle:UpdateState(false)
                end
            end)
        end
        Window:Notify({
            Title = "Final Expedition",
            Description = value and "Auto Join Hard Enabled" or "Auto Join Hard Disabled",
            Lifetime = 3
        })
    end,
    getgenv().FinalExpAutoJoinHardEnabled
)

getgenv().FinalExpAutoJoinHardToggle = getgenv()._finalExpHardToggle

Sections.FinalExpeditionLeft:SubLabel({
    Text = "⚠️ Only enable ONE auto join option at a time"
})

Sections.FinalExpeditionRight:Header({ Text = "⚙️ Automation" })
Sections.FinalExpeditionRight:SubLabel({ Text = "Additional automation options" })

createToggle(
    Sections.FinalExpeditionRight,
    "Auto Skip Shop",
    "FinalExpAutoSkipShopToggle",
    function(value)
        getgenv().FinalExpAutoSkipShopEnabled = value
        Window:Notify({
            Title = "Final Expedition",
            Description = value and "Auto Skip Shop Enabled" or "Auto Skip Shop Disabled",
            Lifetime = 3
        })
    end,
    getgenv().FinalExpAutoSkipShopEnabled
)

Sections.FinalExpeditionRight:SubLabel({
    Text = "Automatically skips the shop selection when available"
})

Sections.FinalExpeditionRight:Divider()

createToggle(
    Sections.FinalExpeditionRight,
    "Skip Rewards",
    "FinalExpSkipRewardsToggle",
    function(value)
        getgenv().FinalExpSkipRewardsEnabled = value
        Window:Notify({
            Title = "Final Expedition",
            Description = value and "Skip Rewards Enabled" or "Skip Rewards Disabled",
            Lifetime = 3
        })
    end,
    getgenv().FinalExpSkipRewardsEnabled
)

Sections.FinalExpeditionRight:SubLabel({
    Text = "Automatically skips reward screens"
})

Sections.FinalExpeditionRight:Divider()

Sections.FinalExpeditionRight:Header({ Text = "🎯 Auto Select Mode" })
Sections.FinalExpeditionRight:SubLabel({ Text = "Automatically select Rest/Dungeon/Double Dungeon/Shop based on priority (1=highest, 4=lowest)" })

createToggle(
    Sections.FinalExpeditionRight,
    "Enable Auto Select Mode",
    "FinalExpAutoSelectModeToggle",
    function(value)
        getgenv().FinalExpAutoSelectModeEnabled = value
        Window:Notify({
            Title = "Final Expedition",
            Description = value and "Auto Select Mode Enabled" or "Auto Select Mode Disabled",
            Lifetime = 3
        })
    end,
    getgenv().FinalExpAutoSelectModeEnabled
)

createInput(
    Sections.FinalExpeditionRight,
    "Rest Priority (1-4)",
    "FinalExpRestPriority",
    "3",
    "Numeric",
    function(value)
        local num = tonumber(value) or 3
        if num < 1 then num = 1 end
        if num > 4 then num = 4 end
        getgenv().FinalExpRestPriority = num
    end
)

createInput(
    Sections.FinalExpeditionRight,
    "Dungeon Priority (1-4)",
    "FinalExpDungeonPriority",
    "1",
    "Numeric",
    function(value)
        local num = tonumber(value) or 1
        if num < 1 then num = 1 end
        if num > 4 then num = 4 end
        getgenv().FinalExpDungeonPriority = num
    end
)

createInput(
    Sections.FinalExpeditionRight,
    "Double Dungeon Priority (1-4)",
    "FinalExpDoubleDungeonPriority",
    "2",
    "Numeric",
    function(value)
        local num = tonumber(value) or 2
        if num < 1 then num = 1 end
        if num > 4 then num = 4 end
        getgenv().FinalExpDoubleDungeonPriority = num
    end
)

createInput(
    Sections.FinalExpeditionRight,
    "Shop Priority (1-4)",
    "FinalExpShopPriority",
    "4",
    "Numeric",
    function(value)
        local num = tonumber(value) or 4
        if num < 1 then num = 1 end
        if num > 4 then num = 4 end
        getgenv().FinalExpShopPriority = num
    end
)

Sections.FinalExpeditionRight:SubLabel({
    Text = "1 = Highest priority, 3 = Lowest priority"
})


Sections.SeamlessFixLeft:Header({ Text = "🔄 Automation Settings" })
Sections.SeamlessFixLeft:Divider()

Sections.SeamlessFixLeft:Header({ Text = "💡 Seamless Fix" })
Sections.SeamlessFixLeft:SubLabel({
    Text = "Ensures the script continues running smoothly when you teleport between game instances"
})

Sections.SeamlessFixLeft:Divider()

Sections.SeamlessFixLeft:Header({ Text = "⚙️ Settings" })

createToggle(
    Sections.SeamlessFixLeft,
    "Enable Seamless Fix",
    "SeamlessFixToggle",
    function(value)
        getgenv().SeamlessFixEnabled = value
        
        task.spawn(function()
            pcall(function()
                local remotes = RS:FindFirstChild("Remotes")
                local setSettings = remotes and remotes:FindFirstChild("SetSettings")
                if setSettings then 
                    setSettings:InvokeServer("SeamlessRetry")
                end
            end)
        end)
        
        Window:Notify({
            Title = "Seamless Fix",
            Description = value and "Enabled - Script will persist through teleports" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().SeamlessFixEnabled
)

createInput(
    Sections.SeamlessFixLeft,
    "Rounds Before Restart",
    "SeamlessRounds",
    "Enter number of rounds (e.g., 4)",
    "Numeric",
    function(value)
        getgenv().SeamlessRounds = tonumber(value) or 4
        Window:Notify({
            Title = "Seamless Fix",
            Description = "Will restart after " .. (tonumber(value) or 4) .. " rounds",
            Lifetime = 3
        })
    end,
    tostring(getgenv().Config.inputs.SeamlessRounds or "4")
)

Sections.SeamlessFixLeft:SubLabel({
    Text = "Script will automatically restart after this many rounds to prevent issues"
})

Sections.SeamlessFixRight:Header({ Text = "🔄 Wave Restart" })
Sections.SeamlessFixRight:SubLabel({
    Text = "Automatically restart the match when reaching a specific wave"
})

if not getgenv().InfiniteRestartEnabled then
    getgenv().InfiniteRestartEnabled = getgenv().Config.toggles.InfiniteRestartToggle or false
end

if not getgenv().InfiniteRestartWave then
    getgenv().InfiniteRestartWave = tonumber(getgenv().Config.inputs.InfiniteRestartWave) or 50
end

createToggle(
    Sections.SeamlessFixRight,
    "Enable Wave Restart",
    "InfiniteRestartToggle",
    function(value)
        getgenv().InfiniteRestartEnabled = value
        Window:Notify({
            Title = "Wave Restart",
            Description = value and "Enabled - Will restart at wave " .. getgenv().InfiniteRestartWave or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().InfiniteRestartEnabled
)

createInput(
    Sections.SeamlessFixRight,
    "Restart at Wave",
    "InfiniteRestartWave",
    "Enter wave number (e.g., 50)",
    "Numeric",
    function(value)
        getgenv().InfiniteRestartWave = tonumber(value) or 50
        Window:Notify({
            Title = "Wave Restart",
            Description = "Will restart at wave " .. (tonumber(value) or 50),
            Lifetime = 3
        })
    end,
    tostring(getgenv().InfiniteRestartWave)
)

Sections.SeamlessFixRight:SubLabel({
    Text = "Match will automatically restart when the wave counter reaches this number"
})

Sections.SeamlessFixRight:Divider()
Sections.SeamlessFixRight:Header({ Text = "🔮 Auto Enchant" })
Sections.SeamlessFixRight:SubLabel({
    Text = "Automatically reroll enchants on your units until you get the desired one"
})

getgenv()._autoEnchantSuccess, getgenv()._autoEnchantErr = pcall(function()
    createToggle(
        Sections.SeamlessFixRight,
        "Auto Enchant",
        "AutoEnchant",
        function(value)
            getgenv().AutoEnchantEnabled = value
            Window:Notify({
                Title = "Auto Enchant",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        false
    )
    
    getgenv()._autoEnchantUnitDropdown = createDropdown(
        Sections.SeamlessFixRight,
        "Unit Selection",
        "AutoEnchantUnit",
        {"Loading units..."},
        false,
        function(value)
            getgenv().AutoEnchantUnit = value
        end,
        getgenv().AutoEnchantUnit
    )
    
    task.spawn(function()
        task.wait(3)
        
        local unitOptions = {}
        local units = getgenv()._getPlayerUnits()
        for _, unit in ipairs(units) do
            table.insert(unitOptions, unit.display)
        end
        
        if #unitOptions == 0 then
            table.insert(unitOptions, "No units found")
        end
        
        if getgenv()._autoEnchantUnitDropdown and getgenv()._autoEnchantUnitDropdown.ClearOptions and getgenv()._autoEnchantUnitDropdown.InsertOptions then
            pcall(function()
                getgenv()._autoEnchantUnitDropdown:ClearOptions()
                getgenv()._autoEnchantUnitDropdown:InsertOptions(unitOptions)
            end)
        end
    end)
    
    createDropdown(
        Sections.SeamlessFixRight,
        "Material",
        "AutoEnchantMaterial",
        {"Pearl", "DuskPearl"},
        false,
        function(value)
            getgenv().AutoEnchantMaterial = value
        end,
        getgenv().AutoEnchantMaterial
    )
    
    createDropdown(
        Sections.SeamlessFixRight,
        "Desired Enchants (Multi-Select)",
        "AutoEnchantDesiredEnchants",
        {"Defense", "Knowledge", "Attack", "Strength", "Annihilation", "Efficiency", "Ruthless", "Mastery", "Omnipotent", "Magical", "Glorious", "Midas", "Mystical"},
        true,
        function(value)
            getgenv().AutoEnchantDesiredEnchants = value
            getgenv().Config.inputs = getgenv().Config.inputs or {}
            getgenv().Config.inputs.AutoEnchantDesiredEnchants = value
            saveConfig(getgenv().Config)
        end,
        getgenv().AutoEnchantDesiredEnchants
    )
end)
if not getgenv()._autoEnchantSuccess then
    warn("[UI ERROR] Auto Enchant UI failed:", getgenv()._autoEnchantErr)
end



if not isInLobby then
    task.spawn(function()
        local pollingInterval = MobileOptimizer:getPollingInterval(2)
        
        while true do
            task.wait(pollingInterval)
            
            if getgenv().InfiniteRestartEnabled then
                pcall(function()
                    local wave = RS:FindFirstChild("Wave")
                    if wave and wave.Value then
                        local currentWave = tonumber(wave.Value) or 0
                        local targetWave = tonumber(getgenv().InfiniteRestartWave) or 50
                        
                        if currentWave >= targetWave then
                            print("[Wave Restart] Wave " .. currentWave .. " reached, restarting match...")
                            
                            if getgenv().SeamlessFixEnabled and getgenv()._SeamlessEndgameCount then
                                getgenv()._SeamlessEndgameCount = getgenv()._SeamlessEndgameCount + 1
                                local maxRounds = getgenv().SeamlessRounds or 4
                                print("[Wave Restart] Seamless counter: " .. getgenv()._SeamlessEndgameCount .. "/" .. maxRounds)
                            end
                            
                            if getgenv().WebhookEnabled and not getgenv().WebhookProcessing then
                                print("[Wave Restart] Sending webhook before restart...")
                                task.spawn(function()
                                    pcall(function()
                                        getgenv()._ForceWebhookSend = true
                                        getgenv()._WebhookSeamlessRestart = true
                                        
                                        local matchTime = "00:00:00"
                                        pcall(function()
                                            local elapsed = RS:FindFirstChild("ElapsedTime")
                                            if elapsed and elapsed.Value then
                                                local seconds = math.floor(elapsed.Value)
                                                local hours = math.floor(seconds / 3600)
                                                local minutes = math.floor((seconds % 3600) / 60)
                                                local secs = seconds % 60
                                                matchTime = string.format("%02d:%02d:%02d", hours, minutes, secs)
                                            end
                                        end)
                                        
                                        print("[Wave Restart] Match time: " .. matchTime .. ", Wave: " .. currentWave)
                                        
                                        if getgenv()._SendWebhookManual then
                                            getgenv()._SendWebhookManual()
                                        end
                                        
                                        task.wait(2)
                                        
                                        local clientData = getClientData()
                                        if clientData then
                                            getgenv()._WebhookInitialData.Jewels = clientData.Jewels or 0
                                            getgenv()._WebhookInitialData.Gold = clientData.Gold or 0
                                            getgenv()._WebhookInitialData.Emeralds = clientData.Emeralds or 0
                                            getgenv()._WebhookInitialData.Rerolls = clientData.Rerolls or 0
                                            getgenv()._WebhookInitialData.CandyBasket = clientData.CandyBasket or 0
                                            getgenv()._WebhookInitialData.HeroTokens = clientData.HeroTokens or 0
                                            getgenv()._WebhookInitialData.EXP = clientData.EXP or 0
                                            getgenv()._WebhookInitialData.HalloweenCookies = clientData.HalloweenCookies or 0
                                            getgenv()._WebhookInitialData.MagicCoins = clientData.MagicCoins or 0
                                            getgenv()._WebhookInitialData.EmberTokens = clientData.EmberTokens or 0
                                            getgenv()._WebhookInitialData.BlazeTokens = clientData.BlazeTokens or 0
                                            getgenv()._WebhookInitialData.HorseTokens = clientData.HorseTokens or 0
                                            getgenv()._WebhookInitialData.DevilDogTokens = clientData.DevilDogTokens or 0
                                            getgenv()._WebhookInitialData.TitanRushTokens = clientData.TitanRushTokens or 0
                                            getgenv()._WebhookInitialData.SoccerTokens = clientData.SoccerTokens or 0
                                            getgenv()._WebhookInitialData.SlimeCoins = clientData.SlimeCoins or 0
                                            
                                            getgenv()._WebhookInitialData.ItemData = {}
                                            if clientData.ItemData then
                                                for itemName, itemInfo in pairs(clientData.ItemData) do
                                                    if itemInfo.Amount then
                                                        getgenv()._WebhookInitialData.ItemData[itemName] = itemInfo.Amount
                                                    end
                                                end
                                            end

                                        end
                                    end)
                                end)
                                
                                task.wait(3)
                            end
                            
                            local remotes = RS:FindFirstChild("Remotes")
                            local restartRemote = remotes and remotes:FindFirstChild("RestartMatch")
                            
                            if restartRemote then
                                local success = ErrorHandler:wrapAsync(function()
                                    restartRemote:FireServer()
                                end, "Wave restart")
                                
                                if success then
                                    print("[Wave Restart] ✅ Restart signal sent")
                                else
                                    ErrorHandler:notify(Window, "Wave Restart Error", "Failed to send restart signal")
                                end
                                
                                Window:Notify({
                                    Title = "Wave Restart",
                                    Description = "Restarting at wave " .. currentWave,
                                    Lifetime = 3
                                })
                                
                                getgenv()._ForceWebhookSend = false
                                getgenv()._WebhookSeamlessRestart = false
                                
                                task.spawn(function()
                                    task.wait(5)
                                    if getgenv()._RefreshWebhookInitialData then
                                        getgenv()._RefreshWebhookInitialData()
                                    end
                                end)
                                
                                task.wait(10)
                            else
                                print("[Wave Restart] ❌ RestartMatch remote not found")
                            end
                        end
                    end
                end)
            end
        end
    end)
end


task.spawn(function()
    task.wait(2)
    
    pcall(function()
        
        local toggleCount = 0
        for flag, value in pairs(getgenv().Config.toggles) do
            local element = MacLib.Flags[flag]
            if element and element.UpdateState then
                pcall(function()
                    element:UpdateState(value)
                    toggleCount = toggleCount + 1
                end)
            end
        end
        
        local inputCount = 0
        for flag, value in pairs(getgenv().Config.inputs) do
            local element = MacLib.Flags[flag]
            if element and element.UpdateText then
                pcall(function()
                    if value ~= nil and value ~= "" then
                        element:UpdateText(tostring(value))
                        inputCount = inputCount + 1
                    end
                end)
            end
        end
        
        local dropdownCount = 0
        for flag, value in pairs(getgenv().Config.dropdowns) do
            local element = MacLib.Flags[flag]
            if element and element.UpdateSelection then
                pcall(function()
                    if value then
                        element:UpdateSelection(value)
                        dropdownCount = dropdownCount + 1
                    end
                end)
            end
        end
        
        
        if getgenv().CurrentMacro and MacLib.Flags["MacroSelect"] then
            pcall(function()
                MacLib.Flags["MacroSelect"]:UpdateSelection(getgenv().CurrentMacro)
            end)
        end
        
        if getgenv().AutoJoinConfig then
            if getgenv().AutoJoinConfig.mode and MacLib.Flags["AutoJoinMode"] then
                pcall(function()
                    MacLib.Flags["AutoJoinMode"]:UpdateSelection(getgenv().AutoJoinConfig.mode)
                end)
            end
            
            if getgenv().AutoJoinConfig.map and MacLib.Flags["AutoJoinMap"] then
                pcall(function()
                    MacLib.Flags["AutoJoinMap"]:UpdateSelection(getgenv().AutoJoinConfig.map)
                end)
            end
            
            if getgenv().AutoJoinConfig.difficulty and MacLib.Flags["AutoJoinDifficulty"] then
                pcall(function()
                    MacLib.Flags["AutoJoinDifficulty"]:UpdateSelection(getgenv().AutoJoinConfig.difficulty)
                end)
            end
        end
        
        if getgenv().BulmaWishType and MacLib.Flags["BulmaWishType"] then
            pcall(function()
                MacLib.Flags["BulmaWishType"]:UpdateSelection(getgenv().BulmaWishType)
            end)
        end
        
        if getgenv().SkeletonKnightTargetUnit and MacLib.Flags["SkeletonKnightTargetUnit"] then
            pcall(function()
                MacLib.Flags["SkeletonKnightTargetUnit"]:UpdateSelection(getgenv().SkeletonKnightTargetUnit)
            end)
        end
        
        if getgenv().AlucardHypnosisTargetUnit and MacLib.Flags["AlucardHypnosisTargetUnit"] then
            pcall(function()
                MacLib.Flags["AlucardHypnosisTargetUnit"]:UpdateSelection(getgenv().AlucardHypnosisTargetUnit)
            end)
        end
        
    end)
end)


getgenv()._GuiService = game:GetService("GuiService")

getgenv()._isTeleporting = false

task.spawn(function()
    local lastEndGameUIInstance = nil
    local hasProcessedCurrentUI = false
    local endGameUIDetectedTime = 0
    local endGameUIWasPresent = false
    local lastActionTime = 0
    local ACTION_TIMEOUT = 45
    local newGameDetected = false
    local lastEndGameUIState = false
    
    while true do
        task.wait(0.2)
        
        local success, errorMsg = pcall(function()
            if not LocalPlayer or not LocalPlayer.PlayerGui then return end
            
            local endGameUI = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
            local currentEndGameUIState = endGameUI and endGameUI.Enabled or false
            
            if lastEndGameUIState and not currentEndGameUIState then
                newGameDetected = true
                hasProcessedCurrentUI = false
                lastEndGameUIInstance = nil
                endGameUIWasPresent = false
                getgenv()._isTeleporting = false
                
                getgenv().MacroGameState.hasStartButton = false
                getgenv().MacroGameState.currentWave = 0
                getgenv().MacroGameState.gameEnded = false
                getgenv().MacroGameState.hasEndGameUI = false
                getgenv().MacroCurrentStep = 1
                getgenv().MacroActionText = ""
                getgenv().MacroUnitText = ""
                getgenv().MacroWaitingText = ""
                getgenv().MacroStatusText = "New Game Started"
                getgenv().MacroPlaybackActive = false
                
                getgenv().SmartCardPicked = {}
                getgenv().SmartCardLastPromptId = nil
                getgenv().SlowerCardPicked = {}
                getgenv().SlowerCardLastPromptId = nil
                
                if getgenv().UpdateMacroStatus then
                    getgenv().UpdateMacroStatus()
                end
            end
            
            lastEndGameUIState = currentEndGameUIState
            
            if endGameUI then
                endGameUIWasPresent = true
            end
            
            if not endGameUI or not endGameUI.Enabled then 
                return 
            end
            
            local bg = endGameUI:FindFirstChild("BG")
            if not bg then return end
            
            local buttons = bg:FindFirstChild("Buttons")
            if not buttons then return end
            
            if lastEndGameUIInstance and endGameUI ~= lastEndGameUIInstance then
                hasProcessedCurrentUI = false
                lastEndGameUIInstance = endGameUI
                endGameUIDetectedTime = tick()
                newGameDetected = false
            end
            
            if not lastEndGameUIInstance then
                lastEndGameUIInstance = endGameUI
                endGameUIDetectedTime = tick()
            end
            
            if hasProcessedCurrentUI then
                return
            end
            
            local nextButton = buttons:FindFirstChild("Next")
            local retryButton = buttons:FindFirstChild("Retry")
            local leaveButton = buttons:FindFirstChild("Leave")
            
            if not retryButton or not nextButton or not leaveButton then
                for _, button in pairs(buttons:GetChildren()) do
                    if button:IsA("TextButton") or button:IsA("ImageButton") then
                        local textLabel = button:FindFirstChildWhichIsA("TextLabel", true)
                        if textLabel then
                            local text = textLabel.Text:lower()
                            if text:find("retry") and not retryButton then
                                retryButton = button
                            elseif text:find("next") and not nextButton then
                                nextButton = button
                            elseif text:find("leave") and not leaveButton then
                                leaveButton = button
                            end
                        end
                    end
                end
            end
            
            if getgenv().DebugMode then
                print(string.format("[Auto Actions] Buttons detected - Next: %s | Retry: %s | Leave: %s", 
                    tostring(nextButton and nextButton.Visible), 
                    tostring(retryButton and retryButton.Visible), 
                    tostring(leaveButton and leaveButton.Visible)))
                print(string.format("[Auto Actions] Toggles - AutoNext: %s | AutoRetry: %s | AutoLeave: %s | AutoSmart: %s",
                    tostring(getgenv().AutoNextEnabled),
                    tostring(getgenv().AutoFastRetryEnabled),
                    tostring(getgenv().AutoLeaveEnabled),
                    tostring(getgenv().AutoSmartEnabled)))
            end
            
            local buttonToPress, actionName = nil, ""
            
            local isFinalExpedition = false
            pcall(function()
                local gamemode = RS:FindFirstChild("Gamemode")
                if gamemode and gamemode.Value == "FinalExpedition" then
                    isFinalExpedition = true
                end
            end)
            
            if isFinalExpedition then
                
                local promptWait = 0
                while promptWait < 10 do
                    local promptExists = false
                    pcall(function()
                        local promptGui = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                        if promptGui and promptGui.Enabled then
                            promptExists = true
                        end
                    end)
                    
                    if not promptExists then
                        break
                    end
                    
                    task.wait(0.5)
                    promptWait = promptWait + 0.5
                end
                
                task.wait(5)
                
                local waitTime = 5
                local maxWaitTime = 15
                
                while waitTime < maxWaitTime do
                    local foundNext = false
                    pcall(function()
                        if buttons then
                            nextButton = buttons:FindFirstChild("Next")
                            if not nextButton then
                                for _, button in pairs(buttons:GetChildren()) do
                                    if button:IsA("TextButton") or button:IsA("ImageButton") then
                                        local textLabel = button:FindFirstChildWhichIsA("TextLabel", true)
                                        if textLabel and textLabel.Text:lower():find("next") then
                                            nextButton = button
                                            break
                                        end
                                    end
                                end
                            end
                            
                            if nextButton and nextButton.Visible then
                                foundNext = true
                            end
                        end
                    end)
                    
                    if foundNext then
                        break
                    end
                    
                    task.wait(0.5)
                    waitTime = waitTime + 0.5
                end
                
                if waitTime >= maxWaitTime then
                    print("[Final Expedition] Timeout waiting for Next button after 15s")
                end
            end
            
            if getgenv().AutoSmartEnabled then
                if nextButton and nextButton.Visible then
                    buttonToPress = nextButton
                    actionName = "Next"
                elseif retryButton and retryButton.Visible then
                    buttonToPress = retryButton
                    actionName = "Retry"
                elseif leaveButton and leaveButton.Visible then
                    if isFinalExpedition and nextButton and nextButton.Visible then
                        buttonToPress = nextButton
                        actionName = "Next"
                    else
                        buttonToPress = leaveButton
                        actionName = "Leave"
                    end
                end
            elseif getgenv().AutoNextEnabled and nextButton and nextButton.Visible then
                buttonToPress = nextButton
                actionName = "Next"
            elseif getgenv().AutoFastRetryEnabled and retryButton and retryButton.Visible then
                buttonToPress = retryButton
                actionName = "Retry"
            elseif getgenv().AutoLeaveEnabled and leaveButton and leaveButton.Visible then
                if isFinalExpedition and nextButton and nextButton.Visible then
                    buttonToPress = nextButton
                    actionName = "Next"
                else
                    buttonToPress = leaveButton
                    actionName = "Leave"
                end
            end
            
            if buttonToPress then
                if getgenv()._isTeleporting then
                    return
                end
                
                if getgenv().WebhookEnabled then
                    if not getgenv().WebhookProcessing then
                        print("[Auto " .. actionName .. "] Triggering webhook...")
                        task.spawn(function()
                            pcall(function()
                                if getgenv()._SendMatchWebhook then
                                    getgenv()._SendMatchWebhook()
                                end
                            end)
                        end)
                    end
                    
                    print("[Auto " .. actionName .. "] Waiting for webhook to complete...")
                    
                    local maxWait = 0
                    local maxWaitTime = 15
                    
                    while getgenv().WebhookProcessing and maxWait < maxWaitTime do
                        task.wait(0.5)
                        maxWait = maxWait + 0.5
                        
                        if maxWait % 5 == 0 then
                            print("[Auto " .. actionName .. "] Still waiting... (" .. maxWait .. "s)")
                        end
                    end
                    
                    if getgenv().WebhookProcessing then
                        warn("[Auto " .. actionName .. "] Webhook timeout, forcing continue")
                        getgenv().WebhookProcessing = false
                    else
                        print("[Auto " .. actionName .. "] ✅ Webhook completed")
                    end
                    
                    task.wait(1)
                else
                    task.wait(0.5)
                end
                
                hasProcessedCurrentUI = true
                lastActionTime = tick()
                
                local pressSuccess = false
                local clickMethod = "Unknown"
                
                local function tryGuiServiceMethod()
                    getgenv()._ButtonPressActive = true
                    local success = pcall(function()
                        if not buttonToPress or not buttonToPress.Parent then
                            getgenv()._ButtonPressActive = false
                            return
                        end
                        
                        if not buttonToPress:IsDescendantOf(game) then
                            getgenv()._ButtonPressActive = false
                            return
                        end
                        
                        if not buttonToPress:IsDescendantOf(LocalPlayer.PlayerGui) then
                            getgenv()._ButtonPressActive = false
                            return
                        end
                        
                        local GuiService = game:GetService("GuiService")
                        
                        pcall(function()
                            GuiService.SelectedObject = nil
                        end)
                        task.wait(0.1)
                        
                        if not buttonToPress or not buttonToPress.Parent or not buttonToPress:IsDescendantOf(LocalPlayer.PlayerGui) then
                            return
                        end
                        
                        local setSuccess = pcall(function()
                            GuiService.SelectedObject = buttonToPress
                        end)
                        
                        if not setSuccess then
                            return
                        end
                        
                        local lockConnection
                        lockConnection = RunService.Heartbeat:Connect(function()
                            pcall(function()
                                if buttonToPress and buttonToPress.Parent and GuiService.SelectedObject ~= buttonToPress then
                                    GuiService.SelectedObject = buttonToPress
                                end
                            end)
                        end)
                        
                        task.wait(0.3)
                        
                        if GuiService.SelectedObject == buttonToPress then
                            VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                            task.wait(0.05)
                            VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                            task.wait(0.2)
                            
                            if lockConnection then
                                lockConnection:Disconnect()
                            end
                            
                            GuiService.SelectedObject = nil
                            pressSuccess = true
                            clickMethod = "GuiService"
                        else
                            if lockConnection then
                                lockConnection:Disconnect()
                            end
                        end
                    end)
                    getgenv()._ButtonPressActive = false
                    return success and pressSuccess
                end
                
                local function tryMouseClickMethod()
                    local success = pcall(function()
                        if not buttonToPress or not buttonToPress.Parent or not buttonToPress:IsDescendantOf(LocalPlayer.PlayerGui) then
                            return
                        end
                        
                        local absolutePosition = buttonToPress.AbsolutePosition
                        local absoluteSize = buttonToPress.AbsoluteSize
                        local centerX = absolutePosition.X + (absoluteSize.X / 2)
                        local centerY = absolutePosition.Y + (absoluteSize.Y / 2)
                        
                        VIM:SendMouseButtonEvent(centerX, centerY, 0, true, game, 0)
                        task.wait(0.05)
                        VIM:SendMouseButtonEvent(centerX, centerY, 0, false, game, 0)
                        task.wait(0.2)
                        
                        pressSuccess = true
                        clickMethod = "MouseClick"
                    end)
                    return success and pressSuccess
                end
                
                local function tryActivatedMethod()
                    local success = pcall(function()
                        if not buttonToPress or not buttonToPress.Parent or not buttonToPress:IsDescendantOf(LocalPlayer.PlayerGui) then
                            return
                        end
                        
                        getgenv()._SkipRecordingNextCall = true
                        for _, signal in pairs({"MouseButton1Click", "Activated"}) do
                            pcall(function()
                                for _, connection in pairs(getconnections(buttonToPress[signal])) do
                                    connection:Fire()
                                end
                            end)
                        end
                        getgenv()._SkipRecordingNextCall = false
                        
                        task.wait(0.2)
                        pressSuccess = true
                        clickMethod = "Activated"
                    end)
                    return success and pressSuccess
                end
                
                if tryGuiServiceMethod() then
                    print("[Auto " .. actionName .. "] ✅ Button pressed successfully! (Method: " .. clickMethod .. ")")
                    getgenv()._isTeleporting = true
                elseif tryMouseClickMethod() then
                    print("[Auto " .. actionName .. "] ✅ Button pressed successfully! (Method: " .. clickMethod .. ")")
                    getgenv()._isTeleporting = true
                elseif tryActivatedMethod() then
                    print("[Auto " .. actionName .. "] ✅ Button pressed successfully! (Method: " .. clickMethod .. ")")
                    getgenv()._isTeleporting = true
                else
                    warn("[Auto " .. actionName .. "] ❌ All click methods failed!")
                end
            end
        end)
    end
end)

do
    task.spawn(function()
    while true do
        task.wait(1)
        
        if getgenv()._checkIfInLobby() then
            task.wait(2)
            continue
        end
        
        if getgenv().AutoReadyEnabled then
            local success, err = pcall(function()
                local bottomGui = LocalPlayer.PlayerGui:FindFirstChild("Bottom")
                if bottomGui then
                    local frame = bottomGui:FindFirstChild("Frame")
                    if frame then
                        local children = frame:GetChildren()
                        if children[2] then
                            local subChildren = children[2]:GetChildren()
                            if subChildren[6] then
                                local textButton = subChildren[6]:FindFirstChild("TextButton")
                                if textButton then
                                    local textLabel = textButton:FindFirstChild("TextLabel")
                                    if textLabel and textLabel.Text == "Start" then
                                        local remotes = RS:FindFirstChild("Remotes")
                                        local playerReady = remotes and remotes:FindFirstChild("PlayerReady")
                                        if playerReady then
                                            ErrorHandler:wrapAsync(function()
                                                playerReady:FireServer()
                                            end, "Auto ready")
                                            task.wait(2)
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end)
            if not success then
                warn("[Auto Ready] Error: " .. tostring(err))
            end
        end
    end
    end)
end

task.spawn(function()
    while true do
        task.wait(0.1)
        
        if not getgenv().AutoEnchantEnabled then
            task.wait(0.5)
            continue
        end
        
        if not getgenv().AutoEnchantUnit or getgenv().AutoEnchantUnit == "" or getgenv().AutoEnchantUnit == "No units found" or getgenv().AutoEnchantUnit == "Loading units..." then
            if getgenv().DebugMode then
                print("[AutoEnchant] Waiting for valid unit selection: " .. tostring(getgenv().AutoEnchantUnit))
            end
            task.wait(0.5)
            continue
        end
        
        if not getgenv().AutoEnchantDesiredEnchants or type(getgenv().AutoEnchantDesiredEnchants) ~= "table" then
            if getgenv().DebugMode then
                print("[AutoEnchant] Waiting for desired enchants to be set")
            end
            task.wait(0.5)
            continue
        end
        
        local hasDesiredEnchant = false
        for enchant, selected in pairs(getgenv().AutoEnchantDesiredEnchants) do
            if selected then
                hasDesiredEnchant = true
                break
            end
        end
        
        if not hasDesiredEnchant then
            if getgenv().DebugMode then
                print("[AutoEnchant] No desired enchants selected")
            end
            task.wait(0.5)
            continue
        end
        
        if getgenv().DebugMode then
            print("[AutoEnchant] Starting enchant attempt for: " .. getgenv().AutoEnchantUnit)
        end
        
        local success, err = pcall(function()
            local unit = getgenv()._findUnitByDisplay(getgenv().AutoEnchantUnit)
            if not unit then
                warn("[AutoEnchant] Selected unit not found")
                return
            end
            
            local currentEnchant = getgenv()._getUnitEnchant(unit.unitID)
            
            if getgenv().AutoEnchantDesiredEnchants[currentEnchant] then
                debugPrint("[AutoEnchant] Unit already has desired enchant: " .. currentEnchant)
                return
            end
            
            local remotes = RS:FindFirstChild("Remotes")
            if not remotes then
                warn("[AutoEnchant] Remotes not found")
                return
            end
            
            local enchants = remotes:FindFirstChild("Enchants")
            if not enchants then
                warn("[AutoEnchant] Enchants folder not found")
                return
            end
            
            local rollEnchant = enchants:FindFirstChild("RollEnchant")
            if not rollEnchant then
                warn("[AutoEnchant] RollEnchant remote not found")
                return
            end
            
            print("[AutoEnchant] Attempting to roll enchant for " .. unit.unitName .. " (ID: " .. unit.unitID .. ") using " .. getgenv().AutoEnchantMaterial)
            print("[AutoEnchant] Current enchant: " .. tostring(currentEnchant))
            
            local rollSuccess, rollResult = pcall(function()
                return rollEnchant:InvokeServer(unit.unitID, getgenv().AutoEnchantMaterial, currentEnchant)
            end)
            
            if rollSuccess then
                debugPrint("[AutoEnchant] Rolled enchant for " .. unit.unitName .. " using " .. getgenv().AutoEnchantMaterial)
                task.wait(0.2)
                
                local newEnchant = getgenv()._getUnitEnchant(unit.unitID)
                if getgenv().AutoEnchantDesiredEnchants[newEnchant] then
                    Window:Notify({
                        Title = "Auto Enchant",
                        Description = "Got " .. newEnchant .. " on " .. unit.unitName .. "!",
                        Lifetime = 5,
                        Style = "Confirm"
                    })
                    getgenv().AutoEnchantEnabled = false
                end
            else
                warn("[AutoEnchant] Failed to roll enchant: " .. tostring(rollResult))
                task.wait(0.5)
            end
        end)
        
        if not success then
            warn("[AutoEnchant] Error: " .. tostring(err))
            task.wait(0.5)
        end
    end
end)



getgenv()._AbilityHelpers1 = getgenv()._AbilityHelpers1 or {}

getgenv()._AbilityHelpers1.getCurrentWave = function()
    local ok, res = pcall(function()
        local waveValue = RS:FindFirstChild("Wave")
        if waveValue and waveValue:IsA("IntValue") then
            return waveValue.Value
        end
        return 0
    end)
    
    if ok and res > 0 then
        return res
    end
    
    local ok2, res2 = pcall(function()
        local gui = LocalPlayer.PlayerGui:FindFirstChild("HUD")
        if not gui then return 0 end
        local frame = gui:FindFirstChild("Frame")
        if not frame then return 0 end
        local wave = frame:FindFirstChild("Wave")
        if not wave then return 0 end
        local label = wave:FindFirstChild("TextLabel")
        if not label then return 0 end
        local text = label.Text
        local num = tonumber(text:match("%d+"))
        return num or 0
    end)
    return ok2 and res2 or 0
end

getgenv()._AbilityHelpers1.getCurrentTimeScale = function()
    local ok, res = pcall(function()
        local timeScale = RS:FindFirstChild("TimeScale")
        if timeScale and timeScale:IsA("NumberValue") then
            return timeScale.Value or 1
        end
        return 1
    end)
    return ok and res or 1
end

getgenv()._AbilityHelpers1.getUpgradeLevel = function(tower)
    if not tower then return 0 end
    local ok, res = pcall(function()
        local u = tower:FindFirstChild("Upgrade")
        if u and u:IsA("ValueBase") then return u.Value or 0 end
        return 0
    end)
    return ok and res or 0
end

getgenv()._AbilityHelpers1.fixAbilityName = function(abilityName)
    local fixed = abilityName
    fixed = fixed:gsub("!!+", "!")
    fixed = fixed:gsub("%?%?+", "?")
    return fixed
end

getgenv()._AbilityHelpers1.useAbility = function(tower, abilityName)
    if tower then
        if abilityName == "Who Decided That?" then
            ErrorHandler:wrapAsync(function() 
                RS.Remotes.Ability:InvokeServer(tower, abilityName)
                print("[Soul Ability] Used: " .. abilityName)
            end, "Use ability: " .. abilityName)
        else
            local correctedName = getgenv()._AbilityHelpers1.fixAbilityName(abilityName)
            ErrorHandler:wrapAsync(function() 
                RS.Remotes.Ability:InvokeServer(tower, correctedName) 
            end, "Use ability: " .. correctedName)
        end
    end
end

getgenv()._AbilityHelpers1.getAbilityData = function(towerName, abilityName)
    if abilityName == "Who Decided That?" then
        return {
            cooldown = 999999,
            requiredLevel = 0,
            isSoulAbility = true
        }
    end
    
    local abilities = getAllAbilities(towerName)
    return abilities[abilityName]
end

getgenv()._AbilityHelpers1.isOnCooldown = function(towerName, abilityName)
    local d = getgenv()._AbilityHelpers1.getAbilityData(towerName, abilityName)
    if not d or not d.cooldown then return false end
    local key = towerName .. "_" .. abilityName
    local last = abilityCooldowns[key]
    if not last then return false end
    
    if d.isSoulAbility then
        local timeSinceUse = tick() - last
        local cooldownRemaining = d.cooldown - timeSinceUse
        return cooldownRemaining > 0.5
    end
    
    local scale = getgenv()._AbilityHelpers1.getCurrentTimeScale()
    local effectiveCd = d.cooldown / scale
    local timeSinceUse = tick() - last
    local cooldownRemaining = effectiveCd - timeSinceUse
    return cooldownRemaining > 0.5
end

getgenv()._AbilityHelpers1.setAbilityUsed = function(towerName, abilityName)
    abilityCooldowns[towerName.."_"..abilityName] = tick()
end

getgenv()._AbilityHelpers1.hasAbilityBeenUnlocked = function(towerName, abilityName, towerLevel)
    local d = getgenv()._AbilityHelpers1.getAbilityData(towerName, abilityName)
    if d and d.isSoulAbility then
        return true
    end
    return d and towerLevel >= d.requiredLevel
end

if not getgenv()._AbilityState then
    getgenv()._AbilityState = {
        abilityCooldowns = {},
        bossSpawnTime = nil,
        generalBossSpawnTime = nil,
        bossInRangeTracker = {}
    }
end

getgenv()._AbilityHelpers2a = getgenv()._AbilityHelpers2a or {}

getgenv()._AbilityHelpers2a.isOnCooldown = function(towerUniqueId, abilityName, actualTowerName)
    local state = getgenv()._AbilityState
    local helpers1 = getgenv()._AbilityHelpers1
    local nameForData = actualTowerName or towerUniqueId:match("^([^_]+)")
    
    local d = helpers1.getAbilityData(nameForData, abilityName)
    if not d or not d.cooldown then return false end
    
    local key = towerUniqueId .. "_" .. abilityName
    local last = state.abilityCooldowns[key]
    if not last then return false end
    
    local scale = helpers1.getCurrentTimeScale()
    local effectiveCd = d.cooldown / scale
    local timeSinceUse = tick() - last
    local cooldownRemaining = effectiveCd - timeSinceUse
    return cooldownRemaining > 0.5
end

getgenv()._AbilityHelpers2a.setAbilityUsed = function(towerUniqueId, abilityName)
    local state = getgenv()._AbilityState
    state.abilityCooldowns[towerUniqueId.."_"..abilityName] = tick()
end

getgenv()._AbilityHelpers2a.bossExists = function()
    local ok, res = pcall(function()
        local enemies = workspace:FindFirstChild("Enemies")
        if not enemies then 
            return false 
        end
        
        for _, enemy in pairs(enemies:GetChildren()) do
            if enemy:IsA("Model") then
                local bossValue = enemy:FindFirstChild("Boss")
                if bossValue and bossValue:IsA("BoolValue") and bossValue.Value == true then
                    return true
                end
            end
        end
        
        return false
    end)
    if not ok then
        warn("[Auto Ability] Error checking boss existence:", res)
    end
    return ok and res
end

getgenv()._AbilityHelpers2a.bossReadyForAbilities = function()
    local state = getgenv()._AbilityState
    if getgenv()._AbilityHelpers2a.bossExists() then
        if not state.generalBossSpawnTime then state.generalBossSpawnTime = tick() end
        return (tick() - state.generalBossSpawnTime) >= 1
    else
        state.generalBossSpawnTime = nil
        return false
    end
end

getgenv()._AbilityHelpers3 = getgenv()._AbilityHelpers3 or {}

getgenv()._AbilityHelpers3.getBossCFrame = function()
    local ok, res = pcall(function()
        local enemies = workspace:FindFirstChild("Enemies")
        if not enemies then return nil end
        
        for _, enemy in pairs(enemies:GetChildren()) do
            if enemy:IsA("Model") then
                local bossValue = enemy:FindFirstChild("Boss")
                if bossValue and bossValue:IsA("BoolValue") and bossValue.Value == true then
                    local hrp = enemy:FindFirstChild("HumanoidRootPart")
                    if hrp then 
                        return hrp.CFrame 
                    end
                end
            end
        end
        
        return nil
    end)
    return ok and res or nil
end

getgenv()._AbilityHelpers3.getTowerCFrame = function(tower)
    if not tower then return nil end
    local ok, res = pcall(function()
        local hrp = tower:FindFirstChild("HumanoidRootPart")
        if hrp then return hrp.CFrame end
        return nil
    end)
    return ok and res or nil
end

getgenv()._AbilityHelpers3.getTowerRange = function(tower)
    if not tower then return 0 end
    local ok, res = pcall(function()
        local stats = tower:FindFirstChild("Stats")
        if not stats then return 0 end
        local range = stats:FindFirstChild("Range")
        if not range then return 0 end
        return range.Value or 0
    end)
    return ok and res or 0
end

getgenv()._AbilityHelpers3.isBossInRange = function(tower)
    local bossCF = getgenv()._AbilityHelpers3.getBossCFrame()
    local towerCF = getgenv()._AbilityHelpers3.getTowerCFrame(tower)
    if not bossCF or not towerCF then 
        return false 
    end
    local range = getgenv()._AbilityHelpers3.getTowerRange(tower)
    if range <= 0 then 
        return false 
    end
    local distance = (bossCF.Position - towerCF.Position).Magnitude
    local inRange = distance <= range
    
    if getgenv().DebugMode then
        print(string.format("[Boss Range] %s: Distance=%.1f, Range=%.1f, InRange=%s", 
            tower.Name, distance, range, tostring(inRange)))
    end
    
    return inRange
end

getgenv()._AbilityHelpers3.checkBossInRangeForDuration = function(tower, requiredDuration)
    if not tower then return false end
    local state = getgenv()._AbilityState
    local name = tower.Name
    local currentTime = tick()
    if getgenv()._AbilityHelpers3.isBossInRange(tower) then
        if requiredDuration == 0 then return true end
        if not state.bossInRangeTracker[name] then
            state.bossInRangeTracker[name] = currentTime
            return false
        else
            return (currentTime - state.bossInRangeTracker[name]) >= requiredDuration
        end
    else
        state.bossInRangeTracker[name] = nil
    end
    return false
end

getgenv()._AbilityHelpers3.getTowerInfoName = function(tower)
    if not tower then return nil end
    local uniqueId = tostring(tower)
    return tower.Name .. "_" .. uniqueId:sub(-8)
end

getgenv()._AbilityHelpers3.resetRoundTrackers = function()
    local state = getgenv()._AbilityState
    state.bossSpawnTime = nil
    state.generalBossSpawnTime = nil
    state.bossInRangeTracker = {}
    state.abilityCooldowns = {}
end

getgenv()._AbilitySystemFuncs = {
    getCurrentWave = getgenv()._AbilityHelpers1.getCurrentWave,
    getCurrentTimeScale = getgenv()._AbilityHelpers1.getCurrentTimeScale,
    getUpgradeLevel = getgenv()._AbilityHelpers1.getUpgradeLevel,
    fixAbilityName = getgenv()._AbilityHelpers1.fixAbilityName,
    useAbility = getgenv()._AbilityHelpers1.useAbility,
    getAbilityData = getgenv()._AbilityHelpers1.getAbilityData,
    hasAbilityBeenUnlocked = getgenv()._AbilityHelpers1.hasAbilityBeenUnlocked,
    isOnCooldown = getgenv()._AbilityHelpers2a.isOnCooldown,
    setAbilityUsed = getgenv()._AbilityHelpers2a.setAbilityUsed,
    bossExists = getgenv()._AbilityHelpers2a.bossExists,
    bossReadyForAbilities = getgenv()._AbilityHelpers2a.bossReadyForAbilities,
    getTowerCFrame = getgenv()._AbilityHelpers3.getTowerCFrame,
    getBossCFrame = getgenv()._AbilityHelpers3.getBossCFrame,
    getTowerRange = getgenv()._AbilityHelpers3.getTowerRange,
    isBossInRange = getgenv()._AbilityHelpers3.isBossInRange,
    checkBossInRangeForDuration = getgenv()._AbilityHelpers3.checkBossInRangeForDuration,
    getTowerInfoName = getgenv()._AbilityHelpers3.getTowerInfoName,
    resetRoundTrackers = getgenv()._AbilityHelpers3.resetRoundTrackers
}

getgenv()._ProcessAbility = function(tower, unitName, abilityName, cfg, currentWave, hasBoss)
    local funcs = getgenv()._AbilitySystemFuncs
    local infoName = funcs.getTowerInfoName(tower) 
    local towerLevel = funcs.getUpgradeLevel(tower)
    local savedCfg = getgenv().Config.abilities[unitName] and getgenv().Config.abilities[unitName][abilityName]
    
    if savedCfg then
        cfg.enabled = savedCfg.enabled
        cfg.onlyOnBoss = savedCfg.onlyOnBoss or false
        cfg.useOnWave = savedCfg.useOnWave or false
        cfg.specificWave = savedCfg.specificWave
        cfg.requireBossInRange = savedCfg.requireBossInRange or false
    end
    
    if not cfg.enabled then return end
    
    local shouldUse = true
    
    if not funcs.hasAbilityBeenUnlocked(unitName, abilityName, towerLevel) then
        return
    end
    
    if funcs.isOnCooldown(infoName, abilityName, unitName) then
        return
    end
    
    if cfg.useOnWave and cfg.specificWave then
        if currentWave ~= cfg.specificWave then
            return
        end
    end
    
    if cfg.onlyOnBoss then
        if not hasBoss then
            return
        end
        
        if not funcs.bossReadyForAbilities() then
            task.wait(0.5)
            if not funcs.bossReadyForAbilities() then
                return
            end
        end
    end
    
    if cfg.requireBossInRange then
        if not hasBoss then
            return
        end
        
        local inRangeChecks = 0
        for i = 1, 5 do
            if funcs.checkBossInRangeForDuration(tower, 0) then
                inRangeChecks = inRangeChecks + 1
            end
            task.wait(0.15)
        end
        
        if inRangeChecks < 4 then
            if getgenv().DebugMode then
                print(string.format("[Ability] %s: Boss not consistently in range (%d/5 checks)", tower.Name, inRangeChecks))
            end
            return
        end
        
        if getgenv().DebugMode then
            print(string.format("[Ability] %s: Boss confirmed in range, using ability", tower.Name))
        end
    end
    
    if not funcs.isOnCooldown(infoName, abilityName, unitName) then
        funcs.useAbility(tower, abilityName)
        funcs.setAbilityUsed(infoName, abilityName)
    end
end

getgenv()._lastGameStartedForAbilities = true

getgenv()._InitializeGameSystems = function()

do
getgenv()._AbilitySystem_lastWave = 0
getgenv()._AbilitySystem_Towers = workspace:WaitForChild("Towers", 10)
getgenv()._AbilitySystem_funcs = getgenv()._AbilitySystemFuncs

getgenv()._checkGameEndedReset = function()
    local ok = pcall(function()
        local endGameUI = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
        if endGameUI and endGameUI:FindFirstChild("Frame") then
            getgenv()._AbilitySystem_funcs.resetRoundTrackers()
        end
    end)
end

task.spawn(function()
    while true do
        task.wait(0.3)
        
        if getgenv()._checkIfInLobby() then
            task.wait(2)
            continue
        end
        
        local function processAllAbilities()
            getgenv()._checkGameEndedReset()
            local currentWave = getgenv()._AbilitySystem_funcs.getCurrentWave()
            local hasBoss = getgenv()._AbilitySystem_funcs.bossExists()
            
            local gameStarted = true
            pcall(function()
                local gs = RS:FindFirstChild("GameStarted")
                if gs and gs.Value ~= nil then
                    gameStarted = gs.Value
                end
            end)
            
            if getgenv().SeamlessFixEnabled and getgenv()._lastGameStartedForAbilities and not gameStarted then
                getgenv()._AbilitySystem_funcs.resetRoundTrackers()
            end
            getgenv()._lastGameStartedForAbilities = gameStarted
            
            if currentWave < getgenv()._AbilitySystem_lastWave then
                getgenv()._AbilitySystem_funcs.resetRoundTrackers()
            end
            
            if currentWave == 1 and getgenv()._AbilitySystem_lastWave > 10 then
                getgenv()._AbilitySystem_funcs.resetRoundTrackers()
            end
            
            getgenv()._AbilitySystem_lastWave = currentWave
            
            if not getgenv()._AbilitySystem_Towers then return end
            if not getgenv().UnitAbilities or type(getgenv().UnitAbilities) ~= "table" then return end
            
            for unitName, abilitiesConfig in pairs(getgenv().UnitAbilities) do
                local towerNameToFind = unitName
                
                if getgenv().EZAUnitMapping and getgenv().EZAUnitMapping[unitName] then
                    towerNameToFind = getgenv().EZAUnitMapping[unitName]
                end
                
                for _, tower in pairs(getgenv()._AbilitySystem_Towers:GetChildren()) do
                    local owner = tower:FindFirstChild("Owner")
                    if tower.Name == towerNameToFind and owner and owner.Value == LocalPlayer then
                        for abilityName, cfg in pairs(abilitiesConfig) do
                            getgenv()._ProcessAbility(tower, unitName, abilityName, cfg, currentWave, hasBoss)
                        end
                    end
                end
            end
        end
        
        pcall(processAllAbilities)
    end
end)

end


do
    task.spawn(function()
        local lastCheckTime = 0
        
        while true do
            task.wait(2)
            
            if getgenv().AutoSellCapsuleEnabled then
                pcall(function()
                    local now = tick()
                    if now - lastCheckTime < 5 then return end
                    lastCheckTime = now
                    
                    local clientData = getgenv().GetClientData and getgenv().GetClientData()
                    if not clientData or not clientData.UnitData then return end
                    
                    local unitsToSell = {}
                    
                    for unitID, unitData in pairs(clientData.UnitData) do
                        if unitData.UnitName and not getgenv()._CapsuleUnitCache[unitID] then
                            local shouldSell = false
                            
                            for unitName, selected in pairs(getgenv().AutoSellCapsuleUnits or {}) do
                                if selected then
                                    local actualUnitName = unitName
                                    for _, capsuleUnit in ipairs({"ZamasuBlackGokuRoseUnevo", "AinzAlbedoUnevo", "SimonUnevo", "RimuruGodlyUnevo", "RimuruGodlyUnevoShiny"}) do
                                        local unitNameModule = getgenv().GetAllAbilities and getgenv().GetAllAbilities()
                                        if unitNameModule and unitNameModule[capsuleUnit] then
                                            local displayName = unitNameModule[capsuleUnit].displayName or capsuleUnit
                                            if displayName == unitName then
                                                actualUnitName = capsuleUnit
                                                break
                                            end
                                        end
                                    end
                                    
                                    if unitData.UnitName == actualUnitName then
                                        shouldSell = true
                                        break
                                    end
                                end
                            end
                            
                            if shouldSell then
                                unitsToSell[unitID] = true
                                print("[Auto Sell Capsule] Marking new unit for sale: " .. unitData.UnitName .. " (ID: " .. unitID .. ")")
                            else
                                getgenv()._CapsuleUnitCache[unitID] = {
                                    UnitName = unitData.UnitName,
                                    ObtainTime = unitData.ObtainTime or 0
                                }
                            end
                        end
                    end
                    
                    if next(unitsToSell) then
                        local sellCount = 0
                        for _ in pairs(unitsToSell) do
                            sellCount = sellCount + 1
                        end
                        
                        print("[Auto Sell Capsule] Selling " .. sellCount .. " units...")
                        
                        local sellRemote = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("SellUnits")
                        if sellRemote then
                            local success = pcall(function()
                                sellRemote:InvokeServer(unitsToSell)
                            end)
                            
                            if success then
                                print("[Auto Sell Capsule] ✅ Successfully sold " .. sellCount .. " units")
                                
                                for unitID in pairs(unitsToSell) do
                                    getgenv()._CapsuleUnitCache[unitID] = nil
                                end
                            else
                                print("[Auto Sell Capsule] ❌ Failed to sell units")
                            end
                        end
                    end
                end)
            end
            
            if getgenv().AutoSellEvent1CapsuleEnabled then
                pcall(function()
                    local now = tick()
                    if now - lastCheckTime < 5 then return end
                    
                    local clientData = getgenv().GetClientData and getgenv().GetClientData()
                    if not clientData or not clientData.UnitData then return end
                    
                    local unitsToSell = {}
                    
                    for unitID, unitData in pairs(clientData.UnitData) do
                        if unitData.UnitName and not getgenv()._Event1CapsuleUnitCache[unitID] then
                            local shouldSell = false
                            
                            for unitName, selected in pairs(getgenv().AutoSellEvent1CapsuleUnits or {}) do
                                if selected then
                                    local actualUnitName = unitName
                                    for _, capsuleUnit in ipairs({"MobUnevo", "LightUnevo", "LelouchUnevo", "LelouchUnevoShiny"}) do
                                        local unitNameModule = getgenv().GetAllAbilities and getgenv().GetAllAbilities()
                                        if unitNameModule and unitNameModule[capsuleUnit] then
                                            local displayName = unitNameModule[capsuleUnit].displayName or capsuleUnit
                                            if displayName == unitName then
                                                actualUnitName = capsuleUnit
                                                break
                                            end
                                        end
                                    end
                                    
                                    if unitData.UnitName == actualUnitName then
                                        shouldSell = true
                                        break
                                    end
                                end
                            end
                            
                            if shouldSell then
                                unitsToSell[unitID] = true
                                print("[Auto Sell Event1 Capsule] Marking new unit for sale: " .. unitData.UnitName .. " (ID: " .. unitID .. ")")
                            else
                                getgenv()._Event1CapsuleUnitCache[unitID] = {
                                    UnitName = unitData.UnitName,
                                    ObtainTime = unitData.ObtainTime or 0
                                }
                            end
                        end
                    end
                    
                    if next(unitsToSell) then
                        local sellCount = 0
                        for _ in pairs(unitsToSell) do
                            sellCount = sellCount + 1
                        end
                        
                        print("[Auto Sell Event1 Capsule] Selling " .. sellCount .. " units...")
                        
                        local sellRemote = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("SellUnits")
                        if sellRemote then
                            local success = pcall(function()
                                sellRemote:InvokeServer(unitsToSell)
                            end)
                            
                            if success then
                                print("[Auto Sell Event1 Capsule] ✅ Successfully sold " .. sellCount .. " units")
                                
                                for unitID in pairs(unitsToSell) do
                                    getgenv()._Event1CapsuleUnitCache[unitID] = nil
                                end
                            else
                                print("[Auto Sell Event1 Capsule] ❌ Failed to sell units")
                            end
                        else
                            warn("[Auto Sell Event1 Capsule] SellUnitsEvent remote not found")
                        end
                    end
                end)
            end
        end
    end)
end


do
    task.spawn(function()
        while true do
            task.wait(1)
            
            if getgenv().WaitForPlayerEnabled then
                pcall(function()
                    local entryUI = nil
                    for _, gui in ipairs(LocalPlayer.PlayerGui:GetChildren()) do
                        if gui.Name:find("Entry") then
                            entryUI = gui
                            break
                        end
                    end
                    
                    if entryUI then
                        local function findTextLabel(parent)
                            for _, child in ipairs(parent:GetDescendants()) do
                                if child:IsA("TextLabel") and child.Text:find("Players") then
                                    return child
                                end
                            end
                            return nil
                        end
                        
                        local textLabel = findTextLabel(entryUI)
                        if textLabel then
                            local text = textLabel.Text
                            local current, max = text:match("%((%d+)/(%d+)%)")
                            
                            if current and max then
                                local currentPlayers = tonumber(current)
                                local targetCount = getgenv().WaitForPlayerCount or 1
                                
                                if currentPlayers >= targetCount then
                                    print("[Wait for Players] ✅ " .. currentPlayers .. "/" .. targetCount .. " players ready")
                                else
                                    print("[Wait for Players] ⏳ Waiting... " .. currentPlayers .. "/" .. targetCount .. " players")
                                end
                            end
                        end
                    end
                end)
            end
            
            if getgenv().JoinPlayerEnabled and getgenv().JoinPlayerTarget and getgenv().JoinPlayerTarget ~= "" and getgenv().JoinPlayerTarget ~= "No other players" then
                pcall(function()
                    local currentGamemode = nil
                    pcall(function()
                        local gamemode = RS:FindFirstChild("Gamemode")
                        if gamemode then
                            currentGamemode = gamemode.Value
                        end
                    end)
                    
                    if currentGamemode == "Portals" then
                        return
                    end
                    
                    if getgenv().WaitForPlayerEnabled then
                        local entryUI = nil
                        for _, gui in ipairs(LocalPlayer.PlayerGui:GetChildren()) do
                            if gui.Name:find("Entry") then
                                entryUI = gui
                                break
                            end
                        end
                        
                        if entryUI then
                            local function findTextLabel(parent)
                                for _, child in ipairs(parent:GetDescendants()) do
                                    if child:IsA("TextLabel") and child.Text:find("Players") then
                                        return child
                                    end
                                end
                                return nil
                            end
                            
                            local textLabel = findTextLabel(entryUI)
                            if textLabel then
                                local waitStartTime = tick()
                                local maxWaitTime = 300
                                
                                while tick() - waitStartTime < maxWaitTime do
                                    local text = textLabel.Text
                                    local current, max = text:match("%((%d+)/(%d+)%)")
                                    
                                    if current and max then
                                        local currentPlayers = tonumber(current)
                                        local targetCount = getgenv().WaitForPlayerCount or 1
                                        
                                        if currentPlayers >= targetCount then
                                            print("[Join Player] ✅ " .. currentPlayers .. "/" .. targetCount .. " players ready, joining portal...")
                                            break
                                        else
                                            print("[Join Player] ⏳ Waiting for players... " .. currentPlayers .. "/" .. targetCount)
                                        end
                                    end
                                    
                                    task.wait(1)
                                end
                            end
                        end
                    end
                    
                    local targetDisplayName = getgenv().JoinPlayerTarget:match("^(.-)%s*%(")
                    if not targetDisplayName then
                        targetDisplayName = getgenv().JoinPlayerTarget
                    end
                    
                    local portalsFolder = workspace:FindFirstChild("Portals")
                    if not portalsFolder then return end
                    
                    for _, tierFolder in ipairs(portalsFolder:GetChildren()) do
                        for _, portal in ipairs(tierFolder:GetChildren()) do
                            local prompt = portal:FindFirstChildOfClass("ProximityPrompt", true)
                            if prompt and prompt.ObjectText and prompt.ObjectText:find(targetDisplayName) then
                                print("[Join Player] Found " .. targetDisplayName .. "'s portal, joining...")
                                
                                local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                                if hrp then
                                    hrp.CFrame = portal:GetPivot()
                                    task.wait(0.5)
                                    
                                    VIM:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                                    task.wait(3)
                                    VIM:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                                    
                                    print("[Join Player] ✅ Joined " .. targetDisplayName .. "'s portal")
                                    task.wait(5)
                                end
                                return
                            end
                        end
                    end
                end)
            end
        end
    end)
end


do
    task.spawn(function()
        local pollingInterval = MobileOptimizer:getPollingInterval(1)
        local lastWave = 0
        
        while true do
            task.wait(pollingInterval)
            
            local currentWave = 0
            pcall(function()
                local wave = RS:FindFirstChild("Wave")
                if wave and wave.Value then
                    currentWave = wave.Value
                end
            end)
            
            if currentWave < lastWave and currentWave <= 5 then
                getgenv().BulmaWishUsedThisRound = false
            end
            
            if getgenv().SeamlessFixEnabled and lastWave >= 50 and currentWave < 50 then
                getgenv().BulmaWishUsedThisRound = false
            end
            
            if currentWave == 1 and lastWave > 10 then
                getgenv().BulmaWishUsedThisRound = false
            end
            
            lastWave = currentWave
            
            if getgenv().BulmaEnabled then
                local success, err = pcall(function()
                    local towers = workspace:FindFirstChild("Towers")
                    if not towers then return end
                    
                    local bulma = nil
                    for _, tower in pairs(towers:GetChildren()) do
                        local owner = tower:FindFirstChild("Owner")
                        if tower.Name == "Bulma" and owner and owner.Value == LocalPlayer then
                            bulma = tower
                            break
                        end
                    end
                    
                    if not bulma then return end
                    
                    local meters = bulma:FindFirstChild("Meters")
                    if not meters then return end
                    
                    local wishBalls = meters:FindFirstChild("Wish Balls")
                    if not wishBalls then return end
                    
                    local ballCount = 0
                    pcall(function()
                        ballCount = wishBalls:GetAttribute("Value") or 0
                    end)
                    
                    if ballCount == 7 and not getgenv().BulmaWishUsedThisRound then
                        getgenv().BulmaWishUsedThisRound = true
                        
                        ErrorHandler:wrapAsync(function()
                            RS.Remotes.Ability:InvokeServer(bulma, "Summon Wish Dragon")
                        end, "Summon Wish Dragon")
                        task.wait(0.5)
                        
                        local wishType = getgenv().BulmaWishType or "Power"
                        ErrorHandler:wrapAsync(function()
                            RS.Remotes.Ability:InvokeServer(bulma, "Wish: " .. wishType)
                        end, "Use Bulma wish")
                        
                        Window:Notify({
                            Title = "Bulma Auto-Wish",
                            Description = "Used Wish: " .. wishType .. " (1x per round)",
                            Lifetime = 3
                        })
                    end
                end)
                
                if not success then
                    warn("[Bulma] Error: " .. tostring(err))
                end
            end
        end
    end)
end



do
    task.spawn(function()
        
        local CLONE_UPGRADE_COSTS = {
        [1] = 1750,
        [2] = 3500,
        [3] = 7000,
        [4] = 12500,
        [5] = 25000,
        [6] = 27500,
        [7] = 30250,
        [8] = 55000
    }
    
    local function getPlayerCash()
        local clientData = getClientData()
        if clientData and clientData.Cash then
            return clientData.Cash
        end
        return 0
    end
    
    local function getJinMoriTower()
        local Towers = workspace:FindFirstChild("Towers")
        if not Towers then return nil end
        
        for _, tower in ipairs(Towers:GetChildren()) do
            local owner = tower:FindFirstChild("Owner")
            if tower.Name == "JinMoriGodly" and tower:IsA("Model") and owner and owner.Value == LocalPlayer then
                return tower
            end
        end
        return nil
    end
    
    local function getJinMoriClones()
        local Towers = workspace:FindFirstChild("Towers")
        if not Towers then return {} end
        
        local clones = {}
        for _, tower in ipairs(Towers:GetChildren()) do
            local owner = tower:FindFirstChild("Owner")
            if tower.Name == "JinMoriGodlyClone" and tower:IsA("Model") and owner and owner.Value == LocalPlayer then
                table.insert(clones, tower)
            end
        end
        return clones
    end
    
    local function useCloneSynthesis(jinMoriTower)
        if not jinMoriTower then return false end
        
        local success, err = ErrorHandler:wrapAsync(function()
            local Ability = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Ability")
            if Ability then
                Ability:InvokeServer(jinMoriTower, "Clone Synthesis")
                return true
            end
        end, "Use Clone Synthesis")
        
        return success
    end
    
    local function upgradeClone(cloneTower)
        if not cloneTower then return false end
        
        local upgradeValue = cloneTower:FindFirstChild("Upgrade")
        if not upgradeValue then return false end
        
        local currentUpgrade = upgradeValue.Value
        if currentUpgrade >= 8 then return false end 
        
        local nextUpgradeCost = CLONE_UPGRADE_COSTS[currentUpgrade + 1]
        if not nextUpgradeCost then return false end
        
        local cash = tonumber(getPlayerCash()) or 0
        if cash < (tonumber(nextUpgradeCost) or 0) then return false end
        
        local success, err = ErrorHandler:wrapAsync(function()
            local UpgradeEvent = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Upgrade")
            if UpgradeEvent then
                UpgradeEvent:InvokeServer(cloneTower)
                return true
            end
        end, "Upgrade Jin Mori clone")
        
        return success
    end
    
    local function useCloneDiffusion(cloneTower)
        if not cloneTower then return false end
        
        local success, err = ErrorHandler:wrapAsync(function()
            local Ability = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Ability")
            if Ability then
                Ability:InvokeServer(cloneTower, "Clone Diffusion")
                return true
            end
        end)
        
        return success
    end
    
    local lastWave = 0
    while true do
        task.wait(1)
        
        local currentWave = 0
        pcall(function()
            local wave = RS:FindFirstChild("Wave")
            if wave and wave.Value then
                currentWave = wave.Value
            end
        end)
        
        if currentWave < lastWave and currentWave <= 5 then
            getgenv().WukongTrackedClones = {}
            getgenv()._WukongLastSynthesisTime = 0
        end
        
        if getgenv().SeamlessFixEnabled and lastWave >= 50 and currentWave < 50 then
            getgenv().WukongTrackedClones = {}
            getgenv()._WukongLastSynthesisTime = 0
        end
        
        if currentWave == 1 and lastWave > 10 then
            getgenv().WukongTrackedClones = {}
            getgenv()._WukongLastSynthesisTime = 0
        end
        
        lastWave = currentWave
        
        if not getgenv().WukongEnabled then continue end
        
        local jinMori = getJinMoriTower()
        if not jinMori then continue end
        
        local jinMoriUpgrade = jinMori:FindFirstChild("Upgrade")
        if not jinMoriUpgrade or jinMoriUpgrade.Value < 8 then continue end
        
        local reachingNirvana = jinMori:FindFirstChild("Meters") and jinMori.Meters:FindFirstChild("ReachingNirvana")
        if not reachingNirvana then continue end
        
        local currentNirvana = reachingNirvana:GetAttribute("Value") or 0
        local maxNirvana = reachingNirvana:GetAttribute("MaxValue") or 4
        
        if currentNirvana < maxNirvana then
            local lastSynthesisTime = getgenv()._WukongLastSynthesisTime or 0
            local currentTime = tick()
            
            if currentTime - lastSynthesisTime >= 10 then
                if currentNirvana < 4 then
                    if useCloneSynthesis(jinMori) then
                        getgenv()._WukongLastSynthesisTime = currentTime
                        
                        Window:Notify({
                            Title = "Auto Wukong",
                            Description = "Clone Synthesis used (" .. (currentNirvana + 1) .. "/" .. maxNirvana .. ")",
                            Lifetime = 3
                        })
                        
                        task.wait(1)
                    end
                end
            end
        end
        
        local clones = getJinMoriClones()
        for _, clone in ipairs(clones) do
            local cloneUpgrade = clone:FindFirstChild("Upgrade")
            if cloneUpgrade and cloneUpgrade.Value < 8 then
                upgradeClone(clone)
                task.wait(0.5)
            end
        end
        
        for _, clone in ipairs(clones) do
            local cloneUpgrade = clone:FindFirstChild("Upgrade")
            if cloneUpgrade and cloneUpgrade.Value == 8 then
                local cloneId = tostring(clone:GetDebugId())
                if not getgenv().WukongTrackedClones[cloneId] then
                    if useCloneDiffusion(clone) then
                        getgenv().WukongTrackedClones[cloneId] = true
                        
                        Window:Notify({
                            Title = "Auto Wukong",
                            Description = "Clone Diffusion used! Nirvana state increased",
                            Lifetime = 3
                        })
                        
                        task.wait(1)
                    end
                end
            end
        end
    end
    end)
end

do
    task.spawn(function()
        task.wait(2)
        
        local function getSkeletonKnightTower()
            local towers = workspace:FindFirstChild("Towers")
            if not towers then 
                return nil 
            end
            
            for _, tower in pairs(towers:GetChildren()) do
                local owner = tower:FindFirstChild("Owner")
                if (tower.Name == "Skull_Knight_EvoEZA" or tower.Name == "Skull_Knight_Evo") and owner and owner.Value == LocalPlayer then
                    return tower
                end
            end
            
            return nil
        end
        
        local function getTargetTowerByDisplayName(displayName)
            if not displayName or displayName == "" or displayName == "No units placed yet" or displayName == "Place a unit first" then 
                return nil 
            end
            
            local towers = workspace:FindFirstChild("Towers")
            if not towers then return nil end
            
            for _, tower in pairs(towers:GetChildren()) do
                local owner = tower:FindFirstChild("Owner")
                if owner and owner.Value == LocalPlayer then
                    local towerName = tower.Name
                    local baseName = towerName:gsub("EZA$", "")
                    local towerDisplayName = getUnitDisplayName(baseName)
                    
                    if towerDisplayName == displayName then
                        return tower
                    end
                end
            end
            
            return nil
        end
        
        
        local lastWave = 0
        while true do
            task.wait(1)
            
            local currentWave = 0
            pcall(function()
                local wave = RS:FindFirstChild("Wave")
                if wave and wave.Value then
                    currentWave = wave.Value
                end
            end)
            
            if currentWave < lastWave and currentWave <= 5 then
                getgenv().SkeletonKnightLastUse = 0
            end
            
            if getgenv().SeamlessFixEnabled and lastWave >= 50 and currentWave < 50 then
                getgenv().SkeletonKnightLastUse = 0
            end
            
            if currentWave == 1 and lastWave > 10 then
                getgenv().SkeletonKnightLastUse = 0
            end
            
            lastWave = currentWave
                        
            if not getgenv().SkeletonKnightEnabled then
                task.wait(2)
                continue
            end
            
            local skeletonKnight = getSkeletonKnightTower()
            if not skeletonKnight then
                task.wait(2)
                continue
            end
            
            local upgrade = skeletonKnight:FindFirstChild("Upgrade")
            if not upgrade then
                task.wait(2)
                continue
            end
            
            
            local isEZA = skeletonKnight.Name == "Skull_Knight_EvoEZA"
            local requiredLevel = isEZA and 0 or 11
            
            if upgrade.Value < requiredLevel then
                task.wait(2)
                continue
            end
            
            
            local currentTime = tick()
            local baseCooldown = 200
            local timeScale = getCurrentTimeScale()
            local effectiveCooldown = baseCooldown / timeScale
            local timeSinceLastUse = currentTime - (getgenv().SkeletonKnightLastUse or 0)
            
            
            if timeSinceLastUse < effectiveCooldown then
                task.wait(1)
                continue
            end
            
            
            if not getgenv().SkeletonKnightTargetUnit or getgenv().SkeletonKnightTargetUnit == "" then
                task.wait(5)
                continue
            end
            
            local targetTower = getTargetTowerByDisplayName(getgenv().SkeletonKnightTargetUnit)
            if not targetTower then
                task.wait(5)
                continue
            end
            
            if not targetTower.Parent then
                task.wait(5)
                continue
            end
                        
            local success, err = ErrorHandler:wrapAsync(function()
                local AbilityEvent = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Ability")
                if not AbilityEvent then
                    AbilityEvent = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Ability")
                end
                
                if AbilityEvent then
                    local result = AbilityEvent:InvokeServer(skeletonKnight, "Savior")                    
                    task.wait(0.5)
                    
                    local SelectUnitEvent = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("AbilityRemotes") and RS.Remotes.AbilityRemotes:FindFirstChild("SelectUnitInWorkspace")
                    if SelectUnitEvent then
                        SelectUnitEvent:FireServer(targetTower)
                        
                        getgenv().SkeletonKnightLastUse = tick()
                        
                        Window:Notify({
                            Title = "Auto Skeleton Knight",
                            Description = "Savior used on " .. getgenv().SkeletonKnightTargetUnit,
                            Lifetime = 3
                        })
                    end
                end
            end)
            task.wait(5)
        end
    end)
    
    task.spawn(function()
        task.wait(2)
        
        local function getAlucardTower()
            local towers = workspace:FindFirstChild("Towers")
            if not towers then 
                return nil 
            end
            
            for _, tower in pairs(towers:GetChildren()) do
                local owner = tower:FindFirstChild("Owner")
                if tower.Name == "Alucard2Evo" and owner and owner.Value == LocalPlayer then
                    return tower
                end
            end
            
            return nil
        end
        
        local function getTargetTowerByDisplayNameAlucard(displayName)
            if not displayName or displayName == "" or displayName == "No units placed yet" or displayName == "Place a unit first" then 
                return nil 
            end
            
            local towers = workspace:FindFirstChild("Towers")
            if not towers then return nil end
            
            for _, tower in pairs(towers:GetChildren()) do
                local owner = tower:FindFirstChild("Owner")
                if owner and owner.Value == LocalPlayer then
                    local towerName = tower.Name
                    local baseName = towerName:gsub("EZA$", "")
                    local towerDisplayName = getUnitDisplayName(baseName)
                    
                    if towerDisplayName == displayName then
                        return tower
                    end
                end
            end
            
            return nil
        end
        
        
        local lastWave = 0
        while true do
            task.wait(1)
            
            local currentWave = 0
            pcall(function()
                local wave = RS:FindFirstChild("Wave")
                if wave and wave.Value then
                    currentWave = wave.Value
                end
            end)
            
            if currentWave < lastWave and currentWave <= 5 then
                getgenv().AlucardHypnosisLastUse = 0
            end
            
            if getgenv().SeamlessFixEnabled and lastWave >= 50 and currentWave < 50 then
                getgenv().AlucardHypnosisLastUse = 0
            end
            
            if currentWave == 1 and lastWave > 10 then
                getgenv().AlucardHypnosisLastUse = 0
            end
            
            lastWave = currentWave
                        
            if not getgenv().AlucardHypnosisEnabled then
                task.wait(2)
                continue
            end
            
            local alucardTower = getAlucardTower()
            if not alucardTower then
                task.wait(2)
                continue
            end
            
            local upgrade = alucardTower:FindFirstChild("Upgrade")
            if not upgrade then
                task.wait(2)
                continue
            end
            
            local requiredLevel = 0
            
            if upgrade.Value < requiredLevel then
                task.wait(2)
                continue
            end
            
            local currentTime = tick()
            local baseCooldown = 200
            local timeScale = getCurrentTimeScale()
            local effectiveCooldown = baseCooldown / timeScale
            local timeSinceLastUse = currentTime - (getgenv().AlucardHypnosisLastUse or 0)
            
            if timeSinceLastUse < effectiveCooldown then
                task.wait(1)
                continue
            end
            
            if not getgenv().AlucardHypnosisTargetUnit or getgenv().AlucardHypnosisTargetUnit == "" then
                task.wait(5)
                continue
            end
            
            local targetTower = getTargetTowerByDisplayNameAlucard(getgenv().AlucardHypnosisTargetUnit)
            if not targetTower then
                task.wait(5)
                continue
            end
            
            if not targetTower.Parent then
                task.wait(5)
                continue
            end
                        
            local success, err = ErrorHandler:wrapAsync(function()
                local AbilityEvent = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Ability")
                if not AbilityEvent then
                    AbilityEvent = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Ability")
                end
                
                if AbilityEvent then
                    local result = AbilityEvent:InvokeServer(alucardTower, "Hypnosis")                    
                    task.wait(0.5)
                    
                    local SelectUnitEvent = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("AbilityRemotes") and RS.Remotes.AbilityRemotes:FindFirstChild("SelectUnitInWorkspace")
                    if SelectUnitEvent then
                        SelectUnitEvent:FireServer(targetTower)
                        
                        getgenv().AlucardHypnosisLastUse = tick()
                        
                        Window:Notify({
                            Title = "Auto True Dracula Hypnosis",
                            Description = "Hypnosis used on " .. getgenv().AlucardHypnosisTargetUnit,
                            Lifetime = 3
                        })
                    end
                end
            end)
            task.wait(5)
        end
    end)
end


do
    task.spawn(function()
        ConnectionManager:trackGroup("GameState",
            LocalPlayer.PlayerGui.ChildAdded:Connect(function(child)
                if child.Name == "EndGameUI" then
                    getgenv().BulmaWishUsedThisRound = false
                            getgenv().WukongTrackedClones = {}
                    getgenv()._WukongLastSynthesisTime = 0
                    getgenv().SkeletonKnightLastUse = 0
                    getgenv().AlucardHypnosisLastUse = 0
                    getgenv().OneEyeDevilCurrentIndex = 0 
                    
                    if getgenv()._EtoEvoAbilityUsed then
                        getgenv()._EtoEvoAbilityUsed = {}
                    end
                    
                    getgenv().GriffithLightUsedThisRound = false
                    
                    if getgenv().MacroRecordingV2 then
                        task.spawn(function()
                            task.wait(1)
                            
                            getgenv().MacroRecordingV2 = false
                            
                            if #getgenv().MacroDataV2 > 0 and getgenv().CurrentMacro then
                                local success = saveMacro(getgenv().CurrentMacro, getgenv().MacroDataV2)
                                if success then
                                    Window:Notify({
                                        Title = "Macro Recording",
                                        Description = "Auto-saved " .. #getgenv().MacroDataV2 .. " steps (game ended)",
                                        Lifetime = 5
                                    })
                                else
                                    Window:Notify({
                                        Title = "Macro Recording",
                                        Description = "Failed to auto-save macro",
                                        Lifetime = 3
                                    })
                                end
                            end
                            
                            getgenv().MacroStatusText = "Idle"
                            getgenv().MacroCurrentStep = 0
                            getgenv().MacroTotalSteps = 0
                            
                            if getgenv().UpdateMacroStatus then
                                getgenv().UpdateMacroStatus()
                            end
                            
                            pcall(function()
                                if getgenv().MacroRecordToggle then
                                    getgenv().MacroRecordToggle:UpdateState(false)
                                end
                            end)
                        end)
                    end
                end
            end),
            "Game State EndGameUI Tracking"
        )
    end)
end

do
    task.spawn(function()
        local SIGIL_ORDER = {
            [0] = "Ocular Sigil: Eye",
            [1] = "Ocular Sigil: Mouth",
            [2] = "Ocular Sigil: Arm",
            [3] = "Ocular Sigil: Leg"
        }
        
        if not getgenv()._EtoEvoAbilityUsed then
            getgenv()._EtoEvoAbilityUsed = {}
        end
        
        local function getEtoEvoTower()
            local towers = workspace:FindFirstChild("Towers")
            if not towers then return nil end
            
            for _, tower in pairs(towers:GetChildren()) do
                local owner = tower:FindFirstChild("Owner")
                if tower.Name == "EtoEvo" and owner and owner.Value == LocalPlayer then
                    return tower
                end
            end
            return nil
        end
        
        local function getTowerInfoName(tower)
            if not tower then return nil end
            local config = tower:FindFirstChild("Config")
            if config then
                local infoName = config:FindFirstChild("InfoName")
                if infoName and infoName.Value then
                    return infoName.Value
                end
            end
            return tower.Name
        end
        
        local function getUpgradeLevel(tower)
            if not tower then return 0 end
            local upgrade = tower:FindFirstChild("Upgrade")
            return upgrade and upgrade.Value or 0
        end
        
        local function getCurrentTimeScale()
            local ok, res = pcall(function()
                local timeScale = RS:FindFirstChild("TimeScale")
                if timeScale and timeScale:IsA("NumberValue") then
                    return timeScale.Value or 1
                end
                return 1
            end)
            return ok and res or 1
        end
        
        local function resetEtoEvoCooldowns()
            if getgenv()._EtoEvoAbilityUsed then
                getgenv()._EtoEvoAbilityUsed = {}
            end
            print("[One Eye Devil] Cooldowns reset")
        end
        
        local function isOnCooldown(infoName, abilityName, unitName)
            if not getgenv()._EtoEvoAbilityUsed[infoName] then
                return false
            end
            
            local lastUse = getgenv()._EtoEvoAbilityUsed[infoName][abilityName]
            if not lastUse then return false end
            
            local baseCooldown = 50
            local towerInfo = getgenv().MacroTowerInfoCache
            if towerInfo and towerInfo[unitName] then
                for level, data in pairs(towerInfo[unitName]) do
                    if data.Abilities then
                        for _, abilityData in ipairs(data.Abilities) do
                            if abilityData.Name == abilityName then
                                baseCooldown = abilityData.Cd or 50
                                break
                            end
                        end
                    end
                end
            end
            
            local timeScale = getCurrentTimeScale()
            local effectiveCooldown = baseCooldown / timeScale
            
            local elapsed = tick() - lastUse
            return elapsed < effectiveCooldown
        end
        
        local function setAbilityUsed(infoName, abilityName)
            if not getgenv()._EtoEvoAbilityUsed[infoName] then
                getgenv()._EtoEvoAbilityUsed[infoName] = {}
            end
            getgenv()._EtoEvoAbilityUsed[infoName][abilityName] = tick()
        end
        
        local function getCardButtons()
            local ok, result = pcall(function()
                local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                if not prompt or not prompt.Enabled then return nil end
                
                local frame = prompt:FindFirstChild("Frame")
                if not frame then return nil end
                
                local frame2 = frame:FindFirstChild("Frame")
                if not frame2 then return nil end
                
                local frame3 = frame2:FindFirstChild("Frame")
                if not frame3 then return nil end
                
                local frame4 = frame3:FindFirstChild("Frame")
                if not frame4 then return nil end
                
                local buttons = {}
                for _, child in ipairs(frame4:GetChildren()) do
                    if child:IsA("TextButton") then
                        table.insert(buttons, child)
                    end
                end
                
                return #buttons > 0 and buttons or nil
            end)
            
            return ok and result or nil
        end
        
        local function getCardName(button)
            local ok, result = pcall(function()
                local function searchForTextLabel(parent, depth)
                    if depth > 10 then return nil end
                    
                    for _, child in ipairs(parent:GetChildren()) do
                        if child:IsA("TextLabel") and child.Text ~= "" and child.Text:find("Ocular Sigil") then
                            return child.Text
                        end
                        
                        if child:IsA("Frame") or child:IsA("Folder") then
                            local found = searchForTextLabel(child, depth + 1)
                            if found then return found end
                        end
                    end
                    
                    return nil
                end
                
                return searchForTextLabel(button, 0)
            end)
            
            return ok and result or nil
        end
        
        local function clickButton(button)
            if not button then return false end
            
            getgenv()._SkipRecordingNextCall = true
            local success = false
            
            if getconnections then
                pcall(function()
                    local events = {"Activated", "MouseButton1Click", "MouseButton1Down"}
                    for _, eventName in ipairs(events) do
                        local connections = getconnections(button[eventName])
                        if connections then
                            for _, conn in ipairs(connections) do
                                if conn and conn.Fire then
                                    conn:Fire()
                                    success = true
                                end
                            end
                        end
                    end
                end)
            end
            
            if not success then
                pcall(function()
                    local GuiService = game:GetService("GuiService")
                    GuiService.SelectedObject = nil
                    task.wait(0.05)
                    GuiService.SelectedObject = button
                    task.wait(0.1)
                    
                    VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                    task.wait(0.02)
                    VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                    
                    success = true
                end)
            end
            
            getgenv()._SkipRecordingNextCall = false
            return success
        end
        
        local lastWave = 0
        local isWaitingForPrompt = false
        local promptWaitStart = 0
        local lastGameStartedForEto = true
        
        while true do
            task.wait(0.3)
            
            if not getgenv().OneEyeDevilEnabled then
                task.wait(2)
                continue
            end
            
            pcall(function()
                local gameStarted = true
                pcall(function()
                    local gs = RS:FindFirstChild("GameStarted")
                    if gs and gs.Value ~= nil then
                        gameStarted = gs.Value
                    end
                end)
                
                if getgenv().SeamlessFixEnabled and lastGameStartedForEto and not gameStarted then
                    resetEtoEvoCooldowns()
                    isWaitingForPrompt = false
                end
                lastGameStartedForEto = gameStarted
                
                local currentWave = 0
                pcall(function()
                    local wave = RS:FindFirstChild("Wave")
                    if wave and wave:IsA("NumberValue") then
                        currentWave = wave.Value
                    end
                end)
                
                if currentWave < lastWave then
                    resetEtoEvoCooldowns()
                    isWaitingForPrompt = false
                end
                
                lastWave = currentWave
                
                local tower = getEtoEvoTower()
                if not tower then 
                    isWaitingForPrompt = false
                    return 
                end
                
                local infoName = getTowerInfoName(tower)
                local towerLevel = getUpgradeLevel(tower)
                
                if towerLevel < 3 then
                    return
                end
                
                local buttons = getCardButtons()
                
                if buttons and #buttons > 0 then
                    if isWaitingForPrompt and tick() - promptWaitStart > 5 then
                        print("[One Eye Devil] Timeout waiting for prompt, resetting")
                        isWaitingForPrompt = false
                    end
                    
                    local targetCard = SIGIL_ORDER[getgenv().OneEyeDevilCurrentIndex]
                    
                    local foundCard = false
                    for _, button in ipairs(buttons) do
                        local cardName = getCardName(button)
                        if cardName then
                            if cardName == targetCard then
                                print("[One Eye Devil] Found target card: " .. cardName)
                                
                                if clickButton(button) then
                                    foundCard = true
                                    isWaitingForPrompt = false
                                    
                                    setAbilityUsed(infoName, "Detachment")
                                    
                                    local timeScale = getCurrentTimeScale()
                                    local baseCd = 50
                                    local effectiveCd = baseCd / timeScale
                                    
                                    getgenv().OneEyeDevilCurrentIndex = (getgenv().OneEyeDevilCurrentIndex + 1) % 4
                                    
                                    local nextCard = SIGIL_ORDER[getgenv().OneEyeDevilCurrentIndex]
                                    local cdText = string.format("%.1fs", effectiveCd)
                                    if timeScale ~= 1 then
                                        cdText = cdText .. " (x" .. timeScale .. " speed)"
                                    end
                                    
                                    print("[One Eye Devil] Selected: " .. cardName .. " | Next: " .. nextCard .. " (CD: " .. cdText .. ")")
                                    
                                    Window:Notify({
                                        Title = "One Eye Devil",
                                        Description = "Selected: " .. cardName,
                                        Lifetime = 2
                                    })
                                    
                                    break
                                end
                            end
                        end
                    end
                    
                    if foundCard then
                        return
                    end
                end
                
                if not isWaitingForPrompt and not isOnCooldown(infoName, "Detachment", "EtoEvo") then
                    print("[One Eye Devil] Using Detachment ability")
                    local abilityUsed, abilityResult = pcall(function()
                        return RS.Remotes.Ability:InvokeServer(tower, "Detachment")
                    end)
                    
                    if abilityUsed and abilityResult then
                        print("[One Eye Devil] Detachment used successfully, waiting for prompt")
                        isWaitingForPrompt = true
                        promptWaitStart = tick()
                    else
                        print("[One Eye Devil] Detachment failed or returned false")
                    end
                end
            end)
        end
    end)
end

do
    task.spawn(function()
        if not getgenv().GriffithLightUsedThisRound then
            getgenv().GriffithLightUsedThisRound = false
        end
        
        local function getGriffithEclipseTower()
            local towers = workspace:FindFirstChild("Towers")
            if not towers then return nil end
            
            for _, tower in pairs(towers:GetChildren()) do
                local owner = tower:FindFirstChild("Owner")
                if tower.Name == "GriffithEclipse" and owner and owner.Value == LocalPlayer then
                    return tower
                end
            end
            return nil
        end
        
        local function getCardButtons()
            local ok, result = pcall(function()
                local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                if not prompt or not prompt.Enabled then return nil end
                
                local frame = prompt:FindFirstChild("Frame")
                if not frame then return nil end
                
                local frame2 = frame:FindFirstChild("Frame")
                if not frame2 then return nil end
                
                local frame3 = frame2:FindFirstChild("Frame")
                if not frame3 then return nil end
                
                local frame4 = frame3:FindFirstChild("Frame")
                if not frame4 then return nil end
                
                local buttons = {}
                for _, child in ipairs(frame4:GetChildren()) do
                    if child:IsA("TextButton") then
                        table.insert(buttons, child)
                    end
                end
                
                return #buttons > 0 and buttons or nil
            end)
            
            return ok and result or nil
        end
        
        local function getCardName(button)
            local ok, result = pcall(function()
                local function searchForTextLabel(parent, depth)
                    if depth > 10 then return nil end
                    
                    for _, child in ipairs(parent:GetChildren()) do
                        if child:IsA("TextLabel") and child.Text ~= "" then
                            local text = child.Text:gsub("<[^>]+>", ""):gsub("%s+", " "):match("^%s*(.-)%s*$")
                            if text:find("Light Sacrifice") then
                                return text
                            end
                        end
                        
                        if child:IsA("Frame") or child:IsA("Folder") then
                            local found = searchForTextLabel(child, depth + 1)
                            if found then return found end
                        end
                    end
                    
                    return nil
                end
                
                return searchForTextLabel(button, 0)
            end)
            
            return ok and result or nil
        end
        
        local function clickButton(button)
            if not button then return false end
            
            local success = false
            
            if getconnections then
                pcall(function()
                    local events = {"Activated", "MouseButton1Click", "MouseButton1Down"}
                    for _, eventName in ipairs(events) do
                        local connections = getconnections(button[eventName])
                        if connections then
                            for _, conn in ipairs(connections) do
                                if conn and conn.Fire then
                                    conn:Fire()
                                    success = true
                                end
                            end
                        end
                    end
                end)
            end
            
            if not success then
                pcall(function()
                    local GuiService = game:GetService("GuiService")
                    GuiService.SelectedObject = nil
                    task.wait(0.05)
                    GuiService.SelectedObject = button
                    task.wait(0.1)
                    
                    VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                    task.wait(0.02)
                    VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                    
                    success = true
                end)
            end
            
            getgenv()._SkipRecordingNextCall = false
            return success
        end
        
        local function getCurrentCash()
            local ok, cash = pcall(function()
                local cashValue = LocalPlayer:FindFirstChild("Cash")
                if cashValue and cashValue:IsA("NumberValue") then
                    return cashValue.Value
                end
                return 0
            end)
            return ok and cash or 0
        end
        
        local lastWave = 0
        local isWaitingForPrompt = false
        local promptWaitStart = 0
        local cashAboveThresholdStart = 0
        local CASH_STABILITY_DURATION = 3
        local lastGameStartedForGriffith = true
        
        while true do
            task.wait(0.3)
            
            if not getgenv().GriffithLightEnabled then
                task.wait(2)
                continue
            end
            
            pcall(function()
                local gameStarted = true
                pcall(function()
                    local gs = RS:FindFirstChild("GameStarted")
                    if gs and gs.Value ~= nil then
                        gameStarted = gs.Value
                    end
                end)
                
                if getgenv().SeamlessFixEnabled and lastGameStartedForGriffith and not gameStarted then
                    getgenv().GriffithLightUsedThisRound = false
                    isWaitingForPrompt = false
                    cashAboveThresholdStart = 0
                end
                lastGameStartedForGriffith = gameStarted
                
                local currentWave = 0
                pcall(function()
                    local wave = RS:FindFirstChild("Wave")
                    if wave and wave:IsA("NumberValue") then
                        currentWave = wave.Value
                    end
                end)
                
                if currentWave < lastWave then
                    getgenv().GriffithLightUsedThisRound = false
                    isWaitingForPrompt = false
                    cashAboveThresholdStart = 0
                end
                
                lastWave = currentWave
                
                if getgenv().GriffithLightUsedThisRound then
                    return
                end
                
                local tower = getGriffithEclipseTower()
                if not tower then 
                    isWaitingForPrompt = false
                    cashAboveThresholdStart = 0
                    return 
                end
                
                local buttons = getCardButtons()
                
                if buttons then
                    if isWaitingForPrompt and tick() - promptWaitStart > 5 then
                        isWaitingForPrompt = false
                        return
                    end
                    
                    if not isWaitingForPrompt then
                        isWaitingForPrompt = true
                        promptWaitStart = tick()
                    end
                    
                    local foundCard = false
                    for _, button in ipairs(buttons) do
                        local cardName = getCardName(button)
                        if cardName and cardName:find("Light Sacrifice") then
                            print("[Griffith Light] Clicking: " .. cardName)
                            
                            if clickButton(button) then
                                foundCard = true
                                isWaitingForPrompt = false
                                getgenv().GriffithLightUsedThisRound = true
                                cashAboveThresholdStart = 0
                                
                                print("[Griffith Light] Light Sacrifice selected - will not use again this round")
                                
                                Window:Notify({
                                    Title = "Griffith Light",
                                    Description = "Light Sacrifice selected! Unit transformed to Umbral Prince",
                                    Lifetime = 3
                                })
                                
                                break
                            end
                        end
                    end

                    return
                end
                
                if not isWaitingForPrompt then
                    local currentCash = getCurrentCash()
                    
                    if currentCash >= 50000 then
                        if cashAboveThresholdStart == 0 then
                            cashAboveThresholdStart = tick()
                            print("[Griffith Light] Cash reached 50k+ - waiting " .. CASH_STABILITY_DURATION .. "s for stability...")
                        end
                        
                        local timeAboveThreshold = tick() - cashAboveThresholdStart
                        
                        if timeAboveThreshold >= CASH_STABILITY_DURATION then
                            local abilityUsed, abilityResult = pcall(function()
                                return RS.Remotes.Ability:InvokeServer(tower, "Sacrifice")
                            end)
                            
                            if abilityUsed and abilityResult then
                                isWaitingForPrompt = true
                                promptWaitStart = tick()
                                print("[Griffith Light] Sacrifice ability used at " .. currentCash .. " cash (stable for " .. string.format("%.1f", timeAboveThreshold) .. "s)")
                            else
                                cashAboveThresholdStart = 0
                            end
                        end
                    else
                        if cashAboveThresholdStart > 0 then
                            print("[Griffith Light] Cash dropped below 50k - resetting stability timer")
                            cashAboveThresholdStart = 0
                        end
                    end
                end
            end)
        end
    end)
end

do
    task.spawn(function()
    local lastWave = 0
    while true do
        task.wait(1)
        pcall(function()
            local wave = RS:FindFirstChild("Wave")
            if wave and wave:IsA("NumberValue") then
                local currentWave = wave.Value
                
                if currentWave < lastWave and currentWave <= 5 then
                    getgenv().BulmaWishUsedThisRound = false
                    getgenv().WukongTrackedClones = {}
                    getgenv()._WukongLastSynthesisTime = 0
                    getgenv().SkeletonKnightLastUse = 0
                    getgenv().AlucardHypnosisLastUse = 0
                    getgenv().OneEyeDevilCurrentIndex = 0 
                    getgenv().GriffithLightUsedThisRound = false
                end
                
                lastWave = currentWave
            end
        end)
    end
end)


task.spawn(function()
    while true do
        task.wait(2)
        
        local currentlyInLobby = false
        pcall(function()
            local lobbyCheck = workspace:FindFirstChild("Lobby")
            currentlyInLobby = lobbyCheck ~= nil
        end)
        
        if currentlyInLobby and (getgenv().FinalExpAutoJoinEasyEnabled or getgenv().FinalExpAutoJoinHardEnabled) then
            pcall(function()
                local finalExpRemote = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("FinalExpeditionStart")
                if finalExpRemote then
                    if getgenv().FinalExpAutoJoinEasyEnabled then
                        finalExpRemote:FireServer("Easy")
                    elseif getgenv().FinalExpAutoJoinHardEnabled then
                        finalExpRemote:FireServer("Hard")
                    end
                end
            end)
        end
    end
end)

task.spawn(function()
    while true do
        task.wait(1)
        
        local currentlyInLobby = false
        pcall(function()
            local lobbyCheck = workspace:FindFirstChild("Lobby")
            currentlyInLobby = lobbyCheck ~= nil
        end)
        
        if not currentlyInLobby then
            pcall(function()
                local promptUI = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                if not promptUI then return end
                
                local frame = promptUI:FindFirstChild("Frame")
                if not frame then return end
                
                local function clickOptionButton(button)
                    if not button then return false end
                    getgenv()._SkipRecordingNextCall = true
                    local events = {"Activated", "MouseButton1Click", "MouseButton1Down", "MouseButton1Up"}
                    for _, ev in ipairs(events) do
                        pcall(function()
                            for _, conn in ipairs(getconnections(button[ev])) do
                                conn:Fire()
                            end
                        end)
                        task.wait(0.05)
                    end
                    getgenv()._SkipRecordingNextCall = false
                    return true
                end
                
                local function findOptionsWithButtons()
                    local options = {}
                    local innerFrames = frame:GetDescendants()
                    for _, obj in pairs(innerFrames) do
                        if obj:IsA("TextButton") then
                            for _, child in pairs(obj:GetDescendants()) do
                                if child:IsA("TextLabel") and child.Text and child.Text ~= "" then
                                    local text = child.Text:gsub("<[^>]+>", ""):gsub("%s+", " "):match("^%s*(.-)%s*$")
                                    if text ~= "" and #text < 100 then
                                        options[text] = obj
                                    end
                                end
                            end
                        end
                    end
                    return options
                end
                
                local availableOptions = findOptionsWithButtons()
                if next(availableOptions) == nil then return end
                
                if getgenv().FinalExpSkipRewardsEnabled then
                    if availableOptions["Click anywhere to continue"] or availableOptions["(Click anywhere to continue)"] then
                        print("[Final Expedition] Reward screen detected - tracking rewards before skip")
                        
                        pcall(function()
                            local promptGui = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                            if promptGui then
                                local allTexts = {}
                                for _, descendant in ipairs(promptGui:GetDescendants()) do
                                    if descendant:IsA("TextLabel") and descendant.Text and descendant.Text ~= "" then
                                        local text = descendant.Text:match("^%s*(.-)%s*$")
                                        if text ~= "" and not text:find("Click") and not text:find("continue") then
                                            table.insert(allTexts, text)
                                        end
                                    end
                                end
                                
                                local chestTypes = {"Shabby", "Standard", "Prismatic", "Godly"}
                                local rewardQuantity = nil
                                local ownedQuantity = nil
                                local foundChestType = nil
                                local foundLoot = false
                                local foundChest = false
                                
                                for _, text in ipairs(allTexts) do
                                    if text:match("^Owned:%s*%d+x$") then
                                        ownedQuantity = tonumber(text:match("%d+"))
                                    elseif text:match("^%d+x$") then
                                        rewardQuantity = tonumber(text:match("%d+"))
                                    end
                                    
                                    for _, chestType in ipairs(chestTypes) do
                                        if text == chestType then
                                            foundChestType = chestType
                                            break
                                        end
                                    end
                                    
                                    if text == "Loot" then
                                        foundLoot = true
                                    end
                                    
                                    if text == "Chest" or text:lower():find("chest") then
                                        foundChest = true
                                    end
                                end
                                
                                if foundChestType and foundLoot and foundChest then
                                    local chestName = foundChestType .. " Loot Chest"
                                    local quantity = rewardQuantity or 1
                                    local owned = ownedQuantity or 0
                                    
                                    if not getgenv().FinalExpChestRewards then
                                        getgenv().FinalExpChestRewards = {}
                                    end
                                    
                                    if not getgenv().FinalExpChestRewards[chestName] then
                                        getgenv().FinalExpChestRewards[chestName] = {amount = 0, owned = owned}
                                    end
                                    
                                    getgenv().FinalExpChestRewards[chestName].amount = getgenv().FinalExpChestRewards[chestName].amount + quantity
                                    getgenv().FinalExpChestRewards[chestName].owned = owned
                                end
                            end
                        end)
                        
                        task.wait(0.5)
                        
                        local textButton = frame:FindFirstChild("TextButton")
                        if textButton and textButton.Visible then
                            clickOptionButton(textButton)
                            task.wait(0.3)
                            return
                        end
                        
                        local folder = frame:FindFirstChild("Folder")
                        if folder then
                            local folderButton = folder:FindFirstChild("TextButton")
                            if folderButton and folderButton.Visible then
                                clickOptionButton(folderButton)
                                task.wait(0.3)
                                return
                            end
                        end
                    end
                end
                
                if getgenv().FinalExpAutoSkipShopEnabled and availableOptions["Shop"] then
                    clickOptionButton(availableOptions["Shop"])
                    task.wait(0.5)
                    
                    local shopButtonClicked = false
                    local maxAttempts = 10
                    for attempt = 1, maxAttempts do
                        local screenGui = LocalPlayer.PlayerGui:FindFirstChild("ScreenGui")
                        if screenGui then
                            local shopFrame = screenGui:FindFirstChild("Frame")
                            if shopFrame then
                                local children = shopFrame:GetChildren()
                                if children[4] then
                                    local innerFrame = children[4]:FindFirstChild("Frame")
                                    if innerFrame then
                                        local folder = innerFrame:FindFirstChild("Folder")
                                        if folder then
                                            local shopButton = folder:FindFirstChild("TextButton")
                                            if shopButton then
                                                clickOptionButton(shopButton)
                                                shopButtonClicked = true
                                                task.wait(0.3)
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        task.wait(0.2)
                    end
                    
                    if not shopButtonClicked then
                        print("[Final Expedition] Shop button not found after " .. maxAttempts .. " attempts")
                    end
                    return
                end
                
                if getgenv().FinalExpAutoSelectModeEnabled then
                    local priorities = {
                        {name = "Rest Point", priority = getgenv().FinalExpRestPriority or 3},
                        {name = "Dungeon", priority = getgenv().FinalExpDungeonPriority or 1},
                        {name = "Double Dungeon", priority = getgenv().FinalExpDoubleDungeonPriority or 2},
                        {name = "Shop", priority = getgenv().FinalExpShopPriority or 4}
                    }
                    
                    table.sort(priorities, function(a, b) return a.priority < b.priority end)
                    
                    for _, option in ipairs(priorities) do
                        if availableOptions[option.name] then
                            clickOptionButton(availableOptions[option.name])
                            task.wait(0.3)
                            
                            if option.name == "Rest Point" then
                                task.wait(0.5)
                                pcall(function()
                                    local screenGui = LocalPlayer.PlayerGui:FindFirstChild("ScreenGui")
                                    if screenGui then
                                        local restFrame = screenGui:FindFirstChild("Frame")
                                        if restFrame then
                                            local children = restFrame:GetChildren()
                                            if children[4] then
                                                local innerFrame = children[4]:FindFirstChild("Frame")
                                                if innerFrame then
                                                    local folder = innerFrame:FindFirstChild("Folder")
                                                    if folder then
                                                        local closeButton = folder:FindFirstChild("TextButton")
                                                        if closeButton then
                                                            clickOptionButton(closeButton)
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end)
                            elseif option.name == "Shop" then
                                print("[Final Expedition] Shop selected - Auto Skip Shop will handle it if enabled")
                            end
                            
                            return
                        end
                    end
                end
            end)
        end
    end
end)


local function findBestPortalFromClientData()
    local clientData = getClientData()
    if not clientData or not clientData.PortalData then 
        return nil 
    end
    
    local selectedMap = getgenv().PortalConfig.selectedMap
    local targetTier = getgenv().PortalConfig.tier
    local useBestPortal = getgenv().PortalConfig.useBestPortal
    local priorities = getgenv().PortalConfig.priorities

    
    local matchingPortals = {}
    
    for portalID, portalInfo in pairs(clientData.PortalData) do
        pcall(function()
            if type(portalInfo) == "table" and portalInfo.PortalData then
                local portalData = portalInfo.PortalData
                if not portalData or type(portalData) ~= "table" then return end
                
                local mapMatch = (selectedMap == "" or portalData.Map == selectedMap)
                
                if mapMatch then
                    table.insert(matchingPortals, {
                        id = portalID,
                        tier = portalData.Tier or 0,
                        challenge = portalData.Challenges or "",
                        map = portalData.Map or ""
                    })
                end
            end
        end)
    end
    
    if #matchingPortals == 0 then 
        return nil 
    end
        
    if useBestPortal then
        table.sort(matchingPortals, function(a, b)
            return a.tier > b.tier
        end)
        
        local bestTier = matchingPortals[1].tier
        local bestTierPortals = {}
        
        for _, portal in ipairs(matchingPortals) do
            if portal.tier == bestTier then
                table.insert(bestTierPortals, portal)
            end
        end
        
        for priority = 1, 6 do
            for challengeName, priorityNum in pairs(priorities) do
                if priorityNum == priority and priorityNum > 0 then
                    for _, portal in ipairs(bestTierPortals) do
                        if portal.challenge == challengeName then
                            return portal.id
                        end
                    end
                end
            end
        end
        
        return bestTierPortals[1].id
    end
    
    local tierFiltered = {}
    for _, portal in ipairs(matchingPortals) do
        if portal.tier == targetTier then
            table.insert(tierFiltered, portal)
        end
    end
    
    if #tierFiltered == 0 then
        return matchingPortals[1].id
    end
    
    for priority = 1, 6 do
        for challengeName, priorityNum in pairs(priorities) do
            if priorityNum == priority and priorityNum > 0 then
                for _, portal in ipairs(tierFiltered) do
                    if portal.challenge == challengeName then
                        return portal.id
                    end
                end
            end
        end
    end
    
    return tierFiltered[1].id
end

local function activatePortalAndStart(portalID)
    if not portalID then 
        return false 
    end
        
    local success, err = pcall(function()
        local remotes = RS:FindFirstChild("Remotes")
        if not remotes then
            return false
        end
        
        local portalsFolder = remotes:FindFirstChild("Portals")
        if not portalsFolder then
            for _, child in ipairs(remotes:GetChildren()) do
                print("  - " .. child.Name .. " (" .. child.ClassName .. ")")
            end
            return false
        end
        
        local activateEvent = portalsFolder:FindFirstChild("Activate")
        if not activateEvent then
            return false
        end
        
        local result = activateEvent:InvokeServer(portalID)
        
        task.wait(0.5)
        
        local startEvent = portalsFolder:FindFirstChild("Start")
        if startEvent then
            startEvent:FireServer()
            return true
        else
            return true
        end
    end)
    
    if not success then
        print("[Portal] ❌ Error activating portal:", err)
    end
    
    return success
end

local function fastSelectPortal()    
    local ok, result = pcall(function()
        local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
        if not prompt then 
            return false 
        end
        
        local frame1 = prompt:FindFirstChild("Frame")
        if not frame1 then 
            return false 
        end
        
        local frame2 = frame1:FindFirstChild("Frame")
        if not frame2 then 
            return false 
        end
        
        local children = frame2:GetChildren()
        if #children < 4 then
            return false
        end
        
        local fourthChild = children[4]
        
        local subChildren = fourthChild:GetChildren()
        if #subChildren < 2 then
            return false
        end
        
        local secondSubChild = subChildren[2]
        
        local portalButton = secondSubChild:FindFirstChild("TextButton")
        if not portalButton then
            return false
        end
        
        local GuiService = game:GetService("GuiService")
        local VIM = game:GetService("VirtualInputManager")
        
        GuiService.SelectedObject = nil
        task.wait(0.1)
        
        GuiService.SelectedObject = portalButton
        
        local lockConnection
        lockConnection = RunService.Heartbeat:Connect(function()
            if GuiService.SelectedObject ~= portalButton then
                GuiService.SelectedObject = portalButton
            end
        end)
        
        task.wait(0.2)
        
        if GuiService.SelectedObject == portalButton then
            VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
            task.wait(0.02)
            VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
            
            task.wait(0.3)
            
            if lockConnection then
                lockConnection:Disconnect()
            end
            
            GuiService.SelectedObject = nil
        else
            if lockConnection then
                lockConnection:Disconnect()
            end
            return false
        end
        
        task.wait(0.2)
        
        local confirmButton = nil
        
        local frame1 = prompt:FindFirstChild("Frame")
        if frame1 then
            local frame2 = frame1:FindFirstChild("Frame")
            if frame2 then
                local children = frame2:GetChildren()
                if #children >= 5 then
                    local fifthChild = children[5]
                    confirmButton = fifthChild:FindFirstChild("TextButton")
                end
            end
        end
        
        if confirmButton then
            GuiService.SelectedObject = nil
            task.wait(0.05)
            
            GuiService.SelectedObject = confirmButton
            
            local confirmLock
            confirmLock = RunService.Heartbeat:Connect(function()
                if GuiService.SelectedObject ~= confirmButton then
                    GuiService.SelectedObject = confirmButton
                end
            end)
            
            task.wait(0.2)
            
            if GuiService.SelectedObject == confirmButton then
                for i = 1, 3 do
                    VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                    task.wait(0.02)
                    VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                    task.wait(0.02)
                end
                
                task.wait(0.1)
                
                if confirmLock then
                    confirmLock:Disconnect()
                end
                
                GuiService.SelectedObject = nil
                return true
            else
                if confirmLock then
                    confirmLock:Disconnect()
                end
                return false
            end
        else
            return false
        end
    end)
    
    if not ok then
        warn("[Portal Reward] Error:", result)
    end
    
    return ok and result
end

task.spawn(function()
    local lastProcessedTime = 0
    local isProcessing = false
    
    while true do
        task.wait(0.5)
        
        if getgenv().PortalConfig.autoPickReward and not isProcessing then
            local success, err = pcall(function()
                local promptUI = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                if not promptUI then return end
                
                local frame = promptUI:FindFirstChild("Frame")
                if not frame or not frame:FindFirstChild("Frame") then return end
                
                local children = frame.Frame:GetChildren()
                local hasPortalButtons = false
                
                for _, child in ipairs(children) do
                    if child:IsA("Frame") then
                        for _, descendant in ipairs(child:GetDescendants()) do
                            if descendant:IsA("TextButton") and descendant.Name == "TextButton" then
                                hasPortalButtons = true
                                break
                            end
                        end
                        if hasPortalButtons then break end
                    end
                end
                
                if hasPortalButtons then
                    local now = tick()
                    if now - lastProcessedTime > 10 then
                        isProcessing = true
                        lastProcessedTime = now
                        task.wait(1)
                        
                        local success = fastSelectPortal()
                        
                        if success then
                            task.wait(2)
                            for i = 1, 10 do
                                if not LocalPlayer.PlayerGui:FindFirstChild("Prompt") then
                                    break
                                end
                                task.wait(0.5)
                            end
                        end
                        
                        isProcessing = false
                    end
                end
            end)
            
            if not success then
                warn("[Portal Reward] Error in detection loop:", err)
                isProcessing = false
            end
        end
    end
end)

task.spawn(function()
    local lastActivationTime = 0
    
    while true do
        task.wait(2)
        
        local shouldActivate = (getgenv().PortalConfig.useBestPortal == true) or 
                               (getgenv().PortalConfig.useSelectedTier == true)
        
        if shouldActivate then
            local currentlyInLobby = false
            pcall(function()
                local lobbyCheck = workspace:FindFirstChild("Lobby")
                currentlyInLobby = lobbyCheck ~= nil
            end)
            
            local canActivate = false
            
            if currentlyInLobby then
                canActivate = true
            else
                local endGameUI = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
                if endGameUI then
                    local gameHasEnded = false
                    if endGameUI:FindFirstChild("Frame") then
                        gameHasEnded = endGameUI.Frame.Visible
                    elseif endGameUI:FindFirstChild("BG") then
                        gameHasEnded = endGameUI.BG.Visible
                    else
                        gameHasEnded = endGameUI.Enabled
                    end
                    canActivate = gameHasEnded
                end
            end
            
            if canActivate then
                local promptExists = LocalPlayer.PlayerGui:FindFirstChild("Prompt") ~= nil
                
                if not promptExists then
                    local now = tick()
                    
                    if now - lastActivationTime > 10 then
                        pcall(function()
                            local portalID = findBestPortalFromClientData()
                            if portalID then
                                local success = activatePortalAndStart(portalID)
                                if success then
                                    lastActivationTime = now
                                end
                            end
                        end)
                    end
                end
            end
        end
    end
end)

if isInLobby then
    task.spawn(function()
        while true do
            task.wait(2)
        end
    end)
end

task.spawn(function()
    while true do
        task.wait(1)
        
        pcall(function()
            local gamemode = RS:FindFirstChild("Gamemode")
            if gamemode and gamemode.Value == "Portal" then
                if getgenv().AutoNextEnabled or getgenv().AutoSmartEnabled then
                    local endGameUI = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
                    if endGameUI and endGameUI:FindFirstChild("BG") then
                        local buttons = endGameUI.BG:FindFirstChild("Buttons")
                        if buttons then
                            local nextButton = buttons:FindFirstChild("Next")
                            if nextButton and nextButton:FindFirstChild("Styling") then
                                local label = nextButton.Styling:FindFirstChild("Label")
                                if label and label.Text == "View Portals" then
                                    getgenv()._SkipRecordingNextCall = true
                                    for i, v in pairs(getconnections(nextButton.MouseButton1Click)) do
                                        v:Fire()
                                    end
                                    getgenv()._SkipRecordingNextCall = false
                                    
                                    task.wait(1)
                                    
                                    if getgenv().PortalConfig.pickPortal then
                                        pcall(function()
                                            local promptUI = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                                            if promptUI and promptUI:FindFirstChild("Frame") then
                                                local frame = promptUI.Frame:FindFirstChild("Frame")
                                                if frame then
                                                    local children = frame:GetChildren()
                                                    for _, child in ipairs(children) do
                                                        if child:IsA("Frame") or child:IsA("GuiObject") then
                                                            local textButton = child:FindFirstChildOfClass("TextButton", true)
                                                            if textButton then
                                                                getgenv()._SkipRecordingNextCall = true
                                                                for i, v in pairs(getconnections(textButton.MouseButton1Click)) do
                                                                    v:Fire()
                                                                end
                                                                getgenv()._SkipRecordingNextCall = false
                                                                task.wait(0.2)
                                                                
                                                                local confirmButton = promptUI:FindFirstChild("Confirm", true)
                                                                if confirmButton and confirmButton:IsA("TextButton") then
                                                                    getgenv()._SkipRecordingNextCall = true
                                                                    for i, v in pairs(getconnections(confirmButton.MouseButton1Click)) do
                                                                        v:Fire()
                                                                    end
                                                                    getgenv()._SkipRecordingNextCall = false
                                                                end
                                                                break
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end)
                                    else
                                        local portalID = findBestPortal()
                                        if portalID then
                                            activatePortal(portalID)
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end)
    end
    end)
end


local function formatNumber(num)
    if not num then return "0" end
    num = math.floor(num + 0.5)
    local s = tostring(num)
    s = s:reverse():gsub("(%d%d%d)", "%1,"):reverse()
    if s:sub(1,1) == "," then s = s:sub(2) end
    return s
end

getgenv()._FormatNumber = formatNumber

local function SendMessageEMBED(url, embed, content)
    print("[SendMessageEMBED] Starting webhook send...")
    if not url or url == "" then
        warn("[Webhook] Invalid URL provided")
        return false
    end
    
    local success, result = pcall(function()
        print("[SendMessageEMBED] Inside pcall...")
        local headers = { ["Content-Type"] = "application/json" }
        local data = { 
            embeds = { { 
                title = embed.title, 
                description = embed.description, 
                color = embed.color, 
                fields = embed.fields, 
                footer = embed.footer, 
                timestamp = os.date("!%Y-%m-%dT%H:%M:%S.000Z") 
            } } 
        }
        
        if content and content ~= "" then
            data.content = content
        end
        
        print("[SendMessageEMBED] Encoding JSON...")
        local httpSvc = game:GetService("HttpService")
        if not httpSvc then
            warn("[Webhook] HttpService not available")
            return false
        end
        
        local body = httpSvc:JSONEncode(data)
        print("[SendMessageEMBED] JSON encoded successfully")
        
        print("[SendMessageEMBED] Finding request function...")
        local requestFunc = syn and syn.request or http_request or request
        if not requestFunc then
            warn("[Webhook] No request function available")
            return false
        end
        print("[SendMessageEMBED] Request function found: " .. tostring(requestFunc))
        
        local maxRetries = 3
        local retryDelay = 1
        local response = nil
        
        print("[SendMessageEMBED] Starting request attempts...")
        for attempt = 1, maxRetries do
            print("[SendMessageEMBED] Attempt " .. attempt .. "/" .. maxRetries)
            local requestSuccess, requestResult = pcall(function()
                return requestFunc({
                    Url = url,
                    Method = "POST",
                    Headers = headers,
                    Body = body
                })
            end)
            
            if requestSuccess and requestResult then
                print("[SendMessageEMBED] Request successful!")
                response = requestResult
                break
            else
                warn("[Webhook] Attempt " .. attempt .. "/" .. maxRetries .. " failed: " .. tostring(requestResult))
                if attempt < maxRetries then
                    task.wait(retryDelay)
                    retryDelay = retryDelay * 2 
                end
            end
        end
        
        if not response then
            warn("[Webhook] All retry attempts failed")
            return false
        end
        
        print("[SendMessageEMBED] Checking response status...")
        if response and response.StatusCode then
            print("[SendMessageEMBED] Status code: " .. response.StatusCode)
            if response.StatusCode == 204 or response.StatusCode == 200 then
                print("[SendMessageEMBED] Success!")
                return true
            else
                warn("[Webhook] Failed with status: " .. response.StatusCode)
                if response.Body then
                    warn("[Webhook] Response: " .. response.Body)
                end
                return false
            end
        end
        
        print("[SendMessageEMBED] Returning true (no status code)")
        return true
    end)
    
    if not success then
        warn("[Webhook] Error sending: " .. tostring(result))
        return false
    end
    
    print("[SendMessageEMBED] Final result: " .. tostring(result))
    return result
end

getgenv()._CompareCapsuleRewards = function(beforeData, afterData)
    if not beforeData or not afterData then return "" end
    
    local rewards = {}
    
    if afterData.UnitData and beforeData.UnitData then
        local unitCounts = {}
        for unitID, unitInfo in pairs(afterData.UnitData) do
            if not beforeData.UnitData[unitID] and unitInfo.UnitName then
                local unitName = unitInfo.UnitName
                unitCounts[unitName] = (unitCounts[unitName] or 0) + 1
            end
        end
        
        for unitName, count in pairs(unitCounts) do
            table.insert(rewards, count .. "x " .. unitName)
        end
    end
    
    if afterData.ItemData and beforeData.ItemData then
        for itemName, itemInfo in pairs(afterData.ItemData) do
            local beforeAmount = (beforeData.ItemData[itemName] and beforeData.ItemData[itemName].Amount) or 0
            local afterAmount = itemInfo.Amount or 0
            local gained = afterAmount - beforeAmount
            
            if gained > 0 then
                local displayName = itemName:gsub("([A-Z])", " %1"):gsub("^%s+", "")
                table.insert(rewards, "+" .. formatNumber(gained) .. " " .. displayName)
            end
        end
    elseif afterData.ItemData then
        for itemName, itemInfo in pairs(afterData.ItemData) do
            local amount = itemInfo.Amount or 0
            if amount > 0 then
                local displayName = itemName:gsub("([A-Z])", " %1"):gsub("^%s+", "")
                table.insert(rewards, "+" .. formatNumber(amount) .. " " .. displayName)
            end
        end
    end
    
    if #rewards == 0 then
        return "No new items"
    end
    
    return table.concat(rewards, "\n")
end

getgenv()._CapsuleWebhookDebounce = getgenv()._CapsuleWebhookDebounce or {}

getgenv()._SendCapsuleWebhook = function(eventName, capsuleCount, rewardsText, clientData)
    if not getgenv().WebhookEnabled or not getgenv().WebhookURL or getgenv().WebhookURL == "" then
        return
    end
    
    if not clientData then 
        return 
    end
    
    local debounceKey = eventName .. "_" .. capsuleCount .. "_" .. tick()
    local lastSendTime = getgenv()._CapsuleWebhookDebounce[eventName] or 0
    local currentTime = tick()
    
    if currentTime - lastSendTime < 5 then
        return
    end
    
    getgenv()._CapsuleWebhookDebounce[eventName] = currentTime
    
    local username = LocalPlayer.Name
    local level = clientData.Level or 0
    local exp = clientData.EXP or 0
    local expNeeded = clientData.EXPNeeded or 0
    
    local function formatStats()
        local stats = "<:gold:1265957290251522089> " .. formatNumber(clientData.Jewels or 0)
        stats = stats .. "\n<:jewel:1217525743408648253> " .. formatNumber(clientData.Gold or 0)
        stats = stats .. "\n<:emerald:1389165843966984192> " .. formatNumber(clientData.Emeralds or 0)
        stats = stats .. "\n<:rerollshard:1426315987019501598> " .. formatNumber(clientData.Rerolls or 0)
        stats = stats .. "\n<:candybasket:1426304615284084827> " .. formatNumber(clientData.CandyBasket or 0)
        
        local bingoStamps = 0
        if clientData.ItemData and clientData.ItemData.HallowenBingoStamp then
            bingoStamps = clientData.ItemData.HallowenBingoStamp.Amount or 0
        end
        stats = stats .. "\n<:bingostamp:1426362482141954068> " .. formatNumber(bingoStamps)
        
        stats = stats .. "\n<:halloweencookies:1430910916534210580> " .. formatNumber(clientData.HalloweenCookies or 0)
        
        stats = stats .. "\n<:slimecoins:1430922724230037684> " .. formatNumber(clientData.MagicCoins or 0)
        
        return stats
    end
    
    local embedFields = {
        { name = "Player Stats", value = formatStats(), inline = true },
        { name = "Capsule Rewards", value = rewardsText ~= "" and rewardsText or "No rewards", inline = true }
    }
    
    local embed = {
        title = eventName,
        description = string.format("**Username:** ||%s||\n**Level:** %d [%s/%s]", 
            username, 
            level, 
            formatNumber(exp), 
            formatNumber(expNeeded)
        ),
        color = 0x9B59B6,
        fields = embedFields,
        footer = { text = "Capsules Opened: " .. formatNumber(capsuleCount) }
    }
    
    local pingContent = ""
    if getgenv().PingOnSecretDrop and getgenv().DiscordUserID and getgenv().DiscordUserID ~= "" then
        pingContent = "<@" .. getgenv().DiscordUserID .. ">"
    end
    
    task.spawn(function()
        SendMessageEMBED(getgenv().WebhookURL, embed, pingContent)
    end)
end

local function getRewards()
    local rewards = {}
    local ok, res = pcall(function()
        local ui = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
        if not ui then return {} end
        local holder = ui:FindFirstChild("BG") and ui.BG:FindFirstChild("Container") and ui.BG.Container:FindFirstChild("Rewards") and ui.BG.Container.Rewards:FindFirstChild("Holder")
        if not holder then return {} end
        
        local waitTime = 0
        local lastCount = 0
        local stableCount = 0
        repeat
            task.wait(0.3)
            waitTime = waitTime + 0.3
            local children = holder:GetChildren()
            local currentCount = 0
            for i = 1, #children do
                if children[i]:IsA("TextButton") then
                    currentCount = currentCount + 1
                end
            end
            if currentCount == lastCount and currentCount > 0 then
                stableCount = stableCount + 1
            else
                stableCount = 0
            end
            lastCount = currentCount
        until (stableCount >= 5 and currentCount > 0) or waitTime > 4
        
        for _, item in pairs(holder:GetChildren()) do
            if item:IsA("TextButton") then
                local rewardName, rewardAmount
                local unitName = item:FindFirstChild("UnitName")
                if unitName and unitName.Text and unitName.Text ~= "" then
                    rewardName = unitName.Text
                end
                local itemName = item:FindFirstChild("ItemName")
                if itemName and itemName.Text and itemName.Text ~= "" then
                    rewardName = itemName.Text
                end
                if rewardName then
                    local amountLabel = item:FindFirstChild("Amount")
                    if amountLabel and amountLabel.Text then
                        local amountText = amountLabel.Text
                        local clean = string.gsub(string.gsub(string.gsub(amountText, "x", ""), "+", ""), ",", "")
                        rewardAmount = tonumber(clean)
                    else
                        rewardAmount = 1
                    end
                    if rewardAmount then
                        table.insert(rewards, { name = rewardName, amount = rewardAmount })
                    end
                end
            end
        end
        return rewards
    end)
    return ok and res or {}
end

getgenv()._GetMatchResult = function()
    local ok, time, wave, result = pcall(function()
        local ui = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
        if not ui then return "00:00:00", "0", "Unknown" end
        local stats = ui:FindFirstChild("BG") and ui.BG:FindFirstChild("Container") and ui.BG.Container:FindFirstChild("Stats")
        if not stats then return "00:00:00", "0", "Unknown" end
        
        local r = (stats:FindFirstChild("Result") and stats.Result.Text) or "Unknown"
        local w = (stats:FindFirstChild("EndWave") and stats.EndWave.Text) or "0"
        
        local t = "00:00:00"
        pcall(function()
            local elapsed = RS:FindFirstChild("ElapsedTime")
            if elapsed and elapsed.Value then
                local roundTime = elapsed.Value - (getgenv()._RoundStartTime or 0)
                if roundTime < 0 then roundTime = elapsed.Value end
                
                local timeScale = 1
                pcall(function()
                    local timeScaleValue = RS:FindFirstChild("TimeScale")
                    if timeScaleValue and timeScaleValue:IsA("NumberValue") then
                        timeScale = timeScaleValue.Value or 1
                    end
                end)
                
                local realTime = roundTime / timeScale
                
                local seconds = math.floor(realTime)
                local hours = math.floor(seconds / 3600)
                local minutes = math.floor((seconds % 3600) / 60)
                local secs = seconds % 60
                t = string.format("%02d:%02d:%02d", hours, minutes, secs)
            end
        end)
        
        if w:find("Wave Reached:") then
            local wm = w:match("Wave Reached:%s*(%d+)")
            if wm then w = wm end
        end
        
        if r:lower():find("win") or r:lower():find("victory") then
            r = "VICTORY"
        elseif r:lower():find("defeat") or r:lower():find("lose") or r:lower():find("loss") then
            r = "DEFEAT"
        end
        
        return t, w, r
    end)
    if ok then return time, wave, result else return "00:00:00", "0", "Unknown" end
end

getgenv()._GetMapInfo = function()
    local ok, name, difficulty = pcall(function()
        local map = workspace:FindFirstChild("Map")
        if not map then return "Unknown Map", "Unknown" end
        local mapName = map:FindFirstChild("MapName")
        local mapDifficulty = map:FindFirstChild("MapDifficulty")
        return mapName and mapName.Value or "Unknown Map", mapDifficulty and mapDifficulty.Value or "Unknown"
    end)
    if ok then return name, difficulty else return "Unknown Map", "Unknown" end
end


do
    if not getgenv()._WebhookInitialData then
        getgenv()._WebhookInitialData = {
            Jewels = 0,
            Gold = 0,
            Emeralds = 0,
            Rerolls = 0,
            CandyBasket = 0,
            HeroTokens = 0,
            EXP = 0,
            ItemData = {},
            ExperienceItemsData = {},
            UnitCounts = {}
        }
    end
    
    if not getgenv()._RoundStartTime then
        getgenv()._RoundStartTime = 0
        task.spawn(function()
            task.wait(2)
            
            pcall(function()
                local elapsed = RS:FindFirstChild("ElapsedTime")
                if elapsed and elapsed.Value then
                    getgenv()._RoundStartTime = elapsed.Value
                end
            end)
            
            local clientData = getClientData()
            if clientData then
                getgenv()._WebhookInitialData.Jewels = clientData.Jewels or 0
                getgenv()._WebhookInitialData.Gold = clientData.Gold or 0
                getgenv()._WebhookInitialData.Emeralds = clientData.Emeralds or 0
                getgenv()._WebhookInitialData.Rerolls = clientData.Rerolls or 0
                getgenv()._WebhookInitialData.CandyBasket = clientData.CandyBasket or 0
                getgenv()._WebhookInitialData.HeroTokens = clientData.HeroTokens or 0
                getgenv()._WebhookInitialData.EXP = clientData.EXP or 0
                getgenv()._WebhookInitialData.HalloweenCookies = clientData.HalloweenCookies or 0
                getgenv()._WebhookInitialData.MagicCoins = clientData.MagicCoins or 0
                getgenv()._WebhookInitialData.EmberTokens = clientData.EmberTokens or 0
                getgenv()._WebhookInitialData.BlazeTokens = clientData.BlazeTokens or 0
                getgenv()._WebhookInitialData.HorseTokens = clientData.HorseTokens or 0
                getgenv()._WebhookInitialData.DevilDogTokens = clientData.DevilDogTokens or 0
                getgenv()._WebhookInitialData.TitanRushTokens = clientData.TitanRushTokens or 0
                getgenv()._WebhookInitialData.SoccerTokens = clientData.SoccerTokens or 0
                getgenv()._WebhookInitialData.SlimeCoins = clientData.SlimeCoins or 0
                
                getgenv()._WebhookInitialData.ItemData = {}
                if clientData.ItemData then
                    for itemName, itemInfo in pairs(clientData.ItemData) do
                        if itemInfo.Amount then
                            getgenv()._WebhookInitialData.ItemData[itemName] = itemInfo.Amount
                        end
                    end
                end
                
                getgenv()._WebhookInitialData.ExperienceItemsData = {}
                if clientData.ExperienceItemsData then
                    for itemName, itemInfo in pairs(clientData.ExperienceItemsData) do
                        if itemInfo.Amount then
                            getgenv()._WebhookInitialData.ExperienceItemsData[itemName] = itemInfo.Amount
                        end
                    end
                end
                
                getgenv()._WebhookInitialData.UnitCounts = {}
                if clientData.UnitData then
                    for unitID, unitInfo in pairs(clientData.UnitData) do
                        if unitInfo.UnitName then
                            local unitName = unitInfo.UnitName
                            getgenv()._WebhookInitialData.UnitCounts[unitName] = (getgenv()._WebhookInitialData.UnitCounts[unitName] or 0) + 1
                        end
                    end
                end
            end
        end)
    end
    
    if not getgenv()._lastWebhookHash then
        getgenv()._lastWebhookHash = ""
    end
    
    if not getgenv()._lastWebhookTime then
        getgenv()._lastWebhookTime = 0
    end
    
    task.spawn(function()
        local WEBHOOK_COOLDOWN = 10
    
    local function sendWebhook()
        local success, err = pcall(function()
            print("[Webhook] sendWebhook called")
            
            if not getgenv().WebhookEnabled then 
                print("[Webhook] Webhook disabled, exiting")
                getgenv().WebhookProcessing = false
                return 
            end
            
            if getgenv().WebhookProcessing and not getgenv()._ForceWebhookSend then
                print("[Webhook] ⚠️ Already processing, skipping duplicate call")
                return
            end
            
            print("[Webhook] Proceeding with webhook send...")
            
            if not getgenv()._ForceWebhookSend then
                local currentTime = tick()
                if currentTime - getgenv()._lastWebhookTime < WEBHOOK_COOLDOWN then 
                    print("[Webhook] ⏱️ Cooldown active - " .. string.format("%.1f", WEBHOOK_COOLDOWN - (currentTime - getgenv()._lastWebhookTime)) .. "s remaining")
                    return 
                end
            end
            
            getgenv()._lastWebhookTime = tick()
            getgenv().WebhookProcessing = true
            print("[Webhook] WebhookProcessing set to true")
            
            local isSeamlessRestart = getgenv()._WebhookSeamlessRestart or false
            
            print("[Webhook] Getting rewards...")
            local rewards = getRewards()
            print("[Webhook] Getting match result...")
            local matchTime, matchWave, matchResult = getgenv()._GetMatchResult()
            print("[Webhook] Match: " .. tostring(matchResult) .. " | Wave: " .. tostring(matchWave) .. " | Time: " .. tostring(matchTime))
            print("[Webhook] Getting map info...")
            local mapName, mapDifficulty = getgenv()._GetMapInfo()
            print("[Webhook] Map: " .. tostring(mapName) .. " | Difficulty: " .. tostring(mapDifficulty))
            
            ClientDataCache.module = nil
            ClientDataCache.lastUpdate = 0
            
            print("[Webhook] Getting client data...")
            local clientData = getClientData()
            
            if not clientData then
                print("[Webhook] ❌ Failed to get client data")
                getgenv().WebhookProcessing = false
                return
            end
            
            print("[Webhook] ✅ Client data retrieved")
            
            if isSeamlessRestart then
                pcall(function()
                    local wave = RS:FindFirstChild("Wave")
                    if wave and wave.Value then
                        matchWave = tostring(wave.Value)
                    end
                    
                    local elapsed = RS:FindFirstChild("ElapsedTime")
                    if elapsed and elapsed.Value then
                        local roundTime = elapsed.Value
                        
                        if getgenv()._RoundStartTime and getgenv()._RoundStartTime > 0 then
                            roundTime = elapsed.Value - getgenv()._RoundStartTime
                            if roundTime < 0 or roundTime > elapsed.Value then
                                roundTime = elapsed.Value
                            end
                        end
                        
                        local timeScale = 1
                        pcall(function()
                            local timeScaleValue = RS:FindFirstChild("TimeScale")
                            if timeScaleValue and timeScaleValue:IsA("NumberValue") then
                                timeScale = timeScaleValue.Value or 1
                            end
                        end)
                        
                        local realTime = roundTime / timeScale
                        
                        local seconds = math.floor(realTime)
                        local hours = math.floor(seconds / 3600)
                        local minutes = math.floor((seconds % 3600) / 60)
                        local secs = seconds % 60
                        matchTime = string.format("%02d:%02d:%02d", hours, minutes, secs)
                    end
                    
                    matchResult = "Seamless Restart"
                end)
                
                print("[Webhook] Seamless restart - Wave: " .. matchWave .. ", Time: " .. matchTime)
            end
            
            if not matchWave or matchWave == "0" or matchWave == "" then
                print("[Webhook] ❌ Invalid wave: " .. tostring(matchWave))
                getgenv().WebhookProcessing = false
                return
            end
            
            if not matchResult or matchResult == "Unknown" or matchResult == "" then
                print("[Webhook] ❌ Invalid match result: " .. tostring(matchResult))
                getgenv().WebhookProcessing = false
                return
            end
            
            if not matchTime or matchTime == "00:00:00" or matchTime == "" then
                print("[Webhook] ❌ Invalid match time: " .. tostring(matchTime))
                getgenv().WebhookProcessing = false
                return
            end
            
            print("[Webhook] ✅ All validation passed")
            
            print("[Webhook] Data validated - Wave: " .. matchWave .. ", Result: " .. matchResult .. ", Time: " .. matchTime)
            
            
            local function formatStats()
                print("[Webhook Debug] Rerolls raw value:", clientData.Rerolls)
                print("[Webhook Debug] Rerolls type:", type(clientData.Rerolls))
                
                local stats = "<:gold:1265957290251522089> " .. formatNumber(clientData.Jewels or 0)
                stats = stats .. "\n<:jewel:1217525743408648253> " .. formatNumber(clientData.Gold or 0)
                stats = stats .. "\n<:emerald:1389165843966984192> " .. formatNumber(clientData.Emeralds or 0)
                stats = stats .. "\n<:rerollshard:1426315987019501598> " .. formatNumber(clientData.Rerolls or 0)
                stats = stats .. "\n<:candybasket:1426304615284084827> " .. formatNumber(clientData.CandyBasket or 0)
                
                local bingoStamps = 0
                if clientData.ItemData and clientData.ItemData.HallowenBingoStamp then
                    bingoStamps = clientData.ItemData.HallowenBingoStamp.Amount or 0
                end
                stats = stats .. "\n<:bingostamp:1426362482141954068> " .. formatNumber(bingoStamps)
                
                stats = stats .. "\n<:halloweencookies:1430910916534210580> " .. formatNumber(clientData.HalloweenCookies or 0)
                
                stats = stats .. "\n<:slimecoins:1430922724230037684> " .. formatNumber(clientData.MagicCoins or 0)
                
                return stats
            end
            
            local rewardsText = ""
            
            if isSeamlessRestart then
                local currencyKeys = {
                    {key = "Jewels", name = "Jewels"},
                    {key = "Gold", name = "Gold"},
                    {key = "Emeralds", name = "Emeralds"},
                    {key = "Rerolls", name = "Rerolls"},
                    {key = "HeroTokens", name = "Hero Coins"},
                    {key = "EXP", name = "Player EXP"},
                    {key = "CandyBasket", name = "Candy Basket"},
                    {key = "HalloweenCookies", name = "Halloween Cookies"},
                    {key = "MagicCoins", name = "Slime Coins"},
                }
                
                for _, currency in ipairs(currencyKeys) do
                    local initial = (getgenv()._WebhookInitialData and getgenv()._WebhookInitialData[currency.key]) or 0
                    local current = clientData[currency.key] or 0
                    local gained = current - initial
                    
                    if gained > 0 then
                        rewardsText = rewardsText .. "+" .. formatNumber(gained) .. " " .. currency.name .. " [ Total: " .. formatNumber(current) .. " ]\n"
                    end
                end
                
                if clientData.ItemData then
                    for itemName, itemInfo in pairs(clientData.ItemData) do
                        local initial = (getgenv()._WebhookInitialData and getgenv()._WebhookInitialData.ItemData and getgenv()._WebhookInitialData.ItemData[itemName]) or 0
                        local current = itemInfo.Amount or 0
                        local gained = current - initial
                        
                        if gained > 0 then
                            local displayName = itemName:gsub("([A-Z])", " %1"):gsub("^%s+", "")
                            rewardsText = rewardsText .. "+" .. formatNumber(gained) .. " " .. displayName .. " [ Total: " .. formatNumber(current) .. " ]\n"
                        end
                    end
                end
                
                if clientData.ExperienceItemsData then
                    for itemName, itemInfo in pairs(clientData.ExperienceItemsData) do
                        local initial = (getgenv()._WebhookInitialData and getgenv()._WebhookInitialData.ExperienceItemsData and getgenv()._WebhookInitialData.ExperienceItemsData[itemName]) or 0
                        local current = itemInfo.Amount or 0
                        local gained = current - initial
                        
                        if gained > 0 then
                            local displayName = itemName:gsub("([A-Z])", " %1"):gsub("^%s+", "")
                            rewardsText = rewardsText .. "+" .. formatNumber(gained) .. " " .. displayName .. " [ Total: " .. formatNumber(current) .. " ]\n"
                        end
                    end
                end
                
                if rewardsText == "" then
                    rewardsText = "No rewards earned this round"
                end
            elseif #rewards > 0 then
                local function findBestMatch(searchTerm, data, dataType)
                    if not searchTerm or not data then return nil end
                    
                    local cleanSearch = searchTerm:gsub(" ", ""):gsub("_", ""):lower()
                    local bestMatch = nil
                    local bestScore = 0
                    
                    local function checkMatch(key)
                        local cleanKey = key:gsub("_", ""):lower()
                        
                        if cleanKey == cleanSearch then
                            return key, 100
                        end
                        
                        if cleanKey:find(cleanSearch) or cleanSearch:find(cleanKey) then
                            local score = 50
                            if cleanKey:sub(1, #cleanSearch) == cleanSearch then
                                score = 80
                            elseif cleanKey:sub(-#cleanSearch) == cleanSearch then
                                score = 70
                            end
                            return key, score
                        end
                        
                        return nil, 0
                    end
                    
                    if dataType == "root" then
                        for key, value in pairs(data) do
                            if type(value) == "number" then
                                local match, score = checkMatch(key)
                                if match and score > bestScore then
                                    bestMatch = match
                                    bestScore = score
                                end
                            end
                        end
                    elseif dataType == "ItemData" and data.ItemData then
                        for key, value in pairs(data.ItemData) do
                            if type(value) == "table" and value.Amount then
                                local match, score = checkMatch(key)
                                if match and score > bestScore then
                                    bestMatch = match
                                    bestScore = score
                                end
                            end
                        end
                    elseif dataType == "ExperienceItemsData" and data.ExperienceItemsData then
                        for key, value in pairs(data.ExperienceItemsData) do
                            if type(value) == "table" and value.Amount then
                                local match, score = checkMatch(key)
                                if match and score > bestScore then
                                    bestMatch = match
                                    bestScore = score
                                end
                            end
                        end
                    end
                    
                    return bestMatch
                end
                
                for _, r in ipairs(rewards) do
                    local initialValue = 0
                    local currentValue = 0
                    local itemName = r.name
                    local itemKey = itemName:gsub(" ", "")
                    
                    if itemKey == "HeroCoins" then itemKey = "HeroTokens" end
                    if itemKey == "PlayerEXP" then itemKey = "EXP" end
                    
                    if r.type == "Unit" then
                        local unitFileName = getUnitFileName(itemName)
                        initialValue = (getgenv()._WebhookInitialData and getgenv()._WebhookInitialData.UnitCounts and getgenv()._WebhookInitialData.UnitCounts[unitFileName]) or 0
                        
                        currentValue = 0
                        if clientData.UnitData then
                            for unitID, unitInfo in pairs(clientData.UnitData) do
                                if unitInfo.UnitName == unitFileName then
                                    currentValue = currentValue + 1
                                end
                            end
                        end
                        
                        local total = currentValue
                        rewardsText = rewardsText .. "+" .. formatNumber(r.amount) .. " " .. itemName .. " [ Total: " .. formatNumber(total) .. " ]\n"
                    elseif clientData[itemKey] and type(clientData[itemKey]) == "number" then
                        currentValue = clientData[itemKey]
                        initialValue = (getgenv()._WebhookInitialData and getgenv()._WebhookInitialData[itemKey]) or 0
                        local total = currentValue
                        rewardsText = rewardsText .. "+" .. formatNumber(r.amount) .. " " .. itemName .. " [ Total: " .. formatNumber(total) .. " ]\n"
                    elseif clientData.ItemData and clientData.ItemData[itemKey] then
                        currentValue = clientData.ItemData[itemKey].Amount or 0
                        initialValue = (getgenv()._WebhookInitialData and getgenv()._WebhookInitialData.ItemData and getgenv()._WebhookInitialData.ItemData[itemKey]) or 0
                        local total = currentValue
                        rewardsText = rewardsText .. "+" .. formatNumber(r.amount) .. " " .. itemName .. " [ Total: " .. formatNumber(total) .. " ]\n"
                    elseif clientData.ExperienceItemsData and clientData.ExperienceItemsData[itemKey] then
                        currentValue = clientData.ExperienceItemsData[itemKey].Amount or 0
                        initialValue = (getgenv()._WebhookInitialData and getgenv()._WebhookInitialData.ExperienceItemsData and getgenv()._WebhookInitialData.ExperienceItemsData[itemKey]) or 0
                        local total = currentValue
                        rewardsText = rewardsText .. "+" .. formatNumber(r.amount) .. " " .. itemName .. " [ Total: " .. formatNumber(total) .. " ]\n"
                    elseif itemName:find("Candy Basket") then
                        currentValue = clientData.CandyBasket or 0
                        initialValue = (getgenv()._WebhookInitialData and getgenv()._WebhookInitialData.CandyBasket) or 0
                        local total = currentValue
                        rewardsText = rewardsText .. "+" .. formatNumber(r.amount) .. " " .. itemName .. " [ Total: " .. formatNumber(total) .. " ]\n"
                    elseif itemName:find("Bingo Stamp") and clientData.ItemData and clientData.ItemData.HallowenBingoStamp then
                        currentValue = clientData.ItemData.HallowenBingoStamp.Amount or 0
                        initialValue = (getgenv()._WebhookInitialData and getgenv()._WebhookInitialData.ItemData and getgenv()._WebhookInitialData.ItemData.HallowenBingoStamp) or 0
                        local total = currentValue
                        rewardsText = rewardsText .. "+" .. formatNumber(r.amount) .. " " .. itemName .. " [ Total: " .. formatNumber(total) .. " ]\n"
                    else
                        local foundMatch = false
                        local matchedKey = findBestMatch(itemKey, clientData, "root")
                        if matchedKey and clientData[matchedKey] and type(clientData[matchedKey]) == "number" then
                            currentValue = clientData[matchedKey]
                            initialValue = (getgenv()._WebhookInitialData and getgenv()._WebhookInitialData[matchedKey]) or 0
                            local total = currentValue
                            rewardsText = rewardsText .. "+" .. formatNumber(r.amount) .. " " .. itemName .. " [ Total: " .. formatNumber(total) .. " ]\n"
                            foundMatch = true
                        end
                        
                        if not foundMatch then
                            matchedKey = findBestMatch(itemKey, clientData, "ItemData")
                            if matchedKey and clientData.ItemData and clientData.ItemData[matchedKey] then
                                currentValue = clientData.ItemData[matchedKey].Amount or 0
                                initialValue = (getgenv()._WebhookInitialData and getgenv()._WebhookInitialData.ItemData and getgenv()._WebhookInitialData.ItemData[matchedKey]) or 0
                                local total = currentValue
                                rewardsText = rewardsText .. "+" .. formatNumber(r.amount) .. " " .. itemName .. " [ Total: " .. formatNumber(total) .. " ]\n"
                                foundMatch = true
                            end
                        end
                        
                        if not foundMatch then
                            matchedKey = findBestMatch(itemKey, clientData, "ExperienceItemsData")
                            if matchedKey and clientData.ExperienceItemsData and clientData.ExperienceItemsData[matchedKey] then
                                currentValue = clientData.ExperienceItemsData[matchedKey].Amount or 0
                                initialValue = (getgenv()._WebhookInitialData and getgenv()._WebhookInitialData.ExperienceItemsData and getgenv()._WebhookInitialData.ExperienceItemsData[matchedKey]) or 0
                                local total = currentValue
                                rewardsText = rewardsText .. "+" .. formatNumber(r.amount) .. " " .. itemName .. " [ Total: " .. formatNumber(total) .. " ]\n"
                                foundMatch = true
                            end
                        end
                        
                        if not foundMatch then
                            local total = r.amount
                            rewardsText = rewardsText .. "+" .. formatNumber(r.amount) .. " " .. itemName .. " [ Total: " .. formatNumber(total) .. " ]\n"
                        end
                    end
                end
            else
                rewardsText = "No rewards found"
            end
            
            if getgenv().FinalExpChestRewards and next(getgenv().FinalExpChestRewards) then
                if rewardsText == "No rewards found" then
                    rewardsText = ""
                end
                if rewardsText ~= "" then
                    rewardsText = rewardsText .. "\n"
                end
                rewardsText = rewardsText .. "**Chests:**\n"
                for chestName, data in pairs(getgenv().FinalExpChestRewards) do
                    local amount = data.amount
                    local owned = data.owned
                    local total = owned + amount
                    rewardsText = rewardsText .. "+" .. formatNumber(amount) .. " " .. chestName .. " [ Total: " .. formatNumber(total) .. " ]\n"
                end
                getgenv().FinalExpChestRewards = {}
            end
            
            local unitsText = ""
            if clientData.Slots then
                local slots = {"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}
                for _, slotName in ipairs(slots) do
                    local slot = clientData.Slots[slotName]
                    if slot and slot.Value then
                        local level = slot.Level or 0
                        local kills = formatNumber(slot.Kills or 0)
                        local unitName = slot.Value
                        unitsText = unitsText .. "[ " .. level .. " ] " .. unitName .. " = " .. kills .. " ⚔️\n"
                    end
                end
            end
            
            local hasUnitDrop = false
            local unitDropName = ""
            for _, r in ipairs(rewards) do
                if r.name and r.type == "Unit" then
                    hasUnitDrop = true
                    unitDropName = r.name
                    break
                end
            end
            
            local description = "**Username:** ||" .. LocalPlayer.Name .. "||\n**Level:** " .. (clientData.Level or 0) .. " [" .. formatNumber(clientData.EXP or 0) .. "/" .. formatNumber(clientData.MaxEXP or 0) .. "]"
            
            local embedColor = 0x00ff00
            if matchResult and (matchResult:upper():find("DEFEAT") or matchResult:upper():find("LOSE") or matchResult:upper():find("LOSS")) then
                embedColor = 0xff0000
            end
            
            local embedFields = {
                { name = "Player Stats", value = (formatStats() ~= "" and formatStats() or "N/A"), inline = true },
                { name = "Rewards", value = (rewardsText ~= "" and rewardsText or "No rewards found"), inline = true },
                { name = "Units", value = (unitsText ~= "" and unitsText or "No units"), inline = false },
                { name = "Match Result", value = (matchTime or "00:00:00") .. " - Wave " .. tostring(matchWave or "0") .. "\n" .. (mapName or "Unknown Map") .. ((mapDifficulty and mapDifficulty ~= "Unknown") and (" [" .. mapDifficulty .. "]") or "") .. " - " .. (matchResult or "Unknown"), inline = false }
            }
            
            if getgenv().WebhookIncludePlayerCount or getgenv().WebhookIncludePlayerNames then
                local playerInfo = ""
                local playerCount = #Players:GetPlayers()
                
                if getgenv().WebhookIncludePlayerCount then
                    playerInfo = "**Players in Server:** " .. playerCount .. "/12\n"
                end
                
                if getgenv().WebhookIncludePlayerNames then
                    local playerNames = {}
                    for _, player in ipairs(Players:GetPlayers()) do
                        table.insert(playerNames, player.DisplayName .. " (@" .. player.Name .. ")")
                    end
                    playerInfo = playerInfo .. "**Players:**\n||" .. table.concat(playerNames, "||\n")
                end
                
                table.insert(embedFields, { name = "Server Info", value = playerInfo, inline = false })
            end
            
            local embed = {
                title = "Anime Last Stand",
                description = description or "N/A",
                color = embedColor,
                fields = embedFields,
                footer = { text = "Byorl Last Stand | https://discord.gg/V3WcdHpd3J" }
            }
            
            local webhookContent = ""
            if hasUnitDrop and getgenv().PingOnSecretDrop and getgenv().DiscordUserID and getgenv().DiscordUserID ~= "" then
                webhookContent = "<@" .. getgenv().DiscordUserID .. "> 🎉 **SECRET UNIT DROP: " .. unitDropName .. "**"
            end
            
            if not getgenv()._webhookSessionID then
                getgenv()._webhookSessionID = tostring(tick())
            end
            
            if not getgenv()._lastWebhookSendTime then
                getgenv()._lastWebhookSendTime = 0
            end
            
            local timeSinceLastSend = tick() - getgenv()._lastWebhookSendTime
            if timeSinceLastSend < 5 then
                print("[Webhook] ⏱️ Cooldown active - " .. string.format("%.1f", 5 - timeSinceLastSend) .. "s remaining")
                getgenv().WebhookProcessing = false
                return
            end
            
            local webhookHash = getgenv()._webhookSessionID .. "_" .. LocalPlayer.Name .. "_" .. matchTime .. "_" .. matchWave .. "_" .. rewardsText .. "_" .. (hasUnitDrop and unitDropName or "")
            
            if webhookHash == getgenv()._lastWebhookHash then
                print("[Webhook] 🔄 Duplicate detected (same as last)")
                getgenv().WebhookProcessing = false
                return
            end
            
            if getgenv()._lastWebhookHashList then
                for _, oldHash in ipairs(getgenv()._lastWebhookHashList) do
                    if oldHash == webhookHash then
                        print("[Webhook] 🔄 Duplicate detected (in history)")
                        getgenv().WebhookProcessing = false
                        return
                    end
                end
            else
                getgenv()._lastWebhookHashList = {}
            end
            
            getgenv()._lastWebhookHash = webhookHash
            table.insert(getgenv()._lastWebhookHashList, webhookHash)
            
            if #getgenv()._lastWebhookHashList > 5 then
                table.remove(getgenv()._lastWebhookHashList, 1)
            end
            
            getgenv()._lastWebhookSendTime = tick()
            
            local sendSuccess = false
            local sendAttempts = 0
            local maxAttempts = 3 
            
            while not sendSuccess and sendAttempts < maxAttempts do
                sendAttempts = sendAttempts + 1
                
                local ok, result = pcall(function()
                    if webhookContent ~= "" then
                        return SendMessageEMBED(getgenv().WebhookURL, embed, webhookContent)
                    else
                        return SendMessageEMBED(getgenv().WebhookURL, embed)
                    end
                end)
                
                if ok and result then
                    sendSuccess = true
                    print("[Webhook] ✅ Webhook sent successfully!")
                    
                    pcall(function()
                        local elapsed = RS:FindFirstChild("ElapsedTime")
                        if elapsed and elapsed.Value then
                            getgenv()._RoundStartTime = elapsed.Value
                        end
                    end)
                    
                    Window:Notify({
                        Title = "Webhook Sent",
                        Description = hasUnitDrop and "Unit drop detected!" or "Match results sent",
                        Lifetime = 3
                    })
                else
                    warn("[Webhook] ❌ Send failed (Attempt " .. sendAttempts .. "/" .. maxAttempts .. ")")
                    if not ok then
                        warn("[Webhook] Error: " .. tostring(result))
                    end
                    
                    if sendAttempts < maxAttempts then
                        task.wait(1)
                    end
                end
            end
            
            if not sendSuccess then
                warn("[Webhook] ❌ Failed to send after " .. maxAttempts .. " attempts")
                Window:Notify({
                    Title = "Webhook Failed",
                    Description = "Failed to send webhook. Check URL and try again.",
                    Lifetime = 5
                })
            end
            
            task.wait(0.5)
            getgenv().WebhookProcessing = false
        end)
        
        if not success then
            warn("[Webhook] ❌ Critical error in sendWebhook: " .. tostring(err))
            getgenv().WebhookProcessing = false
        end
    end
    
    local webhookConnection = nil
    local lastWebhookTime = 0
    local WEBHOOK_COOLDOWN = 30
    
    local function setupWebhookTrigger()
        if webhookConnection then
            webhookConnection:Disconnect()
        end
        
        webhookConnection = ConnectionManager:trackGroup("Webhook",
            LocalPlayer.PlayerGui.ChildAdded:Connect(function(child)
                if child.Name == "EndGameUI" and getgenv().WebhookEnabled then
                if getgenv().WebhookProcessing then
                    return
                end
                
                local isFinalExpedition = false
                local hasLeaveButton = false
                pcall(function()
                    local gamemode = RS:FindFirstChild("Gamemode")
                    if gamemode and gamemode.Value == "FinalExpedition" then
                        isFinalExpedition = true
                    end
                end)
                
                if isFinalExpedition then
                    print("[Webhook] Final Expedition detected, waiting for Prompt GUI to close...")
                    
                    local promptWait = 0
                    while promptWait < 15 do
                        local promptExists = false
                        pcall(function()
                            local promptGui = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                            if promptGui and promptGui.Enabled then
                                promptExists = true
                            end
                        end)
                        
                        if not promptExists then
                            print("[Webhook] Prompt GUI closed after " .. promptWait .. "s, checking if this is the final EndGameUI...")
                            break
                        end
                        
                        task.wait(0.5)
                        promptWait = promptWait + 0.5
                    end
                    
                    task.wait(2)
                    
                    local isFinalScreen = false
                    pcall(function()
                        local endGameUI = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
                        if endGameUI then
                            print("[Webhook] EndGameUI still exists, checking buttons...")
                            
                            local function findButton(parent, buttonName)
                                if not parent then return nil end
                                local button = parent:FindFirstChild(buttonName, true)
                                return button
                            end
                            
                            local leaveButton = findButton(endGameUI, "Leave")
                            local nextButton = findButton(endGameUI, "Next")
                            local retryButton = findButton(endGameUI, "Retry")
                            
                            print("[Webhook] Leave: " .. tostring(leaveButton and leaveButton.Visible))
                            print("[Webhook] Retry: " .. tostring(retryButton and retryButton.Visible))
                            print("[Webhook] Next: " .. tostring(nextButton and nextButton.Visible))
                            
                            if (leaveButton and leaveButton.Visible) or (retryButton and retryButton.Visible) then
                                isFinalScreen = true
                                print("[Webhook] Found Leave or Retry button - this is the final screen")
                            elseif nextButton and nextButton.Visible then
                                local nextText = nextButton:FindFirstChild("TextLabel", true)
                                if nextText and nextText.Text then
                                    print("[Webhook] Next button text: " .. nextText.Text)
                                    if nextText.Text:lower():find("leave") then
                                        isFinalScreen = true
                                        print("[Webhook] Next button says 'Leave' - this is the final screen")
                                    else
                                        isFinalScreen = true
                                        print("[Webhook] Next button found - assuming final screen")
                                    end
                                else
                                    isFinalScreen = true
                                    print("[Webhook] Next button found (no text) - assuming final screen")
                                end
                            else
                                print("[Webhook] No buttons found, checking if EndGameUI persists...")
                                task.wait(2)
                                if LocalPlayer.PlayerGui:FindFirstChild("EndGameUI") then
                                    isFinalScreen = true
                                    print("[Webhook] EndGameUI still exists after 2s - assuming final screen")
                                end
                            end
                        else
                            print("[Webhook] EndGameUI no longer exists")
                        end
                    end)
                    
                    if not isFinalScreen then
                        print("[Webhook] Skipping intermediate EndGameUI in Final Expedition")
                        return
                    else
                        print("[Webhook] Final EndGameUI confirmed in Final Expedition")
                    end
                end
                
                getgenv().WebhookProcessing = true
                
                local promptClosed = false
                local maxWait = 0
                task.spawn(function()
                    while maxWait < 3 and not promptClosed do
                        task.wait(0.1)
                        maxWait = maxWait + 0.1
                        if not LocalPlayer.PlayerGui:FindFirstChild("Prompt") then
                            promptClosed = true
                        end
                    end
                end)
                
                while not promptClosed and maxWait < 3 do
                    task.wait(0.1)
                end
                
                task.wait(0.5)
                sendWebhook()
            end
        end))
    end
    
    setupWebhookTrigger()
    
    getgenv()._SendWebhookManual = function()
        if not getgenv().WebhookEnabled then
            warn("[Webhook] Webhook is disabled")
            return
        end
        
        print("[Webhook] Manual trigger requested")
        sendWebhook()
    end
    
    getgenv()._RefreshWebhookInitialData = function()
        pcall(function()
            local elapsed = RS:FindFirstChild("ElapsedTime")
            if elapsed and elapsed.Value then
                getgenv()._RoundStartTime = elapsed.Value
            end
        end)
        
        local clientData = getClientData()
        if clientData then
            getgenv()._WebhookInitialData.Jewels = clientData.Jewels or 0
            getgenv()._WebhookInitialData.Gold = clientData.Gold or 0
            getgenv()._WebhookInitialData.Emeralds = clientData.Emeralds or 0
            getgenv()._WebhookInitialData.Rerolls = clientData.Rerolls or 0
            getgenv()._WebhookInitialData.CandyBasket = clientData.CandyBasket or 0
            getgenv()._WebhookInitialData.HeroTokens = clientData.HeroTokens or 0
            getgenv()._WebhookInitialData.EXP = clientData.EXP or 0
            
            getgenv()._WebhookInitialData.ItemData = {}
            if clientData.ItemData then
                for itemName, itemInfo in pairs(clientData.ItemData) do
                    if itemInfo.Amount then
                        getgenv()._WebhookInitialData.ItemData[itemName] = itemInfo.Amount
                    end
                end
            end
            
            getgenv()._WebhookInitialData.ExperienceItemsData = {}
            if clientData.ExperienceItemsData then
                for itemName, itemInfo in pairs(clientData.ExperienceItemsData) do
                    if itemInfo.Amount then
                        getgenv()._WebhookInitialData.ExperienceItemsData[itemName] = itemInfo.Amount
                    end
                end
            end
            
            getgenv()._WebhookInitialData.UnitCounts = {}
            if clientData.UnitData then
                for unitID, unitInfo in pairs(clientData.UnitData) do
                    if unitInfo.UnitName then
                        local unitName = unitInfo.UnitName
                        getgenv()._WebhookInitialData.UnitCounts[unitName] = (getgenv()._WebhookInitialData.UnitCounts[unitName] or 0) + 1
                    end
                end
            end
            
            print("[Webhook] Initial data refreshed successfully")
        else
            warn("[Webhook] Failed to get client data")
        end
    end
    
    ConnectionManager:trackGroup("Webhook",
        LocalPlayer.PlayerGui.ChildRemoved:Connect(function(child)
            if child.Name == "EndGameUI" then
                task.wait(1)
                if getgenv().WebhookProcessing then
                getgenv().WebhookProcessing = false
            end
            
            if getgenv().WebhookEnabled then
                task.wait(2)
                getgenv()._RefreshWebhookInitialData()
            end
        end
    end))
    
    task.spawn(function()
        local lastEndGameUICheck = false
        while true do
            task.wait(1)
            
            if not getgenv().WebhookEnabled then
                task.wait(2)
                continue
            end
            
            local currentEndGameUIExists = false
            pcall(function()
                local endGameUI = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
                currentEndGameUIExists = endGameUI and endGameUI.Enabled or false
            end)
            
            if currentEndGameUIExists and not lastEndGameUICheck and not getgenv().WebhookProcessing then
                print("[Webhook] Periodic check detected EndGameUI - triggering webhook")
                task.wait(0.5)
                
                local isFinalExpedition = false
                pcall(function()
                    local gamemode = RS:FindFirstChild("Gamemode")
                    if gamemode and gamemode.Value == "FinalExpedition" then
                        isFinalExpedition = true
                    end
                end)
                
                if isFinalExpedition then
                    print("[Webhook] Final Expedition detected in periodic check")
                    local promptWait = 0
                    while promptWait < 10 do
                        local promptExists = false
                        pcall(function()
                            local promptGui = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                            if promptGui and promptGui.Enabled then
                                promptExists = true
                            end
                        end)
                        
                        if not promptExists then
                            break
                        end
                        
                        task.wait(0.5)
                        promptWait = promptWait + 0.5
                    end
                    
                    task.wait(2)
                end
                
                if not getgenv().WebhookProcessing then
                    getgenv().WebhookProcessing = true
                    task.wait(0.5)
                    sendWebhook()
                end
            end
            
            lastEndGameUICheck = currentEndGameUIExists
        end
    end)
end)



do
    task.spawn(function()
        local eventsFolder = RS:FindFirstChild("Events")
    local halloweenFolder = eventsFolder and eventsFolder:FindFirstChild("Hallowen2025")
    local enterEvent = halloweenFolder and halloweenFolder:FindFirstChild("Enter")
    local startEvent = halloweenFolder and halloweenFolder:FindFirstChild("Start")
    
    while true do
        task.wait(1) 
        

        if not getgenv().AutoEventEnabled then
            task.wait(2)
            continue
        end
        
        if enterEvent and startEvent then
            pcall(function()
                if getgenv().WaitForPlayerEnabled then
                    local entryUI = nil
                    for _, gui in ipairs(LocalPlayer.PlayerGui:GetChildren()) do
                        if gui.Name:find("Entry") then
                            entryUI = gui
                            break
                        end
                    end
                    
                    if entryUI then
                        local function findTextLabel(parent)
                            for _, child in ipairs(parent:GetDescendants()) do
                                if child:IsA("TextLabel") and child.Text:find("Players") then
                                    return child
                                end
                            end
                            return nil
                        end
                        
                        local textLabel = findTextLabel(entryUI)
                        if textLabel then
                            local waitStartTime = tick()
                            local maxWaitTime = 300
                            
                            while tick() - waitStartTime < maxWaitTime do
                                local text = textLabel.Text
                                local current, max = text:match("%((%d+)/(%d+)%)")
                                
                                if current and max then
                                    local currentPlayers = tonumber(current)
                                    local targetCount = getgenv().WaitForPlayerCount or 1
                                    
                                    if currentPlayers >= targetCount then
                                        print("[Auto Event] ✅ " .. currentPlayers .. "/" .. targetCount .. " players ready, joining...")
                                        break
                                    else
                                        print("[Auto Event] ⏳ Waiting for players... " .. currentPlayers .. "/" .. targetCount)
                                    end
                                end
                                
                                task.wait(1)
                            end
                        end
                    end
                end
                
                local delay = getgenv().EventJoinDelay or 0
                if delay > 0 then
                    task.wait(delay)
                end
                
                enterEvent:FireServer()
                startEvent:FireServer()
            end)
        end
    end
    end)
end

if isInLobby then
    task.spawn(function()
        task.wait(1)
        
        local BingoEvents = RS:WaitForChild("Events", 10)
        if not BingoEvents then 
            warn("[Auto Bingo] Events folder not found")
            return 
        end
        
        local BingoFolder = BingoEvents:WaitForChild("Bingo", 10)
        if not BingoFolder then
            return
        end
        
        local UseStampEvent = BingoFolder:FindFirstChild("UseStamp")
        local ClaimRewardEvent = BingoFolder:FindFirstChild("ClaimReward")
        local CompleteBoardEvent = BingoFolder:FindFirstChild("CompleteBoard")
        
        if not UseStampEvent or not ClaimRewardEvent or not CompleteBoardEvent then
            warn("[Auto Bingo] Missing events - UseStamp: " .. tostring(UseStampEvent ~= nil) .. ", ClaimReward: " .. tostring(ClaimRewardEvent ~= nil) .. ", CompleteBoard: " .. tostring(CompleteBoardEvent ~= nil))
            return
        end
                
        while true do
            task.wait(1)
            
            if not getgenv().BingoEnabled then
                task.wait(2)
                continue
            end
            
            local success, err = pcall(function()
                local clientData = getClientData()
                local bingoStamps = 0
                
                if clientData and clientData.ItemData and clientData.ItemData.HallowenBingoStamp then
                    bingoStamps = clientData.ItemData.HallowenBingoStamp.Amount or 0
                end
                
                if bingoStamps < 1 then
                    print("[Auto Bingo] Not enough stamps (" .. bingoStamps .. "), waiting...")
                    task.wait(5)
                    return
                end
                
                
                if UseStampEvent then
                    for i = 1, 25 do
                        pcall(function()
                            UseStampEvent:FireServer()
                        end)
                    end
                end
                
                if ClaimRewardEvent then
                    for i = 1, 11 do
                        pcall(function()
                            ClaimRewardEvent:InvokeServer(i)
                        end)
                    end
                end
                
                task.wait(1)
                
                if CompleteBoardEvent then
                    local boardSuccess, boardResult = pcall(function()
                        return CompleteBoardEvent:InvokeServer()
                    end)
                    if boardSuccess then
                        print("[Auto Bingo] ✅ Board completed successfully! Result: " .. tostring(boardResult))
                    else
                        warn("[Auto Bingo] ❌ Failed to complete board: " .. tostring(boardResult))
                    end
                end
            end)
            
            if not success then
                warn("[Auto Bingo] Error in cycle: " .. tostring(err))
            end
        end
    end)
    
    task.spawn(function()
        task.wait(1)
        local Purchase = RS:WaitForChild("Events"):WaitForChild("Hallowen2025"):WaitForChild("Purchase")
        local OpenCapsule = RS:WaitForChild("Remotes"):WaitForChild("OpenCapsule")
        
        local function clickButton(button)
            if not button then return false end
            getgenv()._SkipRecordingNextCall = true
            local events = {"Activated", "MouseButton1Click", "MouseButton1Down", "MouseButton1Up"}
            for _, ev in ipairs(events) do
                pcall(function()
                    for _, conn in ipairs(getconnections(button[ev])) do
                        conn:Fire()
                    end
                end)
            end
            getgenv()._SkipRecordingNextCall = false
            return true
        end
        
        local function clickAllPromptButtons()
            local success = false
            pcall(function()
                local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                if not prompt then return end
                
                local frame = prompt:FindFirstChild("Frame")
                if not frame then return end
                
                local textButton = frame:FindFirstChild("TextButton")
                if textButton then
                    clickButton(textButton)
                    success = true
                end
                
                local folder = frame:FindFirstChild("Folder")
                if folder then
                    local folderButton = folder:FindFirstChild("TextButton")
                    if folderButton then
                        clickButton(folderButton)
                        success = true
                    end
                end
            end)
            return success
        end
        
        while true do
            task.wait(0.1) 
            
            if not getgenv().CapsuleEnabled then
                task.wait(3)
                continue
            end
            
            if getgenv().Capsule2Enabled then
                local clientData = getClientData()
                if clientData then
                    local candyBasket = clientData.CandyBasket or 0
                    
                    local eventsFolder = RS:FindFirstChild("Events")
                    local halloweenFolder = eventsFolder and eventsFolder:FindFirstChild("Hallowen2025")
                    local purchaseEvent = halloweenFolder and halloweenFolder:FindFirstChild("PurchaseEvent")
                    
                    if purchaseEvent then
                        if candyBasket >= 1000000 then
                            pcall(function() 
                                purchaseEvent:InvokeServer(1, 1000, "Hallowen2025_P2")
                                print("[Auto Capsule 2] Purchased 1000 capsules")
                            end)
                        elseif candyBasket >= 100000 then
                            pcall(function() 
                                purchaseEvent:InvokeServer(1, 100, "Hallowen2025_P2")
                                print("[Auto Capsule 2] Purchased 100 capsules")
                            end)
                        elseif candyBasket >= 10000 then
                            pcall(function() 
                                purchaseEvent:InvokeServer(1, 10, "Hallowen2025_P2")
                                print("[Auto Capsule 2] Purchased 10 capsules")
                            end)
                        elseif candyBasket >= 1000 then
                            pcall(function() 
                                purchaseEvent:InvokeServer(1, 1, "Hallowen2025_P2")
                                print("[Auto Capsule 2] Purchased 1 capsule")
                            end)
                        end
                    end
                    
                    if candyBasket < 1000 then
                        ClientDataCache.module = nil
                        ClientDataCache.lastUpdate = 0
                        clientData = getClientData()
                        local capsuleAmount = 0
                        if clientData and clientData.ItemData and clientData.ItemData.HalloweenCapsule2025 then
                            capsuleAmount = clientData.ItemData.HalloweenCapsule2025.Amount or 0
                        end
                        
                        if capsuleAmount > 0 then
                            local beforeData = {}
                            if clientData.UnitData then
                                beforeData.UnitData = {}
                                for k, v in pairs(clientData.UnitData) do
                                    beforeData.UnitData[k] = v
                                end
                            end
                            if clientData.ItemData then
                                beforeData.ItemData = {}
                                for k, v in pairs(clientData.ItemData) do
                                    beforeData.ItemData[k] = {Amount = v.Amount or 0}
                                end
                            end
                            
                            local openCapsuleEvent = halloweenFolder and halloweenFolder:FindFirstChild("OpenCapsule")
                            if openCapsuleEvent then
                                pcall(function()
                                    openCapsuleEvent:FireServer("HalloweenCapsule2025", capsuleAmount)
                                    print("[Auto Capsule Event 1] Opened " .. capsuleAmount .. " capsules")
                                end)
                                task.wait(0.5)
                                clickAllPromptButtons()
                                
                                local waitTime = math.min(3 + (capsuleAmount / 10000), 10)
                                task.wait(waitTime)
                                
                                local afterData = nil
                                local attempts = 0
                                local maxAttempts = 5
                                
                                while attempts < maxAttempts do
                                    ClientDataCache.module = nil
                                    ClientDataCache.lastUpdate = 0
                                    afterData = getClientData()
                                    
                                    if afterData and afterData.ItemData then
                                        local currentCapsules = (afterData.ItemData.HalloweenCapsule2025 and afterData.ItemData.HalloweenCapsule2025.Amount) or 0
                                        local beforeCapsules = (beforeData.ItemData and beforeData.ItemData.HalloweenCapsule2025 and beforeData.ItemData.HalloweenCapsule2025.Amount) or 0
                                        
                                        if currentCapsules ~= beforeCapsules or attempts >= 3 then
                                            break
                                        end
                                    end
                                    
                                    attempts = attempts + 1
                                    task.wait(1)
                                end
                                
                                if afterData and getgenv()._CompareCapsuleRewards then
                                    local rewardsText = getgenv()._CompareCapsuleRewards(beforeData, afterData)
                                    print("[Auto Capsule Event 1] Rewards:\n" .. rewardsText)
                                    
                                    if getgenv()._SendCapsuleWebhook then
                                        getgenv()._SendCapsuleWebhook("Halloween Event 1 Capsules", capsuleAmount, rewardsText, afterData)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end)
    end
end

task.spawn(function()
    task.wait(0.1)
    
    while true do
        task.wait(0.5)
        
        if not getgenv().AutoBuyCapsuleEnabled then
            task.wait(3)
            continue
        end
        
        pcall(function()
            local clientData = getClientData()
            if not clientData then return end
            
            local candyBasket = clientData.CandyBasket or 0
            
            local eventsFolder = RS:FindFirstChild("Events")
            local halloweenFolder = eventsFolder and eventsFolder:FindFirstChild("Hallowen2025")
            local purchaseEvent = halloweenFolder and halloweenFolder:FindFirstChild("PurchaseEvent")
            
            if purchaseEvent then
                if candyBasket >= 1000000 then
                    pcall(function() 
                        purchaseEvent:InvokeServer(1, 1000, "Hallowen2025_P2")
                        print("[Auto Buy Capsule 1] Purchased 1000 capsules")
                    end)
                    task.wait(0.1)
                elseif candyBasket >= 100000 then
                    pcall(function() 
                        purchaseEvent:InvokeServer(1, 100, "Hallowen2025_P2")
                        print("[Auto Buy Capsule 1] Purchased 100 capsules")
                    end)
                    task.wait(0.1)
                elseif candyBasket >= 10000 then
                    pcall(function() 
                        purchaseEvent:InvokeServer(1, 10, "Hallowen2025_P2")
                        print("[Auto Buy Capsule 1] Purchased 10 capsules")
                    end)
                    task.wait(0.1)
                elseif candyBasket >= 1000 then
                    pcall(function() 
                        purchaseEvent:InvokeServer(1, 1, "Hallowen2025_P2")
                        print("[Auto Buy Capsule 1] Purchased 1 capsule")
                    end)
                    task.wait(0.1)
                end
            end
        end)
    end
end)

task.spawn(function()
    while true do
        task.wait(2)
        
        if not getgenv().AutoEvent2Enabled then
            task.wait(2)
            continue
        end
        
        pcall(function()
            local eventsFolder = RS:FindFirstChild("Events")
            local halloweenFolder = eventsFolder and eventsFolder:FindFirstChild("Hallowen2025")
            local enterEvent = halloweenFolder and halloweenFolder:FindFirstChild("Enter")
            local startEvent = halloweenFolder and halloweenFolder:FindFirstChild("Start")
            
            if enterEvent and startEvent then
                if getgenv().WaitForPlayerEnabled then
                    local entryUI = nil
                    for _, gui in ipairs(LocalPlayer.PlayerGui:GetChildren()) do
                        if gui.Name:find("Entry") then
                            entryUI = gui
                            break
                        end
                    end
                    
                    if entryUI then
                        local function findTextLabel(parent)
                            for _, child in ipairs(parent:GetDescendants()) do
                                if child:IsA("TextLabel") and child.Text:find("Players") then
                                    return child
                                end
                            end
                            return nil
                        end
                        
                        local textLabel = findTextLabel(entryUI)
                        if textLabel then
                            local waitStartTime = tick()
                            local maxWaitTime = 300
                            
                            while tick() - waitStartTime < maxWaitTime do
                                local text = textLabel.Text
                                local current, max = text:match("%((%d+)/(%d+)%)")
                                
                                if current and max then
                                    local currentPlayers = tonumber(current)
                                    local targetCount = getgenv().WaitForPlayerCount or 1
                                    
                                    if currentPlayers >= targetCount then
                                        print("[Auto Event2] ✅ " .. currentPlayers .. "/" .. targetCount .. " players ready, joining...")
                                        break
                                    else
                                        print("[Auto Event2] ⏳ Waiting for players... " .. currentPlayers .. "/" .. targetCount)
                                    end
                                end
                                
                                task.wait(1)
                            end
                        end
                    end
                end
                
                enterEvent:FireServer("Hallowen2025_P2")
                
                task.wait(0.5)
                startEvent:FireServer()
                
                task.wait(5)
            end
        end)
    end
end)

task.spawn(function()
    while true do
        task.wait(0.5)
        
        if not getgenv().AutoCandyEnabled then
            task.wait(2)
            continue
        end
        
        pcall(function()
            local collectibles = workspace:FindFirstChild("Collectibles")
            if not collectibles then return end
            
            local character = LocalPlayer.Character
            if not character or not character:FindFirstChild("HumanoidRootPart") then return end
            
            local hrp = character.HumanoidRootPart
            
            for _, candy in pairs(collectibles:GetChildren()) do
                if candy.Name == "Candy" and candy:IsA("BasePart") then
                    hrp.CFrame = candy.CFrame
                    task.wait(0.1)
                end
            end
        end)
    end
end)

if isInLobby then
    task.spawn(function()
        task.wait(1)
        
        local Purchase, OpenCapsule
        pcall(function()
            Purchase = RS:WaitForChild("Events"):WaitForChild("Hallowen2025"):WaitForChild("Purchase")
            OpenCapsule = RS:WaitForChild("Remotes"):WaitForChild("OpenCapsule")
        end)
        
        if not Purchase or not OpenCapsule then
            warn("[Event 2] Capsule remotes not found")
            return
        end
    
    local function clickButton(button)
        if not button then return false end
        getgenv()._SkipRecordingNextCall = true
        local events = {"Activated", "MouseButton1Click", "MouseButton1Down", "MouseButton1Up"}
        for _, ev in ipairs(events) do
            pcall(function()
                for _, conn in ipairs(getconnections(button[ev])) do
                    conn:Fire()
                end
            end)
        end
        getgenv()._SkipRecordingNextCall = false
        return true
    end
    
    local function clickAllPromptButtons()
        local success = false
        pcall(function()
            local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
            if not prompt then return end
            
            local frame = prompt:FindFirstChild("Frame")
            if not frame then return end
            
            local textButton = frame:FindFirstChild("TextButton")
            if textButton then
                clickButton(textButton)
                success = true
            end
            
            local folder = frame:FindFirstChild("Folder")
            if folder then
                local folderButton = folder:FindFirstChild("TextButton")
                if folderButton then
                    clickButton(folderButton)
                    success = true
                end
            end
        end)
        return success
    end
    
    while true do
        task.wait(0.1)
        
        if not getgenv().Capsule2Enabled then
            task.wait(3)
            continue
        end
        
        pcall(function()
            local clientData = getClientData()
            if not clientData then return end
            
            local halloweenCookies = clientData.HalloweenCookies or 0
            
            if halloweenCookies >= 750000 then
                Purchase:InvokeServer(1, 1000, "Hallowen2025_P2")
            elseif halloweenCookies >= 75000 then
                Purchase:InvokeServer(1, 100, "Hallowen2025_P2")
            elseif halloweenCookies >= 7500 then
                Purchase:InvokeServer(1, 10, "Hallowen2025_P2")
            elseif halloweenCookies >= 750 then
                Purchase:InvokeServer(1, 1, "Hallowen2025_P2")
            end
            
            if halloweenCookies < 1000 then
                ClientDataCache.module = nil
                ClientDataCache.lastUpdate = 0
                clientData = getClientData()
                local capsuleAmount = 0
                if clientData and clientData.ItemData and clientData.ItemData.HalloweenCapsule2025_P2 then
                    capsuleAmount = clientData.ItemData.HalloweenCapsule2025_P2.Amount or 0
                end
                
                if capsuleAmount > 0 then
                    local beforeData = {}
                    if clientData.UnitData then
                        beforeData.UnitData = {}
                        for k, v in pairs(clientData.UnitData) do
                            beforeData.UnitData[k] = v
                        end
                    end
                    if clientData.ItemData then
                        beforeData.ItemData = {}
                        for k, v in pairs(clientData.ItemData) do
                            beforeData.ItemData[k] = {Amount = v.Amount or 0}
                        end
                    end
                    
                    OpenCapsule:FireServer("HalloweenCapsule2025_P2", capsuleAmount)
                    print("[Auto Capsule Event 2] Opened " .. capsuleAmount .. " capsules")
                    task.wait(0.5)
                    clickAllPromptButtons()
                    
                    local waitTime = math.min(3 + (capsuleAmount / 10000), 10)
                    task.wait(waitTime)
                    
                    local afterData = nil
                    local attempts = 0
                    local maxAttempts = 5
                    
                    while attempts < maxAttempts do
                        ClientDataCache.module = nil
                        ClientDataCache.lastUpdate = 0
                        afterData = getClientData()
                        
                        if afterData and afterData.ItemData then
                            local currentCapsules = (afterData.ItemData.HalloweenCapsule2025_P2 and afterData.ItemData.HalloweenCapsule2025_P2.Amount) or 0
                            local beforeCapsules = (beforeData.ItemData and beforeData.ItemData.HalloweenCapsule2025_P2 and beforeData.ItemData.HalloweenCapsule2025_P2.Amount) or 0
                            
                            if currentCapsules ~= beforeCapsules or attempts >= 3 then
                                break
                            end
                        end
                        
                        attempts = attempts + 1
                        task.wait(1)
                    end
                    
                    if afterData and getgenv()._CompareCapsuleRewards then
                        local rewardsText = getgenv()._CompareCapsuleRewards(beforeData, afterData)
                        print("[Auto Capsule Event 2] Rewards:\n" .. rewardsText)
                        
                        if getgenv()._SendCapsuleWebhook then
                            getgenv()._SendCapsuleWebhook("Halloween Event 2 Capsules", capsuleAmount, rewardsText, afterData)
                        end
                    end
                end
            end
        end)
    end
    end)
end

task.spawn(function()
    task.wait(1)
    local Purchase = RS:WaitForChild("Events"):WaitForChild("Hallowen2025"):WaitForChild("Purchase")
    
    while true do
        task.wait(0.5)
        
        if not getgenv().AutoBuyCapsule2Enabled then
            task.wait(3)
            continue
        end
        
        pcall(function()
            local clientData = getClientData()
            if not clientData then return end
            
            local halloweenCookies = clientData.HalloweenCookies or 0
            
            if halloweenCookies >= 750000 then
                Purchase:InvokeServer(1, 1000, "Hallowen2025_P2")
                print("[Auto Buy Capsule 2] Purchased 1000 capsules")
                task.wait(1)
            elseif halloweenCookies >= 75000 then
                Purchase:InvokeServer(1, 100, "Hallowen2025_P2")
                print("[Auto Buy Capsule 2] Purchased 100 capsules")
                task.wait(1)
            elseif halloweenCookies >= 7500 then
                Purchase:InvokeServer(1, 10, "Hallowen2025_P2")
                print("[Auto Buy Capsule 2] Purchased 10 capsules")
                task.wait(1)
            elseif halloweenCookies >= 750 then
                Purchase:InvokeServer(1, 1, "Hallowen2025_P2")
                print("[Auto Buy Capsule 2] Purchased 1 capsule")
                task.wait(1)
            end
        end)
    end
end)

do
    if isInLobby then
        task.spawn(function()
        
        local function getAvailableBreaches()
            local ok, breaches = pcall(function()
                local lobby = workspace:FindFirstChild("Lobby")
                if not lobby then return {} end
                local breachesFolder = lobby:FindFirstChild("Breaches")
                if not breachesFolder then return {} end
                local available = {}
                local children = breachesFolder:GetChildren()
                for i = 1, #children do
                    local part = children[i]
                    local breachPart = part:FindFirstChild("Breach")
                    if breachPart then
                        local proximityPrompt = breachPart:FindFirstChild("ProximityPrompt")
                        if proximityPrompt and proximityPrompt:IsA("ProximityPrompt") then
                            if proximityPrompt.ObjectText and proximityPrompt.ObjectText ~= "" then
                                local breachName = proximityPrompt.ObjectText
                                available[#available + 1] = { name = breachName, instance = part }
                            end
                        end
                    end
                end
                return available
            end)
            if not ok then return {} end
            return breaches or {}
        end
        
        while true do
            task.wait(1)
            if getgenv().BreachEnabled then
                local availableBreaches = getAvailableBreaches()
                for _, breach in ipairs(availableBreaches) do
                    local shouldJoin = getgenv().BreachAutoJoin[breach.name]
                    if shouldJoin then
                        pcall(function()
                            local remote = RS.Remotes.Breach.EnterEvent
                            remote:FireServer(breach.instance)
                        end)
                        task.wait(0.5)
                    end
                end
            end
        end
        end)
    end
end



do
    task.spawn(function()
        
        local VIM = game:GetService("VirtualInputManager")
        local TweenService = game:GetService("TweenService")
    
    local function teleportToShrine()
        local ok, err = pcall(function()
            local shrine = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Shrine")
            if not shrine then return false end
            
            local model = shrine:FindFirstChild("Model")
            if not model then return false end
            
            local proximityPrompt = model:FindFirstChild("ProximityPrompt")
            if not proximityPrompt then return false end
            
            local character = LocalPlayer.Character
            if not character then return false end
            
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if not humanoidRootPart then return false end
            
            local shrinePosition = model:GetPivot().Position
            humanoidRootPart.CFrame = CFrame.new(shrinePosition + Vector3.new(0, 3, 0))
            
            task.wait(0.3)
            
            VIM:SendKeyEvent(true, Enum.KeyCode.E, false, game)
            task.wait(0.05)
            VIM:SendKeyEvent(false, Enum.KeyCode.E, false, game)
            
            return true
        end)
        
        return ok
    end
    
    local lastAttempt = 0
    
    while true do
        task.wait(1)
        
        if getgenv().AutoUnleashSukunaEnabled then
            local now = tick()
            
            if (now - lastAttempt) >= 5 then
                lastAttempt = now
                
                pcall(function()
                    local shrine = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Shrine")
                    if shrine then
                        local model = shrine:FindFirstChild("Model")
                        if model then
                            local proximityPrompt = model:FindFirstChild("ProximityPrompt")
                            if proximityPrompt then
                                teleportToShrine()
                            end
                        end
                    end
                end)
            end
        end
    end
    end)
end



do
    task.spawn(function()
        local VIM = game:GetService("VirtualInputManager")
    
    local function getAvailableCards()
        local ok, result = pcall(function()
            local playerGui = LocalPlayer.PlayerGui
            local prompt = playerGui:FindFirstChild("Prompt")
            if not prompt then return nil end
            local frame = prompt:FindFirstChild("Frame")
            if not frame or not frame:FindFirstChild("Frame") then return nil end
            
            local frameChildren = frame:FindFirstChild("Frame"):GetChildren()
            if #frameChildren < 4 then return nil end
            
            local fourthFrame = frameChildren[4]
            local cardButtons = fourthFrame:GetChildren()
            
            local cards = {}
            for i = 1, math.min(4, #cardButtons) do
                local cardButton = cardButtons[i]
                if cardButton and cardButton:IsA("TextButton") then
                    local frameChild = cardButton:FindFirstChild("Frame")
                    if frameChild then
                        local textLabel = frameChild:FindFirstChild("TextLabel")
                        if textLabel and textLabel.Text and textLabel.Text ~= "" then
                            local cardName = textLabel.Text
                            table.insert(cards, { name = cardName, button = cardButton })
                        end
                    end
                end
            end
            
            return #cards > 0 and cards or nil
        end)
        
        return ok and result or nil
    end
    
    local function findBestCard(list)
        local bestIndex, bestPriority = nil, math.huge
        
        local blacklistedCards = {
            ["Devil's Sacrifice"] = true,
            ["Sacrifice"] = true,
        }
        
        local isBossRush = false
        local isSlimeRush = false
        
        pcall(function()
            local gamemode = RS:FindFirstChild("Gamemode")
            if gamemode then
                if gamemode.Value == "BossRush" then
                    isBossRush = true
                elseif gamemode.Value == "SlimeRush" then
                    isSlimeRush = true
                end
            end
        end)
        
        local priorityTable
        if isBossRush then
            priorityTable = getgenv().BossRushCardPriority
        elseif isSlimeRush then
            priorityTable = getgenv().SlimeRushCardPriority
        else
            priorityTable = getgenv().CardPriority
        end
        
        for i=1,#list do
            local nm = list[i].name
            
            if not blacklistedCards[nm] then
                local p = (priorityTable and priorityTable[nm]) or 999
                if p < bestPriority and p < 999 then
                    bestPriority = p
                    bestIndex = i
                end
            end
        end
        if bestIndex then
            return bestIndex, list[bestIndex], bestPriority
        end
        return nil, nil, nil
    end
    
    local function pressConfirm()
        local confirmButton = nil
        
        pcall(function()
            local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
            if not prompt then return end
            local frame = prompt:FindFirstChild("Frame")
            if not frame then return end
            local inner = frame:FindFirstChild("Frame")
            if not inner then return end
            local children = inner:GetChildren()
            if #children < 5 then return end
            local button = children[5]:FindFirstChild("TextButton")
            if not button then return end
            local label = button:FindFirstChild("TextLabel")
            if label and label.Text == "Confirm" then 
                confirmButton = button 
            end
        end)
        
        if not confirmButton then
            return false
        end
        
        local anySuccess = false
        
        pcall(function()
            local GuiService = game:GetService("GuiService")
            GuiService.SelectedObject = nil
            task.wait(0.05)
            
            GuiService.SelectedObject = confirmButton
            
            local lockConnection
            lockConnection = RunService.Heartbeat:Connect(function()
                pcall(function()
                    if confirmButton and confirmButton.Parent and GuiService.SelectedObject ~= confirmButton then
                        GuiService.SelectedObject = confirmButton
                    end
                end)
            end)
            
            task.wait(0.25)
            
            if GuiService.SelectedObject == confirmButton then
                VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                task.wait(0.05)
                VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                anySuccess = true
            end
            
            if lockConnection then
                lockConnection:Disconnect()
            end
            
            GuiService.SelectedObject = nil
        end)
        
        task.wait(0.1)
        
        pcall(function()
            if getconnections then
                local events = {"Activated", "MouseButton1Click", "MouseButton1Down", "MouseButton1Up"}
                for _, ev in ipairs(events) do
                    pcall(function()
                        local connections = getconnections(confirmButton[ev])
                        if connections then
                            for _, conn in ipairs(connections) do
                                if conn and conn.Fire then
                                    conn:Fire()
                                    anySuccess = true
                                end
                            end
                        end
                    end)
                end
            end
        end)
        
        task.wait(0.1)
        
        pcall(function()
            local VirtualInputManager = game:GetService("VirtualInputManager")
            local absPos = confirmButton.AbsolutePosition
            local absSize = confirmButton.AbsoluteSize
            if absPos and absSize then
                local centerX = absPos.X + (absSize.X / 2)
                local centerY = absPos.Y + (absSize.Y / 2)
                
                VirtualInputManager:SendMouseMoveEvent(centerX, centerY, game)
                task.wait(0.1)
                VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, true, game, 0)
                task.wait(0.05)
                VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, false, game, 0)
                anySuccess = true
            end
        end)
        
        return anySuccess
    end
    
    local function selectCard()
        local isBossRush = false
        local isSlimeRush = false
        
        pcall(function()
            local gamemode = RS:FindFirstChild("Gamemode")
            if gamemode then
                if gamemode.Value == "BossRush" then
                    isBossRush = true
                elseif gamemode.Value == "SlimeRush" then
                    isSlimeRush = true
                end
            end
        end)
        
        if isBossRush then
            if not getgenv().BossRushEnabled then return false end
        elseif isSlimeRush then
            if not getgenv().SlimeRushCardSelectionEnabled then return false end
        else
            if not getgenv().CardSelectionEnabled then return false end
        end
        
        local ok = pcall(function()
            local list = getAvailableCards()
            if not list then return false end
            
            local _, best, priority = findBestCard(list)
            if not best or not best.button or not priority then return false end
            if priority >= 999 then return false end
            
            local button = best.button
            local GuiService = game:GetService("GuiService")
            
            if not button:IsDescendantOf(LocalPlayer.PlayerGui) then
                return false
            end
            
            GuiService.SelectedObject = nil
            task.wait(0.15)
            
            GuiService.SelectedObject = button
            
            local lockConnection
            lockConnection = RunService.Heartbeat:Connect(function()
                pcall(function()
                    if button and button.Parent and GuiService.SelectedObject ~= button then
                        GuiService.SelectedObject = button
                    end
                end)
            end)
            
            task.wait(0.35)
            
            local cardSelected = false
            if GuiService.SelectedObject == button then
                VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                task.wait(0.05)
                VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                cardSelected = true
                
                if lockConnection then
                    lockConnection:Disconnect()
                end
                
                GuiService.SelectedObject = nil
            else
                if lockConnection then
                    lockConnection:Disconnect()
                end
                return false
            end
            
            task.wait(0.3)
            
            pressConfirm()
            task.wait(0.2)
        end)
        
        return ok
    end
    
    local function selectCardSlower()
        local isSlimeRush = false
        pcall(function()
            local gamemode = RS:FindFirstChild("Gamemode")
            if gamemode and gamemode.Value == "SlimeRush" then
                isSlimeRush = true
            end
        end)
        
        if isSlimeRush then
            if not getgenv().SlimeRushSlowerCardSelectionEnabled then return false end
        else
            if not getgenv().SlowerCardSelectionEnabled then return false end
        end
        
        local ok, result = pcall(function()
            local currentSignature = getPromptSignature()
            if not currentSignature then
                return false
            end
            
            if getgenv().SlowerCardLastPromptId == currentSignature then
                return false
            end
            
            local currentWave = 0
            pcall(function()
                local wave = RS:FindFirstChild("Wave")
                if wave and wave.Value then
                    currentWave = wave.Value
                end
            end)
            
            local list = getAvailableCards()
            if not list or #list == 0 then 
                return false 
            end
            
            local bestCard = nil
            local bestValue = -999999
            
            local alreadyPicked = {}
            for _, pickedName in ipairs(getgenv().SlowerCardPicked or {}) do
                alreadyPicked[pickedName] = true
            end
            
            for i=1,#list do
                local nm = list[i].name
                
                if not alreadyPicked[nm] then
                    local value
                    if isSlimeRush then
                        value = calculateSlimeRushCardValue(nm, currentWave)
                    else
                        value = calculateCardValue(nm, currentWave)
                    end
                    
                    if value > bestValue then
                        bestValue = value
                        bestCard = list[i]
                    end
                end
            end
            
            if not bestCard or bestValue <= 0 or not bestCard.button then
                return false
            end
            
            local GuiService = game:GetService("GuiService")
            
            GuiService.SelectedObject = nil
            task.wait(0.25)
            
            GuiService.SelectedObject = bestCard.button
            
            local lockConnection
            lockConnection = RunService.Heartbeat:Connect(function()
                pcall(function()
                    if bestCard.button and bestCard.button.Parent and GuiService.SelectedObject ~= bestCard.button then
                        GuiService.SelectedObject = bestCard.button
                    end
                end)
            end)
            
            task.wait(0.6)
            
            local cardSelected = false
            if GuiService.SelectedObject == bestCard.button then
                VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                task.wait(0.05)
                VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                cardSelected = true
                
                if lockConnection then
                    lockConnection:Disconnect()
                end
                
                GuiService.SelectedObject = nil
            else
                if lockConnection then
                    lockConnection:Disconnect()
                end
                return false
            end
            
            getgenv().SlowerCardLastPromptId = currentSignature
            
            task.wait(0.6)
            
            local confirmButton = nil
            pcall(function()
                local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                if prompt and prompt:FindFirstChild("Frame") and prompt.Frame:FindFirstChild("Frame") then
                    local inner = prompt.Frame.Frame
                    local children = inner:GetChildren()
                    if #children >= 5 then
                        local btn = children[5]:FindFirstChild("TextButton")
                        if btn and btn:FindFirstChild("TextLabel") and btn.TextLabel.Text == "Confirm" then
                            confirmButton = btn
                        end
                    end
                end
            end)
            
            if confirmButton then
                GuiService.SelectedObject = nil
                task.wait(0.15)
                
                GuiService.SelectedObject = confirmButton
                
                local confirmLock
                confirmLock = RunService.Heartbeat:Connect(function()
                    pcall(function()
                        if confirmButton and confirmButton.Parent and GuiService.SelectedObject ~= confirmButton then
                            GuiService.SelectedObject = confirmButton
                        end
                    end)
                end)
                
                task.wait(0.4)
                
                if GuiService.SelectedObject == confirmButton then
                    VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                    task.wait(0.05)
                    VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                    
                    if confirmLock then
                        confirmLock:Disconnect()
                    end
                    
                    GuiService.SelectedObject = nil
                else
                    if confirmLock then
                        confirmLock:Disconnect()
                    end
                end
            end
            
            task.wait(0.5)
            
            local waitTime = 0
            while waitTime < 3 do
                local promptStillOpen = false
                pcall(function()
                    local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                    promptStillOpen = prompt and prompt.Enabled
                end)
                
                if not promptStillOpen then
                    break
                end
                
                task.wait(0.1)
                waitTime = waitTime + 0.1
            end
            
            if not getgenv().SlowerCardPicked then
                getgenv().SlowerCardPicked = {}
            end
            table.insert(getgenv().SlowerCardPicked, bestCard.name)
            
            return true
        end)
        
        if not ok then
            warn("[Slower Card] ❌ Error:", result)
        end
        
        return ok and result
    end
    
    if not getgenv().SmartCardPicked then
        getgenv().SmartCardPicked = {}
    end
    
    if not getgenv().SmartCardLastPromptId then
        getgenv().SmartCardLastPromptId = nil
    end
    
    if not getgenv().SlowerCardPicked then
        getgenv().SlowerCardPicked = {}
    end
    
    if not getgenv().SlowerCardLastPromptId then
        getgenv().SlowerCardLastPromptId = nil
    end
    
    local function getPromptSignature()
        local ok, signature = pcall(function()
            local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
            if not prompt or not prompt.Enabled then
                return nil
            end
            
            local list = getAvailableCards()
            if not list or #list == 0 then
                return nil
            end
            
            local cardNames = {}
            for _, card in ipairs(list) do
                table.insert(cardNames, card.name)
            end
            table.sort(cardNames)
            
            return table.concat(cardNames, "|")
        end)
        return ok and signature or nil
    end
    
    local function calculateSlimeRushCardValue(cardName, currentWave)
        local blacklistedCards = {
            ["Sacrifice"] = true,
        }
        
        if blacklistedCards[cardName] then
            return -999999999
        end
        
        local cardDefinitions = {
            ["Blinded I"] = {type = "wave", coinsPerWave = 2},
            ["Blinded II"] = {type = "wave", coinsPerWave = 5},
            
            ["Intimidation I"] = {type = "kill", coinsPerKill = 2},
            ["Intimidation II"] = {type = "kill", coinsPerKill = 3},
            ["Obstruction I"] = {type = "kill", coinsPerKill = 2},
            ["Obstruction II"] = {type = "kill", coinsPerKill = 3},
            
            ["Restriction I"] = {type = "boss", coinsPerBoss = 50},
            ["Restriction II"] = {type = "boss", coinsPerBoss = 100},
            
            ["Prevention I"] = {type = "finalboss", coinsOnFinal = 250},
            ["Prevention II"] = {type = "finalboss", coinsOnFinal = 500},
            
            ["Hasty I"] = {type = "buff", value = 100},
            ["Hasty II"] = {type = "buff", value = 150},
            ["Precision I"] = {type = "buff", value = 80},
            ["Precision II"] = {type = "buff", value = 120},
            ["True Sight I"] = {type = "buff", value = 90},
            ["True Sight II"] = {type = "buff", value = 130},
            ["Momentum"] = {type = "buff", value = 110},
            ["Fiery Surge I"] = {type = "buff", value = 85},
            ["Fiery Surge II"] = {type = "buff", value = 125},
            ["Hellish Warp I"] = {type = "buff", value = 95},
            ["Hellish Warp II"] = {type = "buff", value = 140},
            ["Entrepreneur"] = {type = "buff", value = 200},
        }
        
        local cardData = cardDefinitions[cardName]
        if not cardData then
            return -999999
        end
        
        local userPriority = (getgenv().SlimeRushCardPriority and getgenv().SlimeRushCardPriority[cardName]) or 1
        if userPriority >= 999 then
            return -999999
        end
        
        local TOTAL_WAVES = 50
        local TOTAL_ENEMIES = 899
        local TOTAL_BOSSES = 4
        
        local wavesRemaining = math.max(1, TOTAL_WAVES - currentWave + 1)
        
        local currentKills = 0
        pcall(function()
            currentKills = game:GetService("Players").LocalPlayer.leaderstats.Kills.Value
        end)
        
        local enemiesRemaining = math.max(1, TOTAL_ENEMIES - currentKills)
        local bossesRemaining = math.max(0, TOTAL_BOSSES - math.floor(currentWave / 12))
        
        local totalCoinValue = 0
        
        if cardData.type == "wave" then
            totalCoinValue = cardData.coinsPerWave * wavesRemaining
        elseif cardData.type == "kill" then
            totalCoinValue = cardData.coinsPerKill * enemiesRemaining
        elseif cardData.type == "boss" then
            totalCoinValue = cardData.coinsPerBoss * bossesRemaining
        elseif cardData.type == "finalboss" then
            totalCoinValue = currentWave < 50 and cardData.coinsOnFinal or 0
        elseif cardData.type == "buff" then
            return -999999
        end
        
        local priorityMultiplier = 1000 / math.max(1, userPriority)
        totalCoinValue = totalCoinValue * priorityMultiplier
        
        return totalCoinValue
    end
    
    local function calculateCardValue(cardName, currentWave)
        local blacklistedCards = {
            ["Devil's Sacrifice"] = true, 
        }
        
        if blacklistedCards[cardName] then
            return -999999999 
        end
        
        local cardDefinitions = {
            ["Critical Denial"] = {type = "wave", candyPerWave = 100},
            ["Weakened Resolve III"] = {type = "wave", candyPerWave = 50},
            ["Fog of War III"] = {type = "wave", candyPerWave = 50},
            ["Weakened Resolve II"] = {type = "wave", candyPerWave = 25},
            ["Fog of War II"] = {type = "wave", candyPerWave = 25},
            ["Power Reversal II"] = {type = "wave", candyPerWave = 25},
            ["Greedy Vampire's"] = {type = "wave", candyPerWave = 25},
            ["Weakened Resolve I"] = {type = "wave", candyPerWave = 15},
            ["Fog of War I"] = {type = "wave", candyPerWave = 15},
            ["Power Reversal I"] = {type = "wave", candyPerWave = 15},
            
            ["Lingering Fear II"] = {type = "kill", bonusCandyPerKill = 2},
            ["Hellish Gravity"] = {type = "kill", bonusCandyPerKill = 2},
            ["Lingering Fear I"] = {type = "kill", bonusCandyPerKill = 1},
            ["Deadly Striker"] = {type = "kill", bonusCandyPerKill = 1},
            
            ["Trick or Treat Coin Flip"] = {type = "special", treatValue = 5000},
        }
        
        local cardData = cardDefinitions[cardName]
        if not cardData then
            local isCandyCard = getgenv().CandyCards and getgenv().CandyCards[cardName] ~= nil
            if not isCandyCard then
                return -999999
            end
            cardData = {type = "wave", candyPerWave = 20}
        end
        
        local userPriority = (getgenv().CardPriority and getgenv().CardPriority[cardName]) or 1
        if userPriority >= 999 then
            return -999999
        end
        
        local TOTAL_WAVES = 50
        local TOTAL_ENEMIES = 1350
        
        local wavesRemaining = math.max(1, TOTAL_WAVES - currentWave + 1)
        
        local currentKills = 0
        pcall(function()
            currentKills = game:GetService("Players").LocalPlayer.leaderstats.Kills.Value
        end)
        
        local enemiesRemaining = math.max(1, TOTAL_ENEMIES - currentKills)
        
        local totalCandyValue = 0
        
        if cardData.type == "wave" then
            totalCandyValue = cardData.candyPerWave * wavesRemaining
            
        elseif cardData.type == "kill" then
            totalCandyValue = cardData.bonusCandyPerKill * enemiesRemaining
            
        elseif cardData.type == "special" and cardName == "Trick or Treat Coin Flip" then
            if wavesRemaining >= 40 then
                totalCandyValue = 2500
            elseif wavesRemaining >= 30 then
                totalCandyValue = 2000
            elseif wavesRemaining >= 20 then
                totalCandyValue = 1500
            else
                totalCandyValue = 1000
            end
        end
        
        local priorityMultiplier = 1.0 / (1.0 + (userPriority - 1) * 0.05)
        totalCandyValue = totalCandyValue * priorityMultiplier
        
        return totalCandyValue
    end
    
    local function selectCardSmart()
        local isSlimeRush = false
        pcall(function()
            local gamemode = RS:FindFirstChild("Gamemode")
            if gamemode and gamemode.Value == "SlimeRush" then
                isSlimeRush = true
            end
        end)
        
        if isSlimeRush then
            if not getgenv().SlimeRushSmartCardSelectionEnabled then
                return false
            end
        else
            if not getgenv().SmartCardSelectionEnabled then 
                return false 
            end
        end
        
        local ok, result = pcall(function()
            local currentSignature = getPromptSignature()
            if not currentSignature then
                return false
            end
            
            if getgenv().SmartCardLastPromptId == currentSignature then
                return false
            end
            
            local currentWave = 0
            pcall(function()
                local wave = RS:FindFirstChild("Wave")
                if wave and wave.Value then
                    currentWave = wave.Value
                end
            end)
            
            local list = getAvailableCards()
            if not list or #list == 0 then 
                print("[Smart Card] ❌ No cards detected in UI")
                return false 
            end
            
            local alreadyPicked = {}
            for _, pickedName in ipairs(getgenv().SmartCardPicked) do
                alreadyPicked[pickedName] = true
            end
            
            local candyCards = {}
            local nonCandyCards = {}
            
            print("[Smart Card] Wave " .. currentWave .. " - Evaluating " .. #list .. " cards:")
            
            for i = 1, #list do
                local cardName = list[i].name
                local button = list[i].button
                
                if not alreadyPicked[cardName] then
                    local value
                    if isSlimeRush then
                        value = calculateSlimeRushCardValue(cardName, currentWave)
                    else
                        value = calculateCardValue(cardName, currentWave)
                    end
                    
                    if value > -999999 then
                        table.insert(candyCards, {
                            name = cardName,
                            button = button,
                            value = value
                        })
                        local valueLabel = isSlimeRush and " coins" or " candy"
                        print("  ✅ " .. cardName .. " = " .. math.floor(value) .. valueLabel)
                    else
                        table.insert(nonCandyCards, cardName)
                        print("  ❌ " .. cardName .. " = SKIPPED")
                    end
                end
            end
            
            table.sort(candyCards, function(a, b)
                return a.value > b.value
            end)
            
            if #candyCards == 0 then
                print("[Smart Card] ⚠️ WARNING: No valid candy cards found! Available cards:")
                for _, name in ipairs(nonCandyCards) do
                    print("    - " .. name)
                end
                return false
            end
            
            local bestCard = candyCards[1]
            print("[Smart Card] 🎯 SELECTING: " .. bestCard.name .. " (" .. math.floor(bestCard.value) .. " candy)")
            
            if not bestCard.button or not bestCard.button:IsDescendantOf(LocalPlayer.PlayerGui) then
                print("[Smart Card] ❌ Button not valid or not in PlayerGui")
                return false
            end
            
            pcall(function()
                local GuiService = game:GetService("GuiService")
                GuiService.SelectedObject = nil
                task.wait(0.1)
                GuiService.SelectedObject = bestCard.button
                task.wait(0.2)
                
                VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                task.wait(0.05)
                VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                
                print("[Smart Card] ✓ Card clicked via GuiService")
            end)
            
            task.wait(0.3)
            
            local confirmSuccess = pressConfirm()
            if confirmSuccess then
                print("[Smart Card] ✓ Confirm button pressed")
            end
            
            task.wait(0.2)
            
            getgenv().SmartCardLastPromptId = currentSignature
            
            table.insert(getgenv().SmartCardPicked, bestCard.name)
            print("[Smart Card] 📝 Picked: " .. bestCard.name .. " (Total picked: " .. #getgenv().SmartCardPicked .. "/5)")
            
            return true
        end)
        
        if not ok then
            warn("[Smart Card] ⚠️ Error:", result)
        end
        
        return ok and result
    end
    
    while true do
        task.wait(1)
        
        local promptVisible = false
        pcall(function()
            local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
            if prompt and prompt.Enabled then
                promptVisible = true
            end
        end)
        
        if not promptVisible then
            task.wait(0.3)
            continue
        end
        
        local gamemodeValue = "Unknown"
        pcall(function()
            local gamemode = RS:FindFirstChild("Gamemode")
            if gamemode then
                gamemodeValue = tostring(gamemode.Value)
            end
        end)
        
        print("[Card Selection] Gamemode detected:", gamemodeValue)
        
        local isBossRush = gamemodeValue == "BossRush"
        local isSlimeRush = gamemodeValue:find("Slime") or gamemodeValue == "SlimeRush"
        local isMidnightHunt = gamemodeValue == "MidnightHunt"
        local isInfinite = gamemodeValue == "Infinite"
        
        if isBossRush and getgenv().BossRushEnabled then
            selectCard()
        elseif isSlimeRush then
            print("[Card Selection] Slime Rush detected, checking toggles...")
            print("[Card Selection] SlimeRushEnabled:", getgenv().SlimeRushEnabled)
            print("[Card Selection] Fast:", getgenv().SlimeRushCardSelectionEnabled)
            print("[Card Selection] Slower:", getgenv().SlimeRushSlowerCardSelectionEnabled)
            print("[Card Selection] Smart:", getgenv().SlimeRushSmartCardSelectionEnabled)
            
            if getgenv().SlimeRushEnabled then
                if getgenv().SlimeRushCardSelectionEnabled then
                    print("[Card Selection] Using Fast Mode")
                    selectCard()
                elseif getgenv().SlimeRushSlowerCardSelectionEnabled then
                    print("[Card Selection] Using Slower Mode")
                    selectCardSlower()
                elseif getgenv().SlimeRushSmartCardSelectionEnabled then
                    print("[Card Selection] Using Smart Mode")
                    selectCardSmart()
                end
            end
        elseif isMidnightHunt or isInfinite then
            if getgenv().CardSelectionEnabled then
                print("[Card Selection] Using Fast Mode for " .. gamemodeValue)
                selectCard()
            elseif getgenv().SlowerCardSelectionEnabled then
                print("[Card Selection] Using Slower Mode for " .. gamemodeValue)
                selectCardSlower()
            elseif getgenv().SmartCardSelectionEnabled then
                print("[Card Selection] Using Smart Mode for " .. gamemodeValue)
                selectCardSmart()
            end
        end
    end
    end)
end



getgenv().SeamlessRestartManager = getgenv().SeamlessRestartManager or {
    endgameCount = 0,
    maxRounds = 4,
    lastEndgameTime = 0,
    debounceTime = 5,
    isRestarting = false,
    restartStartTime = 0,
    restartTimeout = 45,
    lastRestartTimes = {}
}

getgenv()._SeamlessRestartManager_cleanupBeforeRestart = function()
    local manager = getgenv().SeamlessRestartManager
    
    warn("[SeamlessRestartManager] Starting cleanup before restart...")
    
    getgenv()._DiagnosticsLogger_logMemoryUsage("before_restart_cleanup")
    
    local cleanupCount = 0
    
    if ConnectionManager then
        local disconnected = ConnectionManager:disconnectGroup("SeamlessRetry")
        cleanupCount = cleanupCount + disconnected
        warn(string.format("[SeamlessRestartManager] Disconnected %d connections from SeamlessRetry group", disconnected))
    end
    
    if getgenv().MacroPlaybackActive then
        getgenv().MacroPlaybackActive = false
        cleanupCount = cleanupCount + 1
        warn("[SeamlessRestartManager] Stopped macro playback")
    end
    
    getgenv().MacroCurrentStep = 1
    getgenv().MacroActionText = ""
    getgenv().MacroUnitText = ""
    getgenv().MacroWaitingText = ""
    getgenv().MacroStatusText = "Ready for restart"
    warn("[SeamlessRestartManager] Reset macro state to step 1")
    
    pcall(function()
        collectgarbage("collect")
        warn("[SeamlessRestartManager] Triggered memory cleanup")
    end)
    
    task.wait(1)
    
    getgenv()._DiagnosticsLogger_logMemoryUsage("after_restart_cleanup")
    
    
    return cleanupCount
end

getgenv()._SeamlessRestartManager_resetState = function()
    local manager = getgenv().SeamlessRestartManager
    
    manager.isRestarting = false
    manager.restartStartTime = 0
    getgenv()._SeamlessRestartDetected = false
    
    warn("[SeamlessRestartManager] State reset complete")
end

getgenv()._SeamlessRestartManager_enableSeamless = function()
    local success = false
    
    pcall(function()
        local remotes = RS:FindFirstChild("Remotes")
        local setSettings = remotes and remotes:FindFirstChild("SetSettings")
        if setSettings then 
            setSettings:InvokeServer("SeamlessRetry")
            success = true
        end
    end)
    
    task.wait(1)
    
    return success
end

getgenv()._SeamlessRestartManager_disableSeamless = function()
    local success = false
    
    pcall(function()
        local remotes = RS:FindFirstChild("Remotes")
        local setSettings = remotes and remotes:FindFirstChild("SetSettings")
        if setSettings then 
            setSettings:InvokeServer("SeamlessRetry")
            success = true
        end
    end)
    
    task.wait(1)
    
    return success
end

getgenv()._SeamlessRestartManager_initiateRestart = function()
    local manager = getgenv().SeamlessRestartManager
    
    if manager.isRestarting then
        warn("[SeamlessRestartManager] Restart already in progress")
        return false
    end
    
    manager.isRestarting = true
    manager.restartStartTime = tick()
    
    warn("[SeamlessRestartManager] Initiating restart...")
    
    getgenv()._SeamlessRestartManager_cleanupBeforeRestart()
    
    getgenv()._LoadingScreenMonitor_startMonitoring()
    
    local success = false
    pcall(function()
        local remotes = RS:FindFirstChild("Remotes")
        local restartEvent = remotes and remotes:FindFirstChild("RestartMatch")
        if restartEvent then
            restartEvent:FireServer()
            success = true
            warn("[SeamlessRestartManager] RestartMatch fired")
        else
            warn("[SeamlessRestartManager] RestartMatch remote not found")
        end
    end)
    
    task.wait(5)
    
    return success
end

getgenv()._SeamlessRestartManager_waitForRestartComplete = function(timeout)
    local manager = getgenv().SeamlessRestartManager
    timeout = timeout or manager.restartTimeout
    
    local startTime = tick()
    
    warn(string.format("[SeamlessRestartManager] Waiting for restart to complete (timeout: %.1fs)", timeout))
    
    while (tick() - startTime) < timeout do
        local isFrozen, freezeDuration = getgenv()._LoadingScreenMonitor_checkForFreeze()
        
        if isFrozen then
            warn(string.format("[SeamlessRestartManager] Loading screen freeze detected during restart (%.1fs)", freezeDuration))
            getgenv()._LoadingScreenMonitor_stopMonitoring()
            
            local recoverySuccess = getgenv()._RestartRecovery_attemptRecovery("restart_timeout")
            
            if recoverySuccess then
                getgenv()._SeamlessRestartManager_resetState()
                return true, "recovered"
            else
                getgenv()._SeamlessRestartManager_resetState()
                return false, "recovery_failed"
            end
        end
        
        local allPassed = getgenv()._StateVerification_performFullVerification()
        
        if allPassed then
            local timeTaken = tick() - startTime
            warn(string.format("[SeamlessRestartManager] Restart completed successfully (%.2fs)", timeTaken))
            
            getgenv()._DiagnosticsLogger_logMemoryUsage("after_restart_complete")
            
            getgenv()._LoadingScreenMonitor_stopMonitoring()
            getgenv()._SeamlessRestartManager_resetState()
            
            task.wait(2)
            
            return true, "success"
        end
        
        task.wait(1)
    end
    
    local timeTaken = tick() - startTime
    warn(string.format("[SeamlessRestartManager] Restart timed out after %.2fs", timeTaken))
    
    getgenv()._LoadingScreenMonitor_stopMonitoring()
    
    local recoverySuccess = getgenv()._RestartRecovery_attemptRecovery("restart_timeout")
    
    if recoverySuccess then
        getgenv()._SeamlessRestartManager_resetState()
        return true, "recovered"
    else
        getgenv()._SeamlessRestartManager_resetState()
        return false, "timeout"
    end
end

getgenv()._SeamlessRestartManager_trackRestartTime = function()
    local manager = getgenv().SeamlessRestartManager
    local currentTime = tick()
    
    table.insert(manager.lastRestartTimes, currentTime)
    
    if #manager.lastRestartTimes > 10 then
        table.remove(manager.lastRestartTimes, 1)
    end
    
    if #manager.lastRestartTimes >= 2 then
        local totalTime = 0
        for i = 2, #manager.lastRestartTimes do
            totalTime = totalTime + (manager.lastRestartTimes[i] - manager.lastRestartTimes[i-1])
        end
        local avgTime = totalTime / (#manager.lastRestartTimes - 1)
        
        warn(string.format("[SeamlessRestartManager] Average time between restarts: %.1fs", avgTime))
    end
end

if not isInLobby then
    task.spawn(function()
        local manager = getgenv().SeamlessRestartManager
        manager.endgameCount = 0
        getgenv()._SeamlessEndgameCount = manager.endgameCount 
        local maxRoundsReached = false
        local hasRun = false
        local lastEndgameTime = 0
        local DEBOUNCE_TIME = 5
        local lastEndGameUIState = false
        local newGameStartDetected = false

        local maxWait = 0
        local settingsFound = false
        repeat 
            task.wait(0.5) 
            maxWait = maxWait + 0.5 
            local settings = LocalPlayer.PlayerGui:FindFirstChild("Settings")
            if settings and settings:FindFirstChild("SeamlessRetry") then
                settingsFound = true
                break
            end
        until maxWait > 10
        
        if not settingsFound then
            warn("[SeamlessRestartManager] Settings.SeamlessRetry not found after 10s, using fallback detection")
        end
        
        local function getSeamlessValue()
            local ok, result = pcall(function()
                local settings = LocalPlayer.PlayerGui:FindFirstChild("Settings")
                if settings then
                    local seamless = settings:FindFirstChild("SeamlessRetry")
                    if seamless then 
                        return seamless.Value 
                    end
                end
                return false
            end)
            return ok and result or false
        end
        
        local function setSeamlessRetry()
            task.spawn(function()
                pcall(function()
                    local remotes = RS:FindFirstChild("Remotes")
                    local setSettings = remotes and remotes:FindFirstChild("SetSettings")
                    if setSettings then 
                        setSettings:InvokeServer("SeamlessRetry")
                    end
                end)
            end)
        end
        
        local lastSeamlessState = nil
        local lastEndgameCount = 0
        
        local function enableSeamlessIfNeeded()
            if not getgenv().SeamlessFixEnabled then return end
            local maxRounds = getgenv().SeamlessRounds or 4
            manager.maxRounds = maxRounds
            
            if getgenv()._SeamlessEndgameCount then
                manager.endgameCount = getgenv()._SeamlessEndgameCount
            end
            
            local currentSeamlessValue = getSeamlessValue()
            
            if manager.endgameCount < maxRounds then
                if not currentSeamlessValue and (lastSeamlessState ~= false or lastEndgameCount ~= manager.endgameCount) then
                    warn(string.format("[SeamlessRestartManager] Enabling seamless retry (%d/%d)", manager.endgameCount, maxRounds))
                    getgenv()._SeamlessRestartManager_enableSeamless()
                    lastSeamlessState = false
                    lastEndgameCount = manager.endgameCount
                end
            elseif manager.endgameCount >= maxRounds then
                if currentSeamlessValue and (lastSeamlessState ~= true or lastEndgameCount ~= manager.endgameCount) then
                    warn(string.format("[SeamlessRestartManager] Disabling seamless retry - Max rounds reached (%d/%d)", manager.endgameCount, maxRounds))
                    getgenv()._SeamlessRestartManager_disableSeamless()
                    lastSeamlessState = true
                    lastEndgameCount = manager.endgameCount
                end
            end
        end
        
        enableSeamlessIfNeeded()
        
        local seamlessToggleConnection
        seamlessToggleConnection = task.spawn(function()
            while true do
                task.wait(1)
                if getgenv().SeamlessFixEnabled then
                    enableSeamlessIfNeeded()
                end
            end
        end)
        
        local lastGameStartedState = true
        getgenv()._SeamlessRestartDetected = false
        
        task.spawn(function()
            while true do
                task.wait(0.3) 
                
                if not getgenv().SeamlessFixEnabled then
                    task.wait(2)
                    continue
                end
                
                pcall(function()
                    local gameStarted = true
                    pcall(function()
                        local gs = RS:FindFirstChild("GameStarted")
                        if gs and gs.Value ~= nil then
                            gameStarted = gs.Value
                        end
                    end)
                    
                    if lastGameStartedState and not gameStarted then
                        local currentTime = tick()
                        if currentTime - lastEndgameTime >= DEBOUNCE_TIME then
                            
                            if not hasRun then
                                hasRun = true
                                lastEndgameTime = currentTime
                                manager.endgameCount = manager.endgameCount + 1
                                getgenv()._SeamlessEndgameCount = manager.endgameCount
                                getgenv()._SeamlessRestartDetected = true
                                
                                local maxRounds = getgenv().SeamlessRounds or 4
                                
                                getgenv()._DiagnosticsLogger_logSeamlessRestart(manager.endgameCount, maxRounds, "GameStarted")
                                
                                getgenv()._SeamlessRestartManager_trackRestartTime()
                                
                                warn(string.format("[SeamlessRestartManager] Restart counted: %d/%d", manager.endgameCount, maxRounds))
                                
                                task.spawn(function()
                                    task.wait(3)
                                    pcall(function()
                                        local elapsed = RS:FindFirstChild("ElapsedTime")
                                        if elapsed and elapsed.Value then
                                            getgenv()._RoundStartTime = elapsed.Value
                                        end
                                    end)
                                end)
                                
                                task.wait(2)
                                enableSeamlessIfNeeded()
                                
                                task.spawn(function()
                                    task.wait(5)
                                    hasRun = false
                                    getgenv()._SeamlessRestartDetected = false
                                end)
                            end
                        end
                    end
                    
                    lastGameStartedState = gameStarted
                    
                    local endGameUI = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
                    local currentEndGameUIState = endGameUI and endGameUI.Enabled or false
                    
                    if lastEndGameUIState and not currentEndGameUIState then
                        newGameStartDetected = true
                        hasRun = false
                        
                        if getgenv().SeamlessFixEnabled and manager.endgameCount < (getgenv().SeamlessRounds or 4) then
                            task.spawn(function()
                                task.wait(3)
                                pcall(function()
                                    local elapsed = RS:FindFirstChild("ElapsedTime")
                                    if elapsed and elapsed.Value then
                                        getgenv()._RoundStartTime = elapsed.Value
                                    end
                                end)
                            end)
                            
                            task.wait(2)
                            enableSeamlessIfNeeded()
                        end
                    end
                    
                    lastEndGameUIState = currentEndGameUIState
                end)
            end
        end)
        
        ConnectionManager:trackGroup("SeamlessRetry",
            LocalPlayer.PlayerGui.ChildAdded:Connect(function(child)
                pcall(function()
                    if child.Name == "EndGameUI" then
                        task.wait(3)
                        
                        local currentTime = tick()
                        if currentTime - lastEndgameTime < DEBOUNCE_TIME then
                            return
                        end
                        
                        if hasRun then
                            return
                        end
                        
                        hasRun = true
                        lastEndgameTime = currentTime
                        manager.endgameCount = manager.endgameCount + 1
                        getgenv()._SeamlessEndgameCount = manager.endgameCount
                        
                        local maxRounds = getgenv().SeamlessRounds or 4
                        
                        getgenv()._DiagnosticsLogger_logSeamlessRestart(manager.endgameCount, maxRounds, "EndGameUI")
                        
                        getgenv()._SeamlessRestartManager_trackRestartTime()
                        
                        task.spawn(function()
                            task.wait(5)
                            pcall(function()
                                local elapsed = RS:FindFirstChild("ElapsedTime")
                                if elapsed and elapsed.Value then
                                    getgenv()._RoundStartTime = elapsed.Value
                                    warn(string.format("[SeamlessRestartManager] Round start time set (EndGameUI counter): %.1f", elapsed.Value))
                                end
                            end)
                        end)
                        
                        warn(string.format("[SeamlessRestartManager] Endgame detected (method: EndGameUI): %d/%d", manager.endgameCount, maxRounds))
                        
                        if manager.endgameCount >= maxRounds and getgenv().SeamlessFixEnabled then
                            maxRoundsReached = true
                            task.wait(1)
                            
                            if getSeamlessValue() then
                                warn("[SeamlessRestartManager] Disabling seamless retry before full restart")
                                getgenv()._SeamlessRestartManager_disableSeamless()
                            end
                            
                            task.spawn(function()
                                local maxWait = 0
                                while LocalPlayer.PlayerGui:FindFirstChild("EndGameUI") and maxWait < 30 do
                                    task.wait(0.5)
                                    maxWait = maxWait + 0.5
                                end
                                
                                task.wait(2)
                                
                                local success = getgenv()._SeamlessRestartManager_initiateRestart()
                                
                                if success then
                                    local restartSuccess, status = getgenv()._SeamlessRestartManager_waitForRestartComplete(45)
                                    
                                    if restartSuccess then
                                        warn(string.format("[SeamlessRestartManager] Full restart completed: %s", status))
                                        
                                        getgenv()._DiagnosticsLogger_trackAverageRestartTime()
                                        getgenv()._DiagnosticsLogger_logMemoryUsage("full_restart_complete")
                                        
                                        manager.endgameCount = 0
                                        getgenv()._SeamlessEndgameCount = 0
                                        maxRoundsReached = false
                                        hasRun = false
                                        enableSeamlessIfNeeded()
                                    else
                                        warn(string.format("[SeamlessRestartManager] Full restart failed: %s", status))
                                    end
                                else
                                    warn("[SeamlessRestartManager] Failed to initiate restart")
                                end
                            end)
                        else
                            task.delay(3, function()
                                hasRun = false
                            end)
                        end
                    end
                end)
            end)
        )
        
        ConnectionManager:trackGroup("SeamlessRetry",
            LocalPlayer.PlayerGui.ChildRemoved:Connect(function(child) 
                if child.Name == "EndGameUI" then 
                    task.wait(3) 
                    hasRun = false 
                end 
            end)
        )
        
        ConnectionManager:trackGroup("SeamlessRetry",
            LocalPlayer.PlayerGui.ChildAdded:Connect(function(child)
                if child.Name == "TeleportUI" and maxRoundsReached then
                    manager.endgameCount = 0
                    getgenv()._SeamlessEndgameCount = 0
                    maxRoundsReached = false
                    task.wait(2)
                    enableSeamlessIfNeeded()
                end
            end)
        )
    end)
    
end


do
    task.spawn(function()
        local vu = game:GetService("VirtualUser")
        
        Players.LocalPlayer.Idled:Connect(function()
            if getgenv().AntiAFKEnabled then
                vu:CaptureController()
                vu:ClickButton2(Vector2.new())
            end
        end)
        
        task.spawn(function()
            while true do
                task.wait(60)
                if getgenv().AntiAFKEnabled then
                    pcall(function()
                        vu:CaptureController()
                        vu:ClickButton2(Vector2.new())
                    end)
                end
            end
        end)
        
        task.spawn(function()
            while true do
                task.wait(120)
                if getgenv().AntiAFKEnabled then
                    pcall(function()
                        local char = LocalPlayer.Character
                        if char and char:FindFirstChild("HumanoidRootPart") then
                            local hrp = char.HumanoidRootPart
                            hrp.CFrame = hrp.CFrame * CFrame.new(0, 0.1, 0)
                            task.wait(0.1)
                            hrp.CFrame = hrp.CFrame * CFrame.new(0, -0.1, 0)
                        end
                    end)
                end
            end
        end)
    end)
end

do
    task.spawn(function()
        while true do
            task.wait(300) 
            
            pcall(function()
                if towerTracker and towerTracker.upgradeConnections then
                    for tower, conn in pairs(towerTracker.upgradeConnections) do
                        if not tower or not tower.Parent then
                            if conn then conn:Disconnect() end
                            towerTracker.upgradeConnections[tower] = nil
                        end
                    end
                end
                
                if getgenv()._DynamicSummonSections then
                    for unitName, data in pairs(getgenv()._DynamicSummonSections) do
                        local stillExists = false
                        if workspace:FindFirstChild("Towers") then
                            for _, tower in pairs(workspace.Towers:GetChildren()) do
                                if tower.Name == unitName then
                                    local owner = tower:FindFirstChild("Owner")
                                    if owner and owner.Value == LocalPlayer then
                                        stillExists = true
                                        break
                                    end
                                end
                            end
                        end
                        
                        if not stillExists and data.elements then
                            for _, element in ipairs(data.elements) do
                                pcall(function()
                                    if element and element.SetVisiblity then
                                        element:SetVisiblity(false)
                                    end
                                end)
                            end
                            getgenv()._DynamicSummonSections[unitName] = nil
                        end
                    end
                end
                
                safeGarbageCollect()
            end)
        end
    end)
end

do
    task.spawn(function()
        local blackScreenGui, blackFrame
    
    local function createBlack()
        if blackScreenGui then return end
        
        blackScreenGui = Instance.new("ScreenGui")
        blackScreenGui.Name = "BlackScreenOverlay"
        blackScreenGui.DisplayOrder = -999999
        blackScreenGui.IgnoreGuiInset = true
        blackScreenGui.ResetOnSpawn = false
        
        blackFrame = Instance.new("Frame")
        blackFrame.Size = UDim2.new(1, 0, 1, 0)
        blackFrame.BackgroundColor3 = Color3.new(0, 0, 0)
        blackFrame.BorderSizePixel = 0
        blackFrame.ZIndex = -999999
        blackFrame.Parent = blackScreenGui
        
        pcall(function()
            blackScreenGui.Parent = LocalPlayer.PlayerGui
        end)
        
        pcall(function()
            if workspace.CurrentCamera then
                workspace.CurrentCamera.MaxAxisFieldOfView = 0.001
            end
            settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
        end)
        
    end
    
    local function removeBlack()
        if blackScreenGui then
            blackScreenGui:Destroy()
            blackScreenGui = nil
            blackFrame = nil
        end
        
        pcall(function()
            if workspace.CurrentCamera then
                workspace.CurrentCamera.MaxAxisFieldOfView = 70
            end
        end)
        
    end
    
    while true do
        task.wait(0.5)
        if getgenv().BlackScreenEnabled then
            if not blackScreenGui then
                createBlack()
            end
        else
            if blackScreenGui then
                removeBlack()
            end
        end
    end
    end)
end

do
    task.spawn(function()
        local removeInterval = getgenv().IsMacPlatform and 1 or 0.5
        while true do
            task.wait(removeInterval) 
            if getgenv().RemoveEnemiesEnabled then
                pcall(function()
                    local enemies = workspace:FindFirstChild("Enemies")
                    if enemies then
                        local enemyList = enemies:GetChildren()
                        local batchSize = getgenv().IsMacPlatform and 5 or 10
                        local maxEnemies = getgenv().IsMacPlatform and 50 or #enemyList
                        
                        for i = 1, math.min(#enemyList, maxEnemies) do
                            local enemy = enemyList[i]
                            pcall(function()
                                if enemy and enemy.Parent and enemy:IsA("Model") then
                                    local isBoss = enemy:FindFirstChild("Boss")
                                    if not isBoss or not isBoss.Value then
                                        enemy:Destroy()
                                    end
                                end
                            end)
                            if i % batchSize == 0 then
                                task.wait()
                            end
                        end
                    end
                    
                    local spawnedunits = workspace:FindFirstChild("SpawnedUnits")
                    if spawnedunits then
                        local unitList = spawnedunits:GetChildren()
                        for i = 1, #unitList do
                            local su = unitList[i]
                            pcall(function()
                                if su and su.Parent and su:IsA("Model") then
                                    su:Destroy()
                                end
                            end)
                            if i % 10 == 0 then
                                task.wait()
                            end
                        end
                    end
                    
                    local debris = workspace:FindFirstChild("Debris")
                    if debris then
                        local debrisList = debris:GetChildren()
                        for i = 1, #debrisList do
                            pcall(function() 
                                if debrisList[i] then
                                    debrisList[i]:Destroy()
                                end
                            end)
                        end
                    end
                end)
            end
        end
    end)
end

if getgenv().AutoHideUIEnabled or getgenv().Config.toggles.AutoHideUI then
    task.spawn(function()
        task.wait(3)
        
        if Window and Window.SetState then
            pcall(function()
                Window:SetState(false)
            end)
        end
    end)
end

if not isInLobby then
    task.spawn(function()
        local particleInterval = getgenv().IsMacPlatform and 4 or 2
        while true do
            task.wait(particleInterval)
            pcall(function()
                local targets = {workspace.Enemies, workspace.Towers, workspace:FindFirstChild("Effects")}
                for _, parent in pairs(targets) do
                    if parent then
                        for _, obj in pairs(parent:GetDescendants()) do
                            pcall(function()
                                if obj:IsA("ParticleEmitter") then
                                    if obj.Rate > 100 then 
                                        obj.Enabled = false
                                        obj:Destroy()
                                    end
                                elseif obj:IsA("Trail") or obj:IsA("Beam") then
                                    obj.Enabled = false
                                elseif obj:IsA("Sound") then
                                    if obj.Volume > 0.5 then
                                        obj.Volume = 0
                                    end
                                elseif obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") then
                                    obj.Enabled = false
                                    obj:Destroy()
                                end
                            end)
                        end
                    end
                end
                
                local camera = workspace.CurrentCamera
                if camera then
                    for _, effect in pairs(camera:GetChildren()) do
                        pcall(function()
                            if effect:IsA("BlurEffect") or effect:IsA("ColorCorrectionEffect") then
                                effect.Enabled = false
                            end
                        end)
                    end
                end
            end)
        end
    end)
end

if not isInLobby then
    task.spawn(function()
        while true do
            task.wait(15)
            
            pcall(function()
                collectgarbage("collect")
                collectgarbage("collect") 
            end)
            
            if getgenv().FPSBoostEnabled then
                pcall(function()
                    local lighting = game:GetService("Lighting")
                    for _, child in ipairs(lighting:GetChildren()) do
                        pcall(function()
                            if not child:IsA("Sky") and not child:IsA("Atmosphere") then
                                child:Destroy()
                            end
                        end)
                    end
                    lighting.Ambient = Color3.new(1, 1, 1)
                    lighting.Brightness = 1
                    lighting.GlobalShadows = false
                    lighting.FogEnd = 100000
                    lighting.FogStart = 100000
                    lighting.ClockTime = 12
                    lighting.GeographicLatitude = 0
                    
                    local descendants = game.Workspace:GetDescendants()
                    local batchSize = 100
                    for i = 1, #descendants, batchSize do
                        for j = i, math.min(i + batchSize - 1, #descendants) do
                            local obj = descendants[j]
                            pcall(function()
                                if not obj or not obj.Parent then return end
                                
                                if obj:IsA("BasePart") then
                                    if obj:IsA("Part") or obj:IsA("MeshPart") or obj:IsA("WedgePart") or obj:IsA("CornerWedgePart") then
                                        pcall(function() obj.Material = Enum.Material.SmoothPlastic end)
                                        pcall(function() obj.CastShadow = false end)
                                        if obj:FindFirstChildOfClass("Texture") then
                                            for _, t in ipairs(obj:GetChildren()) do
                                                if t:IsA("Texture") then
                                                    pcall(function() t:Destroy() end)
                                                end
                                            end
                                        end
                                        if obj:IsA("MeshPart") then
                                            pcall(function() obj.TextureID = "" end)
                                        end
                                    end
                                    if obj:IsA("Decal") then
                                        pcall(function() obj:Destroy() end)
                                    end
                                end
                                if obj:IsA("SurfaceAppearance") then
                                    pcall(function() obj:Destroy() end)
                                end
                                if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") then
                                    pcall(function() obj.Enabled = false end)
                                end
                                if obj:IsA("Sound") then
                                    pcall(function() 
                                        obj.Volume = 0
                                        obj:Stop()
                                    end)
                                end
                            end)
                        end
                        task.wait()
                    end
                    
                    local mapPath = game.Workspace:FindFirstChild("Map") and game.Workspace.Map:FindFirstChild("Map")
                    if mapPath then
                        for _, ch in ipairs(mapPath:GetChildren()) do
                            if not ch:IsA("Model") then
                                pcall(function() ch:Destroy() end)
                            end
                        end
                    end
                end)
            end
        end
    end)
end

if not isInLobby then
    task.spawn(function()
        while true do
            task.wait(30) 
            pcall(function()
                collectgarbage("collect")
            end)
        end
    end)
    
    task.spawn(function()
        local placedTowers = {}
        local hologramParts = {}
        
        local function getClientData()
            local ok, data = pcall(function()
                return require(RS:WaitForChild("Modules"):WaitForChild("ClientData"))
            end)
            return ok and data or nil
        end
        
        local function getTowerInfo(unitName)
            local ok, data = pcall(function()
                local towerInfoPath = RS:WaitForChild("Modules"):WaitForChild("TowerInfo")
                local towerModule = towerInfoPath:FindFirstChild(unitName)
                if towerModule and towerModule:IsA("ModuleScript") then
                    return require(towerModule)
                end
            end)
            return ok and data or nil
        end
        
        local function isFarmUnit(unitName)
            local towerInfo = getTowerInfo(unitName)
            if not towerInfo or not towerInfo[1] then return false end
            return towerInfo[1].Attack == "Cash"
        end
        
        local function getWaypoints()
            local waypoints = {}
            local waypointsFolder = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Waypoints")
            if not waypointsFolder then return waypoints end
            
            for _, wp in pairs(waypointsFolder:GetChildren()) do
                if wp:IsA("BasePart") then
                    local num = tonumber(wp.Name)
                    if num and num >= 1 then
                        table.insert(waypoints, {number = num, part = wp})
                    end
                end
            end
            
            table.sort(waypoints, function(a, b) return a.number < b.number end)
            return waypoints
        end
        
        local function isValidPlacement(position)
            local rayParams = RaycastParams.new()
            rayParams.FilterType = Enum.RaycastFilterType.Blacklist
            local filterList = {}
            if workspace:FindFirstChild("Towers") then table.insert(filterList, workspace.Towers) end
            if workspace:FindFirstChild("Enemies") then table.insert(filterList, workspace.Enemies) end
            rayParams.FilterDescendantsInstances = filterList
            
            local rayOrigin = position + Vector3.new(0, 10, 0)
            local rayResult = workspace:Raycast(rayOrigin, Vector3.new(0, -20, 0), rayParams)
            
            if not rayResult then return false end
            
            local hitPart = rayResult.Instance
            if not hitPart then return false end
            
            local partName = hitPart.Name:lower()
            if partName:find("waypoint") or partName:find("path") or partName:find("rock") then
                return false
            end
            
            if hitPart.Parent and (hitPart.Parent.Name == "Waypoints" or hitPart.Parent.Name:lower():find("path")) then
                return false
            end
            
            return true
        end
        
        local function getPlacementPosition(slotNum, waypointIndex, distance)
            if getgenv().AutoPlayConfig.autoPlaceAtPosition then
                local customPos = getgenv().AutoPlayConfig.unitPositions[slotNum]
                if customPos then
                    return CFrame.new(customPos)
                end
            end
            
            local waypoints = getWaypoints()
            if #waypoints == 0 then return nil end
            
            local baseIndex = math.floor(waypointIndex)
            local decimal = waypointIndex - baseIndex
            
            baseIndex = math.clamp(baseIndex, 1, #waypoints)
            local waypoint1 = waypoints[baseIndex].part
            
            if not waypoint1 or not waypoint1.Position then return nil end
            
            local waypointPos = waypoint1.Position
            
            if decimal > 0 and baseIndex < #waypoints then
                local waypoint2 = waypoints[baseIndex + 1].part
                if waypoint2 and waypoint2.Position then
                    waypointPos = waypoint1.Position:Lerp(waypoint2.Position, decimal)
                end
            end
            
            if distance == 0 then distance = 10 end
            
            local baseAngle = slotNum * 60
            
            for attempt = 1, 15 do
                local angleVariation = math.random(-20, 20)
                local angle = math.rad(baseAngle + angleVariation)
                
                local distVariation = distance + math.random(-3, 5)
                
                local offset = Vector3.new(
                    math.cos(angle) * distVariation,
                    0,
                    math.sin(angle) * distVariation
                )
                
                local pos = waypointPos + offset
                local cframe = CFrame.new(pos.X, waypointPos.Y, pos.Z)
                
                if isValidPlacement(cframe.Position) then
                    return cframe
                end
            end
            
            local fallbackAngle = math.rad(baseAngle)
            local fallbackOffset = Vector3.new(
                math.cos(fallbackAngle) * (distance + 5),
                0,
                math.sin(fallbackAngle) * (distance + 5)
            )
            local fallbackPos = waypointPos + fallbackOffset
            return CFrame.new(fallbackPos.X, waypointPos.Y, fallbackPos.Z)
        end
        
        local function createHologram(unitName, cframe, slotNum)
            if not getgenv().AutoPlayConfig.hologram then return end
            
            local position = cframe.Position
            
            local part = Instance.new("Part")
            part.Size = Vector3.new(0.5, 0.5, 0.5)
            part.Position = position + Vector3.new(0, 2, 0)
            part.Anchored = true
            part.CanCollide = false
            part.Transparency = 0.5
            part.Color = Color3.fromRGB(0, 255, 100)
            part.Material = Enum.Material.Neon
            part.Shape = Enum.PartType.Ball
            part.Parent = workspace
            
            local beam = Instance.new("Part")
            beam.Size = Vector3.new(0.2, 4, 0.2)
            beam.Position = position
            beam.Anchored = true
            beam.CanCollide = false
            beam.Transparency = 0.6
            beam.Color = Color3.fromRGB(0, 255, 100)
            beam.Material = Enum.Material.Neon
            beam.Parent = workspace
            
            local billboard = Instance.new("BillboardGui")
            billboard.Size = UDim2.new(0, 120, 0, 30)
            billboard.StudsOffset = Vector3.new(0, 3, 0)
            billboard.AlwaysOnTop = true
            billboard.Parent = part
            
            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(1, 0, 1, 0)
            label.BackgroundTransparency = 0.3
            label.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            label.Text = unitName .. " (Slot " .. slotNum .. ")"
            label.TextColor3 = Color3.fromRGB(0, 255, 100)
            label.TextScaled = true
            label.Font = Enum.Font.GothamBold
            label.Parent = billboard
            
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 4)
            corner.Parent = label
            
            table.insert(hologramParts, part)
            table.insert(hologramParts, beam)
            return part
        end
        
        local function clearHolograms()
            for _, part in pairs(hologramParts) do
                pcall(function()
                    if part and part.Parent then
                        part:Destroy()
                    end
                end)
            end
            table.clear(hologramParts)
            hologramParts = {}
        end
        
        local function getPlacedTowerCount(slotNum)
            local clientData = getClientData()
            if not clientData or not clientData.Slots then return 0 end
            
            local sortedSlots = {"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}
            local slotData = clientData.Slots[sortedSlots[slotNum]]
            if not slotData or not slotData.Value then return 0 end
            
            local unitName = slotData.Value
            local unitNameEZA = getEZATowerName(unitName)
            
            local towersFolder = workspace:FindFirstChild("Towers")
            if not towersFolder then return 0 end
            
            local count = 0
            for _, tower in pairs(towersFolder:GetChildren()) do
                if tower.Name == unitName or tower.Name == unitNameEZA then
                    local owner = tower:FindFirstChild("Owner")
                    if owner and owner.Value == Players.LocalPlayer then
                        count = count + 1
                    end
                end
            end
            
            return count
        end
        
        local function getPlacementLimit(unitName)
            local towersFolder = workspace:FindFirstChild("Towers")
            if not towersFolder then return nil end
            
            local unitNameEZA = getEZATowerName(unitName)
            
            local towerModel = towersFolder:FindFirstChild(unitNameEZA)
            if not towerModel then
                towerModel = towersFolder:FindFirstChild(unitName)
            end
            
            if not towerModel then return nil end
            
            local placementLimit = towerModel:FindFirstChild("PlacementLimit")
            if placementLimit and placementLimit:IsA("ValueBase") then
                return placementLimit.Value
            end
            
            return nil
        end
        
        local function placeTower(unitName, cframe, slotNum)
            if not cframe then return false end
            
            local placeEvent = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("PlaceTower")
            if not placeEvent then return false end
            
            local countBefore = getPlacedTowerCount(slotNum)
            
            local success, result = pcall(function()
                return placeEvent:FireServer(unitName, cframe)
            end)
            
            if not success then return false end
            
            task.wait(0.5)
            
            local countAfter = getPlacedTowerCount(slotNum)
            if countAfter > countBefore then return true end
            
            return false
        end
        
        local function upgradeTower(tower)
            if not tower then return false end
            
            local upgradeEvent = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Upgrade")
            if not upgradeEvent then return false end
            
            local success, result = pcall(function()
                return upgradeEvent:InvokeServer(tower)
            end)
            
            if not success then return false end
            
            return true
        end
        
        local function getTowerLevel(tower)
            if not tower then return 0 end
            local level = 0
            pcall(function()
                local upgradeValue = tower:FindFirstChild("Upgrade")
                if upgradeValue then
                    level = upgradeValue.Value or 0
                end
            end)
            return level
        end
        
        local function hologramLoop()
            task.wait(3)
            
            while true do
                task.wait(2)  
                
                if not getgenv().AutoPlayConfig.hologram then
                    clearHolograms()
                    task.wait(1)
                    continue
                end
                
                clearHolograms()
                
                local clientData = getClientData()
                if not clientData or not clientData.Slots then continue end
                
                local pathIndex = getgenv().AutoPlayConfig.pathPercentage or 1
                local distance = math.floor(getgenv().AutoPlayConfig.distanceFromPath or 10)
                
                local sortedSlots = {"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}
                local totalHolograms = 0
                local maxHolograms = 30 
                
                for slotNum = 1, 6 do
                    if totalHolograms >= maxHolograms then break end
                    
                    local slotData = clientData.Slots[sortedSlots[slotNum]]
                    if slotData and slotData.Value then
                        local unitName = slotData.Value
                        local placeCap = math.floor(getgenv().AutoPlayConfig.placeCaps[slotNum] or 1)
                        local currentCount = getPlacedTowerCount(slotNum)
                        
                        if placeCap > 0 then
                            for i = currentCount + 1, math.min(placeCap, currentCount + 10) do  
                                if totalHolograms >= maxHolograms then break end
                                
                                local position = getPlacementPosition(slotNum, pathIndex, distance)
                                if position then
                                    createHologram(unitName, position, slotNum)
                                    totalHolograms = totalHolograms + 1
                                end
                            end
                        end
                    end
                end
                
                pcall(function() collectgarbage("collect") end)
            end
        end
        
        local function autoPlaceLoop()
            task.wait(1)
            
            while true do
                task.wait(1)
                
                if getgenv()._checkIfInLobby() then
                    task.wait(2)
                    continue
                end
                
                if not getgenv().AutoPlayConfig.autoPlace and not getgenv().AutoPlayConfig.autoPlaceAtPosition then
                    task.wait(1)
                    continue
                end
                
                local clientData = getClientData()
                if not clientData or not clientData.Slots then continue end
                
                local currentCash = tonumber(getgenv().MacroCurrentCash) or 0
                
                local pathIndex = getgenv().AutoPlayConfig.pathPercentage or 1
                local distance = math.floor(getgenv().AutoPlayConfig.distanceFromPath or 10)
                
                local unitsToPlace = {}
                local sortedSlots = {"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}
                
                for slotNum = 1, 6 do
                    local slotData = clientData.Slots[sortedSlots[slotNum]]
                    if slotData and slotData.Value and slotData.Value ~= "" then
                        local unitName = slotData.Value
                        local placeCap = math.floor(getgenv().AutoPlayConfig.placeCaps[slotNum] or 1)
                        local currentCount = getPlacedTowerCount(slotNum)
                        
                        if getgenv().DebugMode then
                            print(string.format("[Auto Place] Slot %d: %s (Cap: %d, Current: %d)", slotNum, unitName, placeCap, currentCount))
                        end
                        
                        if placeCap > 0 and currentCount < placeCap then
                            local cost = getgenv().GetPlaceCost and getgenv().GetPlaceCost(unitName) or 0
                            local isFarm = isFarmUnit(unitName)
                            
                            if getgenv().DebugMode then
                                print(string.format("[Auto Place] Adding %s to queue (Cost: %d, IsFarm: %s)", unitName, cost, tostring(isFarm)))
                            end
                            
                            table.insert(unitsToPlace, {
                                slotNum = slotNum,
                                unitName = unitName,
                                cost = cost,
                                isFarm = isFarm
                            })
                        end
                    end
                end
                
                if getgenv().AutoPlayConfig.focusFarm then
                    table.sort(unitsToPlace, function(a, b)
                        if a.isFarm ~= b.isFarm then
                            return a.isFarm 
                        end
                        return a.slotNum < b.slotNum
                    end)
                else
                    table.sort(unitsToPlace, function(a, b)
                        return a.slotNum < b.slotNum
                    end)
                end
                
                for _, unitData in ipairs(unitsToPlace) do
                    currentCash = tonumber(getgenv().MacroCurrentCash) or 0
                    
                    if currentCash >= unitData.cost then
                        local position = getPlacementPosition(unitData.slotNum, pathIndex, distance)
                        if position then
                            if getgenv().DebugMode then
                                print(string.format("[Auto Place] Attempting to place %s (Slot %d) at position", unitData.unitName, unitData.slotNum))
                            end
                            if placeTower(unitData.unitName, position, unitData.slotNum) then
                                if getgenv().DebugMode then
                                    print(string.format("[Auto Place] ✅ Successfully placed %s", unitData.unitName))
                                end
                                task.wait(1)
                                break 
                            else
                                if getgenv().DebugMode then
                                    print(string.format("[Auto Place] ❌ Failed to place %s", unitData.unitName))
                                end
                            end
                        else
                            if getgenv().DebugMode then
                                print(string.format("[Auto Place] ❌ No valid position for %s (Slot %d)", unitData.unitName, unitData.slotNum))
                            end
                        end
                    end
                end
            end
        end
        
        local function autoUpgradeLoop()
            task.wait(2)
            
            while true do
                task.wait(1)
                
                if getgenv()._checkIfInLobby() then
                    task.wait(2)
                    continue
                end
                
                if not getgenv().AutoPlayConfig.autoUpgrade and not getgenv().AutoPlayConfig.autoUpgradePriority then 
                    continue 
                end
                
                
                local clientData = getClientData()
                if not clientData or not clientData.Slots then 
                    continue 
                end
                
                if getgenv().AutoPlayConfig.placeBeforeUpgrade and (getgenv().AutoPlayConfig.autoPlace or getgenv().AutoPlayConfig.autoPlaceAtPosition) then
                    local allUnitsPlaced = true
                    local sortedSlots = {"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}
                    
                    for slotNum = 1, 6 do
                        local slotData = clientData.Slots[sortedSlots[slotNum]]
                        if slotData and slotData.Value and slotData.Value ~= "" then
                            local placeCap = math.floor(getgenv().AutoPlayConfig.placeCaps[slotNum] or 0)
                            local currentCount = getPlacedTowerCount(slotNum)
                            local placementLimit = getPlacementLimit(slotData.Value)
                            
                            local effectiveCap = placeCap
                            if placementLimit and placementLimit > 0 then
                                effectiveCap = math.min(placeCap, placementLimit)
                            end
                            
                            
                            if placeCap > 0 and currentCount < effectiveCap then
                                allUnitsPlaced = false
                                break
                            end
                        end
                    end
                    
                    if not allUnitsPlaced then
                        continue
                    end
                end
                
                local towersFolder = workspace:FindFirstChild("Towers")
                if not towersFolder then continue end
                
                local farmUnits = {}
                local normalUnits = {}
                
                local slotUpgradeCaps = {}
                local slotPriorities = {}
                local unitToSlot = {}
                local sortedSlots = {"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}
                for slotNum = 1, 6 do
                    local slotData = clientData.Slots[sortedSlots[slotNum]]
                    if slotData and slotData.Value then
                        local unitName = slotData.Value
                        local unitNameEZA = getEZATowerName(unitName)
                        local upgradeCap = math.floor(getgenv().AutoPlayConfig.upgradeCaps[slotNum] or 0)
                        
                        slotUpgradeCaps[unitName] = upgradeCap
                        slotUpgradeCaps[unitNameEZA] = upgradeCap
                        
                        slotPriorities[unitName] = getgenv().AutoPlayConfig.upgradePriorities[slotNum] or slotNum
                        slotPriorities[unitNameEZA] = getgenv().AutoPlayConfig.upgradePriorities[slotNum] or slotNum
                        
                        unitToSlot[unitName] = slotNum
                        unitToSlot[unitNameEZA] = slotNum
                    end
                end
                
                for _, tower in pairs(towersFolder:GetChildren()) do
                    local owner = tower:FindFirstChild("Owner")
                    if owner and owner.Value == Players.LocalPlayer then
                        local unitName = tower.Name
                        local level = getTowerLevel(tower)
                        local maxUpgrade = tower:FindFirstChild("MaxUpgrade")
                        local actualMaxLevel = maxUpgrade and maxUpgrade.Value or 20
                        
                        local upgradeCap = slotUpgradeCaps[unitName] or 20 
                        
                        if slotUpgradeCaps[unitName] and slotUpgradeCaps[unitName] == 0 then
                            continue
                        end
                        
                        local effectiveCap = math.min(upgradeCap, actualMaxLevel)
                        
                        if level < effectiveCap then
                            local upgradeCost = getgenv().GetUpgradeCost and getgenv().GetUpgradeCost(unitName, level) or 999999999
                            local priority = slotPriorities[unitName] or 999
                            
                            if isFarmUnit(unitName) then
                                table.insert(farmUnits, {tower = tower, level = level, cap = effectiveCap, unitName = unitName, cost = upgradeCost, priority = priority})
                            else
                                table.insert(normalUnits, {tower = tower, level = level, cap = effectiveCap, unitName = unitName, cost = upgradeCost, priority = priority})
                            end
                        end
                    end
                end
                
                if getgenv().AutoPlayConfig.autoUpgradePriority then
                    table.sort(farmUnits, function(a, b)
                        if a.priority ~= b.priority then
                            return a.priority < b.priority
                        end
                        return a.cost < b.cost
                    end)
                    table.sort(normalUnits, function(a, b)
                        if a.priority ~= b.priority then
                            return a.priority < b.priority
                        end
                        return a.cost < b.cost
                    end)
                else
                    table.sort(farmUnits, function(a, b) return a.cost < b.cost end)
                    table.sort(normalUnits, function(a, b) return a.cost < b.cost end)
                end
                
                local currentCash = tonumber(getgenv().MacroCurrentCash) or 0
                
                local upgraded = false
                
                local allUnits = {}
                for _, data in ipairs(farmUnits) do
                    data.isFarm = true
                    table.insert(allUnits, data)
                end
                for _, data in ipairs(normalUnits) do
                    data.isFarm = false
                    table.insert(allUnits, data)
                end
                
                
                if getgenv().AutoPlayConfig.autoUpgradePriority then
                    table.sort(allUnits, function(a, b)
                        if getgenv().AutoPlayConfig.focusFarm then
                            if a.isFarm ~= b.isFarm then
                                return a.isFarm
                            end
                        end
                        
                        if a.priority ~= b.priority then
                            return a.priority < b.priority
                        end
                        
                        return a.cost < b.cost
                    end)
                else
                    table.sort(allUnits, function(a, b) return a.cost < b.cost end)
                end
                
                if getgenv().AutoPlayConfig.autoUpgradePriority then
                    for _, data in ipairs(allUnits) do
                        if upgraded then break end
                        
                        currentCash = tonumber(getgenv().MacroCurrentCash) or 0
                        
                        
                        if data.cost > 0 and currentCash >= data.cost then
                            local prefix = data.isFarm and "[FARM] " or ""
                            if upgradeTower(data.tower) then
                                upgraded = true
                                task.wait(0.2)

                            end
                        end
                    end
                else
                    for _, data in ipairs(allUnits) do
                        if upgraded then break end
                        currentCash = tonumber(getgenv().MacroCurrentCash) or 0
                        
                        
                        if data.cost > 0 and currentCash >= data.cost then
                            if upgradeTower(data.tower) then
                                upgraded = true
                                task.wait(0.2)

                            end
                       
                        end
                    end
                end
            end
        end
        
        task.spawn(hologramLoop)
        task.spawn(autoPlaceLoop)
        task.spawn(autoUpgradeLoop)
    end)
end
end
end


task.spawn(function()
    local GuiService = game:GetService("GuiService")
    local lastClearTime = tick()
    
    while task.wait(0.5) do
        pcall(function()

            if tick() - lastClearTime > 1 then
                if GuiService.SelectedObject then

                    GuiService.SelectedObject = nil
                end
            end
            lastClearTime = tick()
        end)
    end
end)



getgenv()._ButtonPressActive = false

task.spawn(function()
    local GuiService = game:GetService("GuiService")
    
    while task.wait(0.1) do
        pcall(function()
            if getgenv()._checkIfInLobby() then
                return
            end
            
            if not getgenv()._ButtonPressActive and GuiService.SelectedObject then
                GuiService.SelectedObject = nil
            end
        end)
    end
end)

end

getgenv()._InitializeGameSystems()
